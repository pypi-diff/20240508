# Comparing `tmp/sony_custom_layers-0.1.1-py3-none-any.whl.zip` & `tmp/sony_custom_layers-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,17 +1,25 @@
-Zip file size: 15906 bytes, number of entries: 15
--rw-r--r--  2.0 unx      776 b- defN 23-Dec-07 09:09 sony_custom_layers/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Dec-07 09:09 sony_custom_layers/version.py
--rw-r--r--  2.0 unx      908 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/__init__.py
--rw-r--r--  2.0 unx     1394 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/base_custom_layer.py
--rw-r--r--  2.0 unx     2172 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/custom_objects.py
--rw-r--r--  2.0 unx      922 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/object_detection/__init__.py
--rw-r--r--  2.0 unx     1404 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/object_detection/box_utils.py
--rw-r--r--  2.0 unx     4590 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/object_detection/faster_rcnn_box_decode.py
--rw-r--r--  2.0 unx      964 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/object_detection/score_converter.py
--rw-r--r--  2.0 unx     6964 b- defN 23-Dec-07 09:09 sony_custom_layers/keras/object_detection/ssd_post_process.py
--rw-r--r--  2.0 unx    10174 b- defN 23-Dec-07 09:10 sony_custom_layers-0.1.1.dist-info/LICENSE.md
--rw-r--r--  2.0 unx     2971 b- defN 23-Dec-07 09:10 sony_custom_layers-0.1.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Dec-07 09:10 sony_custom_layers-0.1.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       19 b- defN 23-Dec-07 09:10 sony_custom_layers-0.1.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1486 b- defN 23-Dec-07 09:10 sony_custom_layers-0.1.1.dist-info/RECORD
-15 files, 34858 bytes uncompressed, 13356 bytes compressed:  61.7%
+Zip file size: 27290 bytes, number of entries: 23
+-rw-r--r--  2.0 unx     1498 b- defN 24-May-08 09:06 sony_custom_layers/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 24-May-08 09:06 sony_custom_layers/version.py
+-rw-r--r--  2.0 unx     1217 b- defN 24-May-08 09:06 sony_custom_layers/keras/__init__.py
+-rw-r--r--  2.0 unx     1394 b- defN 24-May-08 09:06 sony_custom_layers/keras/base_custom_layer.py
+-rw-r--r--  2.0 unx     2223 b- defN 24-May-08 09:06 sony_custom_layers/keras/custom_objects.py
+-rw-r--r--  2.0 unx      993 b- defN 24-May-08 09:06 sony_custom_layers/keras/object_detection/__init__.py
+-rw-r--r--  2.0 unx     1404 b- defN 24-May-08 09:06 sony_custom_layers/keras/object_detection/box_utils.py
+-rw-r--r--  2.0 unx     4850 b- defN 24-May-08 09:06 sony_custom_layers/keras/object_detection/faster_rcnn_box_decode.py
+-rw-r--r--  2.0 unx      964 b- defN 24-May-08 09:06 sony_custom_layers/keras/object_detection/score_converter.py
+-rw-r--r--  2.0 unx     8311 b- defN 24-May-08 09:06 sony_custom_layers/keras/object_detection/ssd_post_process.py
+-rw-r--r--  2.0 unx     3661 b- defN 24-May-08 09:06 sony_custom_layers/pytorch/__init__.py
+-rw-r--r--  2.0 unx      919 b- defN 24-May-08 09:06 sony_custom_layers/pytorch/object_detection/__init__.py
+-rw-r--r--  2.0 unx    10741 b- defN 24-May-08 09:06 sony_custom_layers/pytorch/object_detection/nms.py
+-rw-r--r--  2.0 unx     2255 b- defN 24-May-08 09:06 sony_custom_layers/pytorch/object_detection/nms_onnx.py
+-rw-r--r--  2.0 unx     1518 b- defN 24-May-08 09:06 sony_custom_layers/pytorch/object_detection/nms_ort.py
+-rw-r--r--  2.0 unx      776 b- defN 24-May-08 09:06 sony_custom_layers/util/__init__.py
+-rw-r--r--  2.0 unx     3165 b- defN 24-May-08 09:06 sony_custom_layers/util/import_util.py
+-rw-r--r--  2.0 unx     1158 b- defN 24-May-08 09:06 sony_custom_layers/util/test_util.py
+-rw-r--r--  2.0 unx    10174 b- defN 24-May-08 09:06 sony_custom_layers-0.2.0.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx     4004 b- defN 24-May-08 09:06 sony_custom_layers-0.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-08 09:06 sony_custom_layers-0.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       19 b- defN 24-May-08 09:06 sony_custom_layers-0.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2304 b- defN 24-May-08 09:06 sony_custom_layers-0.2.0.dist-info/RECORD
+23 files, 63662 bytes uncompressed, 23410 bytes compressed:  63.2%
```

## zipnote {}

```diff
@@ -24,23 +24,47 @@
 
 Filename: sony_custom_layers/keras/object_detection/score_converter.py
 Comment: 
 
 Filename: sony_custom_layers/keras/object_detection/ssd_post_process.py
 Comment: 
 
-Filename: sony_custom_layers-0.1.1.dist-info/LICENSE.md
+Filename: sony_custom_layers/pytorch/__init__.py
 Comment: 
 
-Filename: sony_custom_layers-0.1.1.dist-info/METADATA
+Filename: sony_custom_layers/pytorch/object_detection/__init__.py
 Comment: 
 
-Filename: sony_custom_layers-0.1.1.dist-info/WHEEL
+Filename: sony_custom_layers/pytorch/object_detection/nms.py
 Comment: 
 
-Filename: sony_custom_layers-0.1.1.dist-info/top_level.txt
+Filename: sony_custom_layers/pytorch/object_detection/nms_onnx.py
 Comment: 
 
-Filename: sony_custom_layers-0.1.1.dist-info/RECORD
+Filename: sony_custom_layers/pytorch/object_detection/nms_ort.py
+Comment: 
+
+Filename: sony_custom_layers/util/__init__.py
+Comment: 
+
+Filename: sony_custom_layers/util/import_util.py
+Comment: 
+
+Filename: sony_custom_layers/util/test_util.py
+Comment: 
+
+Filename: sony_custom_layers-0.2.0.dist-info/LICENSE.md
+Comment: 
+
+Filename: sony_custom_layers-0.2.0.dist-info/METADATA
+Comment: 
+
+Filename: sony_custom_layers-0.2.0.dist-info/WHEEL
+Comment: 
+
+Filename: sony_custom_layers-0.2.0.dist-info/top_level.txt
+Comment: 
+
+Filename: sony_custom_layers-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sony_custom_layers/__init__.py

```diff
@@ -9,7 +9,23 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 # -----------------------------------------------------------------------------
+
+# minimal requirements for dynamic validation in sony_custom_layers.{keras, pytorch}.__init__
+# library names are the names that are used in import statement rather than pip package name, as a library can have
+# multiple providing packages per arch, device etc.
+required_libraries = {
+    'tf': ['tensorflow>=2.10'],
+    'torch': ['torch>=2.0', 'torchvision>=0.15'],
+    'torch_ort': ['onnx', 'onnxruntime', 'onnxruntime_extensions>=0.8.0'],
+}
+
+# pinned requirements of latest tested versions for extra_requires
+pinned_pip_requirements = {
+    'tf': ['tensorflow==2.15.*'],
+    'torch': ['torch==2.2.*', 'torchvision==0.17.*'],
+    'torch_ort': ['onnx==1.15.*', 'onnxruntime==1.17.*', 'onnxruntime_extensions==0.10.*']
+}
```

## sony_custom_layers/version.py

```diff
@@ -1 +1 @@
-__version__ = '0.1.1'
+__version__ = '0.2.0'
```

## sony_custom_layers/keras/__init__.py

```diff
@@ -10,10 +10,16 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 # -----------------------------------------------------------------------------
 
-from .object_detection import FasterRCNNBoxDecode, SSDPostProcess, ScoreConverter
+from sony_custom_layers.util.import_util import validate_installed_libraries
+from sony_custom_layers import required_libraries
 
-from .custom_objects import custom_layers_scope
+validate_installed_libraries(required_libraries['tf'])
+
+from .object_detection import FasterRCNNBoxDecode, SSDPostProcess, ScoreConverter    # noqa: E402
+from .custom_objects import custom_layers_scope    # noqa: E402
+
+__all__ = ['FasterRCNNBoxDecode', 'ScoreConverter', 'SSDPostProcess', 'custom_layers_scope']
```

## sony_custom_layers/keras/custom_objects.py

```diff
@@ -18,34 +18,37 @@
 import tensorflow as tf
 
 
 def custom_layers_scope(*args: dict):
     """
     Scope context manager that can be used to deserialize Keras models containing custom layers
 
-    If a model contains custom layers only from this package:
-        from sony_custom_layers.keras import custom_layers_scope
-        with custom_layers_scope():
-            tf.keras.models.load_model(path)
-
+    If the model contains custom layers only from this package:
+    ```
+    from sony_custom_layers.keras import custom_layers_scope
+    with custom_layers_scope():
+        tf.keras.models.load_model(path)
+    ```
     If the model contains additional custom layers from other sources, there are two ways:
     1. Pass a list of dictionaries {layer_name: layer_object} as *args.
-
+        ```
         with custom_layers_scope({'Op1': Op1, 'Op2': Op2}, {'Op3': Op3}):
             tf.keras.models.load_model(path)
-
+        ```
     2. Combined with other scopes based on tf.keras.utils.custom_object_scope:
-
+        ```
         with custom_layers_scope(), another_scope():
             tf.keras.models.load_model(path)
+
         # or:
+
         with custom_layers_scope():
             with another_scope():
                 tf.keras.models.load_model(path)
-
+        ```
     Args:
         *args: a list of dictionaries for other custom layers
 
     Returns:
         Scope context manager
     """
     return tf.keras.utils.custom_object_scope(*args + (_custom_objects, ))
```

## sony_custom_layers/keras/object_detection/__init__.py

```diff
@@ -13,7 +13,9 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 # -----------------------------------------------------------------------------
 
 from .faster_rcnn_box_decode import FasterRCNNBoxDecode
 from .score_converter import ScoreConverter
 from .ssd_post_process import SSDPostProcess
+
+__all__ = ['FasterRCNNBoxDecode', 'ScoreConverter', 'SSDPostProcess']
```

## sony_custom_layers/keras/object_detection/faster_rcnn_box_decode.py

```diff
@@ -22,28 +22,45 @@
 from sony_custom_layers.keras.base_custom_layer import CustomLayer
 from sony_custom_layers.keras.object_detection.box_utils import corners_to_centroids, centroids_to_corners
 from sony_custom_layers.keras.custom_objects import register_layer
 
 
 @register_layer
 class FasterRCNNBoxDecode(CustomLayer):
+    """
+    Box decoding as per Faster R-CNN <https://arxiv.org/abs/1506.01497>.
+
+    Args:
+        anchors: Anchors with a shape of (n_boxes, 4) in corner coordinates (y_min, x_min, y_max, x_max).
+        scale_factors: Scaling factors in the format (y, x, height, width).
+        clip_window: Clipping window in the format (y_min, x_min, y_max, x_max).
+
+    Inputs:
+        **rel_codes** (Tensor): Relative codes (encoded offsets) with a shape of (batch, n_boxes, 4) in centroid
+                                coordinates (y_center, x_center, h, w).
+
+    Returns:
+        Decoded boxes with a shape of (batch, n_boxes, 4) in corner coordinates (y_min, x_min, y_max, x_max).
+
+    Raises:
+        ValueError: If provided with invalid arguments or an input tensor with unexpected shape
+
+    Example:
+        ```
+        from sony_custom_layers.keras import FasterRCNNBoxDecode
+
+        box_decode = FasterRCNNBoxDecode(anchors,
+                                         scale_factors=(10, 10, 5, 5),
+                                         clip_window=(0, 0, 1, 1))
+        decoded_boxes = box_decode(rel_codes)
+        ```
+    """
 
     def __init__(self, anchors: Union[np.ndarray, tf.Tensor, List[List[float]]],
                  scale_factors: Sequence[Union[float, int]], clip_window: Sequence[Union[float, int]], **kwargs):
-        """
-        Box decoding as per Faster R-CNN (https://arxiv.org/abs/1506.01497).
-
-        Args:
-            anchors: Anchors with a shape of (n_boxes, 4) in corner coordinates (y_min, x_min, y_max, x_max).
-            scale_factors: Scaling factors in the format (y, x, height, width).
-            clip_window: Clipping window in the format (y_min, x_min, y_max, x_max).
-
-        Raises:
-            ValueError: If provided with invalid parameters.
-        """
         super().__init__(**kwargs)
         anchors = tf.constant(anchors)
         if not (len(anchors.shape) == 2 and anchors.shape[-1] == 4):
             raise ValueError(f'Invalid anchors shape {anchors.shape}. Expected shape (n_boxes, 4).')
         self.anchors = anchors
 
         if len(scale_factors) != 4:
@@ -51,25 +68,15 @@
         self.scale_factors = tf.constant(scale_factors, dtype=tf.float32)
 
         if len(clip_window) != 4:
             raise ValueError(f'Invalid clip window {clip_window}. Expected 4 values for (y_min, x_min, y_max, x_max).')
         self.clip_window = clip_window
 
     def call(self, rel_codes: tf.Tensor, *args, **kwargs) -> tf.Tensor:
-        """
-        Args:
-            rel_codes: Relative codes (encoded offsets) with a shape of (batch, n_boxes, 4) in centroid coordinates
-                       (y_center, x_center, h, w).
-
-        Returns:
-            Decoded boxes with a shape of (batch, n_boxes, 4) in corner coordinates (y_min, x_min, y_max, x_max).
-
-        Raises:
-            ValueError: If an input tensor with an unexpected shape is received.
-        """
+        """ """
         if len(rel_codes.shape) != 3 or rel_codes.shape[-1] != 4:
             raise ValueError(f'Invalid input tensor shape {rel_codes.shape}. Expected shape (batch, n_boxes, 4).')
         if rel_codes.shape[-2] != self.anchors.shape[-2]:
             raise ValueError(f'Mismatch in the number of boxes between input tensor ({rel_codes.shape[-2]}) '
                              f'and anchors ({self.anchors.shape[-2]})')
 
         scaled_codes = rel_codes / self.scale_factors
@@ -85,14 +92,15 @@
         boxes = tf.stack([box_y_min, box_x_min, box_y_max, box_x_max], axis=-1)
 
         y_low, x_low, y_high, x_high = self.clip_window
         boxes = tf.clip_by_value(boxes, [y_low, x_low, y_low, x_low], [y_high, x_high, y_high, x_high])
         return boxes
 
     def get_config(self) -> dict:
+        """ """
         config = super().get_config()
         config.update({
             'anchors': self.anchors.numpy().tolist(),
             'scale_factors': self.scale_factors.numpy().tolist(),
             'clip_window': self.clip_window,
         })
         return config
```

## sony_custom_layers/keras/object_detection/ssd_post_process.py

```diff
@@ -38,72 +38,98 @@
 
     def as_dict(self):
         return dataclasses.asdict(self)
 
 
 @register_layer
 class SSDPostProcess(CustomLayer):
+    """
+    SSD Post Processing, based on <https://arxiv.org/abs/1512.02325>.
+
+    Args:
+        anchors (Tensor | np.ndarray): Anchors with a shape of (n_boxes, 4) in corner coordinates
+                                       (y_min, x_min, y_max, x_max).
+        scale_factors (list | tuple): Box decoding scaling factors in the format (y, x, height, width).
+        clip_size (list | tuple): Clipping size in the format (height, width). The decoded boxes are clipped to the
+                                  range y=[0, height] and x=[0, width]. Typically, the clipping size is (1, 1) for
+                                  normalized boxes and the image size for boxes in pixel coordinates.
+        score_converter (ScoreConverter): Conversion to apply to the input logits (sigmoid, softmax, or linear).
+        score_threshold (float): Score threshold for non-maximum suppression.
+        iou_threshold (float): Intersection over union threshold for non-maximum suppression.
+        max_detections (int): The number of detections to return.
+        remove_background (bool) : If True, the first class is removed from the input scores (after the score_converter
+                                   is applied).
+
+    Inputs:
+        A list or tuple of:
+        - **rel_codes** (Tensor): Relative codes (encoded offsets) with a shape of (batch, n_boxes, 4) in centroid
+                            coordinates (y_center, x_center, w, h).
+        - **scores** (Tensor): Scores or logits with a shape of (batch, n_boxes, n_labels).
+
+    Returns:
+        'CombinedNonMaxSuppression' named tuple:
+        - nmsed_boxes: Selected boxes sorted by scores in descending order, with a shape of
+                         (batch, max_detections, 4),in corner coordinates (y_min, x_min, y_max, x_max).
+        - nmsed_scores: Scores corresponding to the selected boxes, with a shape of (batch, max_detections).
+        - nmsed_classes: Labels corresponding to the selected boxes, with a shape of (batch, max_detections).
+                           Each label corresponds to the class index of the selected score in the input scores.
+        - valid_detections: The number of valid detections out of max_detections.
+
+    Raises:
+        ValueError: If provided with invalid arguments or input tensors with unexpected or non-matching shapes.
+
+    Example:
+        ```
+        from sony_custom_layers.keras import SSDPostProcessing, ScoreConverter
+
+        post_process = SSDPostProcess(anchors=anchors,
+                                      scale_factors=(10, 10, 5, 5),
+                                      clip_size=(320, 320),
+                                      score_converter=ScoreConverter.SIGMOID,
+                                      score_threshold=0.01,
+                                      iou_threshold=0.6,
+                                      max_detections=200,
+                                      remove_background=True)
+        res = post_process([rel_codes, logits])
+        boxes = res.nmsed_boxes
+        ```
+    """
 
     def __init__(self,
                  anchors: Union[np.ndarray, tf.Tensor, List[List[float]]],
                  scale_factors: Sequence[Union[int, float]],
                  clip_size: Sequence[Union[int, float]],
                  score_converter: Union[ScoreConverter, str],
                  score_threshold: float,
                  iou_threshold: float,
                  max_detections: int,
                  remove_background: bool = False,
                  **kwargs):
-        """
-        SSD Post Processing, based on https://arxiv.org/abs/1512.02325.
-
-        Args:
-            anchors: Anchors with a shape of (n_boxes, 4) in corner coordinates (y_min, x_min, y_max, x_max).
-            scale_factors: Box decoding scaling factors in the format (y, x, height, width).
-            clip_size: Clipping size in the format (height, width). The decoded boxes are clipped to the
-                       range y=[0, height] and x=[0, width]. Typically, the clipping size is (1, 1) for normalized boxes
-                       and the image size for boxes in pixel coordinates.
-            score_converter: Conversion to apply to the input logits (sigmoid, softmax, or linear).
-            score_threshold: Score threshold for non-maximum suppression.
-            iou_threshold: Intersection over union threshold for non-maximum suppression.
-            max_detections: The number of detections to return.
-            remove_background: If True, the first class is removed from the input scores (after the score_converter is
-                               applied).
-        """
+        """ """
         super().__init__(**kwargs)
+
+        if not 0 <= score_threshold <= 1:
+            raise ValueError(f'Invalid score_threshold {score_threshold} not in range [0, 1]')
+        if not 0 <= iou_threshold <= 1:
+            raise ValueError(f'Invalid iou_threshold {iou_threshold} not in range [0, 1]')
+        if max_detections <= 0:
+            raise ValueError(f'Invalid non-positive max_detections {max_detections}')
+
         self.cfg = SSDPostProcessCfg(anchors=anchors,
                                      scale_factors=scale_factors,
                                      clip_size=clip_size,
                                      score_converter=score_converter,
                                      score_threshold=score_threshold,
                                      iou_threshold=iou_threshold,
                                      max_detections=max_detections,
                                      remove_background=remove_background)
         self._box_decode = FasterRCNNBoxDecode(anchors, scale_factors, (0, 0, *clip_size))
 
     def call(self, inputs: Sequence[tf.Tensor], *args, **kwargs) -> Tuple[tf.Tensor]:
-        """
-        Args:
-            inputs: A list or tuple consisting of (rel_codes, scores).
-              0: Relative codes (encoded offsets) with a shape of (batch, n_boxes, 4) in centroid coordinates
-                 (y_center, x_center, w, h).
-              1: Scores or logits with a shape of (batch, n_boxes, n_labels).
-
-        Returns:
-            0: Selected boxes sorted by scores in descending order, with a shape of (batch, max_detections, 4),
-               in corner coordinates (y_min, x_min, y_max, x_max).
-            1: Scores corresponding to the selected boxes, with a shape of (batch, max_detections).
-            2: Labels corresponding to the selected boxes, with a shape of (batch, max_detections).
-               Each label corresponds to the class index of the selected score in the input scores.
-            3: The number of valid detections out of max_detections.
-
-        Raises:
-            ValueError: If provided input tensors have unexpected or non-matching shapes.
-        """
-
+        """ """
         rel_codes, scores = inputs
         if len(rel_codes.shape) != 3 and rel_codes.shape[-1] != 4:
             raise ValueError(f'Invalid input offsets shape {rel_codes.shape}. '
                              f'Expected shape (batch, n_boxes, 4).')
         if len(scores.shape) != 3:
             raise ValueError(f'Invalid input scores shape {scores.shape}. '
                              f'Expected shape (batch, n_boxes, n_labels).')
@@ -128,12 +154,13 @@
                                                         iou_threshold=self.cfg.iou_threshold,
                                                         score_threshold=self.cfg.score_threshold,
                                                         pad_per_class=False,
                                                         clip_boxes=False)
         return outputs
 
     def get_config(self) -> dict:
+        """ """
         config = super().get_config()
         d = self.cfg.as_dict()
         d['anchors'] = tf.constant(d['anchors']).numpy().tolist()
         config.update(d)
         return config
```

## Comparing `sony_custom_layers-0.1.1.dist-info/LICENSE.md` & `sony_custom_layers-0.2.0.dist-info/LICENSE.md`

 * *Files identical despite different names*

