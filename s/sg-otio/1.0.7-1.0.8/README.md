# Comparing `tmp/sg_otio-1.0.7-py3-none-any.whl.zip` & `tmp/sg_otio-1.0.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,40 +1,40 @@
-Zip file size: 122751 bytes, number of entries: 38
--rw-r--r--  2.0 unx      646 b- defN 24-Apr-25 16:36 sg_otio/__init__.py
--rw-r--r--  2.0 unx    16358 b- defN 24-Apr-25 16:36 sg_otio/clip_group.py
--rw-r--r--  2.0 unx     8613 b- defN 24-Apr-25 16:36 sg_otio/command.py
--rw-r--r--  2.0 unx     5272 b- defN 24-Apr-25 16:36 sg_otio/constants.py
--rw-r--r--  2.0 unx    27820 b- defN 24-Apr-25 16:36 sg_otio/cut_clip.py
--rw-r--r--  2.0 unx    18277 b- defN 24-Apr-25 16:36 sg_otio/cut_diff.py
--rw-r--r--  2.0 unx    12567 b- defN 24-Apr-25 16:36 sg_otio/media_cutter.py
--rw-r--r--  2.0 unx     3595 b- defN 24-Apr-25 16:36 sg_otio/media_uploader.py
--rw-r--r--  2.0 unx      509 b- defN 24-Apr-25 16:36 sg_otio/plugin_manifest.json
--rw-r--r--  2.0 unx    18680 b- defN 24-Apr-25 16:36 sg_otio/sg_cut_reader.py
--rw-r--r--  2.0 unx    51081 b- defN 24-Apr-25 16:36 sg_otio/sg_cut_track_writer.py
--rw-r--r--  2.0 unx    24766 b- defN 24-Apr-25 16:36 sg_otio/sg_settings.py
--rw-r--r--  2.0 unx    52293 b- defN 24-Apr-25 16:36 sg_otio/track_diff.py
--rw-r--r--  2.0 unx    11995 b- defN 24-Apr-25 16:36 sg_otio/utils.py
--rw-r--r--  2.0 unx       86 b- defN 24-Apr-25 16:36 sg_otio/adapters/__init__.py
--rw-r--r--  2.0 unx    49314 b- defN 24-Apr-25 16:36 sg_otio/adapters/cmx_3600.py
--rw-r--r--  2.0 unx     5144 b- defN 24-Apr-25 16:36 sg_otio/adapters/shotgrid.py
--rwxr-xr-x  2.0 unx      313 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.data/scripts/sg-otio
--rwxr-xr-x  2.0 unx     7635 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.data/scripts/sg-otio.py
--rw-r--r--  2.0 unx       86 b- defN 24-Apr-25 16:36 tests/__init__.py
--rw-r--r--  2.0 unx     2733 b- defN 24-Apr-25 16:36 tests/conftest.py
--rw-r--r--  2.0 unx     8328 b- defN 24-Apr-25 16:36 tests/test_clip_group.py
--rw-r--r--  2.0 unx    12853 b- defN 24-Apr-25 16:36 tests/test_command.py
--rw-r--r--  2.0 unx    23131 b- defN 24-Apr-25 16:36 tests/test_cut_clip.py
--rw-r--r--  2.0 unx    74024 b- defN 24-Apr-25 16:36 tests/test_cut_diff.py
--rw-r--r--  2.0 unx     8247 b- defN 24-Apr-25 16:36 tests/test_media_cutter.py
--rw-r--r--  2.0 unx     4543 b- defN 24-Apr-25 16:36 tests/test_media_uploader.py
--rw-r--r--  2.0 unx    42223 b- defN 24-Apr-25 16:36 tests/test_shotgrid_adapter.py
--rw-r--r--  2.0 unx    14741 b- defN 24-Apr-25 16:36 tests/test_utils.py
--rw-r--r--  2.0 unx       86 b- defN 24-Apr-25 16:36 tests/python/__init__.py
--rw-r--r--  2.0 unx     5717 b- defN 24-Apr-25 16:36 tests/python/mock_grid.py
--rw-r--r--  2.0 unx     1187 b- defN 24-Apr-25 16:36 tests/python/sg_test.py
--rw-r--r--  2.0 unx    11357 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     9714 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       14 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3074 b- defN 24-Apr-25 16:36 sg_otio-1.0.7.dist-info/RECORD
-38 files, 537157 bytes uncompressed, 117919 bytes compressed:  78.0%
+Zip file size: 123087 bytes, number of entries: 38
+-rw-r--r--  2.0 unx      646 b- defN 24-May-08 15:53 sg_otio/__init__.py
+-rw-r--r--  2.0 unx    16359 b- defN 24-May-08 15:53 sg_otio/clip_group.py
+-rw-r--r--  2.0 unx     8613 b- defN 24-May-08 15:53 sg_otio/command.py
+-rw-r--r--  2.0 unx     5272 b- defN 24-May-08 15:53 sg_otio/constants.py
+-rw-r--r--  2.0 unx    27820 b- defN 24-May-08 15:53 sg_otio/cut_clip.py
+-rw-r--r--  2.0 unx    18277 b- defN 24-May-08 15:53 sg_otio/cut_diff.py
+-rw-r--r--  2.0 unx    12568 b- defN 24-May-08 15:53 sg_otio/media_cutter.py
+-rw-r--r--  2.0 unx     3595 b- defN 24-May-08 15:53 sg_otio/media_uploader.py
+-rw-r--r--  2.0 unx      509 b- defN 24-May-08 15:53 sg_otio/plugin_manifest.json
+-rw-r--r--  2.0 unx    18681 b- defN 24-May-08 15:53 sg_otio/sg_cut_reader.py
+-rw-r--r--  2.0 unx    51081 b- defN 24-May-08 15:53 sg_otio/sg_cut_track_writer.py
+-rw-r--r--  2.0 unx    24766 b- defN 24-May-08 15:53 sg_otio/sg_settings.py
+-rw-r--r--  2.0 unx    52296 b- defN 24-May-08 15:53 sg_otio/track_diff.py
+-rw-r--r--  2.0 unx    11995 b- defN 24-May-08 15:53 sg_otio/utils.py
+-rw-r--r--  2.0 unx       86 b- defN 24-May-08 15:53 sg_otio/adapters/__init__.py
+-rw-r--r--  2.0 unx    50492 b- defN 24-May-08 15:53 sg_otio/adapters/cmx_3600.py
+-rw-r--r--  2.0 unx     5144 b- defN 24-May-08 15:53 sg_otio/adapters/shotgrid.py
+-rwxr-xr-x  2.0 unx      313 b- defN 24-May-08 15:53 sg_otio-1.0.8.data/scripts/sg-otio
+-rwxr-xr-x  2.0 unx     7635 b- defN 24-May-08 15:53 sg_otio-1.0.8.data/scripts/sg-otio.py
+-rw-r--r--  2.0 unx       86 b- defN 24-May-08 15:53 tests/__init__.py
+-rw-r--r--  2.0 unx     2733 b- defN 24-May-08 15:53 tests/conftest.py
+-rw-r--r--  2.0 unx     8328 b- defN 24-May-08 15:53 tests/test_clip_group.py
+-rw-r--r--  2.0 unx    12857 b- defN 24-May-08 15:53 tests/test_command.py
+-rw-r--r--  2.0 unx    23140 b- defN 24-May-08 15:53 tests/test_cut_clip.py
+-rw-r--r--  2.0 unx    74027 b- defN 24-May-08 15:53 tests/test_cut_diff.py
+-rw-r--r--  2.0 unx     8249 b- defN 24-May-08 15:53 tests/test_media_cutter.py
+-rw-r--r--  2.0 unx     4543 b- defN 24-May-08 15:53 tests/test_media_uploader.py
+-rw-r--r--  2.0 unx    42240 b- defN 24-May-08 15:53 tests/test_shotgrid_adapter.py
+-rw-r--r--  2.0 unx    14741 b- defN 24-May-08 15:53 tests/test_utils.py
+-rw-r--r--  2.0 unx       86 b- defN 24-May-08 15:53 tests/python/__init__.py
+-rw-r--r--  2.0 unx     5717 b- defN 24-May-08 15:53 tests/python/mock_grid.py
+-rw-r--r--  2.0 unx     1187 b- defN 24-May-08 15:53 tests/python/sg_test.py
+-rw-r--r--  2.0 unx    11357 b- defN 24-May-08 15:53 sg_otio-1.0.8.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     9714 b- defN 24-May-08 15:53 sg_otio-1.0.8.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-08 15:53 sg_otio-1.0.8.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 24-May-08 15:53 sg_otio-1.0.8.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       14 b- defN 24-May-08 15:53 sg_otio-1.0.8.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3074 b- defN 24-May-08 15:53 sg_otio-1.0.8.dist-info/RECORD
+38 files, 538376 bytes uncompressed, 118255 bytes compressed:  78.0%
```

## zipnote {}

```diff
@@ -45,18 +45,18 @@
 
 Filename: sg_otio/adapters/cmx_3600.py
 Comment: 
 
 Filename: sg_otio/adapters/shotgrid.py
 Comment: 
 
-Filename: sg_otio-1.0.7.data/scripts/sg-otio
+Filename: sg_otio-1.0.8.data/scripts/sg-otio
 Comment: 
 
-Filename: sg_otio-1.0.7.data/scripts/sg-otio.py
+Filename: sg_otio-1.0.8.data/scripts/sg-otio.py
 Comment: 
 
 Filename: tests/__init__.py
 Comment: 
 
 Filename: tests/conftest.py
 Comment: 
@@ -90,26 +90,26 @@
 
 Filename: tests/python/mock_grid.py
 Comment: 
 
 Filename: tests/python/sg_test.py
 Comment: 
 
-Filename: sg_otio-1.0.7.dist-info/LICENSE.txt
+Filename: sg_otio-1.0.8.dist-info/LICENSE.txt
 Comment: 
 
-Filename: sg_otio-1.0.7.dist-info/METADATA
+Filename: sg_otio-1.0.8.dist-info/METADATA
 Comment: 
 
-Filename: sg_otio-1.0.7.dist-info/WHEEL
+Filename: sg_otio-1.0.8.dist-info/WHEEL
 Comment: 
 
-Filename: sg_otio-1.0.7.dist-info/entry_points.txt
+Filename: sg_otio-1.0.8.dist-info/entry_points.txt
 Comment: 
 
-Filename: sg_otio-1.0.7.dist-info/top_level.txt
+Filename: sg_otio-1.0.8.dist-info/top_level.txt
 Comment: 
 
-Filename: sg_otio-1.0.7.dist-info/RECORD
+Filename: sg_otio-1.0.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sg_otio/clip_group.py

```diff
@@ -464,15 +464,15 @@
         Convenience method to generate :class:`ClipGroup` from a video track.
 
         :param video_track: A class:`otio.schema.Track` instance.
         :returns: A dictionary where keys are shot names and values :class:`ClipGroup`
                   instances.
         """
         shots_by_name = {}
-        for i, clip in enumerate(video_track.each_clip()):
+        for i, clip in enumerate(video_track.find_clips()):
             shot_name = compute_clip_shot_name(clip)
             shot_key = ""
             if shot_name:
                 # Matching Shots must be case insensitive
                 shot_key = shot_name.lower()
             # Ensure a ClipGroup and add SGCutClip to it.
             if shot_key not in shots_by_name:
```

## sg_otio/media_cutter.py

```diff
@@ -75,15 +75,15 @@
 
         :param int max_workers: The maximum number of workers to run in parallel.
                                 If ``None``, the default system value is used.
         :raises RuntimeError: If all media files couldn't be extracted.
         """
         clips_to_extract = []
         futures = []
-        for i, clip in enumerate(self._video_track.each_clip()):
+        for i, clip in enumerate(self._video_track.find_clips()):
             if clip.media_reference.is_missing_reference:
                 media_name = compute_clip_version_name(clip, i + 1)
                 clips_to_extract.append(
                     (clip, media_name, self._get_media_filename(media_name))
                 )
 
         if not clips_to_extract:
```

## sg_otio/sg_cut_reader.py

```diff
@@ -247,15 +247,15 @@
         :param project: A SG Project entity.
         """
         # TODO: check if this is needed? It seems it is only called in test_utils
         # and nowhere else. Should the add_publish_file_media_reference_to_clip and
         # add_version_media_reference_to_clip be tested instead? #9393
         clips_with_no_media_references = []
         clip_media_names = []
-        for i, clip in enumerate(track.each_clip()):
+        for i, clip in enumerate(track.find_clips()):
             if clip.media_reference.is_missing_reference:
                 clips_with_no_media_references.append(clip)
                 clip_media_names.append(compute_clip_version_name(clip, i + 1))
             # TODO: Deal with clips with media references with local filepaths that cannot be found.
         if not clips_with_no_media_references:
             return
         sg_published_files = self._sg.find(
```

## sg_otio/track_diff.py

```diff
@@ -385,15 +385,15 @@
                 )
         logger.debug("Cut comparison performed against %s" % self._sg_entity)
 
         # Retrieve SG Entities from the old_track
         sg_shot_ids = []
         prev_clip_list = []
         if self._old_track:
-            for i, clip in enumerate(self._old_track.each_clip()):
+            for i, clip in enumerate(self._old_track.find_clips()):
                 # Check if we have some SG meta data
                 sg_cut_item = clip.metadata.get("sg")
                 if not sg_cut_item or sg_cut_item.get("type") != "CutItem":
                     raise ValueError(
                         "Invalid clip %s not linked to a SG CutItem" % clip.name
                     )
                 sg_cut_item = sg_cut_item.to_dict()
@@ -427,15 +427,15 @@
             # Build a dictionary where Shot names are the keys, use the Shot id
             # if the name is not set
             sg_shots_dict = dict(((x["code"] or str(x["id"])).lower(), x) for x in sg_shots)
 
         # Retrieve additional Shots from the new track if needed
         self._diffs_by_shots = {}
         more_shot_names = set()
-        for i, clip in enumerate(new_track.each_clip()):
+        for i, clip in enumerate(new_track.find_clips()):
             shot_name = compute_clip_shot_name(clip)
             if shot_name:
                 more_shot_names.add(shot_name)
             # Ensure a SGCutDiffGroup and add SGCutDiff to it.
             self.add_cut_diff(shot_name, clip=clip, index=i + 1, sg_shot=None)
         if more_shot_names:
             logger.debug("Looking for additional Shots %s" % more_shot_names)
@@ -862,15 +862,15 @@
             count = (
                 self.count_for_type(_DIFF_TYPES.NEW) + self.count_for_type(_DIFF_TYPES.CUT_CHANGE)
                 + self.count_for_type(_DIFF_TYPES.REINSTATED) + self.count_for_type(_DIFF_TYPES.RESCAN)
                 + self.count_for_type(_DIFF_TYPES.NO_CHANGE)
             )
             total_count = "%d" % count
             if self._old_track:
-                old_count = len(list(self._old_track.each_clip()))
+                old_count = len(list(self._old_track.find_clips()))
                 if old_count != count:
                     total_count = "%d (%d)" % (count, old_count)
             data_row = ["Total Count:", "%s" % total_count] + [""] * 5
             csv_writer.writerow(data_row)
 
             # Write the data
             csv_writer.writerow([""] * 7)
```

## sg_otio/adapters/cmx_3600.py

```diff
@@ -60,26 +60,34 @@
 }
 
 
 # Currently, the 'style' argument determines
 # the comment string for the media reference:
 #   'avid': '* FROM CLIP:' (default)
 #   'nucoda': '* FROM FILE:'
+#   'premiere': None (If Adobe Premiere imports an EDL that uses
+#                     a "FROM" comment will result in the clips
+#                     being named UNKNOWN instead of using the reel or file name)
 # When adding a new style, please be sure to add sufficient tests
 # to verify both the new and existing styles.
-VALID_EDL_STYLES = ['avid', 'nucoda']
+VALID_EDL_STYLES = {
+    'avid': 'CLIP',
+    'nucoda': 'FILE',
+    'premiere': None,
+}
 
 
 def _extend_source_range_duration(obj, duration):
     obj.source_range = obj.source_range.duration_extended_by(duration)
 
 
-class EDLParser(object):
+class EDLParser:
     def __init__(self, edl_string, rate=24, ignore_timecode_mismatch=False):
         self.timeline = schema.Timeline()
+
         # Start with no tracks. They will be added as we encounter them.
         # This dict maps a track name (e.g "A2" or "V") to an OTIO Track.
         self.tracks_by_name = {}
 
         self.ignore_timecode_mismatch = ignore_timecode_mismatch
 
         self.parse_edl(edl_string, rate=rate)
@@ -354,15 +362,15 @@
         for track in self.timeline.tracks:
             # if the source_range is the same as the available_range
             # then we don't need to set it at all.
             if track.source_range == track.available_range():
                 track.source_range = None
 
 
-class ClipHandler(object):
+class ClipHandler:
     # /path/filename.[1001-1020].ext
     image_sequence_pattern = re.compile(
         r'.*\.(?P<range>\[(?P<start>[0-9]+)-(?P<end>[0-9]+)\])\.\w+$'
     )
 
     def __init__(self, line, comment_data, rate=24, transition_line=None):
         self.clip_num = None
@@ -484,15 +492,15 @@
                 if m:
                     floats = [float(g) for g in m.groups()]
                     slope = [floats[0], floats[1], floats[2]]
                     offset = [floats[3], floats[4], floats[5]]
                     power = [floats[6], floats[7], floats[8]]
                 else:
                     raise EDLParseError(
-                        'Invalid ASC_SOP found: {}'.format(asc_sop))
+                        f'Invalid ASC_SOP found: {asc_sop}')
 
             if asc_sat:
                 sat = float(asc_sat)
 
             clip.metadata['cdl'] = {
                 'asc_sat': sat,
                 'asc_sop': {
@@ -603,15 +611,15 @@
                 raise EDLParseError(
                     'incorrect edit type {} in form statement: {}'.format(
                         edit_type, line,
                     )
                 )
         else:
             raise EDLParseError(
-                'incorrect number of fields [{0}] in form statement: {1}'
+                'incorrect number of fields [{}] in form statement: {}'
                 ''.format(field_count, line))
 
         # Frame numbers (not just timecode) are ok
         for prop in [
             'source_tc_in',
             'source_tc_out',
             'record_tc_in',
@@ -696,15 +704,15 @@
             0,
             transition_duration.rate
         )
         new_trx.out_offset = transition_duration
         return new_trx
 
 
-class CommentHandler(object):
+class CommentHandler:
     # this is the for that all comment 'id' tags take
     regex_template = r'\*?\s*{id}:?\s*(?P<comment_body>.*)'
 
     # this should be a map of all known comments that we can read
     # 'FROM CLIP' or 'FROM FILE' is a required comment to link media
     # An exception is raised if both 'FROM CLIP' and 'FROM FILE' are found
     # needs to be ordered so that FROM CLIP NAME gets matched before FROM CLIP
@@ -714,14 +722,15 @@
         ('FROM CLIP', 'media_reference'),
         ('FROM FILE', 'media_reference'),
         ('LOC', 'locators'),
         ('ASC_SOP', 'asc_sop'),
         ('ASC_SAT', 'asc_sat'),
         ('M2', 'motion_effect'),
         ('\\* FREEZE FRAME', 'freeze_frame'),
+        ('\\* OTIO REFERENCE [a-zA-Z]+', 'media_reference'),
     ])
 
     def __init__(self, comments):
         self.handled = {}
         self.unhandled = []
         for comment in comments:
             self.parse(comment)
@@ -785,17 +794,17 @@
 
 
 def write_to_string(input_otio, rate=None, style='avid', reelname_len=8):
     # TODO: We should have convenience functions in Timeline for this?
     # also only works for a single video track at the moment
 
     video_tracks = [t for t in input_otio.tracks
-                    if t.kind == schema.TrackKind.Video]
+                    if t.kind == schema.TrackKind.Video and t.enabled]
     audio_tracks = [t for t in input_otio.tracks
-                    if t.kind == schema.TrackKind.Audio]
+                    if t.kind == schema.TrackKind.Audio and t.enabled]
 
     if len(video_tracks) != 1:
         raise exceptions.NotSupportedError(
             "Only a single video track is supported, got: {}".format(
                 len(video_tracks)
             )
         )
@@ -819,15 +828,15 @@
         style=style,
         reelname_len=reelname_len
     )
 
     return writer.get_content_for_track_at_index(0, title=input_otio.name)
 
 
-class EDLWriter(object):
+class EDLWriter:
     def __init__(self, tracks, rate, style, reelname_len=8):
         self._tracks = tracks
         self._rate = rate
         self._style = style
         self._reelname_len = reelname_len
 
         if style not in VALID_EDL_STYLES:
@@ -899,35 +908,38 @@
                         track.kind,
                         self._rate,
                         self._style,
                         self._reelname_len
                     )
                 )
             elif isinstance(child, schema.Clip):
-                events.append(
-                    Event(
-                        child,
-                        self._tracks,
-                        track.kind,
-                        self._rate,
-                        self._style,
-                        self._reelname_len
+                if child.enabled:
+                    events.append(
+                        Event(
+                            child,
+                            self._tracks,
+                            track.kind,
+                            self._rate,
+                            self._style,
+                            self._reelname_len
+                        )
                     )
-                )
+                else:
+                    pass
             elif isinstance(child, schema.Gap):
                 # Gaps are represented as missing record timecode, no event
                 # needed.
                 pass
 
-        content = "TITLE: {}\n\n".format(title) if title else ''
-
-        # Convert each event/dissolve-event into plain text.
-        for idx, event in enumerate(events):
-            event.edit_number = idx + 1
-            content += event.to_edl_format() + '\n'
+        content = f"TITLE: {title}\n\n" if title else ''
+        if track.enabled:
+            # Convert each event/dissolve-event into plain text.
+            for idx, event in enumerate(events):
+                event.edit_number = idx + 1
+                content += event.to_edl_format() + '\n'
 
         return content
 
 
 def _supported_timing_effects(clip):
     return [
         fx for fx in clip.effects
@@ -953,26 +965,32 @@
         raise exceptions.NotSupportedError(
             "EDL Adapter only allows one timing effect / clip."
         )
 
     return timing_effect
 
 
-class Event(object):
+class Event:
     def __init__(
         self,
         clip,
         tracks,
         kind,
         rate,
         style,
         reelname_len
     ):
 
-        line = EventLine(kind, rate, reel=_reel_from_clip(clip, reelname_len))
+        # Premiere style uses AX for the reel name
+        if style == 'premiere':
+            reel = 'AX'
+        else:
+            reel = _reel_from_clip(clip, reelname_len)
+
+        line = EventLine(kind, rate, reel=reel)
         line.source_in = clip.source_range.start_time
         line.source_out = clip.source_range.end_time_exclusive()
 
         timing_effect = _relevant_timing_effect(clip)
 
         if timing_effect:
             if timing_effect.effect_name == "FreezeFrame":
@@ -1022,15 +1040,15 @@
         """
         lines = [self.line.to_edl_format(self.edit_number)]
         lines += self.comments if len(self.comments) else []
 
         return "\n".join(lines)
 
 
-class DissolveEvent(object):
+class DissolveEvent:
 
     def __init__(
         self,
         a_side_event,
         transition,
         b_side_clip,
         tracks,
@@ -1141,15 +1159,15 @@
         ]
         lines += self.from_comments if hasattr(self, 'from_comments') else []
         lines += self.to_comments if len(self.to_comments) else []
 
         return "\n".join(lines)
 
 
-class EventLine(object):
+class EventLine:
     def __init__(self, kind, rate, reel='AX'):
         self.reel = reel
         self._kind = 'V' if kind == schema.TrackKind.Video else 'A'
         self._rate = rate
 
         self.source_in = opentime.RationalTime(0.0, rate=rate)
         self.source_out = opentime.RationalTime(0.0, rate=rate)
@@ -1204,14 +1222,18 @@
     if clip.media_reference:
         if hasattr(clip.media_reference, 'target_url'):
             url = clip.media_reference.target_url
 
         elif hasattr(clip.media_reference, 'abstract_target_url'):
             url = _get_image_sequence_url(clip)
 
+        if url:
+            # Premiere style uses the base name of the media reference
+            if style == 'premiere':
+                clip.name = os.path.basename(clip.media_reference.target_url)
     else:
         url = clip.name
 
     if from_or_to not in ['FROM', 'TO']:
         raise exceptions.NotSupportedError(
             "The clip FROM or TO value '{}' is not supported.".format(
                 from_or_to
@@ -1232,36 +1254,45 @@
 
     if clip.name:
         # Avid Media Composer outputs two spaces before the
         # clip name so we match that.
         lines.append(
             "* {from_or_to} CLIP NAME:  {name}{suffix}".format(
                 from_or_to=from_or_to,
-                name=clip.name,
+                name=os.path.basename(url) if style == 'premiere' else clip.name,
                 suffix=suffix
             )
         )
     if timing_effect and timing_effect.effect_name == "FreezeFrame":
         lines.append('* * FREEZE FRAME')
-    if url and style == 'avid':
-        lines.append("* {from_or_to} CLIP: {url}".format(
-            from_or_to=from_or_to,
-            url=url
-        ))
-    if url and style == 'nucoda':
-        lines.append("* {from_or_to} FILE: {url}".format(
-            from_or_to=from_or_to,
-            url=url
-        ))
+
+    # If the style has a spec, apply it and add it as a comment
+    style_spec = VALID_EDL_STYLES.get(style)
+    if url:
+        if style_spec:
+            lines.append("* {from_or_to} {style_spec}: {url}".format(
+                from_or_to=from_or_to,
+                style_spec=style_spec,
+                url=_flip_windows_slashes(url)
+            ))
+        else:
+            lines.append("* OTIO REFERENCE {from_or_to}: {url}".format(
+                from_or_to=from_or_to,
+                url=_flip_windows_slashes(url)
+            ))
 
     if reelname_len and not clip.metadata.get('cmx_3600', {}).get('reel'):
         lines.append("* OTIO TRUNCATED REEL NAME FROM: {url}".format(
             url=os.path.basename(_flip_windows_slashes(url or clip.name))
         ))
 
+    if style == 'premiere':
+        clip.metadata.setdefault('cmx_3600', {})
+        clip.metadata['cmx_3600'].update({'reel': 'AX'})
+
     cdl = clip.metadata.get('cdl')
     if cdl:
         asc_sop = cdl.get('asc_sop')
         asc_sat = cdl.get('asc_sat')
         if asc_sop:
             lines.append(
                 "*ASC_SOP ({} {} {}) ({} {} {}) ({} {} {})".format(
@@ -1288,21 +1319,21 @@
         )
 
         color = marker.color
         meta = marker.metadata.get("cmx_3600")
         if not color and meta and meta.get("color"):
             color = meta.get("color").upper()
         comment = (marker.name or '').upper()
-        lines.append("* LOC: {} {:7} {}".format(timecode, color, comment))
+        lines.append(f"* LOC: {timecode} {color:7} {comment}")
 
     # If we are carrying any unhandled CMX 3600 comments on this clip
     # then output them blindly.
     extra_comments = clip.metadata.get('cmx_3600', {}).get('comments', [])
     for comment in extra_comments:
-        lines.append("* {}".format(comment))
+        lines.append(f"* {comment}")
 
     return lines
 
 
 def _get_image_sequence_url(clip):
     ref = clip.media_reference
     start_frame, end_frame = ref.frame_range_for_time_range(
```

## tests/test_command.py

```diff
@@ -181,15 +181,15 @@
         self._sg_entities_to_delete.extend(self.sg_cut_items)
 
     @staticmethod
     def _mock_compute_clip_shot_name(clip):
         """
         Override compute clip shot name to get a unique shot name per clip.
         """
-        return "shot_%d" % (6665 + list(clip.parent().each_clip()).index(clip) + 1)
+        return "shot_%d" % (6665 + list(clip.parent().find_clips()).index(clip) + 1)
 
     def tearDown(self):
         """
         Called inconditionally after each test.
         """
         super(TestCommand, self).tearDown()
         for sg_entity in self._sg_entities_to_delete:
@@ -216,15 +216,15 @@
                     self.assertEqual(len(timeline.tracks), 1)
                     track = timeline.tracks[0]
                     self.assertIsNotNone(track.metadata.get("sg"))
                     sg_data = track.metadata["sg"]
                     self.assertEqual(sg_data["type"], "Cut")
                     self.assertEqual(sg_data["id"], self.sg_cuts[0]["id"])
                     self.assertEqual(len(track), len(self.sg_cut_items))
-                    for i, clip in enumerate(track.each_clip()):
+                    for i, clip in enumerate(track.find_clips()):
                         # Just check basic stuff
                         self.assertEqual(clip.name, self.sg_cut_items[i]["code"])
                         self.assertEqual(
                             clip.source_range.duration,
                             otio.opentime.RationalTime(
                                 self.sg_cut_items[i]["cut_item_duration"],
                                 24,
@@ -261,15 +261,15 @@
                     self.assertEqual(len(new_timeline.tracks), 1)
                     new_track = new_timeline.tracks[0]
                     self.assertIsNotNone(new_track.metadata.get("sg"))
                     sg_data = new_track.metadata["sg"]
                     self.assertEqual(sg_data["type"], "Cut")
                     self.assertEqual(sg_data["id"], new_cut["id"])
                     self.assertEqual(len(new_track), len(self.sg_cut_items))
-                    for i, clip in enumerate(new_track.each_clip()):
+                    for i, clip in enumerate(new_track.find_clips()):
                         # Just check basic stuff
                         self.assertEqual(clip.name, self.sg_cut_items[i]["code"])
                         self.assertEqual(
                             clip.source_range.duration,
                             otio.opentime.RationalTime(
                                 self.sg_cut_items[i]["cut_item_duration"],
                                 24,
@@ -291,15 +291,15 @@
                     self.assertEqual(len(new_timeline.tracks), 1)
                     new_track = new_timeline.tracks[0]
                     self.assertIsNotNone(new_track.metadata.get("sg"))
                     sg_data = new_track.metadata["sg"]
                     self.assertEqual(sg_data["type"], "Cut")
                     self.assertEqual(sg_data["id"], new_cut2["id"])
                     self.assertEqual(len(new_track), len(self.sg_cut_items))
-                    for i, clip in enumerate(new_track.each_clip()):
+                    for i, clip in enumerate(new_track.find_clips()):
                         # Just check basic stuff
                         self.assertEqual(clip.name, self.sg_cut_items[i]["code"])
                         self.assertEqual(
                             clip.source_range.duration,
                             otio.opentime.RationalTime(
                                 self.sg_cut_items[i]["cut_item_duration"],
                                 24,
```

## tests/test_cut_clip.py

```diff
@@ -43,15 +43,15 @@
             TITLE:   OTIO_TEST
             FCM: NON-DROP FRAME
 
             001  clip_reel_name V     C        00:00:00:00 00:00:01:00 01:00:00:00 01:00:01:00
             * FROM CLIP NAME: clip_name
          """
         timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600")
-        edl_clip = list(timeline.tracks[0].each_clip())[0]
+        edl_clip = list(timeline.tracks[0].find_clips())[0]
         clip = SGCutClip(edl_clip)
         self.assertEqual(clip.name, "clip_reel_name")
 
     def test_shot_name(self):
         """
         Test that the shot name is properly extracted in different scenarios.
         """
@@ -68,26 +68,26 @@
             003  reel_name V     C        00:00:00:00 00:00:01:00 01:00:02:00 01:00:03:00
             * LOC: 01:00:00:12 YELLOW
             004  reel_name V     C        00:00:00:00 00:00:01:00 01:00:03:00 01:00:04:00
             * LOC: 01:00:00:12 YELLOW
             * LOC: 01:00:00:12 YELLOW  shot_004
         """
         timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600")
-        edl_clip = list(timeline.tracks[0].each_clip())[0]
+        edl_clip = list(timeline.tracks[0].find_clips())[0]
         # Set use reel names to True to see it does not affect the outcome.
         sg_settings = SGSettings()
         sg_settings.use_clip_names_for_shot_names = True
         clip = SGCutClip(
             edl_clip
         )
         # Locators and comments present, locator is used.
         self.assertEqual(clip.shot_name, "shot_001")
 
         # Without a locator. Comment starting with COMMENT: is used.
-        edl_clip = list(timeline.tracks[0].each_clip())[1]
+        edl_clip = list(timeline.tracks[0].find_clips())[1]
         clip = SGCutClip(
             edl_clip
         )
         clip._shot_name = compute_clip_shot_name(clip)
         self.assertEqual(clip.shot_name, "shot_002")
 
         # Remove the comment starting with COMMENT:. The bare comment is used.
@@ -119,23 +119,23 @@
             "shot": {"code": "shot_from_SG"}
         }
         clip._shot_name = compute_clip_shot_name(clip)
         self.assertEqual(clip.shot_name, "shot_from_SG")
 
         # A locator with an empty name.
         sg_settings.use_clip_names_for_shot_names = False
-        edl_clip = list(timeline.tracks[0].each_clip())[2]
+        edl_clip = list(timeline.tracks[0].find_clips())[2]
         clip = SGCutClip(
             edl_clip
         )
         clip._shot_name = compute_clip_shot_name(clip)
         self.assertIsNone(clip.shot_name)
 
         # Two locators, the first one has an empty name, the second one has a name.
-        edl_clip = list(timeline.tracks[0].each_clip())[3]
+        edl_clip = list(timeline.tracks[0].find_clips())[3]
         clip = SGCutClip(
             edl_clip
         )
         clip._shot_name = compute_clip_shot_name(clip)
         self.assertEqual(clip.shot_name, "shot_004")
 
     def test_clip_values(self):
@@ -159,15 +159,15 @@
         # to show that the results are still consistent.
         sg_settings = SGSettings()
         sg_settings.default_head_in = 555
         sg_settings.default_head_duration = 10
         sg_settings.default_tail_duration = 20
         edl_timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600")
         video_track = edl_timeline.tracks[0]
-        clips = [SGCutClip(c, index=i + 1) for i, c in enumerate(video_track.each_clip())]
+        clips = [SGCutClip(c, index=i + 1) for i, c in enumerate(video_track.find_clips())]
         self.assertEqual(len(clips), 2)
         clip_1 = clips[0]
         # There's a retime, so the clip is actually 2 * 0.5 seconds long.
         self.assertEqual(clip_1.duration().to_frames(), 24)
         self.assertEqual(clip_1.visible_duration.to_frames(), 48)
         self.assertEqual(clip_1.source_in.to_timecode(), "01:00:00:00")
         self.assertEqual(clip_1.source_out.to_timecode(), "01:00:02:00")
@@ -237,15 +237,15 @@
         sg_settings.timecode_in_to_frame_mapping = _TC2FRAME_AUTOMATIC_MODE
         sg_settings.use_clip_names_for_shot_names = False
         sg_settings.default_head_in = 555
         sg_settings.default_head_duration = 10
         sg_settings.default_tail_duration = 20
         edl_timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600")
         video_track = edl_timeline.tracks[0]
-        clips = [SGCutClip(c) for c in video_track.each_clip()]
+        clips = [SGCutClip(c) for c in video_track.find_clips()]
         self.assertEqual(len(clips), 3)
         for clip in clips:
             self.assertIsNotNone(clip.shot_name)
         clip_1 = clips[0]
         # The normal duration is 24 frames
         self.assertEqual(clip_1.duration().to_frames(), 24)
         # The visible duration takes into account the whole duration of the transition
@@ -283,15 +283,15 @@
     def test_clip_values_with_transitions_from_file(self):
         """
         Test that transitions are properly computed from an example EDL file.
         """
         edl_filepath = os.path.join(self._edls_dir, "raphe_temp1_rfe_R01_v01_TRANSITIONS.edl")
         edl_timeline = otio.adapters.read_from_file(edl_filepath, adapter_name="cmx_3600")
         video_track = edl_timeline.tracks[0]
-        clip = list(video_track.each_clip())[1]
+        clip = list(video_track.find_clips())[1]
         cut_clip = SGCutClip(clip)
         self.assertEqual(cut_clip.source_in.to_timecode(), "00:59:59:09")
         self.assertEqual(cut_clip.source_out.to_timecode(), "01:00:05:15")
         self.assertEqual(cut_clip.record_in.to_timecode(), "01:00:07:23")
         self.assertEqual(cut_clip.record_out.to_timecode(), "01:00:14:05")
         # The normal duration is 120 frames
         self.assertEqual(cut_clip.duration().to_frames(), 120)
@@ -330,15 +330,15 @@
             sg_settings.default_head_in = head_in
             sg_settings.default_head_duration = head_duration
             sg_settings.default_tail_duration = tail_duration
             edl_timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600", rate=30)
             track = edl_timeline.tracks[0]
             clip_group = ClipGroup("shot_001")
             i = 1
-            for clip in track.each_clip():
+            for clip in track.find_clips():
                 clip_group.add_clip(SGCutClip(clip, index=i))
                 i += 1
             self.assertEqual(clip_group.index, 3)  # First clip is the last starting at 01:00:00:00
             # All clips are considered parts of a single big clip, so head in
             # tail out values are identical for all clips, but the cut in and
             # cut out values differ, with different handle durations.
             tail_out = RationalTime(head_in + head_duration + 10 * 30 + tail_duration - 1, 30)
```

## tests/test_cut_diff.py

```diff
@@ -221,15 +221,15 @@
         self._sg_entities_to_delete.extend(self.sg_cut_items)
 
     @staticmethod
     def _mock_compute_clip_shot_name(clip):
         """
         Override compute clip shot name to get a unique shot name per clip.
         """
-        return "shot_%d" % (6665 + list(clip.parent().each_clip()).index(clip) + 1)
+        return "shot_%d" % (6665 + list(clip.parent().find_clips()).index(clip) + 1)
 
     def _get_track_diff(self, new_track, old_track=None, mock_compute_clip_shot_name=None, sg_entity=None):
         """
         Create a track diff altering the shot names so that there's
 
         :param new_track: A :class:`opentimelineio.schema.Track` instance.
         :param old_track: An optional :class:`opentimelineio.schema.Track` instance
@@ -688,15 +688,15 @@
         )
         sg_shots = [
             {"type": "Shot", "code": "old_shot_001", "project": self.mock_project, "id": 1},
             {"type": "Shot", "code": "old_shot_002", "project": self.mock_project, "id": 2}
         ]
         self.add_to_sg_mock_db(sg_shots)
         self._sg_entities_to_delete = sg_shots
-        for i, clip in enumerate(old_track.each_clip()):
+        for i, clip in enumerate(old_track.find_clips()):
             clip.metadata["sg"] = {
                 "type": "CutItem",
                 "id": -1,
                 "cut_item_in": 1009,
                 "cut_item_out": 1018,  # inclusive, ten frames
                 "cut_order": i + 1,
                 "timecode_cut_item_in_text": "%s" % RationalTime(i * 10, 24).to_timecode(),
@@ -770,15 +770,15 @@
         }
         sg_shots = [
             {"type": "Shot", "code": "marker_shot_000", "project": self.mock_project, "id": 1},
             {"type": "Shot", "code": "marker_shot_001", "project": self.mock_project, "id": 2}
         ]
         self.add_to_sg_mock_db(sg_shots)
         self._sg_entities_to_delete = sg_shots
-        for i, clip in enumerate(old_track.each_clip()):
+        for i, clip in enumerate(old_track.find_clips()):
             clip.metadata["sg"] = {
                 "type": "CutItem",
                 "id": -1,
                 "cut_item_in": 1009 + (i // 2) * 10,
                 "cut_item_out": 1009 + (i // 2) * 10 + 10 - 1,
                 "cut_order": i + 1,
                 "timecode_cut_item_in_text": "%s" % RationalTime((i // 2) * 10, 24).to_timecode(),
```

## tests/test_media_cutter.py

```diff
@@ -105,15 +105,15 @@
         self.assertTrue(os.path.isdir(media_cutter._media_dir))
         logger.info("Generated %s" % os.listdir(media_cutter._media_dir))
         # Note that pink_v01 already exists in SG, and blue_v01 already has a media ref,
         # so they won't be extracted, and media refs from cmx have empty names.
         media_names = ["green_tape", "pink_tape", "green_tape", "red_tape", "", "red_tape"]
         file_names = ["green_tape.mov", "pink_tape.mov", "green_tape_001.mov", "red_tape.mov", "foo.mov", "red_tape_001.mov"]
         ffprobe = find_executable("ffprobe")
-        for i, clip in enumerate(timeline.each_clip()):
+        for i, clip in enumerate(timeline.find_clips()):
             self.assertFalse(clip.media_reference.is_missing_reference)
             self.assertEqual(clip.media_reference.name, media_names[i])
             self.assertEqual(os.path.basename(clip.media_reference.target_url), file_names[i])
             # Fourth entry is a dummy reference to "foo.mov"
             if ffprobe and i != 4:
                 media_filepath = clip.media_reference.target_url.replace("file://", "")
                 self.assertEqual(media_cutter._media_dir, os.path.dirname(media_filepath))
@@ -154,14 +154,14 @@
                * FROM CLIP NAME: red_v01.mov
         """
         movie_filepath = os.path.join(self.resources_dir, "media_cutter.mov")
         timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600")
 
         media_cutter = MediaCutter(timeline, movie_filepath)
         media_cutter.cut_media_for_clips()
-        for i, clip in enumerate(timeline.each_clip()):
+        for i, clip in enumerate(timeline.find_clips()):
             clip_name = clip.metadata["cmx_3600"]["reel"]
             self.assertFalse(clip.media_reference.is_missing_reference)
             self.assertEqual(
                 clip.media_reference.name,
                 "%s_%04d" % (clip_name, i + 1)
             )
```

## tests/test_shotgrid_adapter.py

```diff
@@ -158,15 +158,15 @@
         )
 
     @staticmethod
     def _mock_compute_clip_shot_name(clip):
         """
         Override compute clip shot name to get a unique shot name per clip.
         """
-        return "Shot_%d" % (6665 + list(clip.parent().each_clip()).index(clip) + 1)
+        return "Shot_%d" % (6665 + list(clip.parent().find_clips()).index(clip) + 1)
 
     def test_read(self):
         """
         Test reading an SG Cut.
         """
         # Note: we need to use the single mocked sg instance created in setUp
         # for all tests.
@@ -196,15 +196,15 @@
             if k == "entity":
                 # Just check the type and id
                 self.assertEqual(track.metadata["sg"][k]["type"], v["type"])
                 self.assertEqual(track.metadata["sg"][k]["id"], v["id"])
             else:
                 self.assertEqual(track.metadata["sg"][k], v)
         # Check the track clips
-        for i, clip in enumerate(track.each_clip()):
+        for i, clip in enumerate(track.find_clips()):
             self.assertEqual(clip.name, self.mock_versions[i]["code"])
             self.assertEqual(
                 # Cut item in has 1001 + 8 frames more than the source range.
                 clip.source_range.start_time + otio.opentime.from_frames(1009, self.fps),
                 otio.opentime.RationalTime(
                     self.mock_cut_items[i]["cut_item_in"],
                     self.fps
@@ -366,17 +366,17 @@
                 timeline = otio.adapters.read_from_file(
                     SG_CUT_URL,
                     "ShotGrid",
                 )
             tracks = list(timeline.tracks)
             self.assertEqual(len(tracks), 1)
             track = tracks[0]
-            clips = list(track.each_clip())
+            clips = list(track.find_clips())
             self.assertEqual(len(clips), 2)
-            children = list(track.each_child())
+            children = list(track.find_children())
             self.assertEqual(len(children), 3)
             self.assertTrue(isinstance(children[0], otio.schema.Clip))
             self.assertTrue(isinstance(children[2], otio.schema.Clip))
             gap = children[1]
             self.assertTrue(isinstance(gap, otio.schema.Gap))
             source_range = otio.opentime.TimeRange(
                 start_time=otio.opentime.RationalTime(0, self.fps),
@@ -434,15 +434,15 @@
                     # Just check the type and id
                     self.assertEqual(track.metadata["sg"][k]["type"], v["type"])
                     self.assertEqual(track.metadata["sg"][k]["id"], v["id"])
                     self.assertEqual(track.metadata["sg"][k]["name"], v["code"])
                 else:
                     self.assertEqual(track.metadata["sg"][k], v)
             # Check the track clips
-            for i, clip in enumerate(track.each_clip()):
+            for i, clip in enumerate(track.find_clips()):
                 sg_data = clip.metadata["sg"]
                 self.assertEqual(sg_data["type"], "CutItem")
                 cut_item = self.mock_cut_items[i]
                 for k, v in cut_item.items():
                     if isinstance(v, dict):
                         # Just check the type and id
                         self.assertEqual(sg_data[k]["type"], v["type"])
@@ -501,15 +501,15 @@
                             )
                             self.assertEqual(sg_cut_item[field]["id"], self.mock_cut_items[i][field]["id"])
                         else:
                             self.assertEqual(sg_cut_item[field], self.mock_cut_items[i][field])
 
             # Check the SG metadata
             self.assertEqual(track.metadata["sg"]["id"], sg_cuts[0]["id"])
-            for i, clip in enumerate(track.each_clip()):
+            for i, clip in enumerate(track.find_clips()):
                 self.assertEqual(clip.metadata["sg"]["type"], "CutItem")
                 self.assertEqual(clip.metadata["sg"]["id"], sg_cut_items[i]["id"])
 
     def test_read_write_absolute_cut_order(self):
         """
         Test that absolute cut order/entity cut order work as expected.
         """
@@ -531,15 +531,15 @@
             self.assertIsNotNone(sg_cut)
             # Retrieve the CutItems
             sg_cut_items = self.mock_sg.find(
                 "CutItem", [["cut", "is", sg_cut]], [],
                 order=[{"field_name": "cut_order", "direction": "asc"}]
             )
             self.assertEqual(len(sg_cut_items), 3)
-            for i, clip in enumerate(track.each_clip()):
+            for i, clip in enumerate(track.find_clips()):
                 metadata_sg_shot = clip.metadata["sg"]["shot"]
                 sg_shot = self.mock_sg.find_one("Shot", [["id", "is", metadata_sg_shot["id"]]], ["sg_absolute_cut_order", "code"])
                 # Cut order should be 1000 * entity_cut_order + cut_item["cut_order"]
                 entity_cut_order = self.mock_sequence_absolute_cut_order["sg_absolute_cut_order"]
                 self.assertEqual(sg_shot["sg_absolute_cut_order"], 1000 * entity_cut_order + clip.metadata["sg"]["cut_order"])
 
     def test_read_write_to_edl(self):
@@ -578,15 +578,15 @@
             self.assertIsNotNone(sg_cut)
             # Retrieve the CutItems
             sg_cut_items = self.mock_sg.find(
                 "CutItem", [["cut", "is", sg_cut]], [],
                 order=[{"field_name": "cut_order", "direction": "asc"}]
             )
             self.assertEqual(len(sg_cut_items), 3)
-            for i, clip in enumerate(track.each_clip()):
+            for i, clip in enumerate(track.find_clips()):
                 self.assertEqual(clip.metadata["sg"]["id"], sg_cut_items[i]["id"])
 
     def test_write_read_edl_with_versions(self):
         """
         Test that when we write to SG, we create a new version for each CutItem.
         """
         settings = SGSettings()
@@ -657,15 +657,15 @@
                 )
                 self.assertEqual(len(sg_versions), 6)
 
                 # Let's read it from SG.
                 timeline_from_sg = otio.adapters.read_from_file(mock_cut_url, adapter_name="ShotGrid")
 
             # Check all the information relevant to media references is correct.
-            for i, (orig_clip, clip) in enumerate(zip(timeline.each_clip(), timeline_from_sg.each_clip())):
+            for i, (orig_clip, clip) in enumerate(zip(timeline.find_clips(), timeline_from_sg.find_clips())):
                 clip_version_name = compute_clip_version_name(orig_clip, i + 1)
                 self.assertEqual(orig_clip.media_reference.name, clip_version_name)
                 self.assertEqual(orig_clip.media_reference.name, clip.media_reference.name)
                 self.assertEqual(orig_clip.media_reference.target_url, clip.media_reference.target_url)
                 self.assertEqual(orig_clip.media_reference.available_range, clip.media_reference.available_range)
                 orig_clip_pf = orig_clip.media_reference.metadata["sg"]
                 clip_pf = clip.media_reference.metadata["sg"]
@@ -698,15 +698,15 @@
         settings.version_names_template = "from_premiere_{SHOT}_{CLIP_NAME}_{CLIP_INDEX:04d}"
         # The clip used in the Premiere xml is from frame 0 to frame 48,
         # but only frames 5 to 25 are in the track.
         # Note that we don't use media cutter, the media ref comes straight from Premiere.
         xml_file = os.path.join(self.resources_dir, "blue_frame_5_to_25.xml")
         timeline = otio.adapters.read_from_file(xml_file)
         # The path to the media is relative to the machine, replace it.
-        clip = list(timeline.each_clip())[0]
+        clip = list(timeline.find_clips())[0]
         file_path = os.path.join(self.resources_dir, "blue.mov")
         # Premiere prepends its path with file://localhost, and then an absolute path.
         # Keep it to test it would work properly.
         clip.media_reference.target_url = "file://localhost" + file_path
         mock_cut = {
             "type": "Cut",
             "id": 1000,
@@ -739,15 +739,15 @@
                         ["entity", "type_is", "Shot"]
                     ],
                     ["code", "entity"]
                 )
                 self.assertEqual(len(sg_versions), 1)
                 timeline_from_sg = otio.adapters.read_from_file(mock_cut_url, adapter_name="ShotGrid")
             # Check all the information relevant to media references and ranges is correct.
-            for i, (orig_clip, clip) in enumerate(zip(timeline.each_clip(), timeline_from_sg.each_clip())):
+            for i, (orig_clip, clip) in enumerate(zip(timeline.find_clips(), timeline_from_sg.find_clips())):
                 self.assertEqual(orig_clip.media_reference.target_url, clip.media_reference.target_url)
                 # In the case of this test, the available range is different than the visible range.
                 # Since we know the values from the files, also check them.
                 self.assertEqual(orig_clip.visible_range(), clip.visible_range())
                 self.assertEqual(orig_clip.visible_range().start_time.to_frames(), 5)
                 self.assertEqual(orig_clip.visible_range().duration.to_frames(), 20)
                 self.assertEqual(orig_clip.available_range(), clip.available_range())
@@ -780,21 +780,21 @@
         000002 other_reelname      V     C        00:00:00:05 00:00:00:11 01:00:00:16 01:00:00:22
         000003 reelname     V     C        00:00:00:05 00:00:00:16 01:00:00:22 01:00:01:09
         000004 other_reelname       V     C        00:00:00:12 00:00:01:00 01:00:01:09 01:00:01:21
         """
         timeline = otio.adapters.read_from_string(edl, adapter_name="cmx_3600")
         track = timeline.tracks[0]
         # Check all clips have the same name
-        for clip in track.each_clip():
+        for clip in track.find_clips():
             self.assertIn(SGCutClip(clip).name, ["reelname", "other_reelname"])
         with mock.patch.object(shotgun_api3, "Shotgun", return_value=self.mock_sg):
             otio.adapters.write_to_file(timeline, self._SG_SEQ_URL, "ShotGrid")
             # All should have different names
             names = []
-            for i, clip in enumerate(track.each_clip()):
+            for i, clip in enumerate(track.find_clips()):
                 self.assertIsNotNone(clip.metadata.get("sg"))
                 self.assertNotIn(clip.metadata["sg"]["code"], names)
                 names.append(clip.metadata["sg"]["code"])
                 # Check it has the expected form
                 self.assertTrue(
                     re.match(
                         r"^%s(_\d+)?" % SGCutClip(clip).name,
```

## Comparing `sg_otio-1.0.7.data/scripts/sg-otio.py` & `sg_otio-1.0.8.data/scripts/sg-otio.py`

 * *Files identical despite different names*

## Comparing `sg_otio-1.0.7.dist-info/LICENSE.txt` & `sg_otio-1.0.8.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `sg_otio-1.0.7.dist-info/METADATA` & `sg_otio-1.0.8.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sg-otio
-Version: 1.0.7
+Version: 1.0.8
 Summary: A library for OpenTimelineIO integration with ShotGrid
 Home-page: https://github.com/GPLgithub/sg-otio.git
 Author: GPL Technologies
 Author-email: pipelinesupport@gpltech.com
 License: Apache License 2.0
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
@@ -18,15 +18,15 @@
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Operating System :: OS Independent
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Natural Language :: English
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
-Requires-Dist: OpenTimelineIO ==0.15.0
+Requires-Dist: OpenTimelineIO ==0.16.0
 Requires-Dist: shotgun-api3 >=3.3.3
 Requires-Dist: futures ; python_version < "3.2"
 Requires-Dist: pathlib2 ; python_version < "3.4"
 Provides-Extra: dev
 Requires-Dist: flake8 ; extra == 'dev'
 Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: pytest-cov ; extra == 'dev'
```

### html2text {}

 * *error from `html2text {}`:*

 * *File "/tmp/diffoscope_rh6eswxw_/tmpxy1n6xy0_ZipContainer/METADATA", line 243, column 0: CDATA terminal not found*

```diff
@@ -1,22 +1,22 @@
-Metadata-Version: 2.1 Name: sg-otio Version: 1.0.7 Summary: A library for
+Metadata-Version: 2.1 Name: sg-otio Version: 1.0.8 Summary: A library for
 OpenTimelineIO integration with ShotGrid Home-page: https://github.com/
 GPLgithub/sg-otio.git Author: GPL Technologies Author-email:
 pipelinesupport@gpltech.com License: Apache License 2.0 Classifier: Development
 Status :: 4 - Beta Classifier: Intended Audience :: Developers Classifier:
 Topic :: Multimedia :: Video Classifier: Topic :: Multimedia :: Video ::
 Display Classifier: Topic :: Multimedia :: Video :: Non-Linear Editor
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Programming Language :: Python :: 3 Classifier: Programming
 Language :: Python :: 3.7 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9 Classifier: Programming
 Language :: Python :: 3.10 Classifier: Operating System :: OS Independent
 Classifier: License :: OSI Approved :: MIT License Classifier: Natural Language
 :: English Description-Content-Type: text/markdown License-File: LICENSE.txt
-Requires-Dist: OpenTimelineIO ==0.15.0 Requires-Dist: shotgun-api3 >=3.3.3
+Requires-Dist: OpenTimelineIO ==0.16.0 Requires-Dist: shotgun-api3 >=3.3.3
 Requires-Dist: futures ; python_version < "3.2" Requires-Dist: pathlib2 ;
 python_version < "3.4" Provides-Extra: dev Requires-Dist: flake8 ; extra ==
 'dev' Requires-Dist: pytest ; extra == 'dev' Requires-Dist: pytest-cov ; extra
 == 'dev' Requires-Dist: twine ; extra == 'dev' SG Otio, an OpenTimelineIO
 ShotGrid Library ======= [![Run tests](https://github.com/GPLgithub/sg-otio/
 actions/workflows/ci.yaml/badge.svg)](https://github.com/GPLgithub/sg-otio/
 actions/workflows/ci.yaml) [![codecov](https://codecov.io/gh/GPLgithub/sg-otio/
```

## Comparing `sg_otio-1.0.7.dist-info/RECORD` & `sg_otio-1.0.8.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 sg_otio/__init__.py,sha256=7tuqDBkBzQqok-OIdp8hfM2LIYItZjDiL3-R0sL608g,646
-sg_otio/clip_group.py,sha256=OA9deveqSqvFX8MNQTQd-ywb0BD4tEX5nlHqN-LBeio,16358
+sg_otio/clip_group.py,sha256=08xBffWeIw_Ei5M7jXGDykU4tQrBIMdAtyyhoTNILIM,16359
 sg_otio/command.py,sha256=hL6ZzgsJZAL7qRDXwG4N7hpiEiE1sZAveRQDGLdmYKI,8613
 sg_otio/constants.py,sha256=8RFrfHnXlaFia7GAqZZE8i0A63y5HQO8BtFluyk80-Y,5272
 sg_otio/cut_clip.py,sha256=zkH6FW_iEdQSJLWcZ4u0V8R5Q-tmjh_hqU3FNop9O4Q,27820
 sg_otio/cut_diff.py,sha256=wTFaI0FTEQqn7pL5tQy2uDBi6fgQaoYp8YtTifW6vTk,18277
-sg_otio/media_cutter.py,sha256=K6J--mU3U754uLf0y6k_HKQMtZ8B-bRlOC3HblH58FI,12567
+sg_otio/media_cutter.py,sha256=xw7CysiDAulO5tLSochP2oi5wuO0DvyRo91yXL6bbWo,12568
 sg_otio/media_uploader.py,sha256=J_rY8jpCufCu9PRDRgOoFUI2J9oj9nGwQh2qlkd3MOI,3595
 sg_otio/plugin_manifest.json,sha256=-4kysIwSzMjOgPKrd60xxzc_5ml4rU_00YmiQEJkvd0,509
-sg_otio/sg_cut_reader.py,sha256=rhIlBUB8UkkGBBx5r-A_d2ewbseyr2qTCUBplns8ZO8,18680
+sg_otio/sg_cut_reader.py,sha256=2ggVWjsjPN1hfpQGB6rrWVKPMNtbjitmZk9q2vMrftQ,18681
 sg_otio/sg_cut_track_writer.py,sha256=n0hKOV267IAgDOkGKM3Mg6zyI6C9v8ET5Q-Abw5hQbU,51081
 sg_otio/sg_settings.py,sha256=MevECmO642_maJbh1qfs6rwewbiwbwmbXZUncI14zts,24766
-sg_otio/track_diff.py,sha256=Zc3-j7CNBUprymiwsVc7GlBo435LUL6C_8vfHONb42s,52293
+sg_otio/track_diff.py,sha256=mAUm8UJ67U88x-sTuKeT_5cFr0t0vOEDufRLjtjVULQ,52296
 sg_otio/utils.py,sha256=FthKNskkhdoG_CVzh5WpDejiZn4aMfSBKXxnBecr0nA,11995
 sg_otio/adapters/__init__.py,sha256=MgSKMYTSOCZrLTAYWvuqOuBZFLqh1sMiVmYE0EbnSW0,86
-sg_otio/adapters/cmx_3600.py,sha256=J7EeyJe2XZwVOJC3z-eGxwUK4gA_yKETMsdQ52lHnOg,49314
+sg_otio/adapters/cmx_3600.py,sha256=z3WwSRwqNT4DsAY33k3Lgwwq9kCWD1whSJikpL4dfXU,50492
 sg_otio/adapters/shotgrid.py,sha256=2Bed-MFwfX2GYl87kQkWEAwrlbJgtP0vKDWYFY3JTJw,5144
-sg_otio-1.0.7.data/scripts/sg-otio,sha256=apbt0N04h3IC3n1deRvThCCKRfEXQxcTodGP0R4va7Y,313
-sg_otio-1.0.7.data/scripts/sg-otio.py,sha256=zv1Xyx5ykpm6hleXuhYVGBVdrOfzam_PaIGSgtOlNtg,7635
+sg_otio-1.0.8.data/scripts/sg-otio,sha256=apbt0N04h3IC3n1deRvThCCKRfEXQxcTodGP0R4va7Y,313
+sg_otio-1.0.8.data/scripts/sg-otio.py,sha256=zv1Xyx5ykpm6hleXuhYVGBVdrOfzam_PaIGSgtOlNtg,7635
 tests/__init__.py,sha256=MgSKMYTSOCZrLTAYWvuqOuBZFLqh1sMiVmYE0EbnSW0,86
 tests/conftest.py,sha256=K74ZtNxZyAlyKWpTA0Vsqq4qtY1LOkDlYP2lbxGMQPQ,2733
 tests/test_clip_group.py,sha256=tLnaF0an8MZOWKrQigzTYfUU_mWartdG6vtn5F82sTU,8328
-tests/test_command.py,sha256=E1LKM7NpsdJ8m0F3sJMzmtKFHJ6T5yLp-6hiG453vxA,12853
-tests/test_cut_clip.py,sha256=vbtQI4a-f-hfRhN7YWsbtLFckODWFutMAnilSLEr32Q,23131
-tests/test_cut_diff.py,sha256=yVoQLxlRAFWZ0GUeKYBgbrdIeMszohzz2v6zwrWPs1Q,74024
-tests/test_media_cutter.py,sha256=yWRHGKIlksMM69KVSSbxU1TsqsBQ4BmGEFHH7e7iWc0,8247
+tests/test_command.py,sha256=hkM00WdaYsx-8iGR7w6-irQZhNtGM1dnbLTrEKK2HeU,12857
+tests/test_cut_clip.py,sha256=baxXL7WQvDNylEzpETpfZK89mnQ_SluRmtxpP5P3AZY,23140
+tests/test_cut_diff.py,sha256=bD4ygdBxBDBUXcoIYCE4ZBXmc_ADm8h5TQMlxbdvyLk,74027
+tests/test_media_cutter.py,sha256=erVLj6q-J133-c1DfLyOuJeFcEjYMqmhclRhA6S0qW4,8249
 tests/test_media_uploader.py,sha256=kRodTnf0aNJgnUGZezN7Q4jghfajOv57T9MuBLwtpms,4543
-tests/test_shotgrid_adapter.py,sha256=lqpqJSI1Xl-AKYwQEFZxIBk45B3rHRJeoGA4Hx6DJ9Q,42223
+tests/test_shotgrid_adapter.py,sha256=tWuhSNtYyhr9AMSD6EgASyzX_bsbjQNKQB_wfGb1wtU,42240
 tests/test_utils.py,sha256=V5p4w9oZDNaJoy1rslGEBchG1NG-Xrj95Pm5Q6uS1R8,14741
 tests/python/__init__.py,sha256=MgSKMYTSOCZrLTAYWvuqOuBZFLqh1sMiVmYE0EbnSW0,86
 tests/python/mock_grid.py,sha256=9W_qHRSUjZL1XixWUQKJ5HZldOjAZIOdfp07UVkkbU0,5717
 tests/python/sg_test.py,sha256=WjQnSAksulEs1Y_EcoQedTGQwBu4LEOZ5Z7lwO7w4NI,1187
-sg_otio-1.0.7.dist-info/LICENSE.txt,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-sg_otio-1.0.7.dist-info/METADATA,sha256=6UHBREaCOFJp5IDOG3szLN0zyDS2lFvVv6sHcrl2wC8,9714
-sg_otio-1.0.7.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-sg_otio-1.0.7.dist-info/entry_points.txt,sha256=ykAdmWugej6DgSsd2ZVyUSvxlNGeHCBXEIk68qNFFJ0,43
-sg_otio-1.0.7.dist-info/top_level.txt,sha256=hmB1rC6EK99dDurVUVCuzJ9sUBKirxTsSrS925OtzMg,14
-sg_otio-1.0.7.dist-info/RECORD,,
+sg_otio-1.0.8.dist-info/LICENSE.txt,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+sg_otio-1.0.8.dist-info/METADATA,sha256=3x4N6xuarwTyO2GSNFtULQ_sa_KRCw0kSnVKd1dA1Pk,9714
+sg_otio-1.0.8.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+sg_otio-1.0.8.dist-info/entry_points.txt,sha256=ykAdmWugej6DgSsd2ZVyUSvxlNGeHCBXEIk68qNFFJ0,43
+sg_otio-1.0.8.dist-info/top_level.txt,sha256=hmB1rC6EK99dDurVUVCuzJ9sUBKirxTsSrS925OtzMg,14
+sg_otio-1.0.8.dist-info/RECORD,,
```

