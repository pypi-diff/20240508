# Comparing `tmp/dgl-2.1.0-cp39-cp39-manylinux2014_aarch64.whl.zip` & `tmp/dgl-2.2.0-cp39-cp39-macosx_11_0_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,378 +1,374 @@
-Zip file size: 7431777 bytes, number of entries: 376
--rw-r--r--  2.0 unx     1696 b- defN 24-Mar-05 05:59 dgl/__init__.py
--rw-r--r--  2.0 unx       35 b- defN 24-Mar-05 05:59 dgl/_api_internal.py
--rw-r--r--  2.0 unx    32827 b- defN 24-Mar-05 05:59 dgl/_sparse_ops.py
--rw-r--r--  2.0 unx     1608 b- defN 24-Mar-05 05:59 dgl/base.py
--rw-r--r--  2.0 unx    18719 b- defN 24-Mar-05 05:59 dgl/batch.py
--rw-r--r--  2.0 unx     2993 b- defN 24-Mar-05 05:59 dgl/container.py
--rw-r--r--  2.0 unx    80379 b- defN 24-Mar-05 05:59 dgl/convert.py
--rw-r--r--  2.0 unx    14371 b- defN 24-Mar-05 05:59 dgl/core.py
--rw-r--r--  2.0 unx    33811 b- defN 24-Mar-05 05:59 dgl/frame.py
--rw-r--r--  2.0 unx     4264 b- defN 24-Mar-05 05:59 dgl/generators.py
--rw-r--r--  2.0 unx      813 b- defN 24-Mar-05 05:59 dgl/global_config.py
--rw-r--r--  2.0 unx    38125 b- defN 24-Mar-05 05:59 dgl/graph_index.py
--rw-r--r--  2.0 unx   244965 b- defN 24-Mar-05 05:59 dgl/heterograph.py
--rw-r--r--  2.0 unx    48047 b- defN 24-Mar-05 05:59 dgl/heterograph_index.py
--rw-r--r--  2.0 unx     8309 b- defN 24-Mar-05 05:59 dgl/homophily.py
--rw-r--r--  2.0 unx     1823 b- defN 24-Mar-05 05:59 dgl/init.py
--rw-r--r--  2.0 unx     8245 b- defN 24-Mar-05 05:59 dgl/label_informativeness.py
--rwxr-xr-x  2.0 unx  9024609 b- defN 24-Mar-05 06:04 dgl/libdgl.so
--rw-r--r--  2.0 unx      863 b- defN 24-Mar-05 05:59 dgl/logging.py
--rw-r--r--  2.0 unx     3741 b- defN 24-Mar-05 05:59 dgl/merge.py
--rw-r--r--  2.0 unx     6524 b- defN 24-Mar-05 05:59 dgl/ndarray.py
--rw-r--r--  2.0 unx    24432 b- defN 24-Mar-05 05:59 dgl/partition.py
--rw-r--r--  2.0 unx     5788 b- defN 24-Mar-05 05:59 dgl/propagate.py
--rw-r--r--  2.0 unx     2725 b- defN 24-Mar-05 05:59 dgl/random.py
--rw-r--r--  2.0 unx    29015 b- defN 24-Mar-05 05:59 dgl/readout.py
--rw-r--r--  2.0 unx    45412 b- defN 24-Mar-05 05:59 dgl/subgraph.py
--rw-r--r--  2.0 unx    10086 b- defN 24-Mar-05 05:59 dgl/traversal.py
--rw-r--r--  2.0 unx    12633 b- defN 24-Mar-05 05:59 dgl/udf.py
--rw-r--r--  2.0 unx     8741 b- defN 24-Mar-05 05:59 dgl/view.py
--rw-r--r--  2.0 unx      350 b- defN 24-Mar-05 05:59 dgl/_ffi/__init__.py
--rw-r--r--  2.0 unx     3982 b- defN 24-Mar-05 05:59 dgl/_ffi/base.py
--rw-r--r--  2.0 unx      123 b- defN 24-Mar-05 05:59 dgl/_ffi/capi.py
--rw-r--r--  2.0 unx     9350 b- defN 24-Mar-05 05:59 dgl/_ffi/function.py
--rw-r--r--  2.0 unx     3255 b- defN 24-Mar-05 05:59 dgl/_ffi/libinfo.py
--rw-r--r--  2.0 unx    12436 b- defN 24-Mar-05 05:59 dgl/_ffi/ndarray.py
--rw-r--r--  2.0 unx     3750 b- defN 24-Mar-05 05:59 dgl/_ffi/object.py
--rw-r--r--  2.0 unx     1622 b- defN 24-Mar-05 05:59 dgl/_ffi/object_generic.py
--rw-r--r--  2.0 unx     7253 b- defN 24-Mar-05 05:59 dgl/_ffi/runtime_ctypes.py
--rw-r--r--  2.0 unx     1126 b- defN 24-Mar-05 05:59 dgl/_ffi/streams.py
--rw-r--r--  2.0 unx       44 b- defN 24-Mar-05 05:59 dgl/_ffi/_ctypes/__init__.py
--rw-r--r--  2.0 unx     9417 b- defN 24-Mar-05 05:59 dgl/_ffi/_ctypes/function.py
--rw-r--r--  2.0 unx     4229 b- defN 24-Mar-05 05:59 dgl/_ffi/_ctypes/ndarray.py
--rw-r--r--  2.0 unx     3153 b- defN 24-Mar-05 05:59 dgl/_ffi/_ctypes/object.py
--rw-r--r--  2.0 unx     2338 b- defN 24-Mar-05 05:59 dgl/_ffi/_ctypes/types.py
--rw-r--r--  2.0 unx       24 b- defN 24-Mar-05 05:59 dgl/_ffi/_cy2/__init__.py
--rw-r--r--  2.0 unx       24 b- defN 24-Mar-05 05:59 dgl/_ffi/_cy3/__init__.py
--rwxr-xr-x  2.0 unx  1304544 b- defN 24-Mar-05 06:04 dgl/_ffi/_cy3/core.cpython-39-aarch64-linux-gnu.so
--rw-r--r--  2.0 unx   824696 b- defN 24-Mar-05 06:04 dgl/_ffi/_cython/core.cpp
--rw-r--r--  2.0 unx     4465 b- defN 24-Mar-05 05:59 dgl/backend/__init__.py
--rw-r--r--  2.0 unx    47280 b- defN 24-Mar-05 05:59 dgl/backend/backend.py
--rw-r--r--  2.0 unx     1063 b- defN 24-Mar-05 05:59 dgl/backend/set_default_backend.py
--rw-r--r--  2.0 unx       44 b- defN 24-Mar-05 05:59 dgl/backend/mxnet/__init__.py
--rw-r--r--  2.0 unx    17803 b- defN 24-Mar-05 05:59 dgl/backend/mxnet/sparse.py
--rw-r--r--  2.0 unx       50 b- defN 24-Mar-05 05:59 dgl/backend/mxnet/sparse_optim.py
--rw-r--r--  2.0 unx    13279 b- defN 24-Mar-05 05:59 dgl/backend/mxnet/tensor.py
--rw-r--r--  2.0 unx       44 b- defN 24-Mar-05 05:59 dgl/backend/pytorch/__init__.py
--rw-r--r--  2.0 unx    40333 b- defN 24-Mar-05 05:59 dgl/backend/pytorch/sparse.py
--rw-r--r--  2.0 unx    12203 b- defN 24-Mar-05 05:59 dgl/backend/pytorch/tensor.py
--rw-r--r--  2.0 unx      105 b- defN 24-Mar-05 05:59 dgl/backend/tensorflow/__init__.py
--rw-r--r--  2.0 unx    13781 b- defN 24-Mar-05 05:59 dgl/backend/tensorflow/sparse.py
--rw-r--r--  2.0 unx       55 b- defN 24-Mar-05 05:59 dgl/backend/tensorflow/sparse_optim.py
--rw-r--r--  2.0 unx    14521 b- defN 24-Mar-05 05:59 dgl/backend/tensorflow/tensor.py
--rw-r--r--  2.0 unx      150 b- defN 24-Mar-05 05:59 dgl/cuda/__init__.py
--rw-r--r--  2.0 unx     2854 b- defN 24-Mar-05 05:59 dgl/cuda/gpu_cache.py
--rw-r--r--  2.0 unx     6801 b- defN 24-Mar-05 05:59 dgl/cuda/nccl.py
--rw-r--r--  2.0 unx     3352 b- defN 24-Mar-05 05:59 dgl/data/__init__.py
--rw-r--r--  2.0 unx     4514 b- defN 24-Mar-05 05:59 dgl/data/actor.py
--rw-r--r--  2.0 unx    23880 b- defN 24-Mar-05 05:59 dgl/data/adapter.py
--rw-r--r--  2.0 unx     5620 b- defN 24-Mar-05 05:59 dgl/data/bitcoinotc.py
--rw-r--r--  2.0 unx    28653 b- defN 24-Mar-05 05:59 dgl/data/citation_graph.py
--rw-r--r--  2.0 unx     3836 b- defN 24-Mar-05 05:59 dgl/data/cluster.py
--rw-r--r--  2.0 unx     7733 b- defN 24-Mar-05 05:59 dgl/data/csv_dataset.py
--rw-r--r--  2.0 unx    14050 b- defN 24-Mar-05 05:59 dgl/data/csv_dataset_base.py
--rw-r--r--  2.0 unx    10494 b- defN 24-Mar-05 05:59 dgl/data/dgl_dataset.py
--rw-r--r--  2.0 unx     7892 b- defN 24-Mar-05 05:59 dgl/data/fakenews.py
--rw-r--r--  2.0 unx     5280 b- defN 24-Mar-05 05:59 dgl/data/flickr.py
--rw-r--r--  2.0 unx    13482 b- defN 24-Mar-05 05:59 dgl/data/fraud.py
--rw-r--r--  2.0 unx     5743 b- defN 24-Mar-05 05:59 dgl/data/gdelt.py
--rw-r--r--  2.0 unx    14477 b- defN 24-Mar-05 05:59 dgl/data/geom_gcn.py
--rw-r--r--  2.0 unx    14315 b- defN 24-Mar-05 05:59 dgl/data/gindt.py
--rw-r--r--  2.0 unx    16582 b- defN 24-Mar-05 05:59 dgl/data/gnn_benchmark.py
--rw-r--r--  2.0 unx     8936 b- defN 24-Mar-05 05:59 dgl/data/graph_serialize.py
--rw-r--r--  2.0 unx     2844 b- defN 24-Mar-05 05:59 dgl/data/heterograph_serialize.py
--rw-r--r--  2.0 unx    15166 b- defN 24-Mar-05 05:59 dgl/data/heterophilous_graphs.py
--rw-r--r--  2.0 unx     4962 b- defN 24-Mar-05 05:59 dgl/data/icews18.py
--rw-r--r--  2.0 unx     2624 b- defN 24-Mar-05 05:59 dgl/data/karate.py
--rw-r--r--  2.0 unx    24132 b- defN 24-Mar-05 05:59 dgl/data/knowledge_graph.py
--rw-r--r--  2.0 unx    36431 b- defN 24-Mar-05 05:59 dgl/data/lrgb.py
--rw-r--r--  2.0 unx     7509 b- defN 24-Mar-05 05:59 dgl/data/minigc.py
--rw-r--r--  2.0 unx    22787 b- defN 24-Mar-05 05:59 dgl/data/movielens.py
--rw-r--r--  2.0 unx     3952 b- defN 24-Mar-05 05:59 dgl/data/pattern.py
--rw-r--r--  2.0 unx     6374 b- defN 24-Mar-05 05:59 dgl/data/ppi.py
--rw-r--r--  2.0 unx     5025 b- defN 24-Mar-05 05:59 dgl/data/qm7b.py
--rw-r--r--  2.0 unx    10792 b- defN 24-Mar-05 05:59 dgl/data/qm9.py
--rw-r--r--  2.0 unx    14442 b- defN 24-Mar-05 05:59 dgl/data/qm9_edge.py
--rw-r--r--  2.0 unx    36099 b- defN 24-Mar-05 05:59 dgl/data/rdf.py
--rw-r--r--  2.0 unx     7109 b- defN 24-Mar-05 05:59 dgl/data/reddit.py
--rw-r--r--  2.0 unx     8508 b- defN 24-Mar-05 05:59 dgl/data/sbm.py
--rw-r--r--  2.0 unx    13298 b- defN 24-Mar-05 05:59 dgl/data/superpixel.py
--rw-r--r--  2.0 unx    27587 b- defN 24-Mar-05 05:59 dgl/data/synthetic.py
--rw-r--r--  2.0 unx     1883 b- defN 24-Mar-05 05:59 dgl/data/tensor_serialize.py
--rw-r--r--  2.0 unx     9293 b- defN 24-Mar-05 05:59 dgl/data/tree.py
--rw-r--r--  2.0 unx    18212 b- defN 24-Mar-05 05:59 dgl/data/tu.py
--rw-r--r--  2.0 unx    22314 b- defN 24-Mar-05 05:59 dgl/data/utils.py
--rw-r--r--  2.0 unx     5893 b- defN 24-Mar-05 05:59 dgl/data/wikics.py
--rw-r--r--  2.0 unx     5227 b- defN 24-Mar-05 05:59 dgl/data/yelp.py
--rw-r--r--  2.0 unx     3695 b- defN 24-Mar-05 05:59 dgl/data/zinc.py
--rw-r--r--  2.0 unx      399 b- defN 24-Mar-05 05:59 dgl/dataloading/__init__.py
--rw-r--r--  2.0 unx    24179 b- defN 24-Mar-05 05:59 dgl/dataloading/base.py
--rw-r--r--  2.0 unx     5741 b- defN 24-Mar-05 05:59 dgl/dataloading/cluster_gcn.py
--rw-r--r--  2.0 unx    56278 b- defN 24-Mar-05 05:59 dgl/dataloading/dataloader.py
--rw-r--r--  2.0 unx    26307 b- defN 24-Mar-05 05:59 dgl/dataloading/dist_dataloader.py
--rw-r--r--  2.0 unx     5955 b- defN 24-Mar-05 05:59 dgl/dataloading/graphsaint.py
--rw-r--r--  2.0 unx    11316 b- defN 24-Mar-05 05:59 dgl/dataloading/labor_sampler.py
--rw-r--r--  2.0 unx     4347 b- defN 24-Mar-05 05:59 dgl/dataloading/negative_sampler.py
--rw-r--r--  2.0 unx     9889 b- defN 24-Mar-05 05:59 dgl/dataloading/neighbor_sampler.py
--rw-r--r--  2.0 unx     5215 b- defN 24-Mar-05 05:59 dgl/dataloading/shadow.py
--rw-r--r--  2.0 unx     3542 b- defN 24-Mar-05 05:59 dgl/dataloading/spot_target.py
--rwxr-xr-x  2.0 unx   883560 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.0.0.so
--rwxr-xr-x  2.0 unx   883560 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.0.1.so
--rwxr-xr-x  2.0 unx   889104 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.0.so
--rwxr-xr-x  2.0 unx   889104 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.1.so
--rwxr-xr-x  2.0 unx   889104 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.2.so
--rwxr-xr-x  2.0 unx   899688 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.0.so
--rwxr-xr-x  2.0 unx   899688 b- defN 24-Mar-05 06:04 dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.1.so
--rw-r--r--  2.0 unx      111 b- defN 24-Mar-05 05:59 dgl/distgnn/__init__.py
--rw-r--r--  2.0 unx      100 b- defN 24-Mar-05 05:59 dgl/distgnn/partition/__init__.py
--rw-r--r--  2.0 unx    11682 b- defN 24-Mar-05 05:59 dgl/distgnn/partition/libra_partition.py
--rw-r--r--  2.0 unx      114 b- defN 24-Mar-05 05:59 dgl/distgnn/tools/__init__.py
--rw-r--r--  2.0 unx     4252 b- defN 24-Mar-05 05:59 dgl/distgnn/tools/tools.py
--rw-r--r--  2.0 unx      724 b- defN 24-Mar-05 05:59 dgl/distributed/__init__.py
--rw-r--r--  2.0 unx      234 b- defN 24-Mar-05 05:59 dgl/distributed/constants.py
--rw-r--r--  2.0 unx    12936 b- defN 24-Mar-05 05:59 dgl/distributed/dist_context.py
--rw-r--r--  2.0 unx     6396 b- defN 24-Mar-05 05:59 dgl/distributed/dist_dataloader.py
--rw-r--r--  2.0 unx    64123 b- defN 24-Mar-05 05:59 dgl/distributed/dist_graph.py
--rw-r--r--  2.0 unx    11917 b- defN 24-Mar-05 05:59 dgl/distributed/dist_tensor.py
--rw-r--r--  2.0 unx    39814 b- defN 24-Mar-05 05:59 dgl/distributed/graph_partition_book.py
--rw-r--r--  2.0 unx    42400 b- defN 24-Mar-05 05:59 dgl/distributed/graph_services.py
--rw-r--r--  2.0 unx     7163 b- defN 24-Mar-05 05:59 dgl/distributed/id_map.py
--rw-r--r--  2.0 unx    50147 b- defN 24-Mar-05 05:59 dgl/distributed/kvstore.py
--rw-r--r--  2.0 unx    61976 b- defN 24-Mar-05 05:59 dgl/distributed/partition.py
--rw-r--r--  2.0 unx     7175 b- defN 24-Mar-05 05:59 dgl/distributed/role.py
--rw-r--r--  2.0 unx    37523 b- defN 24-Mar-05 05:59 dgl/distributed/rpc.py
--rw-r--r--  2.0 unx     7248 b- defN 24-Mar-05 05:59 dgl/distributed/rpc_client.py
--rw-r--r--  2.0 unx     5698 b- defN 24-Mar-05 05:59 dgl/distributed/rpc_server.py
--rw-r--r--  2.0 unx     2518 b- defN 24-Mar-05 05:59 dgl/distributed/server_state.py
--rw-r--r--  2.0 unx      740 b- defN 24-Mar-05 05:59 dgl/distributed/shared_mem_utils.py
--rw-r--r--  2.0 unx     3859 b- defN 24-Mar-05 05:59 dgl/distributed/standalone_kvstore.py
--rw-r--r--  2.0 unx      429 b- defN 24-Mar-05 05:59 dgl/distributed/utils.py
--rw-r--r--  2.0 unx      377 b- defN 24-Mar-05 05:59 dgl/distributed/nn/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-05 05:59 dgl/distributed/nn/mxnet/__init__.py
--rw-r--r--  2.0 unx       90 b- defN 24-Mar-05 05:59 dgl/distributed/nn/pytorch/__init__.py
--rw-r--r--  2.0 unx     6520 b- defN 24-Mar-05 05:59 dgl/distributed/nn/pytorch/sparse_emb.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-05 05:59 dgl/distributed/nn/tensorflow/__init__.py
--rw-r--r--  2.0 unx      377 b- defN 24-Mar-05 05:59 dgl/distributed/optim/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-05 05:59 dgl/distributed/optim/mxnet/__init__.py
--rw-r--r--  2.0 unx      104 b- defN 24-Mar-05 05:59 dgl/distributed/optim/pytorch/__init__.py
--rw-r--r--  2.0 unx    27827 b- defN 24-Mar-05 05:59 dgl/distributed/optim/pytorch/sparse_optim.py
--rw-r--r--  2.0 unx     3878 b- defN 24-Mar-05 05:59 dgl/distributed/optim/pytorch/utils.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-05 05:59 dgl/distributed/optim/tensorflow/__init__.py
--rw-r--r--  2.0 unx      169 b- defN 24-Mar-05 05:59 dgl/function/__init__.py
--rw-r--r--  2.0 unx      604 b- defN 24-Mar-05 05:59 dgl/function/base.py
--rw-r--r--  2.0 unx     4968 b- defN 24-Mar-05 05:59 dgl/function/message.py
--rw-r--r--  2.0 unx     1983 b- defN 24-Mar-05 05:59 dgl/function/reducer.py
--rw-r--r--  2.0 unx      329 b- defN 24-Mar-05 05:59 dgl/geometry/__init__.py
--rw-r--r--  2.0 unx     3930 b- defN 24-Mar-05 05:59 dgl/geometry/capi.py
--rw-r--r--  2.0 unx     2294 b- defN 24-Mar-05 05:59 dgl/geometry/edge_coarsening.py
--rw-r--r--  2.0 unx     2162 b- defN 24-Mar-05 05:59 dgl/geometry/fps.py
--rw-r--r--  2.0 unx     1548 b- defN 24-Mar-05 05:59 dgl/graphbolt/__init__.py
--rw-r--r--  2.0 unx    11822 b- defN 24-Mar-05 05:59 dgl/graphbolt/base.py
--rw-r--r--  2.0 unx     7616 b- defN 24-Mar-05 05:59 dgl/graphbolt/dataloader.py
--rw-r--r--  2.0 unx     2740 b- defN 24-Mar-05 05:59 dgl/graphbolt/dataset.py
--rw-r--r--  2.0 unx     6790 b- defN 24-Mar-05 05:59 dgl/graphbolt/feature_fetcher.py
--rw-r--r--  2.0 unx     4913 b- defN 24-Mar-05 05:59 dgl/graphbolt/feature_store.py
--rw-r--r--  2.0 unx    30036 b- defN 24-Mar-05 05:59 dgl/graphbolt/item_sampler.py
--rw-r--r--  2.0 unx    14570 b- defN 24-Mar-05 05:59 dgl/graphbolt/itemset.py
--rwxr-xr-x  2.0 unx  1109400 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.0.0.so
--rwxr-xr-x  2.0 unx  1109400 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.0.1.so
--rwxr-xr-x  2.0 unx  1112672 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.1.0.so
--rwxr-xr-x  2.0 unx  1112672 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.1.1.so
--rwxr-xr-x  2.0 unx  1112672 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.1.2.so
--rwxr-xr-x  2.0 unx  1108328 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.2.0.so
--rwxr-xr-x  2.0 unx  1108328 b- defN 24-Mar-05 06:04 dgl/graphbolt/libgraphbolt_pytorch_2.2.1.so
--rw-r--r--  2.0 unx    24948 b- defN 24-Mar-05 05:59 dgl/graphbolt/minibatch.py
--rw-r--r--  2.0 unx     1102 b- defN 24-Mar-05 05:59 dgl/graphbolt/minibatch_transformer.py
--rw-r--r--  2.0 unx     5312 b- defN 24-Mar-05 05:59 dgl/graphbolt/negative_sampler.py
--rw-r--r--  2.0 unx    13737 b- defN 24-Mar-05 05:59 dgl/graphbolt/sampled_subgraph.py
--rw-r--r--  2.0 unx     2295 b- defN 24-Mar-05 05:59 dgl/graphbolt/sampling_graph.py
--rw-r--r--  2.0 unx    15876 b- defN 24-Mar-05 05:59 dgl/graphbolt/subgraph_sampler.py
--rw-r--r--  2.0 unx     6716 b- defN 24-Mar-05 05:59 dgl/graphbolt/utils.py
--rw-r--r--  2.0 unx      486 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/__init__.py
--rw-r--r--  2.0 unx     4197 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/basic_feature_store.py
--rw-r--r--  2.0 unx    52939 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/fused_csc_sampling_graph.py
--rw-r--r--  2.0 unx     1759 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/gpu_cache.py
--rw-r--r--  2.0 unx     3968 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/gpu_cached_feature.py
--rw-r--r--  2.0 unx     2740 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/in_subgraph_sampler.py
--rw-r--r--  2.0 unx     5889 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/legacy_dataset.py
--rw-r--r--  2.0 unx    19716 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/neighbor_sampler.py
--rw-r--r--  2.0 unx    38443 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/ondisk_dataset.py
--rw-r--r--  2.0 unx     3491 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/ondisk_metadata.py
--rw-r--r--  2.0 unx     3688 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/sampled_subgraph_impl.py
--rw-r--r--  2.0 unx     5395 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/temporal_neighbor_sampler.py
--rw-r--r--  2.0 unx    11317 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/torch_based_feature_store.py
--rw-r--r--  2.0 unx     3741 b- defN 24-Mar-05 05:59 dgl/graphbolt/impl/uniform_negative_sampler.py
--rw-r--r--  2.0 unx      152 b- defN 24-Mar-05 05:59 dgl/graphbolt/internal/__init__.py
--rw-r--r--  2.0 unx     1384 b- defN 24-Mar-05 05:59 dgl/graphbolt/internal/datapipe_utils.py
--rw-r--r--  2.0 unx     4512 b- defN 24-Mar-05 05:59 dgl/graphbolt/internal/item_sampler_utils.py
--rw-r--r--  2.0 unx    17295 b- defN 24-Mar-05 05:59 dgl/graphbolt/internal/sample_utils.py
--rw-r--r--  2.0 unx     6894 b- defN 24-Mar-05 05:59 dgl/graphbolt/internal/utils.py
--rw-r--r--  2.0 unx      113 b- defN 24-Mar-05 05:59 dgl/mpops/__init__.py
--rw-r--r--  2.0 unx     6596 b- defN 24-Mar-05 05:59 dgl/mpops/edgewise.py
--rw-r--r--  2.0 unx       72 b- defN 24-Mar-05 05:59 dgl/mpops/fused.py
--rw-r--r--  2.0 unx       65 b- defN 24-Mar-05 05:59 dgl/mpops/nodewise.py
--rw-r--r--  2.0 unx      714 b- defN 24-Mar-05 05:59 dgl/multiprocessing/__init__.py
--rw-r--r--  2.0 unx     3893 b- defN 24-Mar-05 05:59 dgl/multiprocessing/pytorch.py
--rw-r--r--  2.0 unx     1362 b- defN 24-Mar-05 05:59 dgl/nn/__init__.py
--rw-r--r--  2.0 unx       76 b- defN 24-Mar-05 05:59 dgl/nn/functional/__init__.py
--rw-r--r--  2.0 unx      160 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/__init__.py
--rw-r--r--  2.0 unx     9195 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/glob.py
--rw-r--r--  2.0 unx     9018 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/hetero.py
--rw-r--r--  2.0 unx      116 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/softmax.py
--rw-r--r--  2.0 unx     7796 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/utils.py
--rw-r--r--  2.0 unx      980 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/__init__.py
--rw-r--r--  2.0 unx     6229 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/agnnconv.py
--rw-r--r--  2.0 unx     3790 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/appnpconv.py
--rw-r--r--  2.0 unx     6064 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/chebconv.py
--rw-r--r--  2.0 unx     3710 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/densechebconv.py
--rw-r--r--  2.0 unx     4710 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/densegraphconv.py
--rw-r--r--  2.0 unx     3860 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/densesageconv.py
--rw-r--r--  2.0 unx     7000 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/edgeconv.py
--rw-r--r--  2.0 unx    13914 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/gatconv.py
--rw-r--r--  2.0 unx     5085 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/gatedgraphconv.py
--rw-r--r--  2.0 unx     4629 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/ginconv.py
--rw-r--r--  2.0 unx     9940 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/gmmconv.py
--rw-r--r--  2.0 unx    12170 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/graphconv.py
--rw-r--r--  2.0 unx     6302 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/nnconv.py
--rw-r--r--  2.0 unx     9993 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/relgraphconv.py
--rw-r--r--  2.0 unx     8362 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/sageconv.py
--rw-r--r--  2.0 unx     7057 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/sgconv.py
--rw-r--r--  2.0 unx     4172 b- defN 24-Mar-05 05:59 dgl/nn/mxnet/conv/tagconv.py
--rw-r--r--  2.0 unx      382 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/__init__.py
--rw-r--r--  2.0 unx    14118 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/factory.py
--rw-r--r--  2.0 unx    45484 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/glob.py
--rw-r--r--  2.0 unx    14085 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/hetero.py
--rw-r--r--  2.0 unx     7699 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/linear.py
--rw-r--r--  2.0 unx    15866 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/network_emb.py
--rw-r--r--  2.0 unx      118 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/softmax.py
--rw-r--r--  2.0 unx    15231 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/sparse_emb.py
--rw-r--r--  2.0 unx    18172 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/utils.py
--rw-r--r--  2.0 unx     2039 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/__init__.py
--rw-r--r--  2.0 unx     6200 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/agnnconv.py
--rw-r--r--  2.0 unx     4479 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/appnpconv.py
--rw-r--r--  2.0 unx     9941 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/atomicconv.py
--rw-r--r--  2.0 unx     4894 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/cfconv.py
--rw-r--r--  2.0 unx     5160 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/chebconv.py
--rw-r--r--  2.0 unx     2137 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/cugraph_base.py
--rw-r--r--  2.0 unx     7067 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/cugraph_gatconv.py
--rw-r--r--  2.0 unx     7828 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/cugraph_relgraphconv.py
--rw-r--r--  2.0 unx     4949 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/cugraph_sageconv.py
--rw-r--r--  2.0 unx     4092 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/densechebconv.py
--rw-r--r--  2.0 unx     5171 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/densegraphconv.py
--rw-r--r--  2.0 unx     4675 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/densesageconv.py
--rw-r--r--  2.0 unx     8979 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/dgnconv.py
--rw-r--r--  2.0 unx     9439 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/dotgatconv.py
--rw-r--r--  2.0 unx     7799 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/edgeconv.py
--rw-r--r--  2.0 unx    15785 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/edgegatconv.py
--rw-r--r--  2.0 unx    10332 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/egatconv.py
--rw-r--r--  2.0 unx     5726 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/egnnconv.py
--rw-r--r--  2.0 unx    15099 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gatconv.py
--rw-r--r--  2.0 unx     6140 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gatedgcnconv.py
--rw-r--r--  2.0 unx     6229 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gatedgraphconv.py
--rw-r--r--  2.0 unx    13218 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gatv2conv.py
--rw-r--r--  2.0 unx    10659 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gcn2conv.py
--rw-r--r--  2.0 unx     6414 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/ginconv.py
--rw-r--r--  2.0 unx     3697 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gineconv.py
--rw-r--r--  2.0 unx    10102 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/gmmconv.py
--rw-r--r--  2.0 unx    18520 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/graphconv.py
--rw-r--r--  2.0 unx     8622 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/grouprevres.py
--rw-r--r--  2.0 unx     7062 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/hgtconv.py
--rw-r--r--  2.0 unx     6576 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/nnconv.py
--rw-r--r--  2.0 unx    10689 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/pnaconv.py
--rw-r--r--  2.0 unx     6692 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/relgraphconv.py
--rw-r--r--  2.0 unx    11302 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/sageconv.py
--rw-r--r--  2.0 unx     8002 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/sgconv.py
--rw-r--r--  2.0 unx     4910 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/tagconv.py
--rw-r--r--  2.0 unx    19654 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/conv/twirlsconv.py
--rw-r--r--  2.0 unx      186 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/explain/__init__.py
--rw-r--r--  2.0 unx    37449 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/explain/gnnexplainer.py
--rw-r--r--  2.0 unx    42962 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/explain/pgexplainer.py
--rw-r--r--  2.0 unx    29586 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/explain/subgraphx.py
--rw-r--r--  2.0 unx      329 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/__init__.py
--rw-r--r--  2.0 unx     5381 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/biased_mha.py
--rw-r--r--  2.0 unx     3627 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/degree_encoder.py
--rw-r--r--  2.0 unx     6251 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/egt.py
--rw-r--r--  2.0 unx     4191 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/graphormer.py
--rw-r--r--  2.0 unx     5454 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/lap_pos_encoder.py
--rw-r--r--  2.0 unx     3238 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/path_encoder.py
--rw-r--r--  2.0 unx     8254 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/gt/spatial_encoder.py
--rw-r--r--  2.0 unx      159 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/link/__init__.py
--rw-r--r--  2.0 unx     4892 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/link/edgepred.py
--rw-r--r--  2.0 unx     2801 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/link/transe.py
--rw-r--r--  2.0 unx     3351 b- defN 24-Mar-05 05:59 dgl/nn/pytorch/link/transr.py
--rw-r--r--  2.0 unx      156 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/__init__.py
--rw-r--r--  2.0 unx     7249 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/glob.py
--rw-r--r--  2.0 unx     8950 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/hetero.py
--rw-r--r--  2.0 unx      115 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/softmax.py
--rw-r--r--  2.0 unx     2463 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/utils.py
--rw-r--r--  2.0 unx      348 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/__init__.py
--rw-r--r--  2.0 unx     2473 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/appnpconv.py
--rw-r--r--  2.0 unx     5476 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/chebconv.py
--rw-r--r--  2.0 unx     3587 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/densechebconv.py
--rw-r--r--  2.0 unx     5813 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/edgeconv.py
--rw-r--r--  2.0 unx    13481 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/gatconv.py
--rw-r--r--  2.0 unx     4589 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/ginconv.py
--rw-r--r--  2.0 unx    12433 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/graphconv.py
--rw-r--r--  2.0 unx    12307 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/relgraphconv.py
--rw-r--r--  2.0 unx     8389 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/sageconv.py
--rw-r--r--  2.0 unx     6955 b- defN 24-Mar-05 05:59 dgl/nn/tensorflow/conv/sgconv.py
--rw-r--r--  2.0 unx      144 b- defN 24-Mar-05 05:59 dgl/ops/__init__.py
--rw-r--r--  2.0 unx     5382 b- defN 24-Mar-05 05:59 dgl/ops/edge_softmax.py
--rw-r--r--  2.0 unx     1430 b- defN 24-Mar-05 05:59 dgl/ops/gather_mm.py
--rw-r--r--  2.0 unx     6543 b- defN 24-Mar-05 05:59 dgl/ops/sddmm.py
--rw-r--r--  2.0 unx     3938 b- defN 24-Mar-05 05:59 dgl/ops/segment.py
--rw-r--r--  2.0 unx     7709 b- defN 24-Mar-05 05:59 dgl/ops/spmm.py
--rw-r--r--  2.0 unx      363 b- defN 24-Mar-05 05:59 dgl/optim/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-05 05:59 dgl/optim/mxnet/__init__.py
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-05 05:59 dgl/optim/pytorch/__init__.py
--rw-r--r--  2.0 unx    39022 b- defN 24-Mar-05 05:59 dgl/optim/pytorch/sparse_optim.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-05 05:59 dgl/optim/tensorflow/__init__.py
--rw-r--r--  2.0 unx      517 b- defN 24-Mar-05 05:59 dgl/sampling/__init__.py
--rw-r--r--  2.0 unx    14225 b- defN 24-Mar-05 05:59 dgl/sampling/labor.py
--rw-r--r--  2.0 unx     4175 b- defN 24-Mar-05 05:59 dgl/sampling/negative.py
--rw-r--r--  2.0 unx    36980 b- defN 24-Mar-05 05:59 dgl/sampling/neighbor.py
--rw-r--r--  2.0 unx     3338 b- defN 24-Mar-05 05:59 dgl/sampling/node2vec_randomwalk.py
--rw-r--r--  2.0 unx    10278 b- defN 24-Mar-05 05:59 dgl/sampling/pinsage.py
--rw-r--r--  2.0 unx    11619 b- defN 24-Mar-05 05:59 dgl/sampling/randomwalks.py
--rw-r--r--  2.0 unx     4262 b- defN 24-Mar-05 05:59 dgl/sampling/utils.py
--rw-r--r--  2.0 unx     1261 b- defN 24-Mar-05 05:59 dgl/sparse/__init__.py
--rw-r--r--  2.0 unx     4244 b- defN 24-Mar-05 05:59 dgl/sparse/broadcast.py
--rw-r--r--  2.0 unx     5539 b- defN 24-Mar-05 05:59 dgl/sparse/elementwise_op.py
--rw-r--r--  2.0 unx     5836 b- defN 24-Mar-05 05:59 dgl/sparse/elementwise_op_sp.py
--rw-r--r--  2.0 unx     6734 b- defN 24-Mar-05 05:59 dgl/sparse/matmul.py
--rw-r--r--  2.0 unx    12018 b- defN 24-Mar-05 05:59 dgl/sparse/reduction.py
--rw-r--r--  2.0 unx     3306 b- defN 24-Mar-05 05:59 dgl/sparse/sddmm.py
--rw-r--r--  2.0 unx     2480 b- defN 24-Mar-05 05:59 dgl/sparse/softmax.py
--rw-r--r--  2.0 unx    47861 b- defN 24-Mar-05 05:59 dgl/sparse/sparse_matrix.py
--rw-r--r--  2.0 unx     1673 b- defN 24-Mar-05 05:59 dgl/sparse/unary_op.py
--rw-r--r--  2.0 unx      305 b- defN 24-Mar-05 05:59 dgl/sparse/utils.py
--rw-r--r--  2.0 unx      327 b- defN 24-Mar-05 05:59 dgl/storages/__init__.py
--rw-r--r--  2.0 unx     2538 b- defN 24-Mar-05 05:59 dgl/storages/base.py
--rw-r--r--  2.0 unx      826 b- defN 24-Mar-05 05:59 dgl/storages/numpy.py
--rw-r--r--  2.0 unx     2114 b- defN 24-Mar-05 05:59 dgl/storages/pytorch_tensor.py
--rw-r--r--  2.0 unx      548 b- defN 24-Mar-05 05:59 dgl/storages/tensor.py
--rwxr-xr-x  2.0 unx    75568 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.0.0.so
--rwxr-xr-x  2.0 unx    75568 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.0.1.so
--rwxr-xr-x  2.0 unx    75568 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.0.so
--rwxr-xr-x  2.0 unx    75568 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.1.so
--rwxr-xr-x  2.0 unx    75568 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.2.so
--rwxr-xr-x  2.0 unx    75368 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.0.so
--rwxr-xr-x  2.0 unx    75368 b- defN 24-Mar-05 06:04 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.1.so
--rw-r--r--  2.0 unx      116 b- defN 24-Mar-05 05:59 dgl/transforms/__init__.py
--rw-r--r--  2.0 unx   143516 b- defN 24-Mar-05 05:59 dgl/transforms/functional.py
--rw-r--r--  2.0 unx    67187 b- defN 24-Mar-05 05:59 dgl/transforms/module.py
--rw-r--r--  2.0 unx     9180 b- defN 24-Mar-05 05:59 dgl/transforms/to_block.py
--rw-r--r--  2.0 unx      383 b- defN 24-Mar-05 05:59 dgl/utils/__init__.py
--rw-r--r--  2.0 unx     8167 b- defN 24-Mar-05 05:59 dgl/utils/checks.py
--rw-r--r--  2.0 unx    13141 b- defN 24-Mar-05 05:59 dgl/utils/data.py
--rw-r--r--  2.0 unx     2582 b- defN 24-Mar-05 05:59 dgl/utils/exception.py
--rw-r--r--  2.0 unx     2163 b- defN 24-Mar-05 05:59 dgl/utils/filter.py
--rw-r--r--  2.0 unx    36858 b- defN 24-Mar-05 05:59 dgl/utils/internal.py
--rw-r--r--  2.0 unx     2293 b- defN 24-Mar-05 05:59 dgl/utils/pin_memory.py
--rw-r--r--  2.0 unx      281 b- defN 24-Mar-05 05:59 dgl/utils/shared_mem.py
--rw-r--r--  2.0 unx      580 b- defN 24-Mar-05 06:04 dgl-2.1.0.dist-info/METADATA
--rw-r--r--  2.0 unx      112 b- defN 24-Mar-05 06:04 dgl-2.1.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        4 b- defN 24-Mar-05 06:04 dgl-2.1.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    32028 b- defN 24-Mar-05 06:05 dgl-2.1.0.dist-info/RECORD
-376 files, 29456775 bytes uncompressed, 7381995 bytes compressed:  74.9%
+Zip file size: 7398185 bytes, number of entries: 372
+-rw-r--r--  2.0 unx     1696 b- defN 24-May-07 00:35 dgl/__init__.py
+-rw-r--r--  2.0 unx       35 b- defN 24-May-07 00:35 dgl/_api_internal.py
+-rw-r--r--  2.0 unx    32827 b- defN 24-May-07 00:35 dgl/_sparse_ops.py
+-rw-r--r--  2.0 unx     1608 b- defN 24-May-07 00:35 dgl/base.py
+-rw-r--r--  2.0 unx    18719 b- defN 24-May-07 00:35 dgl/batch.py
+-rw-r--r--  2.0 unx     2993 b- defN 24-May-07 00:35 dgl/container.py
+-rw-r--r--  2.0 unx    80695 b- defN 24-May-07 00:35 dgl/convert.py
+-rw-r--r--  2.0 unx    14371 b- defN 24-May-07 00:35 dgl/core.py
+-rw-r--r--  2.0 unx    33811 b- defN 24-May-07 00:35 dgl/frame.py
+-rw-r--r--  2.0 unx     4264 b- defN 24-May-07 00:35 dgl/generators.py
+-rw-r--r--  2.0 unx      813 b- defN 24-May-07 00:35 dgl/global_config.py
+-rw-r--r--  2.0 unx    38125 b- defN 24-May-07 00:35 dgl/graph_index.py
+-rw-r--r--  2.0 unx   244965 b- defN 24-May-07 00:35 dgl/heterograph.py
+-rw-r--r--  2.0 unx    48047 b- defN 24-May-07 00:35 dgl/heterograph_index.py
+-rw-r--r--  2.0 unx     8309 b- defN 24-May-07 00:35 dgl/homophily.py
+-rw-r--r--  2.0 unx     1823 b- defN 24-May-07 00:35 dgl/init.py
+-rw-r--r--  2.0 unx     8245 b- defN 24-May-07 00:35 dgl/label_informativeness.py
+-rwxr-xr-x  2.0 unx  9498864 b- defN 24-May-07 00:42 dgl/libdgl.dylib
+-rw-r--r--  2.0 unx      863 b- defN 24-May-07 00:35 dgl/logging.py
+-rw-r--r--  2.0 unx     3741 b- defN 24-May-07 00:35 dgl/merge.py
+-rw-r--r--  2.0 unx     6524 b- defN 24-May-07 00:35 dgl/ndarray.py
+-rw-r--r--  2.0 unx    24432 b- defN 24-May-07 00:35 dgl/partition.py
+-rw-r--r--  2.0 unx     5788 b- defN 24-May-07 00:35 dgl/propagate.py
+-rw-r--r--  2.0 unx     2725 b- defN 24-May-07 00:35 dgl/random.py
+-rw-r--r--  2.0 unx    29015 b- defN 24-May-07 00:35 dgl/readout.py
+-rw-r--r--  2.0 unx    45412 b- defN 24-May-07 00:35 dgl/subgraph.py
+-rw-r--r--  2.0 unx    10086 b- defN 24-May-07 00:35 dgl/traversal.py
+-rw-r--r--  2.0 unx    12633 b- defN 24-May-07 00:35 dgl/udf.py
+-rw-r--r--  2.0 unx     8741 b- defN 24-May-07 00:35 dgl/view.py
+-rw-r--r--  2.0 unx      350 b- defN 24-May-07 00:35 dgl/_ffi/__init__.py
+-rw-r--r--  2.0 unx     3982 b- defN 24-May-07 00:35 dgl/_ffi/base.py
+-rw-r--r--  2.0 unx      123 b- defN 24-May-07 00:35 dgl/_ffi/capi.py
+-rw-r--r--  2.0 unx     9350 b- defN 24-May-07 00:35 dgl/_ffi/function.py
+-rw-r--r--  2.0 unx     3239 b- defN 24-May-07 00:35 dgl/_ffi/libinfo.py
+-rw-r--r--  2.0 unx    12436 b- defN 24-May-07 00:35 dgl/_ffi/ndarray.py
+-rw-r--r--  2.0 unx     3750 b- defN 24-May-07 00:35 dgl/_ffi/object.py
+-rw-r--r--  2.0 unx     1622 b- defN 24-May-07 00:35 dgl/_ffi/object_generic.py
+-rw-r--r--  2.0 unx     7253 b- defN 24-May-07 00:35 dgl/_ffi/runtime_ctypes.py
+-rw-r--r--  2.0 unx     1126 b- defN 24-May-07 00:35 dgl/_ffi/streams.py
+-rw-r--r--  2.0 unx       44 b- defN 24-May-07 00:35 dgl/_ffi/_ctypes/__init__.py
+-rw-r--r--  2.0 unx     9417 b- defN 24-May-07 00:35 dgl/_ffi/_ctypes/function.py
+-rw-r--r--  2.0 unx     4229 b- defN 24-May-07 00:35 dgl/_ffi/_ctypes/ndarray.py
+-rw-r--r--  2.0 unx     3153 b- defN 24-May-07 00:35 dgl/_ffi/_ctypes/object.py
+-rw-r--r--  2.0 unx     2338 b- defN 24-May-07 00:35 dgl/_ffi/_ctypes/types.py
+-rw-r--r--  2.0 unx       24 b- defN 24-May-07 00:35 dgl/_ffi/_cy2/__init__.py
+-rw-r--r--  2.0 unx       24 b- defN 24-May-07 00:35 dgl/_ffi/_cy3/__init__.py
+-rwxr-xr-x  2.0 unx   207656 b- defN 24-May-07 00:42 dgl/_ffi/_cy3/core.cpython-39-darwin.so
+-rw-r--r--  2.0 unx   580421 b- defN 24-May-07 00:42 dgl/_ffi/_cython/core.cpp
+-rw-r--r--  2.0 unx     4465 b- defN 24-May-07 00:35 dgl/backend/__init__.py
+-rw-r--r--  2.0 unx    47280 b- defN 24-May-07 00:35 dgl/backend/backend.py
+-rw-r--r--  2.0 unx     1063 b- defN 24-May-07 00:35 dgl/backend/set_default_backend.py
+-rw-r--r--  2.0 unx       44 b- defN 24-May-07 00:35 dgl/backend/mxnet/__init__.py
+-rw-r--r--  2.0 unx    17803 b- defN 24-May-07 00:35 dgl/backend/mxnet/sparse.py
+-rw-r--r--  2.0 unx       50 b- defN 24-May-07 00:35 dgl/backend/mxnet/sparse_optim.py
+-rw-r--r--  2.0 unx    13279 b- defN 24-May-07 00:35 dgl/backend/mxnet/tensor.py
+-rw-r--r--  2.0 unx       44 b- defN 24-May-07 00:35 dgl/backend/pytorch/__init__.py
+-rw-r--r--  2.0 unx    40333 b- defN 24-May-07 00:35 dgl/backend/pytorch/sparse.py
+-rw-r--r--  2.0 unx    12201 b- defN 24-May-07 00:35 dgl/backend/pytorch/tensor.py
+-rw-r--r--  2.0 unx      105 b- defN 24-May-07 00:35 dgl/backend/tensorflow/__init__.py
+-rw-r--r--  2.0 unx    13781 b- defN 24-May-07 00:35 dgl/backend/tensorflow/sparse.py
+-rw-r--r--  2.0 unx       55 b- defN 24-May-07 00:35 dgl/backend/tensorflow/sparse_optim.py
+-rw-r--r--  2.0 unx    14521 b- defN 24-May-07 00:35 dgl/backend/tensorflow/tensor.py
+-rw-r--r--  2.0 unx      150 b- defN 24-May-07 00:35 dgl/cuda/__init__.py
+-rw-r--r--  2.0 unx     2854 b- defN 24-May-07 00:35 dgl/cuda/gpu_cache.py
+-rw-r--r--  2.0 unx     6801 b- defN 24-May-07 00:35 dgl/cuda/nccl.py
+-rw-r--r--  2.0 unx     3352 b- defN 24-May-07 00:35 dgl/data/__init__.py
+-rw-r--r--  2.0 unx     4514 b- defN 24-May-07 00:35 dgl/data/actor.py
+-rw-r--r--  2.0 unx    23880 b- defN 24-May-07 00:35 dgl/data/adapter.py
+-rw-r--r--  2.0 unx     5620 b- defN 24-May-07 00:35 dgl/data/bitcoinotc.py
+-rw-r--r--  2.0 unx    28653 b- defN 24-May-07 00:35 dgl/data/citation_graph.py
+-rw-r--r--  2.0 unx     3836 b- defN 24-May-07 00:35 dgl/data/cluster.py
+-rw-r--r--  2.0 unx     7733 b- defN 24-May-07 00:35 dgl/data/csv_dataset.py
+-rw-r--r--  2.0 unx    14050 b- defN 24-May-07 00:35 dgl/data/csv_dataset_base.py
+-rw-r--r--  2.0 unx    10494 b- defN 24-May-07 00:35 dgl/data/dgl_dataset.py
+-rw-r--r--  2.0 unx     7892 b- defN 24-May-07 00:35 dgl/data/fakenews.py
+-rw-r--r--  2.0 unx     5280 b- defN 24-May-07 00:35 dgl/data/flickr.py
+-rw-r--r--  2.0 unx    13482 b- defN 24-May-07 00:35 dgl/data/fraud.py
+-rw-r--r--  2.0 unx     5743 b- defN 24-May-07 00:35 dgl/data/gdelt.py
+-rw-r--r--  2.0 unx    14477 b- defN 24-May-07 00:35 dgl/data/geom_gcn.py
+-rw-r--r--  2.0 unx    14315 b- defN 24-May-07 00:35 dgl/data/gindt.py
+-rw-r--r--  2.0 unx    16582 b- defN 24-May-07 00:35 dgl/data/gnn_benchmark.py
+-rw-r--r--  2.0 unx     8936 b- defN 24-May-07 00:35 dgl/data/graph_serialize.py
+-rw-r--r--  2.0 unx     2844 b- defN 24-May-07 00:35 dgl/data/heterograph_serialize.py
+-rw-r--r--  2.0 unx    15166 b- defN 24-May-07 00:35 dgl/data/heterophilous_graphs.py
+-rw-r--r--  2.0 unx     4962 b- defN 24-May-07 00:35 dgl/data/icews18.py
+-rw-r--r--  2.0 unx     2624 b- defN 24-May-07 00:35 dgl/data/karate.py
+-rw-r--r--  2.0 unx    24132 b- defN 24-May-07 00:35 dgl/data/knowledge_graph.py
+-rw-r--r--  2.0 unx    36431 b- defN 24-May-07 00:35 dgl/data/lrgb.py
+-rw-r--r--  2.0 unx     7509 b- defN 24-May-07 00:35 dgl/data/minigc.py
+-rw-r--r--  2.0 unx    22787 b- defN 24-May-07 00:35 dgl/data/movielens.py
+-rw-r--r--  2.0 unx     3952 b- defN 24-May-07 00:35 dgl/data/pattern.py
+-rw-r--r--  2.0 unx     6374 b- defN 24-May-07 00:35 dgl/data/ppi.py
+-rw-r--r--  2.0 unx     5025 b- defN 24-May-07 00:35 dgl/data/qm7b.py
+-rw-r--r--  2.0 unx    10792 b- defN 24-May-07 00:35 dgl/data/qm9.py
+-rw-r--r--  2.0 unx    14442 b- defN 24-May-07 00:35 dgl/data/qm9_edge.py
+-rw-r--r--  2.0 unx    36099 b- defN 24-May-07 00:35 dgl/data/rdf.py
+-rw-r--r--  2.0 unx     7109 b- defN 24-May-07 00:35 dgl/data/reddit.py
+-rw-r--r--  2.0 unx     8508 b- defN 24-May-07 00:35 dgl/data/sbm.py
+-rw-r--r--  2.0 unx    13298 b- defN 24-May-07 00:35 dgl/data/superpixel.py
+-rw-r--r--  2.0 unx    27587 b- defN 24-May-07 00:35 dgl/data/synthetic.py
+-rw-r--r--  2.0 unx     1883 b- defN 24-May-07 00:35 dgl/data/tensor_serialize.py
+-rw-r--r--  2.0 unx     9293 b- defN 24-May-07 00:35 dgl/data/tree.py
+-rw-r--r--  2.0 unx    18213 b- defN 24-May-07 00:35 dgl/data/tu.py
+-rw-r--r--  2.0 unx    22314 b- defN 24-May-07 00:35 dgl/data/utils.py
+-rw-r--r--  2.0 unx     5893 b- defN 24-May-07 00:35 dgl/data/wikics.py
+-rw-r--r--  2.0 unx     5227 b- defN 24-May-07 00:35 dgl/data/yelp.py
+-rw-r--r--  2.0 unx     3695 b- defN 24-May-07 00:35 dgl/data/zinc.py
+-rw-r--r--  2.0 unx      399 b- defN 24-May-07 00:35 dgl/dataloading/__init__.py
+-rw-r--r--  2.0 unx    24179 b- defN 24-May-07 00:35 dgl/dataloading/base.py
+-rw-r--r--  2.0 unx     5741 b- defN 24-May-07 00:35 dgl/dataloading/cluster_gcn.py
+-rw-r--r--  2.0 unx    56278 b- defN 24-May-07 00:35 dgl/dataloading/dataloader.py
+-rw-r--r--  2.0 unx    26307 b- defN 24-May-07 00:35 dgl/dataloading/dist_dataloader.py
+-rw-r--r--  2.0 unx     5955 b- defN 24-May-07 00:35 dgl/dataloading/graphsaint.py
+-rw-r--r--  2.0 unx    11316 b- defN 24-May-07 00:35 dgl/dataloading/labor_sampler.py
+-rw-r--r--  2.0 unx     4347 b- defN 24-May-07 00:35 dgl/dataloading/negative_sampler.py
+-rw-r--r--  2.0 unx     9889 b- defN 24-May-07 00:35 dgl/dataloading/neighbor_sampler.py
+-rw-r--r--  2.0 unx     5215 b- defN 24-May-07 00:35 dgl/dataloading/shadow.py
+-rw-r--r--  2.0 unx     3542 b- defN 24-May-07 00:35 dgl/dataloading/spot_target.py
+-rwxr-xr-x  2.0 unx  1015568 b- defN 24-May-07 00:42 dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.0.dylib
+-rwxr-xr-x  2.0 unx  1015568 b- defN 24-May-07 00:42 dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.1.dylib
+-rwxr-xr-x  2.0 unx  1015568 b- defN 24-May-07 00:42 dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.2.dylib
+-rwxr-xr-x  2.0 unx  1050328 b- defN 24-May-07 00:42 dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.0.dylib
+-rwxr-xr-x  2.0 unx  1050328 b- defN 24-May-07 00:42 dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.1.dylib
+-rwxr-xr-x  2.0 unx  1050328 b- defN 24-May-07 00:42 dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.2.dylib
+-rw-r--r--  2.0 unx      111 b- defN 24-May-07 00:35 dgl/distgnn/__init__.py
+-rw-r--r--  2.0 unx      100 b- defN 24-May-07 00:35 dgl/distgnn/partition/__init__.py
+-rw-r--r--  2.0 unx    11682 b- defN 24-May-07 00:35 dgl/distgnn/partition/libra_partition.py
+-rw-r--r--  2.0 unx      114 b- defN 24-May-07 00:35 dgl/distgnn/tools/__init__.py
+-rw-r--r--  2.0 unx     4252 b- defN 24-May-07 00:35 dgl/distgnn/tools/tools.py
+-rw-r--r--  2.0 unx      724 b- defN 24-May-07 00:35 dgl/distributed/__init__.py
+-rw-r--r--  2.0 unx      234 b- defN 24-May-07 00:35 dgl/distributed/constants.py
+-rw-r--r--  2.0 unx    12936 b- defN 24-May-07 00:35 dgl/distributed/dist_context.py
+-rw-r--r--  2.0 unx     6396 b- defN 24-May-07 00:35 dgl/distributed/dist_dataloader.py
+-rw-r--r--  2.0 unx    64123 b- defN 24-May-07 00:35 dgl/distributed/dist_graph.py
+-rw-r--r--  2.0 unx    11972 b- defN 24-May-07 00:35 dgl/distributed/dist_tensor.py
+-rw-r--r--  2.0 unx    40122 b- defN 24-May-07 00:35 dgl/distributed/graph_partition_book.py
+-rw-r--r--  2.0 unx    42467 b- defN 24-May-07 00:35 dgl/distributed/graph_services.py
+-rw-r--r--  2.0 unx     7163 b- defN 24-May-07 00:35 dgl/distributed/id_map.py
+-rw-r--r--  2.0 unx    50424 b- defN 24-May-07 00:35 dgl/distributed/kvstore.py
+-rw-r--r--  2.0 unx    61976 b- defN 24-May-07 00:35 dgl/distributed/partition.py
+-rw-r--r--  2.0 unx     7175 b- defN 24-May-07 00:35 dgl/distributed/role.py
+-rw-r--r--  2.0 unx    37523 b- defN 24-May-07 00:35 dgl/distributed/rpc.py
+-rw-r--r--  2.0 unx     7248 b- defN 24-May-07 00:35 dgl/distributed/rpc_client.py
+-rw-r--r--  2.0 unx     5698 b- defN 24-May-07 00:35 dgl/distributed/rpc_server.py
+-rw-r--r--  2.0 unx     2518 b- defN 24-May-07 00:35 dgl/distributed/server_state.py
+-rw-r--r--  2.0 unx      740 b- defN 24-May-07 00:35 dgl/distributed/shared_mem_utils.py
+-rw-r--r--  2.0 unx     3859 b- defN 24-May-07 00:35 dgl/distributed/standalone_kvstore.py
+-rw-r--r--  2.0 unx      377 b- defN 24-May-07 00:35 dgl/distributed/nn/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 00:35 dgl/distributed/nn/mxnet/__init__.py
+-rw-r--r--  2.0 unx       90 b- defN 24-May-07 00:35 dgl/distributed/nn/pytorch/__init__.py
+-rw-r--r--  2.0 unx     6580 b- defN 24-May-07 00:35 dgl/distributed/nn/pytorch/sparse_emb.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 00:35 dgl/distributed/nn/tensorflow/__init__.py
+-rw-r--r--  2.0 unx      377 b- defN 24-May-07 00:35 dgl/distributed/optim/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 00:35 dgl/distributed/optim/mxnet/__init__.py
+-rw-r--r--  2.0 unx      104 b- defN 24-May-07 00:35 dgl/distributed/optim/pytorch/__init__.py
+-rw-r--r--  2.0 unx    27827 b- defN 24-May-07 00:35 dgl/distributed/optim/pytorch/sparse_optim.py
+-rw-r--r--  2.0 unx     3878 b- defN 24-May-07 00:35 dgl/distributed/optim/pytorch/utils.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 00:35 dgl/distributed/optim/tensorflow/__init__.py
+-rw-r--r--  2.0 unx      169 b- defN 24-May-07 00:35 dgl/function/__init__.py
+-rw-r--r--  2.0 unx      604 b- defN 24-May-07 00:35 dgl/function/base.py
+-rw-r--r--  2.0 unx     4968 b- defN 24-May-07 00:35 dgl/function/message.py
+-rw-r--r--  2.0 unx     1983 b- defN 24-May-07 00:35 dgl/function/reducer.py
+-rw-r--r--  2.0 unx      329 b- defN 24-May-07 00:35 dgl/geometry/__init__.py
+-rw-r--r--  2.0 unx     3930 b- defN 24-May-07 00:35 dgl/geometry/capi.py
+-rw-r--r--  2.0 unx     2294 b- defN 24-May-07 00:35 dgl/geometry/edge_coarsening.py
+-rw-r--r--  2.0 unx     2162 b- defN 24-May-07 00:35 dgl/geometry/fps.py
+-rw-r--r--  2.0 unx     1568 b- defN 24-May-07 00:35 dgl/graphbolt/__init__.py
+-rw-r--r--  2.0 unx    11403 b- defN 24-May-07 00:35 dgl/graphbolt/base.py
+-rw-r--r--  2.0 unx     7616 b- defN 24-May-07 00:35 dgl/graphbolt/dataloader.py
+-rw-r--r--  2.0 unx     2740 b- defN 24-May-07 00:35 dgl/graphbolt/dataset.py
+-rw-r--r--  2.0 unx     6790 b- defN 24-May-07 00:35 dgl/graphbolt/feature_fetcher.py
+-rw-r--r--  2.0 unx     4913 b- defN 24-May-07 00:35 dgl/graphbolt/feature_store.py
+-rw-r--r--  2.0 unx    32950 b- defN 24-May-07 00:35 dgl/graphbolt/item_sampler.py
+-rw-r--r--  2.0 unx    15948 b- defN 24-May-07 00:35 dgl/graphbolt/itemset.py
+-rwxr-xr-x  2.0 unx  2095160 b- defN 24-May-07 00:42 dgl/graphbolt/libgraphbolt_pytorch_2.1.0.dylib
+-rwxr-xr-x  2.0 unx  2095160 b- defN 24-May-07 00:42 dgl/graphbolt/libgraphbolt_pytorch_2.1.1.dylib
+-rwxr-xr-x  2.0 unx  2095160 b- defN 24-May-07 00:42 dgl/graphbolt/libgraphbolt_pytorch_2.1.2.dylib
+-rwxr-xr-x  2.0 unx  2063248 b- defN 24-May-07 00:42 dgl/graphbolt/libgraphbolt_pytorch_2.2.0.dylib
+-rwxr-xr-x  2.0 unx  2063248 b- defN 24-May-07 00:42 dgl/graphbolt/libgraphbolt_pytorch_2.2.1.dylib
+-rwxr-xr-x  2.0 unx  2063248 b- defN 24-May-07 00:42 dgl/graphbolt/libgraphbolt_pytorch_2.2.2.dylib
+-rw-r--r--  2.0 unx    14320 b- defN 24-May-07 00:35 dgl/graphbolt/minibatch.py
+-rw-r--r--  2.0 unx     1102 b- defN 24-May-07 00:35 dgl/graphbolt/minibatch_transformer.py
+-rw-r--r--  2.0 unx     3292 b- defN 24-May-07 00:35 dgl/graphbolt/negative_sampler.py
+-rw-r--r--  2.0 unx    12314 b- defN 24-May-07 00:35 dgl/graphbolt/sampled_subgraph.py
+-rw-r--r--  2.0 unx     2295 b- defN 24-May-07 00:35 dgl/graphbolt/sampling_graph.py
+-rw-r--r--  2.0 unx    10379 b- defN 24-May-07 00:35 dgl/graphbolt/subgraph_sampler.py
+-rw-r--r--  2.0 unx     3751 b- defN 24-May-07 00:35 dgl/graphbolt/utils.py
+-rw-r--r--  2.0 unx      486 b- defN 24-May-07 00:35 dgl/graphbolt/impl/__init__.py
+-rw-r--r--  2.0 unx     4197 b- defN 24-May-07 00:35 dgl/graphbolt/impl/basic_feature_store.py
+-rw-r--r--  2.0 unx    56491 b- defN 24-May-07 00:35 dgl/graphbolt/impl/fused_csc_sampling_graph.py
+-rw-r--r--  2.0 unx     1759 b- defN 24-May-07 00:35 dgl/graphbolt/impl/gpu_cache.py
+-rw-r--r--  2.0 unx     3968 b- defN 24-May-07 00:35 dgl/graphbolt/impl/gpu_cached_feature.py
+-rw-r--r--  2.0 unx     2735 b- defN 24-May-07 00:35 dgl/graphbolt/impl/in_subgraph_sampler.py
+-rw-r--r--  2.0 unx     5859 b- defN 24-May-07 00:35 dgl/graphbolt/impl/legacy_dataset.py
+-rw-r--r--  2.0 unx    22956 b- defN 24-May-07 00:35 dgl/graphbolt/impl/neighbor_sampler.py
+-rw-r--r--  2.0 unx    38844 b- defN 24-May-07 00:35 dgl/graphbolt/impl/ondisk_dataset.py
+-rw-r--r--  2.0 unx     3491 b- defN 24-May-07 00:35 dgl/graphbolt/impl/ondisk_metadata.py
+-rw-r--r--  2.0 unx     3688 b- defN 24-May-07 00:35 dgl/graphbolt/impl/sampled_subgraph_impl.py
+-rw-r--r--  2.0 unx     5692 b- defN 24-May-07 00:35 dgl/graphbolt/impl/temporal_neighbor_sampler.py
+-rw-r--r--  2.0 unx    14798 b- defN 24-May-07 00:35 dgl/graphbolt/impl/torch_based_feature_store.py
+-rw-r--r--  2.0 unx     3161 b- defN 24-May-07 00:35 dgl/graphbolt/impl/uniform_negative_sampler.py
+-rw-r--r--  2.0 unx      152 b- defN 24-May-07 00:35 dgl/graphbolt/internal/__init__.py
+-rw-r--r--  2.0 unx     1384 b- defN 24-May-07 00:35 dgl/graphbolt/internal/datapipe_utils.py
+-rw-r--r--  2.0 unx     4512 b- defN 24-May-07 00:35 dgl/graphbolt/internal/item_sampler_utils.py
+-rw-r--r--  2.0 unx    17419 b- defN 24-May-07 00:35 dgl/graphbolt/internal/sample_utils.py
+-rw-r--r--  2.0 unx     7343 b- defN 24-May-07 00:35 dgl/graphbolt/internal/utils.py
+-rw-r--r--  2.0 unx      113 b- defN 24-May-07 00:35 dgl/mpops/__init__.py
+-rw-r--r--  2.0 unx     6596 b- defN 24-May-07 00:35 dgl/mpops/edgewise.py
+-rw-r--r--  2.0 unx       72 b- defN 24-May-07 00:35 dgl/mpops/fused.py
+-rw-r--r--  2.0 unx       65 b- defN 24-May-07 00:35 dgl/mpops/nodewise.py
+-rw-r--r--  2.0 unx      714 b- defN 24-May-07 00:35 dgl/multiprocessing/__init__.py
+-rw-r--r--  2.0 unx     3893 b- defN 24-May-07 00:35 dgl/multiprocessing/pytorch.py
+-rw-r--r--  2.0 unx     1362 b- defN 24-May-07 00:35 dgl/nn/__init__.py
+-rw-r--r--  2.0 unx       76 b- defN 24-May-07 00:35 dgl/nn/functional/__init__.py
+-rw-r--r--  2.0 unx      160 b- defN 24-May-07 00:35 dgl/nn/mxnet/__init__.py
+-rw-r--r--  2.0 unx     9195 b- defN 24-May-07 00:35 dgl/nn/mxnet/glob.py
+-rw-r--r--  2.0 unx     9018 b- defN 24-May-07 00:35 dgl/nn/mxnet/hetero.py
+-rw-r--r--  2.0 unx      116 b- defN 24-May-07 00:35 dgl/nn/mxnet/softmax.py
+-rw-r--r--  2.0 unx     7796 b- defN 24-May-07 00:35 dgl/nn/mxnet/utils.py
+-rw-r--r--  2.0 unx      980 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/__init__.py
+-rw-r--r--  2.0 unx     6229 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/agnnconv.py
+-rw-r--r--  2.0 unx     3790 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/appnpconv.py
+-rw-r--r--  2.0 unx     6064 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/chebconv.py
+-rw-r--r--  2.0 unx     3710 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/densechebconv.py
+-rw-r--r--  2.0 unx     4710 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/densegraphconv.py
+-rw-r--r--  2.0 unx     3860 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/densesageconv.py
+-rw-r--r--  2.0 unx     7000 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/edgeconv.py
+-rw-r--r--  2.0 unx    13914 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/gatconv.py
+-rw-r--r--  2.0 unx     5085 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/gatedgraphconv.py
+-rw-r--r--  2.0 unx     4629 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/ginconv.py
+-rw-r--r--  2.0 unx     9940 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/gmmconv.py
+-rw-r--r--  2.0 unx    12170 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/graphconv.py
+-rw-r--r--  2.0 unx     6302 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/nnconv.py
+-rw-r--r--  2.0 unx     9993 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/relgraphconv.py
+-rw-r--r--  2.0 unx     8362 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/sageconv.py
+-rw-r--r--  2.0 unx     7057 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/sgconv.py
+-rw-r--r--  2.0 unx     4172 b- defN 24-May-07 00:35 dgl/nn/mxnet/conv/tagconv.py
+-rw-r--r--  2.0 unx      382 b- defN 24-May-07 00:35 dgl/nn/pytorch/__init__.py
+-rw-r--r--  2.0 unx    14118 b- defN 24-May-07 00:35 dgl/nn/pytorch/factory.py
+-rw-r--r--  2.0 unx    45484 b- defN 24-May-07 00:35 dgl/nn/pytorch/glob.py
+-rw-r--r--  2.0 unx    14085 b- defN 24-May-07 00:35 dgl/nn/pytorch/hetero.py
+-rw-r--r--  2.0 unx     7699 b- defN 24-May-07 00:35 dgl/nn/pytorch/linear.py
+-rw-r--r--  2.0 unx    15866 b- defN 24-May-07 00:35 dgl/nn/pytorch/network_emb.py
+-rw-r--r--  2.0 unx      118 b- defN 24-May-07 00:35 dgl/nn/pytorch/softmax.py
+-rw-r--r--  2.0 unx    15231 b- defN 24-May-07 00:35 dgl/nn/pytorch/sparse_emb.py
+-rw-r--r--  2.0 unx    18172 b- defN 24-May-07 00:35 dgl/nn/pytorch/utils.py
+-rw-r--r--  2.0 unx     2039 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/__init__.py
+-rw-r--r--  2.0 unx     6200 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/agnnconv.py
+-rw-r--r--  2.0 unx     4479 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/appnpconv.py
+-rw-r--r--  2.0 unx     9941 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/atomicconv.py
+-rw-r--r--  2.0 unx     4894 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/cfconv.py
+-rw-r--r--  2.0 unx     5160 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/chebconv.py
+-rw-r--r--  2.0 unx     2137 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/cugraph_base.py
+-rw-r--r--  2.0 unx     7067 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/cugraph_gatconv.py
+-rw-r--r--  2.0 unx     7828 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/cugraph_relgraphconv.py
+-rw-r--r--  2.0 unx     4949 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/cugraph_sageconv.py
+-rw-r--r--  2.0 unx     4092 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/densechebconv.py
+-rw-r--r--  2.0 unx     5171 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/densegraphconv.py
+-rw-r--r--  2.0 unx     4675 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/densesageconv.py
+-rw-r--r--  2.0 unx     8979 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/dgnconv.py
+-rw-r--r--  2.0 unx     9439 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/dotgatconv.py
+-rw-r--r--  2.0 unx     7799 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/edgeconv.py
+-rw-r--r--  2.0 unx    15785 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/edgegatconv.py
+-rw-r--r--  2.0 unx    10332 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/egatconv.py
+-rw-r--r--  2.0 unx     5726 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/egnnconv.py
+-rw-r--r--  2.0 unx    15099 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gatconv.py
+-rw-r--r--  2.0 unx     6140 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gatedgcnconv.py
+-rw-r--r--  2.0 unx     6229 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gatedgraphconv.py
+-rw-r--r--  2.0 unx    13218 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gatv2conv.py
+-rw-r--r--  2.0 unx    10659 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gcn2conv.py
+-rw-r--r--  2.0 unx     6414 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/ginconv.py
+-rw-r--r--  2.0 unx     3697 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gineconv.py
+-rw-r--r--  2.0 unx    10102 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/gmmconv.py
+-rw-r--r--  2.0 unx    18520 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/graphconv.py
+-rw-r--r--  2.0 unx     8622 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/grouprevres.py
+-rw-r--r--  2.0 unx     7062 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/hgtconv.py
+-rw-r--r--  2.0 unx     6576 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/nnconv.py
+-rw-r--r--  2.0 unx    10689 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/pnaconv.py
+-rw-r--r--  2.0 unx     6692 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/relgraphconv.py
+-rw-r--r--  2.0 unx    11302 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/sageconv.py
+-rw-r--r--  2.0 unx     8002 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/sgconv.py
+-rw-r--r--  2.0 unx     4910 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/tagconv.py
+-rw-r--r--  2.0 unx    19654 b- defN 24-May-07 00:35 dgl/nn/pytorch/conv/twirlsconv.py
+-rw-r--r--  2.0 unx      186 b- defN 24-May-07 00:35 dgl/nn/pytorch/explain/__init__.py
+-rw-r--r--  2.0 unx    37449 b- defN 24-May-07 00:35 dgl/nn/pytorch/explain/gnnexplainer.py
+-rw-r--r--  2.0 unx    42962 b- defN 24-May-07 00:35 dgl/nn/pytorch/explain/pgexplainer.py
+-rw-r--r--  2.0 unx    29586 b- defN 24-May-07 00:35 dgl/nn/pytorch/explain/subgraphx.py
+-rw-r--r--  2.0 unx      329 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/__init__.py
+-rw-r--r--  2.0 unx     5381 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/biased_mha.py
+-rw-r--r--  2.0 unx     3627 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/degree_encoder.py
+-rw-r--r--  2.0 unx     6251 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/egt.py
+-rw-r--r--  2.0 unx     4191 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/graphormer.py
+-rw-r--r--  2.0 unx     5454 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/lap_pos_encoder.py
+-rw-r--r--  2.0 unx     3238 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/path_encoder.py
+-rw-r--r--  2.0 unx     8254 b- defN 24-May-07 00:35 dgl/nn/pytorch/gt/spatial_encoder.py
+-rw-r--r--  2.0 unx      159 b- defN 24-May-07 00:35 dgl/nn/pytorch/link/__init__.py
+-rw-r--r--  2.0 unx     4892 b- defN 24-May-07 00:35 dgl/nn/pytorch/link/edgepred.py
+-rw-r--r--  2.0 unx     2801 b- defN 24-May-07 00:35 dgl/nn/pytorch/link/transe.py
+-rw-r--r--  2.0 unx     3351 b- defN 24-May-07 00:35 dgl/nn/pytorch/link/transr.py
+-rw-r--r--  2.0 unx      156 b- defN 24-May-07 00:35 dgl/nn/tensorflow/__init__.py
+-rw-r--r--  2.0 unx     7249 b- defN 24-May-07 00:35 dgl/nn/tensorflow/glob.py
+-rw-r--r--  2.0 unx     8950 b- defN 24-May-07 00:35 dgl/nn/tensorflow/hetero.py
+-rw-r--r--  2.0 unx      115 b- defN 24-May-07 00:35 dgl/nn/tensorflow/softmax.py
+-rw-r--r--  2.0 unx     2463 b- defN 24-May-07 00:35 dgl/nn/tensorflow/utils.py
+-rw-r--r--  2.0 unx      348 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/__init__.py
+-rw-r--r--  2.0 unx     2473 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/appnpconv.py
+-rw-r--r--  2.0 unx     5476 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/chebconv.py
+-rw-r--r--  2.0 unx     3587 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/densechebconv.py
+-rw-r--r--  2.0 unx     5813 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/edgeconv.py
+-rw-r--r--  2.0 unx    13481 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/gatconv.py
+-rw-r--r--  2.0 unx     4589 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/ginconv.py
+-rw-r--r--  2.0 unx    12433 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/graphconv.py
+-rw-r--r--  2.0 unx    12307 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/relgraphconv.py
+-rw-r--r--  2.0 unx     8389 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/sageconv.py
+-rw-r--r--  2.0 unx     6955 b- defN 24-May-07 00:35 dgl/nn/tensorflow/conv/sgconv.py
+-rw-r--r--  2.0 unx      144 b- defN 24-May-07 00:35 dgl/ops/__init__.py
+-rw-r--r--  2.0 unx     5382 b- defN 24-May-07 00:35 dgl/ops/edge_softmax.py
+-rw-r--r--  2.0 unx     1430 b- defN 24-May-07 00:35 dgl/ops/gather_mm.py
+-rw-r--r--  2.0 unx     6543 b- defN 24-May-07 00:35 dgl/ops/sddmm.py
+-rw-r--r--  2.0 unx     3938 b- defN 24-May-07 00:35 dgl/ops/segment.py
+-rw-r--r--  2.0 unx     7709 b- defN 24-May-07 00:35 dgl/ops/spmm.py
+-rw-r--r--  2.0 unx      363 b- defN 24-May-07 00:35 dgl/optim/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 00:35 dgl/optim/mxnet/__init__.py
+-rw-r--r--  2.0 unx       92 b- defN 24-May-07 00:35 dgl/optim/pytorch/__init__.py
+-rw-r--r--  2.0 unx    39022 b- defN 24-May-07 00:35 dgl/optim/pytorch/sparse_optim.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 00:35 dgl/optim/tensorflow/__init__.py
+-rw-r--r--  2.0 unx      517 b- defN 24-May-07 00:35 dgl/sampling/__init__.py
+-rw-r--r--  2.0 unx    14225 b- defN 24-May-07 00:35 dgl/sampling/labor.py
+-rw-r--r--  2.0 unx     4175 b- defN 24-May-07 00:35 dgl/sampling/negative.py
+-rw-r--r--  2.0 unx    36980 b- defN 24-May-07 00:35 dgl/sampling/neighbor.py
+-rw-r--r--  2.0 unx     3338 b- defN 24-May-07 00:35 dgl/sampling/node2vec_randomwalk.py
+-rw-r--r--  2.0 unx    10278 b- defN 24-May-07 00:35 dgl/sampling/pinsage.py
+-rw-r--r--  2.0 unx    11619 b- defN 24-May-07 00:35 dgl/sampling/randomwalks.py
+-rw-r--r--  2.0 unx     4262 b- defN 24-May-07 00:35 dgl/sampling/utils.py
+-rw-r--r--  2.0 unx     1261 b- defN 24-May-07 00:35 dgl/sparse/__init__.py
+-rw-r--r--  2.0 unx     4244 b- defN 24-May-07 00:35 dgl/sparse/broadcast.py
+-rw-r--r--  2.0 unx     5539 b- defN 24-May-07 00:35 dgl/sparse/elementwise_op.py
+-rw-r--r--  2.0 unx     5836 b- defN 24-May-07 00:35 dgl/sparse/elementwise_op_sp.py
+-rw-r--r--  2.0 unx     6734 b- defN 24-May-07 00:35 dgl/sparse/matmul.py
+-rw-r--r--  2.0 unx    12018 b- defN 24-May-07 00:35 dgl/sparse/reduction.py
+-rw-r--r--  2.0 unx     3306 b- defN 24-May-07 00:35 dgl/sparse/sddmm.py
+-rw-r--r--  2.0 unx     2480 b- defN 24-May-07 00:35 dgl/sparse/softmax.py
+-rw-r--r--  2.0 unx    47861 b- defN 24-May-07 00:35 dgl/sparse/sparse_matrix.py
+-rw-r--r--  2.0 unx     1673 b- defN 24-May-07 00:35 dgl/sparse/unary_op.py
+-rw-r--r--  2.0 unx      305 b- defN 24-May-07 00:35 dgl/sparse/utils.py
+-rw-r--r--  2.0 unx      327 b- defN 24-May-07 00:35 dgl/storages/__init__.py
+-rw-r--r--  2.0 unx     2538 b- defN 24-May-07 00:35 dgl/storages/base.py
+-rw-r--r--  2.0 unx      826 b- defN 24-May-07 00:35 dgl/storages/numpy.py
+-rw-r--r--  2.0 unx     2114 b- defN 24-May-07 00:35 dgl/storages/pytorch_tensor.py
+-rw-r--r--  2.0 unx      548 b- defN 24-May-07 00:35 dgl/storages/tensor.py
+-rwxr-xr-x  2.0 unx    52608 b- defN 24-May-07 00:42 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.0.dylib
+-rwxr-xr-x  2.0 unx    52608 b- defN 24-May-07 00:42 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.1.dylib
+-rwxr-xr-x  2.0 unx    52608 b- defN 24-May-07 00:42 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.2.dylib
+-rwxr-xr-x  2.0 unx    52608 b- defN 24-May-07 00:42 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.0.dylib
+-rwxr-xr-x  2.0 unx    52608 b- defN 24-May-07 00:42 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.1.dylib
+-rwxr-xr-x  2.0 unx    52608 b- defN 24-May-07 00:42 dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.2.dylib
+-rw-r--r--  2.0 unx      116 b- defN 24-May-07 00:35 dgl/transforms/__init__.py
+-rw-r--r--  2.0 unx   143516 b- defN 24-May-07 00:35 dgl/transforms/functional.py
+-rw-r--r--  2.0 unx    67187 b- defN 24-May-07 00:35 dgl/transforms/module.py
+-rw-r--r--  2.0 unx     9180 b- defN 24-May-07 00:35 dgl/transforms/to_block.py
+-rw-r--r--  2.0 unx      383 b- defN 24-May-07 00:35 dgl/utils/__init__.py
+-rw-r--r--  2.0 unx     8167 b- defN 24-May-07 00:35 dgl/utils/checks.py
+-rw-r--r--  2.0 unx    13480 b- defN 24-May-07 00:35 dgl/utils/data.py
+-rw-r--r--  2.0 unx     2582 b- defN 24-May-07 00:35 dgl/utils/exception.py
+-rw-r--r--  2.0 unx     2163 b- defN 24-May-07 00:35 dgl/utils/filter.py
+-rw-r--r--  2.0 unx    36858 b- defN 24-May-07 00:35 dgl/utils/internal.py
+-rw-r--r--  2.0 unx     2293 b- defN 24-May-07 00:35 dgl/utils/pin_memory.py
+-rw-r--r--  2.0 unx      281 b- defN 24-May-07 00:35 dgl/utils/shared_mem.py
+-rw-r--r--  2.0 unx      615 b- defN 24-May-07 00:42 dgl-2.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 24-May-07 00:42 dgl-2.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        4 b- defN 24-May-07 00:42 dgl-2.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    31675 b- defN 24-May-07 00:42 dgl-2.2.0.dist-info/RECORD
+372 files, 33035515 bytes uncompressed, 7348957 bytes compressed:  77.8%
```

## zipnote {}

```diff
@@ -45,15 +45,15 @@
 
 Filename: dgl/init.py
 Comment: 
 
 Filename: dgl/label_informativeness.py
 Comment: 
 
-Filename: dgl/libdgl.so
+Filename: dgl/libdgl.dylib
 Comment: 
 
 Filename: dgl/logging.py
 Comment: 
 
 Filename: dgl/merge.py
 Comment: 
@@ -132,15 +132,15 @@
 
 Filename: dgl/_ffi/_cy2/__init__.py
 Comment: 
 
 Filename: dgl/_ffi/_cy3/__init__.py
 Comment: 
 
-Filename: dgl/_ffi/_cy3/core.cpython-39-aarch64-linux-gnu.so
+Filename: dgl/_ffi/_cy3/core.cpython-39-darwin.so
 Comment: 
 
 Filename: dgl/_ffi/_cython/core.cpp
 Comment: 
 
 Filename: dgl/backend/__init__.py
 Comment: 
@@ -348,33 +348,30 @@
 
 Filename: dgl/dataloading/shadow.py
 Comment: 
 
 Filename: dgl/dataloading/spot_target.py
 Comment: 
 
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.0.0.so
+Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.0.dylib
 Comment: 
 
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.0.1.so
+Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.1.dylib
 Comment: 
 
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.0.so
+Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.2.dylib
 Comment: 
 
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.1.so
+Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.0.dylib
 Comment: 
 
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.2.so
+Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.1.dylib
 Comment: 
 
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.0.so
-Comment: 
-
-Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.1.so
+Filename: dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.2.dylib
 Comment: 
 
 Filename: dgl/distgnn/__init__.py
 Comment: 
 
 Filename: dgl/distgnn/partition/__init__.py
 Comment: 
@@ -438,17 +435,14 @@
 
 Filename: dgl/distributed/shared_mem_utils.py
 Comment: 
 
 Filename: dgl/distributed/standalone_kvstore.py
 Comment: 
 
-Filename: dgl/distributed/utils.py
-Comment: 
-
 Filename: dgl/distributed/nn/__init__.py
 Comment: 
 
 Filename: dgl/distributed/nn/mxnet/__init__.py
 Comment: 
 
 Filename: dgl/distributed/nn/pytorch/__init__.py
@@ -522,33 +516,30 @@
 
 Filename: dgl/graphbolt/item_sampler.py
 Comment: 
 
 Filename: dgl/graphbolt/itemset.py
 Comment: 
 
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.0.0.so
+Filename: dgl/graphbolt/libgraphbolt_pytorch_2.1.0.dylib
 Comment: 
 
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.0.1.so
+Filename: dgl/graphbolt/libgraphbolt_pytorch_2.1.1.dylib
 Comment: 
 
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.1.0.so
+Filename: dgl/graphbolt/libgraphbolt_pytorch_2.1.2.dylib
 Comment: 
 
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.1.1.so
+Filename: dgl/graphbolt/libgraphbolt_pytorch_2.2.0.dylib
 Comment: 
 
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.1.2.so
+Filename: dgl/graphbolt/libgraphbolt_pytorch_2.2.1.dylib
 Comment: 
 
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.2.0.so
-Comment: 
-
-Filename: dgl/graphbolt/libgraphbolt_pytorch_2.2.1.so
+Filename: dgl/graphbolt/libgraphbolt_pytorch_2.2.2.dylib
 Comment: 
 
 Filename: dgl/graphbolt/minibatch.py
 Comment: 
 
 Filename: dgl/graphbolt/minibatch_transformer.py
 Comment: 
@@ -1053,33 +1044,30 @@
 
 Filename: dgl/storages/pytorch_tensor.py
 Comment: 
 
 Filename: dgl/storages/tensor.py
 Comment: 
 
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.0.0.so
-Comment: 
-
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.0.1.so
+Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.0.dylib
 Comment: 
 
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.0.so
+Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.1.dylib
 Comment: 
 
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.1.so
+Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.2.dylib
 Comment: 
 
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.2.so
+Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.0.dylib
 Comment: 
 
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.0.so
+Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.1.dylib
 Comment: 
 
-Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.1.so
+Filename: dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.2.dylib
 Comment: 
 
 Filename: dgl/transforms/__init__.py
 Comment: 
 
 Filename: dgl/transforms/functional.py
 Comment: 
@@ -1110,20 +1098,20 @@
 
 Filename: dgl/utils/pin_memory.py
 Comment: 
 
 Filename: dgl/utils/shared_mem.py
 Comment: 
 
-Filename: dgl-2.1.0.dist-info/METADATA
+Filename: dgl-2.2.0.dist-info/METADATA
 Comment: 
 
-Filename: dgl-2.1.0.dist-info/WHEEL
+Filename: dgl-2.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: dgl-2.1.0.dist-info/top_level.txt
+Filename: dgl-2.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: dgl-2.1.0.dist-info/RECORD
+Filename: dgl-2.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dgl/convert.py

```diff
@@ -383,15 +383,20 @@
     )
     retg = DGLGraph(hgidx, ntypes, etypes)
 
     return retg.to(device)
 
 
 def create_block(
-    data_dict, num_src_nodes=None, num_dst_nodes=None, idtype=None, device=None
+    data_dict,
+    num_src_nodes=None,
+    num_dst_nodes=None,
+    idtype=None,
+    device=None,
+    node_count_check=True,
 ):
     """Create a message flow graph (MFG) as a :class:`DGLBlock` object.
 
     Parameters
     ----------
     data_dict : graph data
         The dictionary data for constructing a MFG. The keys are in the form of
@@ -452,14 +457,17 @@
         If ``None`` (default), DGL infers the ID type from the :attr:`data_dict` argument.
     device : device context, optional
         The device of the returned graph, which should be a framework-specific device object
         (e.g., ``torch.device``). If ``None`` (default), DGL uses the device of the tensors of
         the :attr:`data` argument. If :attr:`data` is not a tuple of node-tensors, the
         returned graph is on CPU.  If the specified :attr:`device` differs from that of the
         provided tensors, it casts the given tensors to the specified device first.
+    node_count_check : bool, optional
+        When num_src_nodes and num_dst_nodes are passed, whether we should perform
+        sanity checks to ensure they are valid.
 
     Returns
     -------
     DGLBlock
         The created MFG.
 
     Notes
@@ -536,21 +544,24 @@
         num_src_nodes = defaultdict(int)
         num_dst_nodes = defaultdict(int)
 
     # Convert all data to node tensors first
     node_tensor_dict = {}
     for (sty, ety, dty), data in data_dict.items():
         (sparse_fmt, arrays), urange, vrange = utils.graphdata2tensors(
-            data, idtype, bipartite=True
+            data,
+            idtype,
+            bipartite=True,
+            infer_node_count=need_infer or node_count_check,
         )
         node_tensor_dict[(sty, ety, dty)] = (sparse_fmt, arrays)
         if need_infer:
             num_src_nodes[sty] = max(num_src_nodes[sty], urange)
             num_dst_nodes[dty] = max(num_dst_nodes[dty], vrange)
-        else:  # sanity check
+        elif node_count_check:  # sanity check
             if num_src_nodes[sty] < urange:
                 raise DGLError(
                     "The given number of nodes of source node type {} must be larger"
                     " than the max ID in the data, but got {} and {}.".format(
                         sty, num_src_nodes[sty], urange - 1
                     )
                 )
```

## dgl/_ffi/libinfo.py

```diff
@@ -101,9 +101,8 @@
     return lib_found
 
 
 # current version
 # We use the version of the incoming release for code
 # that is under development.
 # The following line is set by dgl/python/update_version.py
-__version__ = "2.1.0"
-__commit__ = ''
+__version__ = "2.2.0"
```

## dgl/_ffi/_cython/core.cpp

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 3.0.8 */
+/* Generated by Cython 0.29.28 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "../include/dgl/runtime/c_object_api.h",
             "../include/dgl/runtime/c_runtime_api.h",
@@ -33,62 +33,28 @@
     "module_name": "dgl._ffi._cy3.core"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
-#if defined(CYTHON_LIMITED_API) && 0
-  #ifndef Py_LIMITED_API
-    #if CYTHON_LIMITED_API+0 > 0x03030000
-      #define Py_LIMITED_API CYTHON_LIMITED_API
-    #else
-      #define Py_LIMITED_API 0x03030000
-    #endif
-  #endif
-#endif
-
 #include "Python.h"
-
-    #if PY_MAJOR_VERSION >= 3
-      #define __Pyx_PyFloat_FromString(obj)  PyFloat_FromString(obj)
-    #else
-      #define __Pyx_PyFloat_FromString(obj)  PyFloat_FromString(obj, NULL)
-    #endif
-    
-
-    #if PY_MAJOR_VERSION <= 2
-    #define PyDict_GetItemWithError _PyDict_GetItemWithError
-    #endif
-    
-
-    #if (PY_VERSION_HEX < 0x030700b1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM < 0x07030600)) && !defined(PyContextVar_Get)
-    #define PyContextVar_Get(var, d, v)         ((d) ?             ((void)(var), Py_INCREF(d), (v)[0] = (d), 0) :             ((v)[0] = NULL, 0)         )
-    #endif
-    
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02070000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
-    #error Cython requires Python 2.7+ or Python 3.3+.
-#else
-#if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
-#define __PYX_EXTRA_ABI_MODULE_NAME "limited"
+#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
+    #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define __PYX_EXTRA_ABI_MODULE_NAME ""
-#endif
-#define CYTHON_ABI "3_0_8" __PYX_EXTRA_ABI_MODULE_NAME
-#define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
-#define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030008F0
+#define CYTHON_ABI "0_29_28"
+#define CYTHON_HEX_VERSION 0x001D1CF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
-#if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
+#if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
   #endif
   #ifndef __cdecl
     #define __cdecl
   #endif
   #ifndef __fastcall
@@ -99,92 +65,30 @@
   #define DL_IMPORT(t) t
 #endif
 #ifndef DL_EXPORT
   #define DL_EXPORT(t) t
 #endif
 #define __PYX_COMMA ,
 #ifndef HAVE_LONG_LONG
-  #define HAVE_LONG_LONG
+  #if PY_VERSION_HEX >= 0x02070000
+    #define HAVE_LONG_LONG
+  #endif
 #endif
 #ifndef PY_LONG_LONG
   #define PY_LONG_LONG LONG_LONG
 #endif
 #ifndef Py_HUGE_VAL
   #define Py_HUGE_VAL HUGE_VAL
 #endif
-#define __PYX_LIMITED_VERSION_HEX PY_VERSION_HEX
-#if defined(GRAALVM_PYTHON)
-  /* For very preliminary testing purposes. Most variables are set the same as PyPy.
-     The existence of this section does not imply that anything works or is even tested */
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 1
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 0
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 0
-  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #undef CYTHON_AVOID_BORROWED_REFS
-  #define CYTHON_AVOID_BORROWED_REFS 1
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
-  #endif
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PYPY_VERSION)
+#ifdef PYPY_VERSION
   #define CYTHON_COMPILING_IN_PYPY 1
+  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
   #define CYTHON_USE_TYPE_SLOTS 0
-  #ifndef CYTHON_USE_TYPE_SPECS
-    #define CYTHON_USE_TYPE_SPECS 0
-  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #if PY_VERSION_HEX < 0x03050000
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
@@ -201,115 +105,35 @@
   #define CYTHON_AVOID_BORROWED_REFS 1
   #undef CYTHON_ASSUME_SAFE_MACROS
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
-  #endif
-  #if PY_VERSION_HEX < 0x03090000
-    #undef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(CYTHON_LIMITED_API)
-  #ifdef Py_LIMITED_API
-    #undef __PYX_LIMITED_VERSION_HEX
-    #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
-  #endif
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 1
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_CLINE_IN_TRACEBACK
-  #define CYTHON_CLINE_IN_TRACEBACK 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 1
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #undef CYTHON_USE_ASYNC_SLOTS
-  #define CYTHON_USE_ASYNC_SLOTS 0
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_WRITER
-    #define CYTHON_USE_UNICODE_WRITER 0
-  #endif
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS 1
-  #endif
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 1
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 0
-  #endif
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
+#elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #ifndef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
+  #undef CYTHON_USE_ASYNC_SLOTS
+  #define CYTHON_USE_ASYNC_SLOTS 0
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
@@ -324,46 +148,45 @@
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
+  #undef CYTHON_PEP489_MULTI_PHASE_INIT
+  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
-  #ifndef CYTHON_USE_TYPE_SPECS
-    #define CYTHON_USE_TYPE_SPECS 0
-  #endif
-  #ifndef CYTHON_USE_PYTYPE_LOOKUP
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYTYPE_LOOKUP
+    #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
     #define CYTHON_USE_PYTYPE_LOOKUP 1
   #endif
   #if PY_MAJOR_VERSION < 3
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
-  #ifndef CYTHON_USE_PYLONG_INTERNALS
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
     #define CYTHON_USE_PYLONG_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
@@ -379,67 +202,42 @@
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
-  #ifndef CYTHON_FAST_THREAD_STATE
+  #if PY_VERSION_HEX >= 0x030B00A4
+    #undef CYTHON_FAST_THREAD_STATE
+    #define CYTHON_FAST_THREAD_STATE 0
+  #elif !defined(CYTHON_FAST_THREAD_STATE)
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
-  #ifndef CYTHON_FAST_GIL
-    #define CYTHON_FAST_GIL (PY_MAJOR_VERSION < 3 || PY_VERSION_HEX >= 0x03060000 && PY_VERSION_HEX < 0x030C00A6)
-  #endif
-  #ifndef CYTHON_METH_FASTCALL
-    #define CYTHON_METH_FASTCALL (PY_VERSION_HEX >= 0x030700A1)
-  #endif
   #ifndef CYTHON_FAST_PYCALL
-    #define CYTHON_FAST_PYCALL 1
+    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030B00A1)
   #endif
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_MODULE_STATE
-    #define CYTHON_USE_MODULE_STATE 0
-  #endif
-  #if PY_VERSION_HEX < 0x030400a1
-    #undef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 0
-  #elif !defined(CYTHON_USE_TP_FINALIZE)
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
-  #if PY_VERSION_HEX < 0x030600B1
-    #undef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS 0
-  #elif !defined(CYTHON_USE_DICT_VERSIONS)
-    #define CYTHON_USE_DICT_VERSIONS  (PY_VERSION_HEX < 0x030C00A5)
+  #ifndef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
+  #endif
+  #ifndef CYTHON_USE_DICT_VERSIONS
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
   #endif
-  #if PY_VERSION_HEX < 0x030700A3
+  #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
-    #define CYTHON_USE_EXC_INFO_STACK 1
-  #endif
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
-#if !defined(CYTHON_VECTORCALL)
-#define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
-#endif
-#define CYTHON_BACKPORT_VECTORCALL (CYTHON_METH_FASTCALL && PY_VERSION_HEX < 0x030800B1)
 #if CYTHON_USE_PYLONG_INTERNALS
   #if PY_MAJOR_VERSION < 3
     #include "longintrepr.h"
   #endif
   #undef SHIFT
   #undef BASE
   #undef MASK
@@ -461,136 +259,78 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_RESTRICT restrict
   #else
     #define CYTHON_RESTRICT
   #endif
 #endif
 #ifndef CYTHON_UNUSED
-  #if defined(__cplusplus)
-    /* for clang __has_cpp_attribute(maybe_unused) is true even before C++17
-     * but leads to warnings with -pedantic, since it is a C++17 feature */
-    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
-      #if __has_cpp_attribute(maybe_unused)
-        #define CYTHON_UNUSED [[maybe_unused]]
-      #endif
-    #endif
-  #endif
-#endif
-#ifndef CYTHON_UNUSED
 # if defined(__GNUC__)
 #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #     define CYTHON_UNUSED __attribute__ ((__unused__))
 #   else
 #     define CYTHON_UNUSED
 #   endif
 # elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
 #   define CYTHON_UNUSED __attribute__ ((__unused__))
 # else
 #   define CYTHON_UNUSED
 # endif
 #endif
-#ifndef CYTHON_UNUSED_VAR
+#ifndef CYTHON_MAYBE_UNUSED_VAR
 #  if defined(__cplusplus)
-     template<class T> void CYTHON_UNUSED_VAR( const T& ) { }
+     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
 #  else
-#    define CYTHON_UNUSED_VAR(x) (void)(x)
+#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
 #  endif
 #endif
-#ifndef CYTHON_MAYBE_UNUSED_VAR
-  #define CYTHON_MAYBE_UNUSED_VAR(x) CYTHON_UNUSED_VAR(x)
-#endif
 #ifndef CYTHON_NCP_UNUSED
 # if CYTHON_COMPILING_IN_CPYTHON
 #  define CYTHON_NCP_UNUSED
 # else
 #  define CYTHON_NCP_UNUSED CYTHON_UNUSED
 # endif
 #endif
-#ifndef CYTHON_USE_CPP_STD_MOVE
-  #if defined(__cplusplus) && (\
-    __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1600))
-    #define CYTHON_USE_CPP_STD_MOVE 1
-  #else
-    #define CYTHON_USE_CPP_STD_MOVE 0
-  #endif
-#endif
 #define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
 #ifdef _MSC_VER
     #ifndef _MSC_STDINT_H_
         #if _MSC_VER < 1300
-            typedef unsigned char     uint8_t;
-            typedef unsigned short    uint16_t;
-            typedef unsigned int      uint32_t;
-        #else
-            typedef unsigned __int8   uint8_t;
-            typedef unsigned __int16  uint16_t;
-            typedef unsigned __int32  uint32_t;
-        #endif
-    #endif
-    #if _MSC_VER < 1300
-        #ifdef _WIN64
-            typedef unsigned long long  __pyx_uintptr_t;
+           typedef unsigned char     uint8_t;
+           typedef unsigned int      uint32_t;
         #else
-            typedef unsigned int        __pyx_uintptr_t;
-        #endif
-    #else
-        #ifdef _WIN64
-            typedef unsigned __int64    __pyx_uintptr_t;
-        #else
-            typedef unsigned __int32    __pyx_uintptr_t;
+           typedef unsigned __int8   uint8_t;
+           typedef unsigned __int32  uint32_t;
         #endif
     #endif
 #else
-    #include <stdint.h>
-    typedef uintptr_t  __pyx_uintptr_t;
+   #include <stdint.h>
 #endif
 #ifndef CYTHON_FALLTHROUGH
-  #if defined(__cplusplus)
-    /* for clang __has_cpp_attribute(fallthrough) is true even before C++17
-     * but leads to warnings with -pedantic, since it is a C++17 feature */
-    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
-      #if __has_cpp_attribute(fallthrough)
-        #define CYTHON_FALLTHROUGH [[fallthrough]]
-      #endif
-    #endif
-    #ifndef CYTHON_FALLTHROUGH
-      #if __has_cpp_attribute(clang::fallthrough)
-        #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
-      #elif __has_cpp_attribute(gnu::fallthrough)
-        #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
-      #endif
+  #if defined(__cplusplus) && __cplusplus >= 201103L
+    #if __has_cpp_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH [[fallthrough]]
+    #elif __has_cpp_attribute(clang::fallthrough)
+      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
+    #elif __has_cpp_attribute(gnu::fallthrough)
+      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
     #endif
   #endif
   #ifndef CYTHON_FALLTHROUGH
     #if __has_attribute(fallthrough)
       #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
     #else
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
-  #if defined(__clang__) && defined(__apple_build_version__)
+  #if defined(__clang__ ) && defined(__apple_build_version__)
     #if __apple_build_version__ < 7000000
       #undef  CYTHON_FALLTHROUGH
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
 #endif
-#ifdef __cplusplus
-  template <typename T>
-  struct __PYX_IS_UNSIGNED_IMPL {static const bool value = T(0) < T(-1);};
-  #define __PYX_IS_UNSIGNED(type) (__PYX_IS_UNSIGNED_IMPL<type>::value)
-#else
-  #define __PYX_IS_UNSIGNED(type) (((type)-1) > 0)
-#endif
-#if CYTHON_COMPILING_IN_PYPY == 1
-  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x030A0000)
-#else
-  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000)
-#endif
-#define __PYX_REINTERPRET_FUNCION(func_pointer, other_pointer) ((func_pointer)(void(*)(void))(other_pointer))
 
 #ifndef __cplusplus
   #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
 #endif
 #ifndef CYTHON_INLINE
   #if defined(__clang__)
     #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
@@ -606,292 +346,158 @@
 class __Pyx_FakeReference {
   public:
     __Pyx_FakeReference() : ptr(NULL) { }
     __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
     T *operator->() { return ptr; }
     T *operator&() { return ptr; }
     operator T&() { return *ptr; }
-    template<typename U> bool operator ==(const U& other) const { return *ptr == other; }
-    template<typename U> bool operator !=(const U& other) const { return *ptr != other; }
-    template<typename U> bool operator==(const __Pyx_FakeReference<U>& other) const { return *ptr == *other.ptr; }
-    template<typename U> bool operator!=(const __Pyx_FakeReference<U>& other) const { return *ptr != *other.ptr; }
+    template<typename U> bool operator ==(U other) { return *ptr == other; }
+    template<typename U> bool operator !=(U other) { return *ptr != other; }
   private:
     T *ptr;
 };
 
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
+  #define Py_OptimizeFlag 0
+#endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_DefaultClassType PyClass_Type
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+  #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
   #define __Pyx_DefaultClassType PyType_Type
-#if CYTHON_COMPILING_IN_LIMITED_API
-    static CYTHON_INLINE PyObject* __Pyx_PyCode_New(int a, int p, int k, int l, int s, int f,
+#if PY_VERSION_HEX >= 0x030B00A1
+    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
                                                     PyObject *code, PyObject *c, PyObject* n, PyObject *v,
                                                     PyObject *fv, PyObject *cell, PyObject* fn,
                                                     PyObject *name, int fline, PyObject *lnos) {
-        PyObject *exception_table = NULL;
-        PyObject *types_module=NULL, *code_type=NULL, *result=NULL;
-        #if __PYX_LIMITED_VERSION_HEX < 0x030B0000
-        PyObject *version_info;
-        PyObject *py_minor_version = NULL;
-        #endif
-        long minor_version = 0;
+        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
+        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
+        const char *fn_cstr=NULL;
+        const char *name_cstr=NULL;
+        PyCodeObject* co=NULL;
         PyObject *type, *value, *traceback;
         PyErr_Fetch(&type, &value, &traceback);
-        #if __PYX_LIMITED_VERSION_HEX >= 0x030B0000
-        minor_version = 11;
-        #else
-        if (!(version_info = PySys_GetObject("version_info"))) goto end;
-        if (!(py_minor_version = PySequence_GetItem(version_info, 1))) goto end;
-        minor_version = PyLong_AsLong(py_minor_version);
-        Py_DECREF(py_minor_version);
-        if (minor_version == -1 && PyErr_Occurred()) goto end;
-        #endif
-        if (!(types_module = PyImport_ImportModule("types"))) goto end;
-        if (!(code_type = PyObject_GetAttrString(types_module, "CodeType"))) goto end;
-        if (minor_version <= 7) {
-            (void)p;
-            result = PyObject_CallFunction(code_type, "iiiiiOOOOOOiOO", a, k, l, s, f, code,
-                          c, n, v, fn, name, fline, lnos, fv, cell);
-        } else if (minor_version <= 10) {
-            result = PyObject_CallFunction(code_type, "iiiiiiOOOOOOiOO", a,p, k, l, s, f, code,
-                          c, n, v, fn, name, fline, lnos, fv, cell);
-        } else {
-            if (!(exception_table = PyBytes_FromStringAndSize(NULL, 0))) goto end;
-            result = PyObject_CallFunction(code_type, "iiiiiiOOOOOOOiOO", a,p, k, l, s, f, code,
-                          c, n, v, fn, name, name, fline, lnos, exception_table, fv, cell);
-        }
-    end:
-        Py_XDECREF(code_type);
-        Py_XDECREF(exception_table);
-        Py_XDECREF(types_module);
+        if (!(kwds=PyDict_New())) goto end;
+        if (!(argcount=PyLong_FromLong(a))) goto end;
+        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
+        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
+        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
+        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
+        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
+        if (!(nlocals=PyLong_FromLong(l))) goto end;
+        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
+        if (!(stacksize=PyLong_FromLong(s))) goto end;
+        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
+        if (!(flags=PyLong_FromLong(f))) goto end;
+        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
+        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
+        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
+        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
+        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
+        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
+        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
+        Py_XDECREF((PyObject*)co);
+        co = (PyCodeObject*)call_result;
+        call_result = NULL;
+        if (0) {
+            cleanup_code_too:
+            Py_XDECREF((PyObject*)co);
+            co = NULL;
+        }
+        end:
+        Py_XDECREF(kwds);
+        Py_XDECREF(argcount);
+        Py_XDECREF(posonlyargcount);
+        Py_XDECREF(kwonlyargcount);
+        Py_XDECREF(nlocals);
+        Py_XDECREF(stacksize);
+        Py_XDECREF(replace);
+        Py_XDECREF(call_result);
+        Py_XDECREF(empty);
         if (type) {
             PyErr_Restore(type, value, traceback);
         }
-        return result;
+        return co;
     }
-    #ifndef CO_OPTIMIZED
-    #define CO_OPTIMIZED 0x0001
-    #endif
-    #ifndef CO_NEWLOCALS
-    #define CO_NEWLOCALS 0x0002
-    #endif
-    #ifndef CO_VARARGS
-    #define CO_VARARGS 0x0004
-    #endif
-    #ifndef CO_VARKEYWORDS
-    #define CO_VARKEYWORDS 0x0008
-    #endif
-    #ifndef CO_ASYNC_GENERATOR
-    #define CO_ASYNC_GENERATOR 0x0200
-    #endif
-    #ifndef CO_GENERATOR
-    #define CO_GENERATOR 0x0020
-    #endif
-    #ifndef CO_COROUTINE
-    #define CO_COROUTINE 0x0080
-    #endif
-#elif PY_VERSION_HEX >= 0x030B0000
-  static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int p, int k, int l, int s, int f,
-                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
-                                                    PyObject *fv, PyObject *cell, PyObject* fn,
-                                                    PyObject *name, int fline, PyObject *lnos) {
-    PyCodeObject *result;
-    PyObject *empty_bytes = PyBytes_FromStringAndSize("", 0);
-    if (!empty_bytes) return NULL;
-    result =
-      #if PY_VERSION_HEX >= 0x030C0000
-        PyUnstable_Code_NewWithPosOnlyArgs
-      #else
-        PyCode_NewWithPosOnlyArgs
-      #endif
-        (a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, name, fline, lnos, empty_bytes);
-    Py_DECREF(empty_bytes);
-    return result;
-  }
-#elif PY_VERSION_HEX >= 0x030800B2 && !CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_NewWithPosOnlyArgs(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
-#endif
-#if PY_VERSION_HEX >= 0x030900A4 || defined(Py_IS_TYPE)
-  #define __Pyx_IS_TYPE(ob, type) Py_IS_TYPE(ob, type)
-#else
-  #define __Pyx_IS_TYPE(ob, type) (((const PyObject*)ob)->ob_type == (type))
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_Is)
-  #define __Pyx_Py_Is(x, y)  Py_Is(x, y)
-#else
-  #define __Pyx_Py_Is(x, y) ((x) == (y))
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsNone)
-  #define __Pyx_Py_IsNone(ob) Py_IsNone(ob)
-#else
-  #define __Pyx_Py_IsNone(ob) __Pyx_Py_Is((ob), Py_None)
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsTrue)
-  #define __Pyx_Py_IsTrue(ob) Py_IsTrue(ob)
-#else
-  #define __Pyx_Py_IsTrue(ob) __Pyx_Py_Is((ob), Py_True)
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsFalse)
-  #define __Pyx_Py_IsFalse(ob) Py_IsFalse(ob)
-#else
-  #define __Pyx_Py_IsFalse(ob) __Pyx_Py_Is((ob), Py_False)
-#endif
-#define __Pyx_NoneAsNull(obj)  (__Pyx_Py_IsNone(obj) ? NULL : (obj))
-#if PY_VERSION_HEX >= 0x030900F0 && !CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyObject_GC_IsFinalized(o) PyObject_GC_IsFinalized(o)
-#else
-  #define __Pyx_PyObject_GC_IsFinalized(o) _PyGC_FINALIZED(o)
-#endif
-#ifndef CO_COROUTINE
-  #define CO_COROUTINE 0x80
-#endif
-#ifndef CO_ASYNC_GENERATOR
-  #define CO_ASYNC_GENERATOR 0x200
+  #define __Pyx_DefaultClassType PyType_Type
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
   #define Py_TPFLAGS_CHECKTYPES 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_INDEX
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_FINALIZE
   #define Py_TPFLAGS_HAVE_FINALIZE 0
 #endif
-#ifndef Py_TPFLAGS_SEQUENCE
-  #define Py_TPFLAGS_SEQUENCE 0
-#endif
-#ifndef Py_TPFLAGS_MAPPING
-  #define Py_TPFLAGS_MAPPING 0
-#endif
 #ifndef METH_STACKLESS
   #define METH_STACKLESS 0
 #endif
 #if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
   #define __Pyx_PyCFunctionFast _PyCFunctionFast
   #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
 #endif
-#if CYTHON_METH_FASTCALL
-  #define __Pyx_METH_FASTCALL METH_FASTCALL
-  #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
-  #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
-#else
-  #define __Pyx_METH_FASTCALL METH_VARARGS
-  #define __Pyx_PyCFunction_FastCall PyCFunction
-  #define __Pyx_PyCFunction_FastCallWithKeywords PyCFunctionWithKeywords
-#endif
-#if CYTHON_VECTORCALL
-  #define __pyx_vectorcallfunc vectorcallfunc
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  PY_VECTORCALL_ARGUMENTS_OFFSET
-  #define __Pyx_PyVectorcall_NARGS(n)  PyVectorcall_NARGS((size_t)(n))
-#elif CYTHON_BACKPORT_VECTORCALL
-  typedef PyObject *(*__pyx_vectorcallfunc)(PyObject *callable, PyObject *const *args,
-                                            size_t nargsf, PyObject *kwnames);
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  ((size_t)1 << (8 * sizeof(size_t) - 1))
-  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(((size_t)(n)) & ~__Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET))
-#else
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  0
-  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(n))
-#endif
-#if PY_MAJOR_VERSION >= 0x030900B1
-#define __Pyx_PyCFunction_CheckExact(func)  PyCFunction_CheckExact(func)
-#else
-#define __Pyx_PyCFunction_CheckExact(func)  PyCFunction_Check(func)
-#endif
-#define __Pyx_CyOrPyCFunction_Check(func)  PyCFunction_Check(func)
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_CyOrPyCFunction_GET_FUNCTION(func)  (((PyCFunctionObject*)(func))->m_ml->ml_meth)
-#elif !CYTHON_COMPILING_IN_LIMITED_API
-#define __Pyx_CyOrPyCFunction_GET_FUNCTION(func)  PyCFunction_GET_FUNCTION(func)
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_CyOrPyCFunction_GET_FLAGS(func)  (((PyCFunctionObject*)(func))->m_ml->ml_flags)
-static CYTHON_INLINE PyObject* __Pyx_CyOrPyCFunction_GET_SELF(PyObject *func) {
-    return (__Pyx_CyOrPyCFunction_GET_FLAGS(func) & METH_STATIC) ? NULL : ((PyCFunctionObject*)func)->m_self;
-}
-#endif
-static CYTHON_INLINE int __Pyx__IsSameCFunction(PyObject *func, void *cfunc) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-    return PyCFunction_Check(func) && PyCFunction_GetFunction(func) == (PyCFunction) cfunc;
-#else
-    return PyCFunction_Check(func) && PyCFunction_GET_FUNCTION(func) == (PyCFunction) cfunc;
-#endif
-}
-#define __Pyx_IsSameCFunction(func, cfunc)   __Pyx__IsSameCFunction(func, cfunc)
-#if __PYX_LIMITED_VERSION_HEX < 0x030900B1
-  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  ((void)m, PyType_FromSpecWithBases(s, b))
-  typedef PyObject *(*__Pyx_PyCMethod)(PyObject *, PyTypeObject *, PyObject *const *, size_t, PyObject *);
+#if CYTHON_FAST_PYCCALL
+#define __Pyx_PyFastCFunction_Check(func)\
+    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
 #else
-  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  PyType_FromModuleAndSpec(m, s, b)
-  #define __Pyx_PyCMethod  PyCMethod
-#endif
-#ifndef METH_METHOD
-  #define METH_METHOD 0x200
+#define __Pyx_PyFastCFunction_Check(func) 0
 #endif
 #if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
   #define PyObject_Malloc(s)   PyMem_Malloc(s)
   #define PyObject_Free(p)     PyMem_Free(p)
   #define PyObject_Realloc(p)  PyMem_Realloc(p)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
+  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
+  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
+  #define PyMem_RawFree(p)             PyMem_Free(p)
+#endif
+#if CYTHON_COMPILING_IN_PYSTON
+  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
 #else
   #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
   #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyThreadState_Current PyThreadState_Get()
-#elif !CYTHON_FAST_THREAD_STATE
+#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
-#elif PY_VERSION_HEX >= 0x030d00A1
-  #define __Pyx_PyThreadState_Current PyThreadState_GetUnchecked()
 #elif PY_VERSION_HEX >= 0x03060000
   #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
 #elif PY_VERSION_HEX >= 0x03000000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #else
   #define __Pyx_PyThreadState_Current _PyThreadState_Current
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE void *__Pyx_PyModule_GetState(PyObject *op)
-{
-    void *result;
-    result = PyModule_GetState(op);
-    if (!result)
-        Py_FatalError("Couldn't find the module state");
-    return result;
-}
-#endif
-#define __Pyx_PyObject_GetSlot(obj, name, func_ctype)  __Pyx_PyType_GetSlot(Py_TYPE(obj), name, func_ctype)
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((func_ctype) PyType_GetSlot((type), Py_##name))
-#else
-  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((type)->name)
-#endif
 #if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
 #include "pythread.h"
 #define Py_tss_NEEDS_INIT 0
 typedef int Py_tss_t;
 static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
   *key = PyThread_create_key();
   return 0;
@@ -914,171 +520,86 @@
 static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
   return PyThread_set_key_value(*key, value);
 }
 static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
   return PyThread_get_key_value(*key);
 }
 #endif
-#if PY_MAJOR_VERSION < 3
-    #if CYTHON_COMPILING_IN_PYPY
-        #if PYPY_VERSION_NUM < 0x07030600
-            #if defined(__cplusplus) && __cplusplus >= 201402L
-                [[deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")]]
-            #elif defined(__GNUC__) || defined(__clang__)
-                __attribute__ ((__deprecated__("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")))
-            #elif defined(_MSC_VER)
-                __declspec(deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6"))
-            #endif
-            static CYTHON_INLINE int PyGILState_Check(void) {
-                return 0;
-            }
-        #else  // PYPY_VERSION_NUM < 0x07030600
-        #endif  // PYPY_VERSION_NUM < 0x07030600
-    #else
-        static CYTHON_INLINE int PyGILState_Check(void) {
-            PyThreadState * tstate = _PyThreadState_Current;
-            return tstate && (tstate == PyGILState_GetThisThreadState());
-        }
-    #endif
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030d0000 || defined(_PyDict_NewPresized)
+#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
 #define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
 #else
 #define __Pyx_PyDict_NewPresized(n)  PyDict_New()
 #endif
 #if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
 #else
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX > 0x030600B4 && PY_VERSION_HEX < 0x030d0000 && CYTHON_USE_UNICODE_INTERNALS
-#define __Pyx_PyDict_GetItemStrWithError(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
-static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStr(PyObject *dict, PyObject *name) {
-    PyObject *res = __Pyx_PyDict_GetItemStrWithError(dict, name);
-    if (res == NULL) PyErr_Clear();
-    return res;
-}
-#elif PY_MAJOR_VERSION >= 3 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07020000)
-#define __Pyx_PyDict_GetItemStrWithError  PyDict_GetItemWithError
-#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
-#else
-static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStrWithError(PyObject *dict, PyObject *name) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyDict_GetItem(dict, name);
-#else
-    PyDictEntry *ep;
-    PyDictObject *mp = (PyDictObject*) dict;
-    long hash = ((PyStringObject *) name)->ob_shash;
-    assert(hash != -1);
-    ep = (mp->ma_lookup)(mp, name, hash);
-    if (ep == NULL) {
-        return NULL;
-    }
-    return ep->me_value;
-#endif
-}
-#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
-#endif
-#if CYTHON_USE_TYPE_SLOTS
-  #define __Pyx_PyType_GetFlags(tp)   (((PyTypeObject *)tp)->tp_flags)
-  #define __Pyx_PyType_HasFeature(type, feature)  ((__Pyx_PyType_GetFlags(type) & (feature)) != 0)
-  #define __Pyx_PyObject_GetIterNextFunc(obj)  (Py_TYPE(obj)->tp_iternext)
-#else
-  #define __Pyx_PyType_GetFlags(tp)   (PyType_GetFlags((PyTypeObject *)tp))
-  #define __Pyx_PyType_HasFeature(type, feature)  PyType_HasFeature(type, feature)
-  #define __Pyx_PyObject_GetIterNextFunc(obj)  PyIter_Next
-#endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_SetItemOnTypeDict(tp, k, v) PyObject_GenericSetAttr((PyObject*)tp, k, v)
-#else
-  #define __Pyx_SetItemOnTypeDict(tp, k, v) PyDict_SetItem(tp->tp_dict, k, v)
-#endif
-#if CYTHON_USE_TYPE_SPECS && PY_VERSION_HEX >= 0x03080000
-#define __Pyx_PyHeapTypeObject_GC_Del(obj)  {\
-    PyTypeObject *type = Py_TYPE((PyObject*)obj);\
-    assert(__Pyx_PyType_HasFeature(type, Py_TPFLAGS_HEAPTYPE));\
-    PyObject_GC_Del(obj);\
-    Py_DECREF(type);\
-}
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
+#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
 #else
-#define __Pyx_PyHeapTypeObject_GC_Del(obj)  PyObject_GC_Del(obj)
+#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define CYTHON_PEP393_ENABLED 1
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GetLength(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_ReadChar(u, i)
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((void)u, 1114111U)
-  #define __Pyx_PyUnicode_KIND(u)         ((void)u, (0))
-  #define __Pyx_PyUnicode_DATA(u)         ((void*)u)
-  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)k, PyUnicode_ReadChar((PyObject*)(d), i))
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GetLength(u))
-#elif PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
   #define CYTHON_PEP393_ENABLED 1
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_READY(op)       (0)
+  #if defined(PyUnicode_IS_READY)
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
   #else
-    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                                0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_READY(op)       (0)
   #endif
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
-  #define __Pyx_PyUnicode_KIND(u)         ((int)PyUnicode_KIND(u))
+  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
   #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
   #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, (Py_UCS4) ch)
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
+  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
+  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
   #else
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-    #else
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-    #endif
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+  #endif
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
   #endif
 #else
   #define CYTHON_PEP393_ENABLED 0
   #define PyUnicode_1BYTE_KIND  1
   #define PyUnicode_2BYTE_KIND  2
   #define PyUnicode_4BYTE_KIND  4
   #define __Pyx_PyUnicode_READY(op)       (0)
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535U : 1114111U)
-  #define __Pyx_PyUnicode_KIND(u)         ((int)sizeof(Py_UNICODE))
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
+  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
   #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
   #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = (Py_UNICODE) ch)
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
   #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
 #endif
 #if CYTHON_COMPILING_IN_PYPY
   #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
 #else
   #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
       PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
 #endif
-#if CYTHON_COMPILING_IN_PYPY
-  #if !defined(PyUnicode_DecodeUnicodeEscape)
-    #define PyUnicode_DecodeUnicodeEscape(s, size, errors)  PyUnicode_Decode(s, size, "unicode_escape", errors)
-  #endif
-  #if !defined(PyUnicode_Contains) || (PY_MAJOR_VERSION == 2 && PYPY_VERSION_NUM < 0x07030500)
-    #undef PyUnicode_Contains
-    #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
-  #endif
-  #if !defined(PyByteArray_Check)
-    #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
-  #endif
-  #if !defined(PyObject_Format)
-    #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
-  #endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
+  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
+  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
+  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
 #endif
 #define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
 #define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
 #else
   #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
@@ -1099,81 +620,45 @@
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
   #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
 #else
   #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
   #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
-  #define __Pyx_PySequence_ListKeepNew(obj)\
-    (likely(PyList_CheckExact(obj) && Py_REFCNT(obj) == 1) ? __Pyx_NewRef(obj) : PySequence_List(obj))
-#else
-  #define __Pyx_PySequence_ListKeepNew(obj)  PySequence_List(obj)
-#endif
 #ifndef PySet_CheckExact
-  #define PySet_CheckExact(obj)        __Pyx_IS_TYPE(obj, &PySet_Type)
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
 #endif
 #if PY_VERSION_HEX >= 0x030900A4
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
 #else
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
 #endif
 #if CYTHON_ASSUME_SAFE_MACROS
-  #define __Pyx_PySequence_ITEM(o, i) PySequence_ITEM(o, i)
   #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
-  #define __Pyx_PyTuple_SET_ITEM(o, i, v) (PyTuple_SET_ITEM(o, i, v), (0))
-  #define __Pyx_PyList_SET_ITEM(o, i, v) (PyList_SET_ITEM(o, i, v), (0))
-  #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_GET_SIZE(o)
-  #define __Pyx_PyList_GET_SIZE(o) PyList_GET_SIZE(o)
-  #define __Pyx_PySet_GET_SIZE(o) PySet_GET_SIZE(o)
-  #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_GET_SIZE(o)
-  #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_GET_SIZE(o)
 #else
-  #define __Pyx_PySequence_ITEM(o, i) PySequence_GetItem(o, i)
   #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
-  #define __Pyx_PyTuple_SET_ITEM(o, i, v) PyTuple_SetItem(o, i, v)
-  #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
-  #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
-  #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
-  #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
-  #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
-  #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
-#endif
-#if PY_VERSION_HEX >= 0x030d00A1
-  #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
-#else
-  static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
-      PyObject *module = PyImport_AddModule(name);
-      Py_XINCREF(module);
-      return module;
-  }
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
-  #define __Pyx_Py3Int_Check(op)       PyLong_Check(op)
-  #define __Pyx_Py3Int_CheckExact(op)  PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
   #define PyInt_FromLong               PyLong_FromLong
   #define PyInt_FromSize_t             PyLong_FromSize_t
   #define PyInt_FromSsize_t            PyLong_FromSsize_t
   #define PyInt_AsLong                 PyLong_AsLong
   #define PyInt_AS_LONG                PyLong_AS_LONG
   #define PyInt_AsSsize_t              PyLong_AsSsize_t
   #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
   #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
   #define PyNumber_Int                 PyNumber_Long
-#else
-  #define __Pyx_Py3Int_Check(op)       (PyLong_Check(op) || PyInt_Check(op))
-  #define __Pyx_Py3Int_CheckExact(op)  (PyLong_CheckExact(op) || PyInt_CheckExact(op))
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyBoolObject                 PyLongObject
 #endif
 #if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
@@ -1183,14 +668,19 @@
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
   #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
   #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
 #endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
+#else
+  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
+#endif
 #if CYTHON_USE_ASYNC_SLOTS
   #if PY_VERSION_HEX >= 0x030500B1
     #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
     #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
   #else
     #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
   #endif
@@ -1201,18 +691,16 @@
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
 
-#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
-  #if !defined(_USE_MATH_DEFINES)
-    #define _USE_MATH_DEFINES
-  #endif
+#if defined(WIN32) || defined(MS_WINDOWS)
+  #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
 #else
 static CYTHON_INLINE float __PYX_NAN() {
   float value;
@@ -1227,38 +715,32 @@
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
     { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
-#ifdef CYTHON_EXTERN_C
-    #undef __PYX_EXTERN_C
-    #define __PYX_EXTERN_C CYTHON_EXTERN_C
-#elif defined(__PYX_EXTERN_C)
-    #ifdef _MSC_VER
-    #pragma message ("Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.")
-    #else
-    #warning Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.
-    #endif
-#else
-    #define __PYX_EXTERN_C extern "C++"
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
 #endif
 
 #define __PYX_HAVE__dgl___ffi___cy3__core
 #define __PYX_HAVE_API__dgl___ffi___cy3__core
 /* Early includes */
 #include "ios"
 #include "new"
 #include "stdexcept"
 #include "typeinfo"
 #include <vector>
 #include <string.h>
 #include <stdio.h>
-#include <stddef.h>
 #include "pythread.h"
 #include <stdint.h>
 #include "dgl/runtime/c_runtime_api.h"
 #include "dgl/runtime/c_object_api.h"
 #include "dgl/runtime/dlpack_convert.h"
 #ifdef _OPENMP
 #include <omp.h>
@@ -1304,18 +786,17 @@
 #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define __Pyx_sst_abs(value) llabs(value)
 #elif defined (__GNUC__)
     #define __Pyx_sst_abs(value) __builtin_llabs(value)
 #else
     #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
 #endif
-static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s);
 static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
 static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
-static CYTHON_INLINE PyObject* __Pyx_PyByteArray_FromString(const char*);
+#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
 #define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
 #define __Pyx_PyBytes_FromString        PyBytes_FromString
 #define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
 #if PY_MAJOR_VERSION < 3
     #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
     #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
@@ -1325,40 +806,29 @@
 #endif
 #define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyObject_AsWritableString(s)    ((char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
     const Py_UNICODE *u_end = u;
     while (*u_end++) ;
     return (size_t)(u_end - u - 1);
 }
-#endif
-#define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
 #define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
 #define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
@@ -1376,62 +846,16 @@
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
 #else
 #define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
 #endif
-#if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_VERSION_HEX >= 0x030C00A7
-  #ifndef _PyLong_SIGN_MASK
-    #define _PyLong_SIGN_MASK 3
-  #endif
-  #ifndef _PyLong_NON_SIZE_BITS
-    #define _PyLong_NON_SIZE_BITS 3
-  #endif
-  #define __Pyx_PyLong_Sign(x)  (((PyLongObject*)x)->long_value.lv_tag & _PyLong_SIGN_MASK)
-  #define __Pyx_PyLong_IsNeg(x)  ((__Pyx_PyLong_Sign(x) & 2) != 0)
-  #define __Pyx_PyLong_IsNonNeg(x)  (!__Pyx_PyLong_IsNeg(x))
-  #define __Pyx_PyLong_IsZero(x)  (__Pyx_PyLong_Sign(x) & 1)
-  #define __Pyx_PyLong_IsPos(x)  (__Pyx_PyLong_Sign(x) == 0)
-  #define __Pyx_PyLong_CompactValueUnsigned(x)  (__Pyx_PyLong_Digits(x)[0])
-  #define __Pyx_PyLong_DigitCount(x)  ((Py_ssize_t) (((PyLongObject*)x)->long_value.lv_tag >> _PyLong_NON_SIZE_BITS))
-  #define __Pyx_PyLong_SignedDigitCount(x)\
-        ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * __Pyx_PyLong_DigitCount(x))
-  #if defined(PyUnstable_Long_IsCompact) && defined(PyUnstable_Long_CompactValue)
-    #define __Pyx_PyLong_IsCompact(x)     PyUnstable_Long_IsCompact((PyLongObject*) x)
-    #define __Pyx_PyLong_CompactValue(x)  PyUnstable_Long_CompactValue((PyLongObject*) x)
-  #else
-    #define __Pyx_PyLong_IsCompact(x)     (((PyLongObject*)x)->long_value.lv_tag < (2 << _PyLong_NON_SIZE_BITS))
-    #define __Pyx_PyLong_CompactValue(x)  ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * (Py_ssize_t) __Pyx_PyLong_Digits(x)[0])
-  #endif
-  typedef Py_ssize_t  __Pyx_compact_pylong;
-  typedef size_t  __Pyx_compact_upylong;
-  #else
-  #define __Pyx_PyLong_IsNeg(x)  (Py_SIZE(x) < 0)
-  #define __Pyx_PyLong_IsNonNeg(x)  (Py_SIZE(x) >= 0)
-  #define __Pyx_PyLong_IsZero(x)  (Py_SIZE(x) == 0)
-  #define __Pyx_PyLong_IsPos(x)  (Py_SIZE(x) > 0)
-  #define __Pyx_PyLong_CompactValueUnsigned(x)  ((Py_SIZE(x) == 0) ? 0 : __Pyx_PyLong_Digits(x)[0])
-  #define __Pyx_PyLong_DigitCount(x)  __Pyx_sst_abs(Py_SIZE(x))
-  #define __Pyx_PyLong_SignedDigitCount(x)  Py_SIZE(x)
-  #define __Pyx_PyLong_IsCompact(x)  (Py_SIZE(x) == 0 || Py_SIZE(x) == 1 || Py_SIZE(x) == -1)
-  #define __Pyx_PyLong_CompactValue(x)\
-        ((Py_SIZE(x) == 0) ? (sdigit) 0 : ((Py_SIZE(x) < 0) ? -(sdigit)__Pyx_PyLong_Digits(x)[0] : (sdigit)__Pyx_PyLong_Digits(x)[0]))
-  typedef sdigit  __Pyx_compact_pylong;
-  typedef digit  __Pyx_compact_upylong;
-  #endif
-  #if PY_VERSION_HEX >= 0x030C00A5
-  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->long_value.ob_digit)
-  #else
-  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->ob_digit)
-  #endif
-#endif
+#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-#include <string.h>
 static int __Pyx_sys_getdefaultencoding_not_ascii;
 static int __Pyx_init_sys_getdefaultencoding_params(void) {
     PyObject* sys;
     PyObject* default_encoding = NULL;
     PyObject* ascii_chars_u = NULL;
     PyObject* ascii_chars_b = NULL;
     const char* default_encoding_c;
@@ -1444,15 +868,15 @@
     if (!default_encoding_c) goto bad;
     if (strcmp(default_encoding_c, "ascii") == 0) {
         __Pyx_sys_getdefaultencoding_not_ascii = 0;
     } else {
         char ascii_chars[128];
         int c;
         for (c = 0; c < 128; c++) {
-            ascii_chars[c] = (char) c;
+            ascii_chars[c] = c;
         }
         __Pyx_sys_getdefaultencoding_not_ascii = 1;
         ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
         if (!ascii_chars_u) goto bad;
         ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
         if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
             PyErr_Format(
@@ -1474,15 +898,14 @@
 }
 #endif
 #if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
 #define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
 #else
 #define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
 #if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-#include <string.h>
 static char* __PYX_DEFAULT_STRING_ENCODING;
 static int __Pyx_init_sys_getdefaultencoding_params(void) {
     PyObject* sys;
     PyObject* default_encoding = NULL;
     char* default_encoding_c;
     sys = PyImport_ImportModule("sys");
     if (!sys) goto bad;
@@ -1510,92 +933,64 @@
   #define unlikely(x) __builtin_expect(!!(x), 0)
 #else /* !__GNUC__ or GCC < 2.95 */
   #define likely(x)   (x)
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
 static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
 
-#if !CYTHON_USE_MODULE_STATE
 static PyObject *__pyx_m = NULL;
-#endif
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_cython_runtime = NULL;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static PyObject *__pyx_empty_unicode;
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
-static const char * __pyx_cfilenm = __FILE__;
+static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
-/* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
   "dgl/_ffi/_cython/./object.pxi",
-  "<stringsource>",
+  "stringsource",
   "dgl/_ffi/_cython/./function.pxi",
-  "contextvars.pxd",
   "dgl/_ffi/_cython/./base.pxi",
-  "dgl/_ffi/_cython/core.pyx",
   "dgl/_ffi/_cython/./ndarray.pxi",
+  "dgl/_ffi/_cython/core.pyx",
   "type.pxd",
   "bool.pxd",
   "complex.pxd",
 };
-/* #### Code section: utility_code_proto_before_types ### */
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
 #endif
 
 /* NoFastGil.proto */
 #define __Pyx_PyGILState_Ensure PyGILState_Ensure
 #define __Pyx_PyGILState_Release PyGILState_Release
 #define __Pyx_FastGIL_Remember()
 #define __Pyx_FastGIL_Forget()
 #define __Pyx_FastGilFuncInit()
 
-/* #### Code section: numeric_typedefs ### */
 
 /* "dgl/_ffi/_cython/base.pxi":58
  *         DGLContext v_ctx
  * 
  * ctypedef int64_t dgl_index_t             # <<<<<<<<<<<<<<
  * ctypedef DGLArray* DGLArrayHandle
  * ctypedef void* DGLStreamHandle
  */
 typedef int64_t __pyx_t_3dgl_4_ffi_4_cy3_4core_dgl_index_t;
-/* #### Code section: complex_type_declarations ### */
-/* #### Code section: type_declarations ### */
 
 /*--- Type declarations ---*/
 struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase;
 struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase;
 struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
-struct __pyx_opt_args_7cpython_11contextvars_get_value;
-struct __pyx_opt_args_7cpython_11contextvars_get_value_no_default;
-
-/* "cpython/contextvars.pxd":112
- * 
- * 
- * cdef inline object get_value(var, default_value=None):             # <<<<<<<<<<<<<<
- *     """Return a new reference to the value of the context variable,
- *     or the default value of the context variable,
- */
-struct __pyx_opt_args_7cpython_11contextvars_get_value {
-  int __pyx_n;
-  PyObject *default_value;
-};
-
-/* "cpython/contextvars.pxd":129
- * 
- * 
- * cdef inline object get_value_no_default(var, default_value=None):             # <<<<<<<<<<<<<<
- *     """Return a new reference to the value of the context variable,
- *     or the provided default value if no such value was found.
- */
-struct __pyx_opt_args_7cpython_11contextvars_get_value_no_default {
-  int __pyx_n;
-  PyObject *default_value;
-};
 
 /* "dgl/_ffi/_cython/base.pxi":9
  * import ctypes
  * 
  * cdef enum DGLObjectTypeCode:             # <<<<<<<<<<<<<<
  *     kObjectInt = 0
  *     kObjectUInt = 1
@@ -1764,157 +1159,86 @@
  */
 
 struct __pyx_vtabstruct_3dgl_4_ffi_4_cy3_4core_NDArrayBase {
   PyObject *(*_set_handle)(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *, PyObject *);
 };
 static struct __pyx_vtabstruct_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *, PyObject *);
-/* #### Code section: utility_code_proto ### */
 
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
 #if CYTHON_REFNANNY
   typedef struct {
-    void (*INCREF)(void*, PyObject*, Py_ssize_t);
-    void (*DECREF)(void*, PyObject*, Py_ssize_t);
-    void (*GOTREF)(void*, PyObject*, Py_ssize_t);
-    void (*GIVEREF)(void*, PyObject*, Py_ssize_t);
-    void* (*SetupContext)(const char*, Py_ssize_t, const char*);
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
     void (*FinishContext)(void**);
   } __Pyx_RefNannyAPIStruct;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
   #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
 #ifdef WITH_THREAD
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
           if (acquire_gil) {\
               PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
               PyGILState_Release(__pyx_gilstate_save);\
           } else {\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
-          }
-  #define __Pyx_RefNannyFinishContextNogil() {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __Pyx_RefNannyFinishContext();\
-              PyGILState_Release(__pyx_gilstate_save);\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
           }
 #else
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__))
-  #define __Pyx_RefNannyFinishContextNogil() __Pyx_RefNannyFinishContext()
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
 #endif
-  #define __Pyx_RefNannyFinishContextNogil() {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __Pyx_RefNannyFinishContext();\
-              PyGILState_Release(__pyx_gilstate_save);\
-          }
   #define __Pyx_RefNannyFinishContext()\
           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
-  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_XINCREF(r)  do { if((r) == NULL); else {__Pyx_INCREF(r); }} while(0)
-  #define __Pyx_XDECREF(r)  do { if((r) == NULL); else {__Pyx_DECREF(r); }} while(0)
-  #define __Pyx_XGOTREF(r)  do { if((r) == NULL); else {__Pyx_GOTREF(r); }} while(0)
-  #define __Pyx_XGIVEREF(r) do { if((r) == NULL); else {__Pyx_GIVEREF(r);}} while(0)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
 #else
   #define __Pyx_RefNannyDeclarations
   #define __Pyx_RefNannySetupContext(name, acquire_gil)
-  #define __Pyx_RefNannyFinishContextNogil()
   #define __Pyx_RefNannyFinishContext()
   #define __Pyx_INCREF(r) Py_INCREF(r)
   #define __Pyx_DECREF(r) Py_DECREF(r)
   #define __Pyx_GOTREF(r)
   #define __Pyx_GIVEREF(r)
   #define __Pyx_XINCREF(r) Py_XINCREF(r)
   #define __Pyx_XDECREF(r) Py_XDECREF(r)
   #define __Pyx_XGOTREF(r)
   #define __Pyx_XGIVEREF(r)
 #endif
-#define __Pyx_Py_XDECREF_SET(r, v) do {\
-        PyObject *tmp = (PyObject *) r;\
-        r = v; Py_XDECREF(tmp);\
-    } while (0)
 #define __Pyx_XDECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_XDECREF(tmp);\
     } while (0)
 #define __Pyx_DECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_DECREF(tmp);\
     } while (0)
 #define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
 #define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
 
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
-#else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
-#endif
-
-/* PyThreadStateGet.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
-#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
-#if PY_VERSION_HEX >= 0x030C00A6
-#define __Pyx_PyErr_Occurred()  (__pyx_tstate->current_exception != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->current_exception ? (PyObject*) Py_TYPE(__pyx_tstate->current_exception) : (PyObject*) NULL)
-#else
-#define __Pyx_PyErr_Occurred()  (__pyx_tstate->curexc_type != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->curexc_type)
-#endif
-#else
-#define __Pyx_PyThreadState_declare
-#define __Pyx_PyThreadState_assign
-#define __Pyx_PyErr_Occurred()  (PyErr_Occurred() != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  PyErr_Occurred()
-#endif
-
-/* PyErrFetchRestore.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A6
-#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
-#else
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#endif
-#else
-#define __Pyx_PyErr_Clear() PyErr_Clear()
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
-#endif
-
 /* PyObjectGetAttrStr.proto */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
-/* PyObjectGetAttrStrNoError.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
-
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
 /* IncludeStringH.proto */
 #include <string.h>
 
 /* decode_c_string_utf16.proto */
@@ -1933,64 +1257,63 @@
 
 /* decode_c_string.proto */
 static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
          const char* cstring, Py_ssize_t start, Py_ssize_t stop,
          const char* encoding, const char* errors,
          PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
 
+/* PyCFunctionFastCall.proto */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
+#else
+#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
+#endif
+
 /* PyFunctionFastCall.proto */
 #if CYTHON_FAST_PYCALL
-#if !CYTHON_VECTORCALL
 #define __Pyx_PyFunction_FastCall(func, args, nargs)\
     __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
+#if 1 || PY_VERSION_HEX < 0x030600B1
 static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
+#else
+#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
 #endif
 #define __Pyx_BUILD_ASSERT_EXPR(cond)\
     (sizeof(char [1 - 2*!(cond)]) - 1)
 #ifndef Py_MEMBER_SIZE
 #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
 #endif
-#if !CYTHON_VECTORCALL
-#if PY_VERSION_HEX >= 0x03080000
-  #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6 && !CYTHON_COMPILING_IN_LIMITED_API
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-  #define __Pxy_PyFrame_Initialize_Offsets()
-  #define __Pyx_PyFrame_GetLocalsplus(frame)  ((frame)->f_localsplus)
-#else
+#if CYTHON_FAST_PYCALL
   static size_t __pyx_pyframe_localsplus_offset = 0;
   #include "frameobject.h"
   #define __Pxy_PyFrame_Initialize_Offsets()\
     ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
-#endif
-#endif
+#endif // CYTHON_FAST_PYCALL
 #endif
 
 /* PyObjectCall.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
 #else
 #define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
 #endif
 
+/* PyObjectCall2Args.proto */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
+
 /* PyObjectCallMethO.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
 #endif
 
-/* PyObjectFastCall.proto */
-#define __Pyx_PyObject_FastCall(func, args, nargs)  __Pyx_PyObject_FastCallDict(func, args, (size_t)(nargs), NULL)
-static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs);
+/* PyObjectCallOneArg.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
 
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
 #define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
     (version_var) = __PYX_GET_DICT_VERSION(dict);\
@@ -2012,137 +1335,106 @@
 #define __PYX_GET_DICT_VERSION(dict)  (0)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
 #define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
 /* GetModuleGlobalName.proto */
 #if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  do {\
+#define __Pyx_GetModuleGlobalName(var, name)  {\
     static PY_UINT64_T __pyx_dict_version = 0;\
     static PyObject *__pyx_dict_cached_value = NULL;\
     (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
         (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
         __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
     PY_UINT64_T __pyx_dict_version;\
     PyObject *__pyx_dict_cached_value;\
     (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
+}
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
-/* RaiseException.proto */
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+/* PyThreadStateGet.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
+#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
+#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
+#else
+#define __Pyx_PyThreadState_declare
+#define __Pyx_PyThreadState_assign
+#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
+#endif
 
-/* TupleAndListFromArray.proto */
+/* PyErrFetchRestore.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n);
-static CYTHON_INLINE PyObject* __Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n);
+#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
+#else
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
 #endif
-
-/* BytesEquals.proto */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* UnicodeEquals.proto */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* fastcall.proto */
-#if CYTHON_AVOID_BORROWED_REFS
-    #define __Pyx_Arg_VARARGS(args, i) PySequence_GetItem(args, i)
-#elif CYTHON_ASSUME_SAFE_MACROS
-    #define __Pyx_Arg_VARARGS(args, i) PyTuple_GET_ITEM(args, i)
-#else
-    #define __Pyx_Arg_VARARGS(args, i) PyTuple_GetItem(args, i)
-#endif
-#if CYTHON_AVOID_BORROWED_REFS
-    #define __Pyx_Arg_NewRef_VARARGS(arg) __Pyx_NewRef(arg)
-    #define __Pyx_Arg_XDECREF_VARARGS(arg) Py_XDECREF(arg)
-#else
-    #define __Pyx_Arg_NewRef_VARARGS(arg) arg
-    #define __Pyx_Arg_XDECREF_VARARGS(arg)
-#endif
-#define __Pyx_NumKwargs_VARARGS(kwds) PyDict_Size(kwds)
-#define __Pyx_KwValues_VARARGS(args, nargs) NULL
-#define __Pyx_GetKwValue_VARARGS(kw, kwvalues, s) __Pyx_PyDict_GetItemStrWithError(kw, s)
-#define __Pyx_KwargsAsDict_VARARGS(kw, kwvalues) PyDict_Copy(kw)
-#if CYTHON_METH_FASTCALL
-    #define __Pyx_Arg_FASTCALL(args, i) args[i]
-    #define __Pyx_NumKwargs_FASTCALL(kwds) PyTuple_GET_SIZE(kwds)
-    #define __Pyx_KwValues_FASTCALL(args, nargs) ((args) + (nargs))
-    static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s);
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
-    CYTHON_UNUSED static PyObject *__Pyx_KwargsAsDict_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues);
-  #else
-    #define __Pyx_KwargsAsDict_FASTCALL(kw, kwvalues) _PyStack_AsDict(kwvalues, kw)
-  #endif
-    #define __Pyx_Arg_NewRef_FASTCALL(arg) arg  /* no-op, __Pyx_Arg_FASTCALL is direct and this needs
-                                                   to have the same reference counting */
-    #define __Pyx_Arg_XDECREF_FASTCALL(arg)
-#else
-    #define __Pyx_Arg_FASTCALL __Pyx_Arg_VARARGS
-    #define __Pyx_NumKwargs_FASTCALL __Pyx_NumKwargs_VARARGS
-    #define __Pyx_KwValues_FASTCALL __Pyx_KwValues_VARARGS
-    #define __Pyx_GetKwValue_FASTCALL __Pyx_GetKwValue_VARARGS
-    #define __Pyx_KwargsAsDict_FASTCALL __Pyx_KwargsAsDict_VARARGS
-    #define __Pyx_Arg_NewRef_FASTCALL(arg) __Pyx_Arg_NewRef_VARARGS(arg)
-    #define __Pyx_Arg_XDECREF_FASTCALL(arg) __Pyx_Arg_XDECREF_VARARGS(arg)
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-#define __Pyx_ArgsSlice_VARARGS(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_VARARGS(args, start), stop - start)
-#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_FASTCALL(args, start), stop - start)
 #else
-#define __Pyx_ArgsSlice_VARARGS(args, start, stop) PyTuple_GetSlice(args, start, stop)
-#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) PyTuple_GetSlice(args, start, stop)
+#define __Pyx_PyErr_Clear() PyErr_Clear()
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
 #endif
 
+/* RaiseException.proto */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+
+/* WriteUnraisableException.proto */
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename,
+                                  int full_traceback, int nogil);
+
 /* RaiseArgTupleInvalid.proto */
 static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
     Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
 
 /* RaiseDoubleKeywords.proto */
 static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
 
 /* ParseKeywords.proto */
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject *const *kwvalues,
-    PyObject **argnames[],
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
     const char* function_name);
 
 /* ListAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
     if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
         Py_INCREF(x);
-        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
-        L->ob_item[len] = x;
-        #else
         PyList_SET_ITEM(list, len, x);
-        #endif
         __Pyx_SET_SIZE(list, len + 1);
         return 0;
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
-/* PyObjectCall2Args.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
-
-/* PyObjectCallOneArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
-
 /* PyObjectGetMethod.proto */
 static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
 
 /* PyObjectCallMethod1.proto */
 static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);
 
 /* append.proto */
@@ -2154,17 +1446,14 @@
     __Pyx_SetItemInt_Fast(o, (Py_ssize_t)i, v, is_list, wraparound, boundscheck) :\
     (is_list ? (PyErr_SetString(PyExc_IndexError, "list assignment index out of range"), -1) :\
                __Pyx_SetItemInt_Generic(o, to_py_func(i), v)))
 static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v);
 static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v,
                                                int is_list, int wraparound, int boundscheck);
 
-/* RaiseUnexpectedTypeError.proto */
-static int __Pyx_RaiseUnexpectedTypeError(const char *expected, PyObject *obj);
-
 /* GetItemInt.proto */
 #define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
     (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
     __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
     (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
                __Pyx_GetItemInt_Generic(o, to_py_func(i))))
 #define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
@@ -2179,57 +1468,60 @@
     (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                               int wraparound, int boundscheck);
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                      int is_list, int wraparound, int boundscheck);
 
-/* WriteUnraisableException.proto */
-static void __Pyx_WriteUnraisable(const char *name, int clineno,
-                                  int lineno, const char *filename,
-                                  int full_traceback, int nogil);
-
 /* PyObjectFormatAndDecref.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatSimpleAndDecref(PyObject* s, PyObject* f);
 static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatAndDecref(PyObject* s, PyObject* f);
 
 /* JoinPyUnicode.proto */
 static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
                                       Py_UCS4 max_char);
 
-/* KeywordStringCheck.proto */
-static int __Pyx_CheckKeywordStrings(PyObject *kw, const char* function_name, int kw_allowed);
-
 /* GetTopmostException.proto */
-#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
+#if CYTHON_USE_EXC_INFO_STACK
 static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
 #endif
 
 /* SaveResetException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
 #else
 #define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
 #define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
 #endif
 
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
+
 /* GetException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
-/* PyObject_Str.proto */
-#define __Pyx_PyObject_Str(obj)\
-    (likely(PyString_CheckExact(obj)) ? __Pyx_NewRef(obj) : PyObject_Str(obj))
+/* PyObjectCallNoArg.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
+#else
+#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
+#endif
 
 /* PyObjectSetAttrStr.proto */
 #if CYTHON_USE_TYPE_SLOTS
 #define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
 static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
 #else
 #define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
@@ -2245,301 +1537,88 @@
 
 /* PySequenceContains.proto */
 static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
     int result = PySequence_Contains(seq, item);
     return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
 }
 
-/* AssertionsEnabled.proto */
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define __Pyx_init_assertions_enabled()  (0)
-  #define __pyx_assertions_enabled()  (1)
-#elif CYTHON_COMPILING_IN_LIMITED_API  ||  (CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030C0000)
-  static int __pyx_assertions_enabled_flag;
-  #define __pyx_assertions_enabled() (__pyx_assertions_enabled_flag)
-  static int __Pyx_init_assertions_enabled(void) {
-    PyObject *builtins, *debug, *debug_str;
-    int flag;
-    builtins = PyEval_GetBuiltins();
-    if (!builtins) goto bad;
-    debug_str = PyUnicode_FromStringAndSize("__debug__", 9);
-    if (!debug_str) goto bad;
-    debug = PyObject_GetItem(builtins, debug_str);
-    Py_DECREF(debug_str);
-    if (!debug) goto bad;
-    flag = PyObject_IsTrue(debug);
-    Py_DECREF(debug);
-    if (flag == -1) goto bad;
-    __pyx_assertions_enabled_flag = flag;
-    return 0;
-  bad:
-    __pyx_assertions_enabled_flag = 1;
-    return -1;
-  }
-#else
-  #define __Pyx_init_assertions_enabled()  (0)
-  #define __pyx_assertions_enabled()  (!Py_OptimizeFlag)
-#endif
-
 /* PyIntCompare.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_NeObjC(PyObject *op1, PyObject *op2, long intval, long inplace);
 
+/* KeywordStringCheck.proto */
+static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);
+
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
 
 /* PyObject_GenericGetAttr.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
 #endif
 
-/* IncludeStructmemberH.proto */
-#include <structmember.h>
-
-/* FixUpExtensionType.proto */
-#if CYTHON_USE_TYPE_SPECS
-static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type);
-#endif
-
-/* PyObjectCallNoArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
-
-/* PyObjectCallMethod0.proto */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
-
-/* ValidateBasesTuple.proto */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases);
-#endif
-
-/* PyType_Ready.proto */
-CYTHON_UNUSED static int __Pyx_PyType_Ready(PyTypeObject *t);
-
 /* SetVTable.proto */
-static int __Pyx_SetVtable(PyTypeObject* typeptr , void* vtable);
+static int __Pyx_SetVtable(PyObject *dict, void *vtable);
 
-/* GetVTable.proto */
-static void* __Pyx_GetVtable(PyTypeObject *type);
-
-/* MergeVTables.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type);
-#endif
+/* PyObjectGetAttrStrNoError.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce(PyObject* type_obj);
-#endif
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto_3_0_8
-#define __PYX_HAVE_RT_ImportType_proto_3_0_8
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
-#include <stdalign.h>
-#endif
-#if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || __cplusplus >= 201103L
-#define __PYX_GET_STRUCT_ALIGNMENT_3_0_8(s) alignof(s)
-#else
-#define __PYX_GET_STRUCT_ALIGNMENT_3_0_8(s) sizeof(void*)
-#endif
-enum __Pyx_ImportType_CheckSize_3_0_8 {
-   __Pyx_ImportType_CheckSize_Error_3_0_8 = 0,
-   __Pyx_ImportType_CheckSize_Warn_3_0_8 = 1,
-   __Pyx_ImportType_CheckSize_Ignore_3_0_8 = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto
+#define __PYX_HAVE_RT_ImportType_proto
+enum __Pyx_ImportType_CheckSize {
+   __Pyx_ImportType_CheckSize_Error = 0,
+   __Pyx_ImportType_CheckSize_Warn = 1,
+   __Pyx_ImportType_CheckSize_Ignore = 2
 };
-static PyTypeObject *__Pyx_ImportType_3_0_8(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_8 check_size);
+static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
-/* ImportDottedModule.proto */
-static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple);
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple);
-#endif
-
-/* FetchSharedCythonModule.proto */
-static PyObject *__Pyx_FetchSharedCythonABIModule(void);
-
-/* FetchCommonType.proto */
-#if !CYTHON_USE_TYPE_SPECS
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
-#else
-static PyTypeObject* __Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases);
-#endif
-
-/* PyMethodNew.proto */
-#if CYTHON_COMPILING_IN_LIMITED_API
-static PyObject *__Pyx_PyMethod_New(PyObject *func, PyObject *self, PyObject *typ) {
-    PyObject *typesModule=NULL, *methodType=NULL, *result=NULL;
-    CYTHON_UNUSED_VAR(typ);
-    if (!self)
-        return __Pyx_NewRef(func);
-    typesModule = PyImport_ImportModule("types");
-    if (!typesModule) return NULL;
-    methodType = PyObject_GetAttrString(typesModule, "MethodType");
-    Py_DECREF(typesModule);
-    if (!methodType) return NULL;
-    result = PyObject_CallFunctionObjArgs(methodType, func, self, NULL);
-    Py_DECREF(methodType);
-    return result;
-}
-#elif PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_PyMethod_New(PyObject *func, PyObject *self, PyObject *typ) {
-    CYTHON_UNUSED_VAR(typ);
-    if (!self)
-        return __Pyx_NewRef(func);
-    return PyMethod_New(func, self);
-}
-#else
-    #define __Pyx_PyMethod_New PyMethod_New
-#endif
-
-/* PyVectorcallFastCallDict.proto */
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw);
-#endif
-
-/* CythonFunctionShared.proto */
-#define __Pyx_CyFunction_USED
-#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
-#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
-#define __Pyx_CYFUNCTION_CCLASS        0x04
-#define __Pyx_CYFUNCTION_COROUTINE     0x08
-#define __Pyx_CyFunction_GetClosure(f)\
-    (((__pyx_CyFunctionObject *) (f))->func_closure)
-#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_CyFunction_GetClassObj(f)\
-      (((__pyx_CyFunctionObject *) (f))->func_classobj)
-#else
-  #define __Pyx_CyFunction_GetClassObj(f)\
-      ((PyObject*) ((PyCMethodObject *) (f))->mm_class)
-#endif
-#define __Pyx_CyFunction_SetClassObj(f, classobj)\
-    __Pyx__CyFunction_SetClassObj((__pyx_CyFunctionObject *) (f), (classobj))
-#define __Pyx_CyFunction_Defaults(type, f)\
-    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
-#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
-    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
-typedef struct {
-#if CYTHON_COMPILING_IN_LIMITED_API
-    PyObject_HEAD
-    PyObject *func;
-#elif PY_VERSION_HEX < 0x030900B1
-    PyCFunctionObject func;
-#else
-    PyCMethodObject func;
-#endif
-#if CYTHON_BACKPORT_VECTORCALL
-    __pyx_vectorcallfunc func_vectorcall;
-#endif
-#if PY_VERSION_HEX < 0x030500A0 || CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *func_weakreflist;
-#endif
-    PyObject *func_dict;
-    PyObject *func_name;
-    PyObject *func_qualname;
-    PyObject *func_doc;
-    PyObject *func_globals;
-    PyObject *func_code;
-    PyObject *func_closure;
-#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *func_classobj;
-#endif
-    void *defaults;
-    int defaults_pyobjects;
-    size_t defaults_size;
-    int flags;
-    PyObject *defaults_tuple;
-    PyObject *defaults_kwdict;
-    PyObject *(*defaults_getter)(PyObject *);
-    PyObject *func_annotations;
-    PyObject *func_is_coroutine;
-} __pyx_CyFunctionObject;
-#undef __Pyx_CyOrPyCFunction_Check
-#define __Pyx_CyFunction_Check(obj)  __Pyx_TypeCheck(obj, __pyx_CyFunctionType)
-#define __Pyx_CyOrPyCFunction_Check(obj)  __Pyx_TypeCheck2(obj, __pyx_CyFunctionType, &PyCFunction_Type)
-#define __Pyx_CyFunction_CheckExact(obj)  __Pyx_IS_TYPE(obj, __pyx_CyFunctionType)
-static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc);
-#undef __Pyx_IsSameCFunction
-#define __Pyx_IsSameCFunction(func, cfunc)   __Pyx__IsSameCyOrCFunction(func, cfunc)
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
-static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj);
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
-                                                         size_t size,
-                                                         int pyobjects);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
-                                                            PyObject *tuple);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
-                                                             PyObject *dict);
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
-                                                              PyObject *dict);
-static int __pyx_CyFunction_init(PyObject *module);
-#if CYTHON_METH_FASTCALL
-static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-#if CYTHON_BACKPORT_VECTORCALL
-#define __Pyx_CyFunction_func_vectorcall(f) (((__pyx_CyFunctionObject*)f)->func_vectorcall)
-#else
-#define __Pyx_CyFunction_func_vectorcall(f) (((PyCFunctionObject*)f)->vectorcall)
-#endif
-#endif
-
-/* CythonFunction.proto */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
-
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
 
 /* CodeObjectCache.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 typedef struct {
     PyCodeObject* code_object;
     int code_line;
 } __Pyx_CodeObjectCacheEntry;
 struct __Pyx_CodeObjectCache {
     int count;
     int max_count;
     __Pyx_CodeObjectCacheEntry* entries;
 };
 static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
 static PyCodeObject *__pyx_find_code_object(int code_line);
 static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
-#endif
 
 /* AddTraceback.proto */
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename);
 
 /* GCCDiagnostics.proto */
-#if !defined(__INTEL_COMPILER) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
 #define __Pyx_HAS_GCC_DIAGNOSTIC
 #endif
 
 /* CppExceptionConversion.proto */
 #ifndef __Pyx_CppExn2PyErr
 #include <new>
 #include <typeinfo>
@@ -2577,17 +1656,14 @@
   catch (...)
   {
     PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
   }
 }
 #endif
 
-/* None.proto */
-#include <new>
-
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value);
 
 /* CIntFromPy.proto */
@@ -2604,154 +1680,133 @@
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int64_t(int64_t value);
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value);
 
-/* FormatTypeName.proto */
-#if CYTHON_COMPILING_IN_LIMITED_API
-typedef PyObject *__Pyx_TypeName;
-#define __Pyx_FMT_TYPENAME "%U"
-static __Pyx_TypeName __Pyx_PyType_GetName(PyTypeObject* tp);
-#define __Pyx_DECREF_TypeName(obj) Py_XDECREF(obj)
-#else
-typedef const char *__Pyx_TypeName;
-#define __Pyx_FMT_TYPENAME "%.200s"
-#define __Pyx_PyType_GetName(tp) ((tp)->tp_name)
-#define __Pyx_DECREF_TypeName(obj)
-#endif
-
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
 /* FastTypeChecks.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 #define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
-#define __Pyx_TypeCheck2(obj, type1, type2) __Pyx_IsAnySubtype2(Py_TYPE(obj), (PyTypeObject *)type1, (PyTypeObject *)type2)
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
-static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
 #else
 #define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
-#define __Pyx_TypeCheck2(obj, type1, type2) (PyObject_TypeCheck(obj, (PyTypeObject *)type1) || PyObject_TypeCheck(obj, (PyTypeObject *)type2))
 #define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
 #define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
 #endif
-#define __Pyx_PyErr_ExceptionMatches2(err1, err2)  __Pyx_PyErr_GivenExceptionMatches2(__Pyx_PyErr_CurrentExceptionType(), err1, err2)
 #define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
 
 /* CheckBinaryVersion.proto */
-static unsigned long __Pyx_get_runtime_version(void);
-static int __Pyx_check_binary_version(unsigned long ct_version, unsigned long rt_version, int allow_newer);
+static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
-/* #### Code section: module_declarations ### */
-static CYTHON_INLINE double __pyx_f_7cpython_7complex_7complex_4real_real(PyComplexObject *__pyx_v_self); /* proto*/
-static CYTHON_INLINE double __pyx_f_7cpython_7complex_7complex_4imag_imag(PyComplexObject *__pyx_v_self); /* proto*/
 static PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_10ObjectBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_handle); /* proto*/
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_12FunctionBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, PyObject *__pyx_v_handle); /* proto*/
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, PyObject *__pyx_v_handle); /* proto*/
 
-/* Module declarations from "libcpp.vector" */
-
-/* Module declarations from "libcpp" */
-
-/* Module declarations from "cpython.version" */
-
-/* Module declarations from "__builtin__" */
+/* Module declarations from 'libcpp.vector' */
 
-/* Module declarations from "cpython.type" */
+/* Module declarations from 'libcpp' */
 
-/* Module declarations from "libc.string" */
+/* Module declarations from 'cpython.version' */
 
-/* Module declarations from "libc.stdio" */
+/* Module declarations from '__builtin__' */
 
-/* Module declarations from "cpython.object" */
+/* Module declarations from 'cpython.type' */
+static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
 
-/* Module declarations from "cpython.ref" */
+/* Module declarations from 'libc.string' */
 
-/* Module declarations from "cpython.exc" */
+/* Module declarations from 'libc.stdio' */
 
-/* Module declarations from "cpython.module" */
+/* Module declarations from 'cpython.object' */
 
-/* Module declarations from "cpython.mem" */
+/* Module declarations from 'cpython.ref' */
 
-/* Module declarations from "cpython.tuple" */
+/* Module declarations from 'cpython.exc' */
 
-/* Module declarations from "cpython.list" */
+/* Module declarations from 'cpython.module' */
 
-/* Module declarations from "cpython.sequence" */
+/* Module declarations from 'cpython.mem' */
 
-/* Module declarations from "cpython.mapping" */
+/* Module declarations from 'cpython.tuple' */
 
-/* Module declarations from "cpython.iterator" */
+/* Module declarations from 'cpython.list' */
 
-/* Module declarations from "cpython.number" */
+/* Module declarations from 'cpython.sequence' */
 
-/* Module declarations from "cpython.int" */
+/* Module declarations from 'cpython.mapping' */
 
-/* Module declarations from "__builtin__" */
+/* Module declarations from 'cpython.iterator' */
 
-/* Module declarations from "cpython.bool" */
+/* Module declarations from 'cpython.number' */
 
-/* Module declarations from "cpython.long" */
+/* Module declarations from 'cpython.int' */
 
-/* Module declarations from "cpython.float" */
+/* Module declarations from '__builtin__' */
 
-/* Module declarations from "__builtin__" */
+/* Module declarations from 'cpython.bool' */
+static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;
 
-/* Module declarations from "cpython.complex" */
+/* Module declarations from 'cpython.long' */
 
-/* Module declarations from "cpython.string" */
+/* Module declarations from 'cpython.float' */
 
-/* Module declarations from "libc.stddef" */
+/* Module declarations from '__builtin__' */
 
-/* Module declarations from "cpython.unicode" */
+/* Module declarations from 'cpython.complex' */
+static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;
 
-/* Module declarations from "cpython.pyport" */
+/* Module declarations from 'cpython.string' */
 
-/* Module declarations from "cpython.dict" */
+/* Module declarations from 'cpython.unicode' */
 
-/* Module declarations from "cpython.instance" */
+/* Module declarations from 'cpython.dict' */
 
-/* Module declarations from "cpython.function" */
+/* Module declarations from 'cpython.instance' */
 
-/* Module declarations from "cpython.method" */
+/* Module declarations from 'cpython.function' */
 
-/* Module declarations from "cpython.weakref" */
+/* Module declarations from 'cpython.method' */
 
-/* Module declarations from "cpython.getargs" */
+/* Module declarations from 'cpython.weakref' */
 
-/* Module declarations from "cpython.pythread" */
+/* Module declarations from 'cpython.getargs' */
 
-/* Module declarations from "cpython.pystate" */
+/* Module declarations from 'cpython.pythread' */
 
-/* Module declarations from "cpython.cobject" */
+/* Module declarations from 'cpython.pystate' */
 
-/* Module declarations from "cpython.oldbuffer" */
+/* Module declarations from 'cpython.cobject' */
 
-/* Module declarations from "cpython.set" */
+/* Module declarations from 'cpython.oldbuffer' */
 
-/* Module declarations from "cpython.buffer" */
+/* Module declarations from 'cpython.set' */
 
-/* Module declarations from "cpython.bytes" */
+/* Module declarations from 'cpython.buffer' */
 
-/* Module declarations from "cpython.pycapsule" */
+/* Module declarations from 'cpython.bytes' */
 
-/* Module declarations from "cpython.contextvars" */
+/* Module declarations from 'cpython.pycapsule' */
 
-/* Module declarations from "cpython" */
+/* Module declarations from 'cpython' */
 
-/* Module declarations from "libc.stdint" */
+/* Module declarations from 'libc.stdint' */
 
-/* Module declarations from "dgl._ffi._cy3.core" */
+/* Module declarations from 'dgl._ffi._cy3.core' */
+static PyTypeObject *__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase = 0;
+static PyTypeObject *__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase = 0;
+static PyTypeObject *__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase = 0;
 static char const *__pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor;
 static char const *__pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_used_dltensor;
 static PyObject *__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS = 0;
 static PyObject *__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET = 0;
 static PyObject *__pyx_v_3dgl_4_ffi_4_cy3_4core__CLASS_NDARRAY = 0;
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_py_str(char const *); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(PyObject *); /*proto*/
@@ -2765,67 +1820,53 @@
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_make_ret_bytes(void *); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_make_ret(DGLValue, int); /*proto*/
 static CYTHON_INLINE int __pyx_f_3dgl_4_ffi_4_cy3_4core_FuncCall3(void *, PyObject *, int, DGLValue *, int *); /*proto*/
 static CYTHON_INLINE int __pyx_f_3dgl_4_ffi_4_cy3_4core_FuncCall(void *, PyObject *, DGLValue *, int *); /*proto*/
 static CYTHON_INLINE int __pyx_f_3dgl_4_ffi_4_cy3_4core_ConstructorCall(void *, int, PyObject *, void **); /*proto*/
 static PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core__c_dlpack_deleter(PyObject *); /*proto*/
 static PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_c_make_array(void *, PyObject *); /*proto*/
-/* #### Code section: typeinfo ### */
-/* #### Code section: before_global_var ### */
 #define __Pyx_MODULE_NAME "dgl._ffi._cy3.core"
 extern int __pyx_module_is_main_dgl___ffi___cy3__core;
 int __pyx_module_is_main_dgl___ffi___cy3__core = 0;
 
-/* Implementation of "dgl._ffi._cy3.core" */
-/* #### Code section: global_var ### */
+/* Implementation of 'dgl._ffi._cy3.core' */
 static PyObject *__pyx_builtin_AttributeError;
 static PyObject *__pyx_builtin_TypeError;
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin_ValueError;
 static PyObject *__pyx_builtin_RuntimeError;
-static PyObject *__pyx_builtin_AssertionError;
-/* #### Code section: string_decls ### */
 static const char __pyx_k_[] = "'";
-static const char __pyx_k__7[] = ".";
-static const char __pyx_k__8[] = "*";
-static const char __pyx_k__9[] = "";
-static const char __pyx_k_gc[] = "gc";
-static const char __pyx_k__39[] = "?";
+static const char __pyx_k__13[] = "";
 static const char __pyx_k_cls[] = "cls";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_ptr[] = "ptr";
 static const char __pyx_k_ret[] = "ret";
-static const char __pyx_k_args[] = "args";
 static const char __pyx_k_base[] = "base";
 static const char __pyx_k_cast[] = "cast";
 static const char __pyx_k_data[] = "data";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_name[] = "__name__";
-static const char __pyx_k_self[] = "self";
 static const char __pyx_k_size[] = "size";
-static const char __pyx_k_spec[] = "__spec__";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_class[] = "__class__";
 static const char __pyx_k_index[] = "index";
 static const char __pyx_k_range[] = "range";
 static const char __pyx_k_utf_8[] = "utf-8";
 static const char __pyx_k_value[] = "value";
 static const char __pyx_k_Number[] = "Number";
 static const char __pyx_k_append[] = "append";
 static const char __pyx_k_c_byte[] = "c_byte";
 static const char __pyx_k_ctypes[] = "ctypes";
-static const char __pyx_k_enable[] = "enable";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_handle[] = "handle";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_pyfunc[] = "pyfunc";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_POINTER[] = "POINTER";
 static const char __pyx_k_chandle[] = "chandle";
-static const char __pyx_k_disable[] = "disable";
 static const char __pyx_k_fcreate[] = "fcreate";
 static const char __pyx_k_is_view[] = "is_view";
 static const char __pyx_k_memmove[] = "memmove";
 static const char __pyx_k_numbers[] = "numbers";
 static const char __pyx_k_DGLError[] = "DGLError";
 static const char __pyx_k_Integral[] = "Integral";
 static const char __pyx_k_c_void_p[] = "c_void_p";
@@ -2833,18 +1874,15 @@
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_setstate[] = "__setstate__";
 static const char __pyx_k_TypeError[] = "TypeError";
 static const char __pyx_k_addressof[] = "addressof";
 static const char __pyx_k_alignment[] = "alignment";
 static const char __pyx_k_dgl_tcode[] = "_dgl_tcode";
 static const char __pyx_k_is_global[] = "is_global";
-static const char __pyx_k_isenabled[] = "isenabled";
-static const char __pyx_k_pyx_state[] = "__pyx_state";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
-static const char __pyx_k_to_dlpack[] = "to_dlpack";
 static const char __pyx_k_traceback[] = "traceback";
 static const char __pyx_k_DGLContext[] = "DGLContext";
 static const char __pyx_k_ObjectBase[] = "ObjectBase";
 static const char __pyx_k_ValueError[] = "ValueError";
 static const char __pyx_k_dgl_handle[] = "_dgl_handle";
 static const char __pyx_k_format_exc[] = "format_exc";
 static const char __pyx_k_func_class[] = "func_class";
@@ -2858,63 +1896,148 @@
 static const char __pyx_k_from_dlpack[] = "_from_dlpack";
 static const char __pyx_k_CLASS_MODULE[] = "_CLASS_MODULE";
 static const char __pyx_k_DGLByteArray[] = "DGLByteArray";
 static const char __pyx_k_FunctionBase[] = "FunctionBase";
 static const char __pyx_k_RuntimeError[] = "RuntimeError";
 static const char __pyx_k_api_internal[] = "_api_internal";
 static const char __pyx_k_fconstructor[] = "fconstructor";
-static const char __pyx_k_initializing[] = "_initializing";
-static const char __pyx_k_is_coroutine[] = "_is_coroutine";
 static const char __pyx_k_module_class[] = "module_class";
 static const char __pyx_k_string_types[] = "string_types";
-static const char __pyx_k_stringsource[] = "<stringsource>";
 static const char __pyx_k_ObjectGeneric[] = "ObjectGeneric";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_reg_extension[] = "_reg_extension";
-static const char __pyx_k_AssertionError[] = "AssertionError";
 static const char __pyx_k_AttributeError[] = "AttributeError";
 static const char __pyx_k_CLASS_FUNCTION[] = "_CLASS_FUNCTION";
 static const char __pyx_k_DGLArrayHandle[] = "DGLArrayHandle";
 static const char __pyx_k_memmove_failed[] = "memmove failed";
 static const char __pyx_k_object_generic[] = "object_generic";
 static const char __pyx_k_runtime_ctypes[] = "runtime_ctypes";
 static const char __pyx_k_register_object[] = "_register_object";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_CTypesDGLContext[] = "CTypesDGLContext";
 static const char __pyx_k_PyDGLArrayHandle[] = "PyDGLArrayHandle";
 static const char __pyx_k_set_class_module[] = "_set_class_module";
 static const char __pyx_k_CTypesDGLDataType[] = "CTypesDGLDataType";
 static const char __pyx_k_convert_to_object[] = "convert_to_object";
 static const char __pyx_k_set_class_ndarray[] = "_set_class_ndarray";
-static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_dgl__ffi__cy3_core[] = "dgl._ffi._cy3.core";
 static const char __pyx_k_set_class_function[] = "_set_class_function";
 static const char __pyx_k_convert_to_dgl_func[] = "convert_to_dgl_func";
-static const char __pyx_k_NDArrayBase_to_dlpack[] = "NDArrayBase.to_dlpack";
 static const char __pyx_k_Unhandled_type_code_d[] = "Unhandled type code %d";
 static const char __pyx_k_set_class_object_base[] = "_set_class_object_base";
 static const char __pyx_k_object_has_no_attribute[] = "' object has no attribute '";
-static const char __pyx_k_ObjectBase___reduce_cython[] = "ObjectBase.__reduce_cython__";
-static const char __pyx_k_init_handle_by_constructor[] = "__init_handle_by_constructor__";
-static const char __pyx_k_NDArrayBase___reduce_cython[] = "NDArrayBase.__reduce_cython__";
 static const char __pyx_k_dgl__ffi__cython_object_pxi[] = "dgl/_ffi/_cython/./object.pxi";
-static const char __pyx_k_FunctionBase___reduce_cython[] = "FunctionBase.__reduce_cython__";
-static const char __pyx_k_ObjectBase___setstate_cython[] = "ObjectBase.__setstate_cython__";
 static const char __pyx_k_dgl__ffi__cython_ndarray_pxi[] = "dgl/_ffi/_cython/./ndarray.pxi";
-static const char __pyx_k_NDArrayBase___setstate_cython[] = "NDArrayBase.__setstate_cython__";
 static const char __pyx_k_dgl__ffi__cython_function_pxi[] = "dgl/_ffi/_cython/./function.pxi";
-static const char __pyx_k_FunctionBase___setstate_cython[] = "FunctionBase.__setstate_cython__";
 static const char __pyx_k_Don_t_know_how_to_handle_type_s[] = "Don't know how to handle type %s";
 static const char __pyx_k_PackedFunction_can_only_support[] = "PackedFunction can only support one return value";
 static const char __pyx_k_Expect_a_dltensor_field_pycapsul[] = "Expect a dltensor field, pycapsule.PyCapsule can only be consumed once";
-static const char __pyx_k_ObjectBase___init_handle_by_cons[] = "ObjectBase.__init_handle_by_constructor__";
 static const char __pyx_k_self_chandle_cannot_be_converted[] = "self.chandle cannot be converted to a Python object for pickling";
 static const char __pyx_k_to_dlpack_do_not_work_with_memor[] = "to_dlpack do not work with memory views";
-/* #### Code section: decls ### */
+static PyObject *__pyx_kp_u_;
+static PyObject *__pyx_n_s_AttributeError;
+static PyObject *__pyx_n_s_CLASS_FUNCTION;
+static PyObject *__pyx_n_s_CLASS_MODULE;
+static PyObject *__pyx_n_s_CTypesDGLContext;
+static PyObject *__pyx_n_s_CTypesDGLDataType;
+static PyObject *__pyx_n_s_DGLArrayHandle;
+static PyObject *__pyx_n_s_DGLByteArray;
+static PyObject *__pyx_n_s_DGLContext;
+static PyObject *__pyx_n_s_DGLDataType;
+static PyObject *__pyx_n_s_DGLError;
+static PyObject *__pyx_kp_u_Don_t_know_how_to_handle_type_s;
+static PyObject *__pyx_kp_u_Expect_a_dltensor_field_pycapsul;
+static PyObject *__pyx_n_s_FunctionBase;
+static PyObject *__pyx_n_s_Integral;
+static PyObject *__pyx_n_s_NDArrayBase;
+static PyObject *__pyx_n_s_Number;
+static PyObject *__pyx_n_s_OBJECT_TYPE;
+static PyObject *__pyx_n_s_ObjectBase;
+static PyObject *__pyx_n_s_ObjectGeneric;
+static PyObject *__pyx_n_s_POINTER;
+static PyObject *__pyx_kp_u_PackedFunction_can_only_support;
+static PyObject *__pyx_n_s_PyDGLArrayHandle;
+static PyObject *__pyx_n_s_RuntimeError;
+static PyObject *__pyx_n_s_TypeError;
+static PyObject *__pyx_kp_u_Unhandled_type_code_d;
+static PyObject *__pyx_n_s_ValueError;
+static PyObject *__pyx_n_s__13;
+static PyObject *__pyx_n_s_addressof;
+static PyObject *__pyx_n_s_alignment;
+static PyObject *__pyx_n_s_api_internal;
+static PyObject *__pyx_n_s_append;
+static PyObject *__pyx_n_s_base;
+static PyObject *__pyx_n_s_c_byte;
+static PyObject *__pyx_n_s_c_is_global;
+static PyObject *__pyx_n_s_c_void_p;
+static PyObject *__pyx_n_s_cast;
+static PyObject *__pyx_n_s_chandle;
+static PyObject *__pyx_n_s_class;
+static PyObject *__pyx_n_s_cline_in_traceback;
+static PyObject *__pyx_n_s_cls;
+static PyObject *__pyx_n_s_convert_to_dgl_func;
+static PyObject *__pyx_n_s_convert_to_object;
+static PyObject *__pyx_n_s_ctypes;
+static PyObject *__pyx_n_s_data;
+static PyObject *__pyx_n_s_dgl__ffi__cy3_core;
+static PyObject *__pyx_kp_s_dgl__ffi__cython_function_pxi;
+static PyObject *__pyx_kp_s_dgl__ffi__cython_ndarray_pxi;
+static PyObject *__pyx_kp_s_dgl__ffi__cython_object_pxi;
+static PyObject *__pyx_n_s_dgl_handle;
+static PyObject *__pyx_n_s_dgl_tcode;
+static PyObject *__pyx_n_s_dltensor;
+static PyObject *__pyx_n_s_encode;
+static PyObject *__pyx_n_s_fconstructor;
+static PyObject *__pyx_n_s_fcreate;
+static PyObject *__pyx_n_s_format_exc;
+static PyObject *__pyx_n_s_from_buffer;
+static PyObject *__pyx_n_s_from_dlpack;
+static PyObject *__pyx_n_s_func_class;
+static PyObject *__pyx_n_s_getstate;
+static PyObject *__pyx_n_s_handle;
+static PyObject *__pyx_n_s_import;
+static PyObject *__pyx_n_s_index;
+static PyObject *__pyx_n_s_is_global;
+static PyObject *__pyx_n_s_is_view;
+static PyObject *__pyx_n_s_main;
+static PyObject *__pyx_n_s_make_array;
+static PyObject *__pyx_n_s_memmove;
+static PyObject *__pyx_kp_u_memmove_failed;
+static PyObject *__pyx_n_s_module_class;
+static PyObject *__pyx_n_s_name;
+static PyObject *__pyx_n_s_new;
+static PyObject *__pyx_n_s_numbers;
+static PyObject *__pyx_n_s_object_generic;
+static PyObject *__pyx_kp_u_object_has_no_attribute;
+static PyObject *__pyx_n_s_ptr;
+static PyObject *__pyx_n_s_pyfunc;
+static PyObject *__pyx_n_s_pyx_vtable;
+static PyObject *__pyx_n_s_range;
+static PyObject *__pyx_n_s_reduce;
+static PyObject *__pyx_n_s_reduce_cython;
+static PyObject *__pyx_n_s_reduce_ex;
+static PyObject *__pyx_n_s_reg_extension;
+static PyObject *__pyx_n_s_register_object;
+static PyObject *__pyx_n_s_ret;
+static PyObject *__pyx_n_s_runtime_ctypes;
+static PyObject *__pyx_kp_s_self_chandle_cannot_be_converted;
+static PyObject *__pyx_n_s_set_class_function;
+static PyObject *__pyx_n_s_set_class_module;
+static PyObject *__pyx_n_s_set_class_ndarray;
+static PyObject *__pyx_n_s_set_class_object_base;
+static PyObject *__pyx_n_s_setstate;
+static PyObject *__pyx_n_s_setstate_cython;
+static PyObject *__pyx_n_s_size;
+static PyObject *__pyx_n_s_string_types;
+static PyObject *__pyx_n_s_test;
+static PyObject *__pyx_kp_u_to_dlpack_do_not_work_with_memor;
+static PyObject *__pyx_n_s_traceback;
+static PyObject *__pyx_kp_u_utf_8;
+static PyObject *__pyx_n_s_value;
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core__register_object(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_index, PyObject *__pyx_v_cls); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle___get__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self); /* proto */
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_2__set__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
 static void __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase___dealloc__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_2__getattr__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_name); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_fconstructor, PyObject *__pyx_v_args); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self); /* proto */
@@ -2942,1332 +2065,81 @@
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10_reg_extension(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_fcreate); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_12_make_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_handle, PyObject *__pyx_v_is_view); /* proto */
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_14_set_class_ndarray(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls); /* proto */
 static PyObject *__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_ObjectBase(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_FunctionBase(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_NDArrayBase(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-/* #### Code section: late_includes ### */
-/* #### Code section: module_state ### */
-typedef struct {
-  PyObject *__pyx_d;
-  PyObject *__pyx_b;
-  PyObject *__pyx_cython_runtime;
-  PyObject *__pyx_empty_tuple;
-  PyObject *__pyx_empty_bytes;
-  PyObject *__pyx_empty_unicode;
-  #ifdef __Pyx_CyFunction_USED
-  PyTypeObject *__pyx_CyFunctionType;
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  PyTypeObject *__pyx_FusedFunctionType;
-  #endif
-  #ifdef __Pyx_Generator_USED
-  PyTypeObject *__pyx_GeneratorType;
-  #endif
-  #ifdef __Pyx_IterableCoroutine_USED
-  PyTypeObject *__pyx_IterableCoroutineType;
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  PyTypeObject *__pyx_CoroutineAwaitType;
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  PyTypeObject *__pyx_CoroutineType;
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  PyTypeObject *__pyx_ptype_7cpython_4type_type;
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  PyTypeObject *__pyx_ptype_7cpython_4bool_bool;
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  PyTypeObject *__pyx_ptype_7cpython_7complex_complex;
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  PyObject *__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase;
-  PyObject *__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase;
-  PyObject *__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
-  #endif
-  PyTypeObject *__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase;
-  PyTypeObject *__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase;
-  PyTypeObject *__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
-  PyObject *__pyx_kp_u_;
-  PyObject *__pyx_n_s_AssertionError;
-  PyObject *__pyx_n_s_AttributeError;
-  PyObject *__pyx_n_s_CLASS_FUNCTION;
-  PyObject *__pyx_n_s_CLASS_MODULE;
-  PyObject *__pyx_n_s_CTypesDGLContext;
-  PyObject *__pyx_n_s_CTypesDGLDataType;
-  PyObject *__pyx_n_s_DGLArrayHandle;
-  PyObject *__pyx_n_s_DGLByteArray;
-  PyObject *__pyx_n_s_DGLContext;
-  PyObject *__pyx_n_s_DGLDataType;
-  PyObject *__pyx_n_s_DGLError;
-  PyObject *__pyx_kp_u_Don_t_know_how_to_handle_type_s;
-  PyObject *__pyx_kp_u_Expect_a_dltensor_field_pycapsul;
-  PyObject *__pyx_n_s_FunctionBase;
-  PyObject *__pyx_n_s_FunctionBase___reduce_cython;
-  PyObject *__pyx_n_s_FunctionBase___setstate_cython;
-  PyObject *__pyx_n_s_Integral;
-  PyObject *__pyx_n_s_NDArrayBase;
-  PyObject *__pyx_n_s_NDArrayBase___reduce_cython;
-  PyObject *__pyx_n_s_NDArrayBase___setstate_cython;
-  PyObject *__pyx_n_s_NDArrayBase_to_dlpack;
-  PyObject *__pyx_n_s_Number;
-  PyObject *__pyx_n_s_OBJECT_TYPE;
-  PyObject *__pyx_n_s_ObjectBase;
-  PyObject *__pyx_n_s_ObjectBase___init_handle_by_cons;
-  PyObject *__pyx_n_s_ObjectBase___reduce_cython;
-  PyObject *__pyx_n_s_ObjectBase___setstate_cython;
-  PyObject *__pyx_n_s_ObjectGeneric;
-  PyObject *__pyx_n_s_POINTER;
-  PyObject *__pyx_kp_u_PackedFunction_can_only_support;
-  PyObject *__pyx_n_s_PyDGLArrayHandle;
-  PyObject *__pyx_n_s_RuntimeError;
-  PyObject *__pyx_n_s_TypeError;
-  PyObject *__pyx_kp_u_Unhandled_type_code_d;
-  PyObject *__pyx_n_s_ValueError;
-  PyObject *__pyx_n_s__39;
-  PyObject *__pyx_kp_u__7;
-  PyObject *__pyx_n_s__8;
-  PyObject *__pyx_n_s__9;
-  PyObject *__pyx_n_s_addressof;
-  PyObject *__pyx_n_s_alignment;
-  PyObject *__pyx_n_s_api_internal;
-  PyObject *__pyx_n_s_append;
-  PyObject *__pyx_n_s_args;
-  PyObject *__pyx_n_s_asyncio_coroutines;
-  PyObject *__pyx_n_s_base;
-  PyObject *__pyx_n_s_c_byte;
-  PyObject *__pyx_n_s_c_is_global;
-  PyObject *__pyx_n_s_c_void_p;
-  PyObject *__pyx_n_s_cast;
-  PyObject *__pyx_n_s_chandle;
-  PyObject *__pyx_n_s_class;
-  PyObject *__pyx_n_s_cline_in_traceback;
-  PyObject *__pyx_n_s_cls;
-  PyObject *__pyx_n_s_convert_to_dgl_func;
-  PyObject *__pyx_n_s_convert_to_object;
-  PyObject *__pyx_n_s_ctypes;
-  PyObject *__pyx_n_s_data;
-  PyObject *__pyx_n_s_dgl__ffi__cy3_core;
-  PyObject *__pyx_kp_s_dgl__ffi__cython_function_pxi;
-  PyObject *__pyx_kp_s_dgl__ffi__cython_ndarray_pxi;
-  PyObject *__pyx_kp_s_dgl__ffi__cython_object_pxi;
-  PyObject *__pyx_n_s_dgl_handle;
-  PyObject *__pyx_n_s_dgl_tcode;
-  PyObject *__pyx_kp_u_disable;
-  PyObject *__pyx_n_s_dltensor;
-  PyObject *__pyx_kp_u_enable;
-  PyObject *__pyx_n_s_encode;
-  PyObject *__pyx_n_s_fconstructor;
-  PyObject *__pyx_n_s_fcreate;
-  PyObject *__pyx_n_s_format_exc;
-  PyObject *__pyx_n_s_from_buffer;
-  PyObject *__pyx_n_s_from_dlpack;
-  PyObject *__pyx_n_s_func_class;
-  PyObject *__pyx_kp_u_gc;
-  PyObject *__pyx_n_s_getstate;
-  PyObject *__pyx_n_s_handle;
-  PyObject *__pyx_n_s_import;
-  PyObject *__pyx_n_s_index;
-  PyObject *__pyx_n_s_init_handle_by_constructor;
-  PyObject *__pyx_n_s_initializing;
-  PyObject *__pyx_n_s_is_coroutine;
-  PyObject *__pyx_n_s_is_global;
-  PyObject *__pyx_n_s_is_view;
-  PyObject *__pyx_kp_u_isenabled;
-  PyObject *__pyx_n_s_main;
-  PyObject *__pyx_n_s_make_array;
-  PyObject *__pyx_n_s_memmove;
-  PyObject *__pyx_kp_u_memmove_failed;
-  PyObject *__pyx_n_s_module_class;
-  PyObject *__pyx_n_s_name;
-  PyObject *__pyx_n_s_new;
-  PyObject *__pyx_n_s_numbers;
-  PyObject *__pyx_n_s_object_generic;
-  PyObject *__pyx_kp_u_object_has_no_attribute;
-  PyObject *__pyx_n_s_ptr;
-  PyObject *__pyx_n_s_pyfunc;
-  PyObject *__pyx_n_s_pyx_state;
-  PyObject *__pyx_n_s_pyx_vtable;
-  PyObject *__pyx_n_s_range;
-  PyObject *__pyx_n_s_reduce;
-  PyObject *__pyx_n_s_reduce_cython;
-  PyObject *__pyx_n_s_reduce_ex;
-  PyObject *__pyx_n_s_reg_extension;
-  PyObject *__pyx_n_s_register_object;
-  PyObject *__pyx_n_s_ret;
-  PyObject *__pyx_n_s_runtime_ctypes;
-  PyObject *__pyx_n_s_self;
-  PyObject *__pyx_kp_s_self_chandle_cannot_be_converted;
-  PyObject *__pyx_n_s_set_class_function;
-  PyObject *__pyx_n_s_set_class_module;
-  PyObject *__pyx_n_s_set_class_ndarray;
-  PyObject *__pyx_n_s_set_class_object_base;
-  PyObject *__pyx_n_s_setstate;
-  PyObject *__pyx_n_s_setstate_cython;
-  PyObject *__pyx_n_s_size;
-  PyObject *__pyx_n_s_spec;
-  PyObject *__pyx_n_s_string_types;
-  PyObject *__pyx_kp_s_stringsource;
-  PyObject *__pyx_n_s_test;
-  PyObject *__pyx_n_s_to_dlpack;
-  PyObject *__pyx_kp_u_to_dlpack_do_not_work_with_memor;
-  PyObject *__pyx_n_s_traceback;
-  PyObject *__pyx_kp_u_utf_8;
-  PyObject *__pyx_n_s_value;
-  PyObject *__pyx_int_0;
-  PyObject *__pyx_tuple__2;
-  PyObject *__pyx_tuple__3;
-  PyObject *__pyx_tuple__4;
-  PyObject *__pyx_tuple__5;
-  PyObject *__pyx_tuple__6;
-  PyObject *__pyx_tuple__10;
-  PyObject *__pyx_tuple__12;
-  PyObject *__pyx_tuple__14;
-  PyObject *__pyx_tuple__16;
-  PyObject *__pyx_tuple__18;
-  PyObject *__pyx_tuple__22;
-  PyObject *__pyx_tuple__24;
-  PyObject *__pyx_tuple__26;
-  PyObject *__pyx_tuple__28;
-  PyObject *__pyx_tuple__30;
-  PyObject *__pyx_tuple__33;
-  PyObject *__pyx_tuple__35;
-  PyObject *__pyx_tuple__37;
-  PyObject *__pyx_codeobj__11;
-  PyObject *__pyx_codeobj__13;
-  PyObject *__pyx_codeobj__15;
-  PyObject *__pyx_codeobj__17;
-  PyObject *__pyx_codeobj__19;
-  PyObject *__pyx_codeobj__20;
-  PyObject *__pyx_codeobj__21;
-  PyObject *__pyx_codeobj__23;
-  PyObject *__pyx_codeobj__25;
-  PyObject *__pyx_codeobj__27;
-  PyObject *__pyx_codeobj__29;
-  PyObject *__pyx_codeobj__31;
-  PyObject *__pyx_codeobj__32;
-  PyObject *__pyx_codeobj__34;
-  PyObject *__pyx_codeobj__36;
-  PyObject *__pyx_codeobj__38;
-} __pyx_mstate;
-
-#if CYTHON_USE_MODULE_STATE
-#ifdef __cplusplus
-namespace {
-  extern struct PyModuleDef __pyx_moduledef;
-} /* anonymous namespace */
-#else
-static struct PyModuleDef __pyx_moduledef;
-#endif
-
-#define __pyx_mstate(o) ((__pyx_mstate *)__Pyx_PyModule_GetState(o))
-
-#define __pyx_mstate_global (__pyx_mstate(PyState_FindModule(&__pyx_moduledef)))
-
-#define __pyx_m (PyState_FindModule(&__pyx_moduledef))
-#else
-static __pyx_mstate __pyx_mstate_global_static =
-#ifdef __cplusplus
-    {};
-#else
-    {0};
-#endif
-static __pyx_mstate *__pyx_mstate_global = &__pyx_mstate_global_static;
-#endif
-/* #### Code section: module_state_clear ### */
-#if CYTHON_USE_MODULE_STATE
-static int __pyx_m_clear(PyObject *m) {
-  __pyx_mstate *clear_module_state = __pyx_mstate(m);
-  if (!clear_module_state) return 0;
-  Py_CLEAR(clear_module_state->__pyx_d);
-  Py_CLEAR(clear_module_state->__pyx_b);
-  Py_CLEAR(clear_module_state->__pyx_cython_runtime);
-  Py_CLEAR(clear_module_state->__pyx_empty_tuple);
-  Py_CLEAR(clear_module_state->__pyx_empty_bytes);
-  Py_CLEAR(clear_module_state->__pyx_empty_unicode);
-  #ifdef __Pyx_CyFunction_USED
-  Py_CLEAR(clear_module_state->__pyx_CyFunctionType);
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  Py_CLEAR(clear_module_state->__pyx_FusedFunctionType);
-  #endif
-  Py_CLEAR(clear_module_state->__pyx_ptype_7cpython_4type_type);
-  Py_CLEAR(clear_module_state->__pyx_ptype_7cpython_4bool_bool);
-  Py_CLEAR(clear_module_state->__pyx_ptype_7cpython_7complex_complex);
-  Py_CLEAR(clear_module_state->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase);
-  Py_CLEAR(clear_module_state->__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase);
-  Py_CLEAR(clear_module_state->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase);
-  Py_CLEAR(clear_module_state->__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase);
-  Py_CLEAR(clear_module_state->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase);
-  Py_CLEAR(clear_module_state->__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_);
-  Py_CLEAR(clear_module_state->__pyx_n_s_AssertionError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_AttributeError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_CLASS_FUNCTION);
-  Py_CLEAR(clear_module_state->__pyx_n_s_CLASS_MODULE);
-  Py_CLEAR(clear_module_state->__pyx_n_s_CTypesDGLContext);
-  Py_CLEAR(clear_module_state->__pyx_n_s_CTypesDGLDataType);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DGLArrayHandle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DGLByteArray);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DGLContext);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DGLDataType);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DGLError);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Don_t_know_how_to_handle_type_s);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Expect_a_dltensor_field_pycapsul);
-  Py_CLEAR(clear_module_state->__pyx_n_s_FunctionBase);
-  Py_CLEAR(clear_module_state->__pyx_n_s_FunctionBase___reduce_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_FunctionBase___setstate_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Integral);
-  Py_CLEAR(clear_module_state->__pyx_n_s_NDArrayBase);
-  Py_CLEAR(clear_module_state->__pyx_n_s_NDArrayBase___reduce_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_NDArrayBase___setstate_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_NDArrayBase_to_dlpack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Number);
-  Py_CLEAR(clear_module_state->__pyx_n_s_OBJECT_TYPE);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ObjectBase);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ObjectBase___init_handle_by_cons);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ObjectBase___reduce_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ObjectBase___setstate_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ObjectGeneric);
-  Py_CLEAR(clear_module_state->__pyx_n_s_POINTER);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_PackedFunction_can_only_support);
-  Py_CLEAR(clear_module_state->__pyx_n_s_PyDGLArrayHandle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_RuntimeError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_TypeError);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Unhandled_type_code_d);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ValueError);
-  Py_CLEAR(clear_module_state->__pyx_n_s__39);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__7);
-  Py_CLEAR(clear_module_state->__pyx_n_s__8);
-  Py_CLEAR(clear_module_state->__pyx_n_s__9);
-  Py_CLEAR(clear_module_state->__pyx_n_s_addressof);
-  Py_CLEAR(clear_module_state->__pyx_n_s_alignment);
-  Py_CLEAR(clear_module_state->__pyx_n_s_api_internal);
-  Py_CLEAR(clear_module_state->__pyx_n_s_append);
-  Py_CLEAR(clear_module_state->__pyx_n_s_args);
-  Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
-  Py_CLEAR(clear_module_state->__pyx_n_s_base);
-  Py_CLEAR(clear_module_state->__pyx_n_s_c_byte);
-  Py_CLEAR(clear_module_state->__pyx_n_s_c_is_global);
-  Py_CLEAR(clear_module_state->__pyx_n_s_c_void_p);
-  Py_CLEAR(clear_module_state->__pyx_n_s_cast);
-  Py_CLEAR(clear_module_state->__pyx_n_s_chandle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_class);
-  Py_CLEAR(clear_module_state->__pyx_n_s_cline_in_traceback);
-  Py_CLEAR(clear_module_state->__pyx_n_s_cls);
-  Py_CLEAR(clear_module_state->__pyx_n_s_convert_to_dgl_func);
-  Py_CLEAR(clear_module_state->__pyx_n_s_convert_to_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ctypes);
-  Py_CLEAR(clear_module_state->__pyx_n_s_data);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dgl__ffi__cy3_core);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_dgl__ffi__cython_function_pxi);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_dgl__ffi__cython_ndarray_pxi);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_dgl__ffi__cython_object_pxi);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dgl_handle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dgl_tcode);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_disable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dltensor);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_enable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_encode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_fconstructor);
-  Py_CLEAR(clear_module_state->__pyx_n_s_fcreate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_format_exc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_from_buffer);
-  Py_CLEAR(clear_module_state->__pyx_n_s_from_dlpack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_func_class);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_gc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_getstate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_handle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_import);
-  Py_CLEAR(clear_module_state->__pyx_n_s_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_init_handle_by_constructor);
-  Py_CLEAR(clear_module_state->__pyx_n_s_initializing);
-  Py_CLEAR(clear_module_state->__pyx_n_s_is_coroutine);
-  Py_CLEAR(clear_module_state->__pyx_n_s_is_global);
-  Py_CLEAR(clear_module_state->__pyx_n_s_is_view);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_isenabled);
-  Py_CLEAR(clear_module_state->__pyx_n_s_main);
-  Py_CLEAR(clear_module_state->__pyx_n_s_make_array);
-  Py_CLEAR(clear_module_state->__pyx_n_s_memmove);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_memmove_failed);
-  Py_CLEAR(clear_module_state->__pyx_n_s_module_class);
-  Py_CLEAR(clear_module_state->__pyx_n_s_name);
-  Py_CLEAR(clear_module_state->__pyx_n_s_new);
-  Py_CLEAR(clear_module_state->__pyx_n_s_numbers);
-  Py_CLEAR(clear_module_state->__pyx_n_s_object_generic);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_object_has_no_attribute);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ptr);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyfunc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_state);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_vtable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_range);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce_ex);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reg_extension);
-  Py_CLEAR(clear_module_state->__pyx_n_s_register_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ret);
-  Py_CLEAR(clear_module_state->__pyx_n_s_runtime_ctypes);
-  Py_CLEAR(clear_module_state->__pyx_n_s_self);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_self_chandle_cannot_be_converted);
-  Py_CLEAR(clear_module_state->__pyx_n_s_set_class_function);
-  Py_CLEAR(clear_module_state->__pyx_n_s_set_class_module);
-  Py_CLEAR(clear_module_state->__pyx_n_s_set_class_ndarray);
-  Py_CLEAR(clear_module_state->__pyx_n_s_set_class_object_base);
-  Py_CLEAR(clear_module_state->__pyx_n_s_setstate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_setstate_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_size);
-  Py_CLEAR(clear_module_state->__pyx_n_s_spec);
-  Py_CLEAR(clear_module_state->__pyx_n_s_string_types);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_stringsource);
-  Py_CLEAR(clear_module_state->__pyx_n_s_test);
-  Py_CLEAR(clear_module_state->__pyx_n_s_to_dlpack);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_to_dlpack_do_not_work_with_memor);
-  Py_CLEAR(clear_module_state->__pyx_n_s_traceback);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_utf_8);
-  Py_CLEAR(clear_module_state->__pyx_n_s_value);
-  Py_CLEAR(clear_module_state->__pyx_int_0);
-  Py_CLEAR(clear_module_state->__pyx_tuple__2);
-  Py_CLEAR(clear_module_state->__pyx_tuple__3);
-  Py_CLEAR(clear_module_state->__pyx_tuple__4);
-  Py_CLEAR(clear_module_state->__pyx_tuple__5);
-  Py_CLEAR(clear_module_state->__pyx_tuple__6);
-  Py_CLEAR(clear_module_state->__pyx_tuple__10);
-  Py_CLEAR(clear_module_state->__pyx_tuple__12);
-  Py_CLEAR(clear_module_state->__pyx_tuple__14);
-  Py_CLEAR(clear_module_state->__pyx_tuple__16);
-  Py_CLEAR(clear_module_state->__pyx_tuple__18);
-  Py_CLEAR(clear_module_state->__pyx_tuple__22);
-  Py_CLEAR(clear_module_state->__pyx_tuple__24);
-  Py_CLEAR(clear_module_state->__pyx_tuple__26);
-  Py_CLEAR(clear_module_state->__pyx_tuple__28);
-  Py_CLEAR(clear_module_state->__pyx_tuple__30);
-  Py_CLEAR(clear_module_state->__pyx_tuple__33);
-  Py_CLEAR(clear_module_state->__pyx_tuple__35);
-  Py_CLEAR(clear_module_state->__pyx_tuple__37);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__11);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__13);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__15);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__17);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__19);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__20);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__21);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__23);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__25);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__27);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__29);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__31);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__32);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__34);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__36);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__38);
-  return 0;
-}
-#endif
-/* #### Code section: module_state_traverse ### */
-#if CYTHON_USE_MODULE_STATE
-static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
-  __pyx_mstate *traverse_module_state = __pyx_mstate(m);
-  if (!traverse_module_state) return 0;
-  Py_VISIT(traverse_module_state->__pyx_d);
-  Py_VISIT(traverse_module_state->__pyx_b);
-  Py_VISIT(traverse_module_state->__pyx_cython_runtime);
-  Py_VISIT(traverse_module_state->__pyx_empty_tuple);
-  Py_VISIT(traverse_module_state->__pyx_empty_bytes);
-  Py_VISIT(traverse_module_state->__pyx_empty_unicode);
-  #ifdef __Pyx_CyFunction_USED
-  Py_VISIT(traverse_module_state->__pyx_CyFunctionType);
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  Py_VISIT(traverse_module_state->__pyx_FusedFunctionType);
-  #endif
-  Py_VISIT(traverse_module_state->__pyx_ptype_7cpython_4type_type);
-  Py_VISIT(traverse_module_state->__pyx_ptype_7cpython_4bool_bool);
-  Py_VISIT(traverse_module_state->__pyx_ptype_7cpython_7complex_complex);
-  Py_VISIT(traverse_module_state->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase);
-  Py_VISIT(traverse_module_state->__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase);
-  Py_VISIT(traverse_module_state->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase);
-  Py_VISIT(traverse_module_state->__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase);
-  Py_VISIT(traverse_module_state->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase);
-  Py_VISIT(traverse_module_state->__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_);
-  Py_VISIT(traverse_module_state->__pyx_n_s_AssertionError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_AttributeError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_CLASS_FUNCTION);
-  Py_VISIT(traverse_module_state->__pyx_n_s_CLASS_MODULE);
-  Py_VISIT(traverse_module_state->__pyx_n_s_CTypesDGLContext);
-  Py_VISIT(traverse_module_state->__pyx_n_s_CTypesDGLDataType);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DGLArrayHandle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DGLByteArray);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DGLContext);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DGLDataType);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DGLError);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Don_t_know_how_to_handle_type_s);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Expect_a_dltensor_field_pycapsul);
-  Py_VISIT(traverse_module_state->__pyx_n_s_FunctionBase);
-  Py_VISIT(traverse_module_state->__pyx_n_s_FunctionBase___reduce_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_FunctionBase___setstate_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Integral);
-  Py_VISIT(traverse_module_state->__pyx_n_s_NDArrayBase);
-  Py_VISIT(traverse_module_state->__pyx_n_s_NDArrayBase___reduce_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_NDArrayBase___setstate_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_NDArrayBase_to_dlpack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Number);
-  Py_VISIT(traverse_module_state->__pyx_n_s_OBJECT_TYPE);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ObjectBase);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ObjectBase___init_handle_by_cons);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ObjectBase___reduce_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ObjectBase___setstate_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ObjectGeneric);
-  Py_VISIT(traverse_module_state->__pyx_n_s_POINTER);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_PackedFunction_can_only_support);
-  Py_VISIT(traverse_module_state->__pyx_n_s_PyDGLArrayHandle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_RuntimeError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_TypeError);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Unhandled_type_code_d);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ValueError);
-  Py_VISIT(traverse_module_state->__pyx_n_s__39);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__7);
-  Py_VISIT(traverse_module_state->__pyx_n_s__8);
-  Py_VISIT(traverse_module_state->__pyx_n_s__9);
-  Py_VISIT(traverse_module_state->__pyx_n_s_addressof);
-  Py_VISIT(traverse_module_state->__pyx_n_s_alignment);
-  Py_VISIT(traverse_module_state->__pyx_n_s_api_internal);
-  Py_VISIT(traverse_module_state->__pyx_n_s_append);
-  Py_VISIT(traverse_module_state->__pyx_n_s_args);
-  Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
-  Py_VISIT(traverse_module_state->__pyx_n_s_base);
-  Py_VISIT(traverse_module_state->__pyx_n_s_c_byte);
-  Py_VISIT(traverse_module_state->__pyx_n_s_c_is_global);
-  Py_VISIT(traverse_module_state->__pyx_n_s_c_void_p);
-  Py_VISIT(traverse_module_state->__pyx_n_s_cast);
-  Py_VISIT(traverse_module_state->__pyx_n_s_chandle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_class);
-  Py_VISIT(traverse_module_state->__pyx_n_s_cline_in_traceback);
-  Py_VISIT(traverse_module_state->__pyx_n_s_cls);
-  Py_VISIT(traverse_module_state->__pyx_n_s_convert_to_dgl_func);
-  Py_VISIT(traverse_module_state->__pyx_n_s_convert_to_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ctypes);
-  Py_VISIT(traverse_module_state->__pyx_n_s_data);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dgl__ffi__cy3_core);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_dgl__ffi__cython_function_pxi);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_dgl__ffi__cython_ndarray_pxi);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_dgl__ffi__cython_object_pxi);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dgl_handle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dgl_tcode);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_disable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dltensor);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_enable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_encode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_fconstructor);
-  Py_VISIT(traverse_module_state->__pyx_n_s_fcreate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_format_exc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_from_buffer);
-  Py_VISIT(traverse_module_state->__pyx_n_s_from_dlpack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_func_class);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_gc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_getstate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_handle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_import);
-  Py_VISIT(traverse_module_state->__pyx_n_s_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_init_handle_by_constructor);
-  Py_VISIT(traverse_module_state->__pyx_n_s_initializing);
-  Py_VISIT(traverse_module_state->__pyx_n_s_is_coroutine);
-  Py_VISIT(traverse_module_state->__pyx_n_s_is_global);
-  Py_VISIT(traverse_module_state->__pyx_n_s_is_view);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_isenabled);
-  Py_VISIT(traverse_module_state->__pyx_n_s_main);
-  Py_VISIT(traverse_module_state->__pyx_n_s_make_array);
-  Py_VISIT(traverse_module_state->__pyx_n_s_memmove);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_memmove_failed);
-  Py_VISIT(traverse_module_state->__pyx_n_s_module_class);
-  Py_VISIT(traverse_module_state->__pyx_n_s_name);
-  Py_VISIT(traverse_module_state->__pyx_n_s_new);
-  Py_VISIT(traverse_module_state->__pyx_n_s_numbers);
-  Py_VISIT(traverse_module_state->__pyx_n_s_object_generic);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_object_has_no_attribute);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ptr);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyfunc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_state);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_vtable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_range);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce_ex);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reg_extension);
-  Py_VISIT(traverse_module_state->__pyx_n_s_register_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ret);
-  Py_VISIT(traverse_module_state->__pyx_n_s_runtime_ctypes);
-  Py_VISIT(traverse_module_state->__pyx_n_s_self);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_self_chandle_cannot_be_converted);
-  Py_VISIT(traverse_module_state->__pyx_n_s_set_class_function);
-  Py_VISIT(traverse_module_state->__pyx_n_s_set_class_module);
-  Py_VISIT(traverse_module_state->__pyx_n_s_set_class_ndarray);
-  Py_VISIT(traverse_module_state->__pyx_n_s_set_class_object_base);
-  Py_VISIT(traverse_module_state->__pyx_n_s_setstate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_setstate_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_size);
-  Py_VISIT(traverse_module_state->__pyx_n_s_spec);
-  Py_VISIT(traverse_module_state->__pyx_n_s_string_types);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_stringsource);
-  Py_VISIT(traverse_module_state->__pyx_n_s_test);
-  Py_VISIT(traverse_module_state->__pyx_n_s_to_dlpack);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_to_dlpack_do_not_work_with_memor);
-  Py_VISIT(traverse_module_state->__pyx_n_s_traceback);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_utf_8);
-  Py_VISIT(traverse_module_state->__pyx_n_s_value);
-  Py_VISIT(traverse_module_state->__pyx_int_0);
-  Py_VISIT(traverse_module_state->__pyx_tuple__2);
-  Py_VISIT(traverse_module_state->__pyx_tuple__3);
-  Py_VISIT(traverse_module_state->__pyx_tuple__4);
-  Py_VISIT(traverse_module_state->__pyx_tuple__5);
-  Py_VISIT(traverse_module_state->__pyx_tuple__6);
-  Py_VISIT(traverse_module_state->__pyx_tuple__10);
-  Py_VISIT(traverse_module_state->__pyx_tuple__12);
-  Py_VISIT(traverse_module_state->__pyx_tuple__14);
-  Py_VISIT(traverse_module_state->__pyx_tuple__16);
-  Py_VISIT(traverse_module_state->__pyx_tuple__18);
-  Py_VISIT(traverse_module_state->__pyx_tuple__22);
-  Py_VISIT(traverse_module_state->__pyx_tuple__24);
-  Py_VISIT(traverse_module_state->__pyx_tuple__26);
-  Py_VISIT(traverse_module_state->__pyx_tuple__28);
-  Py_VISIT(traverse_module_state->__pyx_tuple__30);
-  Py_VISIT(traverse_module_state->__pyx_tuple__33);
-  Py_VISIT(traverse_module_state->__pyx_tuple__35);
-  Py_VISIT(traverse_module_state->__pyx_tuple__37);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__11);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__13);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__15);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__17);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__19);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__20);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__21);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__23);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__25);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__27);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__29);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__31);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__32);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__34);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__36);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__38);
-  return 0;
-}
-#endif
-/* #### Code section: module_state_defines ### */
-#define __pyx_d __pyx_mstate_global->__pyx_d
-#define __pyx_b __pyx_mstate_global->__pyx_b
-#define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
-#define __pyx_empty_tuple __pyx_mstate_global->__pyx_empty_tuple
-#define __pyx_empty_bytes __pyx_mstate_global->__pyx_empty_bytes
-#define __pyx_empty_unicode __pyx_mstate_global->__pyx_empty_unicode
-#ifdef __Pyx_CyFunction_USED
-#define __pyx_CyFunctionType __pyx_mstate_global->__pyx_CyFunctionType
-#endif
-#ifdef __Pyx_FusedFunction_USED
-#define __pyx_FusedFunctionType __pyx_mstate_global->__pyx_FusedFunctionType
-#endif
-#ifdef __Pyx_Generator_USED
-#define __pyx_GeneratorType __pyx_mstate_global->__pyx_GeneratorType
-#endif
-#ifdef __Pyx_IterableCoroutine_USED
-#define __pyx_IterableCoroutineType __pyx_mstate_global->__pyx_IterableCoroutineType
-#endif
-#ifdef __Pyx_Coroutine_USED
-#define __pyx_CoroutineAwaitType __pyx_mstate_global->__pyx_CoroutineAwaitType
-#endif
-#ifdef __Pyx_Coroutine_USED
-#define __pyx_CoroutineType __pyx_mstate_global->__pyx_CoroutineType
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#define __pyx_ptype_7cpython_4type_type __pyx_mstate_global->__pyx_ptype_7cpython_4type_type
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#define __pyx_ptype_7cpython_4bool_bool __pyx_mstate_global->__pyx_ptype_7cpython_4bool_bool
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#define __pyx_ptype_7cpython_7complex_complex __pyx_mstate_global->__pyx_ptype_7cpython_7complex_complex
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#define __pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase __pyx_mstate_global->__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase
-#define __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase __pyx_mstate_global->__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase
-#define __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase __pyx_mstate_global->__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase
-#endif
-#define __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase __pyx_mstate_global->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase
-#define __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase __pyx_mstate_global->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase
-#define __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase __pyx_mstate_global->__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase
-#define __pyx_kp_u_ __pyx_mstate_global->__pyx_kp_u_
-#define __pyx_n_s_AssertionError __pyx_mstate_global->__pyx_n_s_AssertionError
-#define __pyx_n_s_AttributeError __pyx_mstate_global->__pyx_n_s_AttributeError
-#define __pyx_n_s_CLASS_FUNCTION __pyx_mstate_global->__pyx_n_s_CLASS_FUNCTION
-#define __pyx_n_s_CLASS_MODULE __pyx_mstate_global->__pyx_n_s_CLASS_MODULE
-#define __pyx_n_s_CTypesDGLContext __pyx_mstate_global->__pyx_n_s_CTypesDGLContext
-#define __pyx_n_s_CTypesDGLDataType __pyx_mstate_global->__pyx_n_s_CTypesDGLDataType
-#define __pyx_n_s_DGLArrayHandle __pyx_mstate_global->__pyx_n_s_DGLArrayHandle
-#define __pyx_n_s_DGLByteArray __pyx_mstate_global->__pyx_n_s_DGLByteArray
-#define __pyx_n_s_DGLContext __pyx_mstate_global->__pyx_n_s_DGLContext
-#define __pyx_n_s_DGLDataType __pyx_mstate_global->__pyx_n_s_DGLDataType
-#define __pyx_n_s_DGLError __pyx_mstate_global->__pyx_n_s_DGLError
-#define __pyx_kp_u_Don_t_know_how_to_handle_type_s __pyx_mstate_global->__pyx_kp_u_Don_t_know_how_to_handle_type_s
-#define __pyx_kp_u_Expect_a_dltensor_field_pycapsul __pyx_mstate_global->__pyx_kp_u_Expect_a_dltensor_field_pycapsul
-#define __pyx_n_s_FunctionBase __pyx_mstate_global->__pyx_n_s_FunctionBase
-#define __pyx_n_s_FunctionBase___reduce_cython __pyx_mstate_global->__pyx_n_s_FunctionBase___reduce_cython
-#define __pyx_n_s_FunctionBase___setstate_cython __pyx_mstate_global->__pyx_n_s_FunctionBase___setstate_cython
-#define __pyx_n_s_Integral __pyx_mstate_global->__pyx_n_s_Integral
-#define __pyx_n_s_NDArrayBase __pyx_mstate_global->__pyx_n_s_NDArrayBase
-#define __pyx_n_s_NDArrayBase___reduce_cython __pyx_mstate_global->__pyx_n_s_NDArrayBase___reduce_cython
-#define __pyx_n_s_NDArrayBase___setstate_cython __pyx_mstate_global->__pyx_n_s_NDArrayBase___setstate_cython
-#define __pyx_n_s_NDArrayBase_to_dlpack __pyx_mstate_global->__pyx_n_s_NDArrayBase_to_dlpack
-#define __pyx_n_s_Number __pyx_mstate_global->__pyx_n_s_Number
-#define __pyx_n_s_OBJECT_TYPE __pyx_mstate_global->__pyx_n_s_OBJECT_TYPE
-#define __pyx_n_s_ObjectBase __pyx_mstate_global->__pyx_n_s_ObjectBase
-#define __pyx_n_s_ObjectBase___init_handle_by_cons __pyx_mstate_global->__pyx_n_s_ObjectBase___init_handle_by_cons
-#define __pyx_n_s_ObjectBase___reduce_cython __pyx_mstate_global->__pyx_n_s_ObjectBase___reduce_cython
-#define __pyx_n_s_ObjectBase___setstate_cython __pyx_mstate_global->__pyx_n_s_ObjectBase___setstate_cython
-#define __pyx_n_s_ObjectGeneric __pyx_mstate_global->__pyx_n_s_ObjectGeneric
-#define __pyx_n_s_POINTER __pyx_mstate_global->__pyx_n_s_POINTER
-#define __pyx_kp_u_PackedFunction_can_only_support __pyx_mstate_global->__pyx_kp_u_PackedFunction_can_only_support
-#define __pyx_n_s_PyDGLArrayHandle __pyx_mstate_global->__pyx_n_s_PyDGLArrayHandle
-#define __pyx_n_s_RuntimeError __pyx_mstate_global->__pyx_n_s_RuntimeError
-#define __pyx_n_s_TypeError __pyx_mstate_global->__pyx_n_s_TypeError
-#define __pyx_kp_u_Unhandled_type_code_d __pyx_mstate_global->__pyx_kp_u_Unhandled_type_code_d
-#define __pyx_n_s_ValueError __pyx_mstate_global->__pyx_n_s_ValueError
-#define __pyx_n_s__39 __pyx_mstate_global->__pyx_n_s__39
-#define __pyx_kp_u__7 __pyx_mstate_global->__pyx_kp_u__7
-#define __pyx_n_s__8 __pyx_mstate_global->__pyx_n_s__8
-#define __pyx_n_s__9 __pyx_mstate_global->__pyx_n_s__9
-#define __pyx_n_s_addressof __pyx_mstate_global->__pyx_n_s_addressof
-#define __pyx_n_s_alignment __pyx_mstate_global->__pyx_n_s_alignment
-#define __pyx_n_s_api_internal __pyx_mstate_global->__pyx_n_s_api_internal
-#define __pyx_n_s_append __pyx_mstate_global->__pyx_n_s_append
-#define __pyx_n_s_args __pyx_mstate_global->__pyx_n_s_args
-#define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
-#define __pyx_n_s_base __pyx_mstate_global->__pyx_n_s_base
-#define __pyx_n_s_c_byte __pyx_mstate_global->__pyx_n_s_c_byte
-#define __pyx_n_s_c_is_global __pyx_mstate_global->__pyx_n_s_c_is_global
-#define __pyx_n_s_c_void_p __pyx_mstate_global->__pyx_n_s_c_void_p
-#define __pyx_n_s_cast __pyx_mstate_global->__pyx_n_s_cast
-#define __pyx_n_s_chandle __pyx_mstate_global->__pyx_n_s_chandle
-#define __pyx_n_s_class __pyx_mstate_global->__pyx_n_s_class
-#define __pyx_n_s_cline_in_traceback __pyx_mstate_global->__pyx_n_s_cline_in_traceback
-#define __pyx_n_s_cls __pyx_mstate_global->__pyx_n_s_cls
-#define __pyx_n_s_convert_to_dgl_func __pyx_mstate_global->__pyx_n_s_convert_to_dgl_func
-#define __pyx_n_s_convert_to_object __pyx_mstate_global->__pyx_n_s_convert_to_object
-#define __pyx_n_s_ctypes __pyx_mstate_global->__pyx_n_s_ctypes
-#define __pyx_n_s_data __pyx_mstate_global->__pyx_n_s_data
-#define __pyx_n_s_dgl__ffi__cy3_core __pyx_mstate_global->__pyx_n_s_dgl__ffi__cy3_core
-#define __pyx_kp_s_dgl__ffi__cython_function_pxi __pyx_mstate_global->__pyx_kp_s_dgl__ffi__cython_function_pxi
-#define __pyx_kp_s_dgl__ffi__cython_ndarray_pxi __pyx_mstate_global->__pyx_kp_s_dgl__ffi__cython_ndarray_pxi
-#define __pyx_kp_s_dgl__ffi__cython_object_pxi __pyx_mstate_global->__pyx_kp_s_dgl__ffi__cython_object_pxi
-#define __pyx_n_s_dgl_handle __pyx_mstate_global->__pyx_n_s_dgl_handle
-#define __pyx_n_s_dgl_tcode __pyx_mstate_global->__pyx_n_s_dgl_tcode
-#define __pyx_kp_u_disable __pyx_mstate_global->__pyx_kp_u_disable
-#define __pyx_n_s_dltensor __pyx_mstate_global->__pyx_n_s_dltensor
-#define __pyx_kp_u_enable __pyx_mstate_global->__pyx_kp_u_enable
-#define __pyx_n_s_encode __pyx_mstate_global->__pyx_n_s_encode
-#define __pyx_n_s_fconstructor __pyx_mstate_global->__pyx_n_s_fconstructor
-#define __pyx_n_s_fcreate __pyx_mstate_global->__pyx_n_s_fcreate
-#define __pyx_n_s_format_exc __pyx_mstate_global->__pyx_n_s_format_exc
-#define __pyx_n_s_from_buffer __pyx_mstate_global->__pyx_n_s_from_buffer
-#define __pyx_n_s_from_dlpack __pyx_mstate_global->__pyx_n_s_from_dlpack
-#define __pyx_n_s_func_class __pyx_mstate_global->__pyx_n_s_func_class
-#define __pyx_kp_u_gc __pyx_mstate_global->__pyx_kp_u_gc
-#define __pyx_n_s_getstate __pyx_mstate_global->__pyx_n_s_getstate
-#define __pyx_n_s_handle __pyx_mstate_global->__pyx_n_s_handle
-#define __pyx_n_s_import __pyx_mstate_global->__pyx_n_s_import
-#define __pyx_n_s_index __pyx_mstate_global->__pyx_n_s_index
-#define __pyx_n_s_init_handle_by_constructor __pyx_mstate_global->__pyx_n_s_init_handle_by_constructor
-#define __pyx_n_s_initializing __pyx_mstate_global->__pyx_n_s_initializing
-#define __pyx_n_s_is_coroutine __pyx_mstate_global->__pyx_n_s_is_coroutine
-#define __pyx_n_s_is_global __pyx_mstate_global->__pyx_n_s_is_global
-#define __pyx_n_s_is_view __pyx_mstate_global->__pyx_n_s_is_view
-#define __pyx_kp_u_isenabled __pyx_mstate_global->__pyx_kp_u_isenabled
-#define __pyx_n_s_main __pyx_mstate_global->__pyx_n_s_main
-#define __pyx_n_s_make_array __pyx_mstate_global->__pyx_n_s_make_array
-#define __pyx_n_s_memmove __pyx_mstate_global->__pyx_n_s_memmove
-#define __pyx_kp_u_memmove_failed __pyx_mstate_global->__pyx_kp_u_memmove_failed
-#define __pyx_n_s_module_class __pyx_mstate_global->__pyx_n_s_module_class
-#define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
-#define __pyx_n_s_new __pyx_mstate_global->__pyx_n_s_new
-#define __pyx_n_s_numbers __pyx_mstate_global->__pyx_n_s_numbers
-#define __pyx_n_s_object_generic __pyx_mstate_global->__pyx_n_s_object_generic
-#define __pyx_kp_u_object_has_no_attribute __pyx_mstate_global->__pyx_kp_u_object_has_no_attribute
-#define __pyx_n_s_ptr __pyx_mstate_global->__pyx_n_s_ptr
-#define __pyx_n_s_pyfunc __pyx_mstate_global->__pyx_n_s_pyfunc
-#define __pyx_n_s_pyx_state __pyx_mstate_global->__pyx_n_s_pyx_state
-#define __pyx_n_s_pyx_vtable __pyx_mstate_global->__pyx_n_s_pyx_vtable
-#define __pyx_n_s_range __pyx_mstate_global->__pyx_n_s_range
-#define __pyx_n_s_reduce __pyx_mstate_global->__pyx_n_s_reduce
-#define __pyx_n_s_reduce_cython __pyx_mstate_global->__pyx_n_s_reduce_cython
-#define __pyx_n_s_reduce_ex __pyx_mstate_global->__pyx_n_s_reduce_ex
-#define __pyx_n_s_reg_extension __pyx_mstate_global->__pyx_n_s_reg_extension
-#define __pyx_n_s_register_object __pyx_mstate_global->__pyx_n_s_register_object
-#define __pyx_n_s_ret __pyx_mstate_global->__pyx_n_s_ret
-#define __pyx_n_s_runtime_ctypes __pyx_mstate_global->__pyx_n_s_runtime_ctypes
-#define __pyx_n_s_self __pyx_mstate_global->__pyx_n_s_self
-#define __pyx_kp_s_self_chandle_cannot_be_converted __pyx_mstate_global->__pyx_kp_s_self_chandle_cannot_be_converted
-#define __pyx_n_s_set_class_function __pyx_mstate_global->__pyx_n_s_set_class_function
-#define __pyx_n_s_set_class_module __pyx_mstate_global->__pyx_n_s_set_class_module
-#define __pyx_n_s_set_class_ndarray __pyx_mstate_global->__pyx_n_s_set_class_ndarray
-#define __pyx_n_s_set_class_object_base __pyx_mstate_global->__pyx_n_s_set_class_object_base
-#define __pyx_n_s_setstate __pyx_mstate_global->__pyx_n_s_setstate
-#define __pyx_n_s_setstate_cython __pyx_mstate_global->__pyx_n_s_setstate_cython
-#define __pyx_n_s_size __pyx_mstate_global->__pyx_n_s_size
-#define __pyx_n_s_spec __pyx_mstate_global->__pyx_n_s_spec
-#define __pyx_n_s_string_types __pyx_mstate_global->__pyx_n_s_string_types
-#define __pyx_kp_s_stringsource __pyx_mstate_global->__pyx_kp_s_stringsource
-#define __pyx_n_s_test __pyx_mstate_global->__pyx_n_s_test
-#define __pyx_n_s_to_dlpack __pyx_mstate_global->__pyx_n_s_to_dlpack
-#define __pyx_kp_u_to_dlpack_do_not_work_with_memor __pyx_mstate_global->__pyx_kp_u_to_dlpack_do_not_work_with_memor
-#define __pyx_n_s_traceback __pyx_mstate_global->__pyx_n_s_traceback
-#define __pyx_kp_u_utf_8 __pyx_mstate_global->__pyx_kp_u_utf_8
-#define __pyx_n_s_value __pyx_mstate_global->__pyx_n_s_value
-#define __pyx_int_0 __pyx_mstate_global->__pyx_int_0
-#define __pyx_tuple__2 __pyx_mstate_global->__pyx_tuple__2
-#define __pyx_tuple__3 __pyx_mstate_global->__pyx_tuple__3
-#define __pyx_tuple__4 __pyx_mstate_global->__pyx_tuple__4
-#define __pyx_tuple__5 __pyx_mstate_global->__pyx_tuple__5
-#define __pyx_tuple__6 __pyx_mstate_global->__pyx_tuple__6
-#define __pyx_tuple__10 __pyx_mstate_global->__pyx_tuple__10
-#define __pyx_tuple__12 __pyx_mstate_global->__pyx_tuple__12
-#define __pyx_tuple__14 __pyx_mstate_global->__pyx_tuple__14
-#define __pyx_tuple__16 __pyx_mstate_global->__pyx_tuple__16
-#define __pyx_tuple__18 __pyx_mstate_global->__pyx_tuple__18
-#define __pyx_tuple__22 __pyx_mstate_global->__pyx_tuple__22
-#define __pyx_tuple__24 __pyx_mstate_global->__pyx_tuple__24
-#define __pyx_tuple__26 __pyx_mstate_global->__pyx_tuple__26
-#define __pyx_tuple__28 __pyx_mstate_global->__pyx_tuple__28
-#define __pyx_tuple__30 __pyx_mstate_global->__pyx_tuple__30
-#define __pyx_tuple__33 __pyx_mstate_global->__pyx_tuple__33
-#define __pyx_tuple__35 __pyx_mstate_global->__pyx_tuple__35
-#define __pyx_tuple__37 __pyx_mstate_global->__pyx_tuple__37
-#define __pyx_codeobj__11 __pyx_mstate_global->__pyx_codeobj__11
-#define __pyx_codeobj__13 __pyx_mstate_global->__pyx_codeobj__13
-#define __pyx_codeobj__15 __pyx_mstate_global->__pyx_codeobj__15
-#define __pyx_codeobj__17 __pyx_mstate_global->__pyx_codeobj__17
-#define __pyx_codeobj__19 __pyx_mstate_global->__pyx_codeobj__19
-#define __pyx_codeobj__20 __pyx_mstate_global->__pyx_codeobj__20
-#define __pyx_codeobj__21 __pyx_mstate_global->__pyx_codeobj__21
-#define __pyx_codeobj__23 __pyx_mstate_global->__pyx_codeobj__23
-#define __pyx_codeobj__25 __pyx_mstate_global->__pyx_codeobj__25
-#define __pyx_codeobj__27 __pyx_mstate_global->__pyx_codeobj__27
-#define __pyx_codeobj__29 __pyx_mstate_global->__pyx_codeobj__29
-#define __pyx_codeobj__31 __pyx_mstate_global->__pyx_codeobj__31
-#define __pyx_codeobj__32 __pyx_mstate_global->__pyx_codeobj__32
-#define __pyx_codeobj__34 __pyx_mstate_global->__pyx_codeobj__34
-#define __pyx_codeobj__36 __pyx_mstate_global->__pyx_codeobj__36
-#define __pyx_codeobj__38 __pyx_mstate_global->__pyx_codeobj__38
-/* #### Code section: module_code ### */
-
-/* "cpython/complex.pxd":19
- * 
- *         @property
- *         cdef inline double real(self):             # <<<<<<<<<<<<<<
- *             return self.cval.real
- * 
- */
-
-static CYTHON_INLINE double __pyx_f_7cpython_7complex_7complex_4real_real(PyComplexObject *__pyx_v_self) {
-  double __pyx_r;
-
-  /* "cpython/complex.pxd":20
- *         @property
- *         cdef inline double real(self):
- *             return self.cval.real             # <<<<<<<<<<<<<<
- * 
- *         @property
- */
-  __pyx_r = __pyx_v_self->cval.real;
-  goto __pyx_L0;
-
-  /* "cpython/complex.pxd":19
- * 
- *         @property
- *         cdef inline double real(self):             # <<<<<<<<<<<<<<
- *             return self.cval.real
- * 
- */
-
-  /* function exit code */
-  __pyx_L0:;
-  return __pyx_r;
-}
-
-/* "cpython/complex.pxd":23
- * 
- *         @property
- *         cdef inline double imag(self):             # <<<<<<<<<<<<<<
- *             return self.cval.imag
- * 
- */
-
-static CYTHON_INLINE double __pyx_f_7cpython_7complex_7complex_4imag_imag(PyComplexObject *__pyx_v_self) {
-  double __pyx_r;
-
-  /* "cpython/complex.pxd":24
- *         @property
- *         cdef inline double imag(self):
- *             return self.cval.imag             # <<<<<<<<<<<<<<
- * 
- *     # PyTypeObject PyComplex_Type
- */
-  __pyx_r = __pyx_v_self->cval.imag;
-  goto __pyx_L0;
-
-  /* "cpython/complex.pxd":23
- * 
- *         @property
- *         cdef inline double imag(self):             # <<<<<<<<<<<<<<
- *             return self.cval.imag
- * 
- */
-
-  /* function exit code */
-  __pyx_L0:;
-  return __pyx_r;
-}
-
-/* "cpython/contextvars.pxd":112
- * 
- * 
- * cdef inline object get_value(var, default_value=None):             # <<<<<<<<<<<<<<
- *     """Return a new reference to the value of the context variable,
- *     or the default value of the context variable,
- */
-
-static CYTHON_INLINE PyObject *__pyx_f_7cpython_11contextvars_get_value(PyObject *__pyx_v_var, struct __pyx_opt_args_7cpython_11contextvars_get_value *__pyx_optional_args) {
-  PyObject *__pyx_v_default_value = ((PyObject *)Py_None);
-  PyObject *__pyx_v_value;
-  PyObject *__pyx_v_pyvalue = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_value", 1);
-  if (__pyx_optional_args) {
-    if (__pyx_optional_args->__pyx_n > 0) {
-      __pyx_v_default_value = __pyx_optional_args->default_value;
-    }
-  }
-
-  /* "cpython/contextvars.pxd":117
- *     or None if no such value or default was found.
- *     """
- *     cdef PyObject *value = NULL             # <<<<<<<<<<<<<<
- *     PyContextVar_Get(var, NULL, &value)
- *     if value is NULL:
- */
-  __pyx_v_value = NULL;
-
-  /* "cpython/contextvars.pxd":118
- *     """
- *     cdef PyObject *value = NULL
- *     PyContextVar_Get(var, NULL, &value)             # <<<<<<<<<<<<<<
- *     if value is NULL:
- *         # context variable does not have a default
- */
-  __pyx_t_1 = PyContextVar_Get(__pyx_v_var, NULL, (&__pyx_v_value)); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(3, 118, __pyx_L1_error)
-
-  /* "cpython/contextvars.pxd":119
- *     cdef PyObject *value = NULL
- *     PyContextVar_Get(var, NULL, &value)
- *     if value is NULL:             # <<<<<<<<<<<<<<
- *         # context variable does not have a default
- *         pyvalue = default_value
- */
-  __pyx_t_2 = (__pyx_v_value == NULL);
-  if (__pyx_t_2) {
-
-    /* "cpython/contextvars.pxd":121
- *     if value is NULL:
- *         # context variable does not have a default
- *         pyvalue = default_value             # <<<<<<<<<<<<<<
- *     else:
- *         # value or default value of context variable
- */
-    __Pyx_INCREF(__pyx_v_default_value);
-    __pyx_v_pyvalue = __pyx_v_default_value;
-
-    /* "cpython/contextvars.pxd":119
- *     cdef PyObject *value = NULL
- *     PyContextVar_Get(var, NULL, &value)
- *     if value is NULL:             # <<<<<<<<<<<<<<
- *         # context variable does not have a default
- *         pyvalue = default_value
- */
-    goto __pyx_L3;
-  }
-
-  /* "cpython/contextvars.pxd":124
- *     else:
- *         # value or default value of context variable
- *         pyvalue = <object>value             # <<<<<<<<<<<<<<
- *         Py_XDECREF(value)  # PyContextVar_Get() returned an owned reference as 'PyObject*'
- *     return pyvalue
- */
-  /*else*/ {
-    __pyx_t_3 = ((PyObject *)__pyx_v_value);
-    __Pyx_INCREF(__pyx_t_3);
-    __pyx_v_pyvalue = __pyx_t_3;
-    __pyx_t_3 = 0;
-
-    /* "cpython/contextvars.pxd":125
- *         # value or default value of context variable
- *         pyvalue = <object>value
- *         Py_XDECREF(value)  # PyContextVar_Get() returned an owned reference as 'PyObject*'             # <<<<<<<<<<<<<<
- *     return pyvalue
- * 
- */
-    Py_XDECREF(__pyx_v_value);
-  }
-  __pyx_L3:;
-
-  /* "cpython/contextvars.pxd":126
- *         pyvalue = <object>value
- *         Py_XDECREF(value)  # PyContextVar_Get() returned an owned reference as 'PyObject*'
- *     return pyvalue             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_pyvalue);
-  __pyx_r = __pyx_v_pyvalue;
-  goto __pyx_L0;
-
-  /* "cpython/contextvars.pxd":112
- * 
- * 
- * cdef inline object get_value(var, default_value=None):             # <<<<<<<<<<<<<<
- *     """Return a new reference to the value of the context variable,
- *     or the default value of the context variable,
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("cpython.contextvars.get_value", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_pyvalue);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "cpython/contextvars.pxd":129
- * 
- * 
- * cdef inline object get_value_no_default(var, default_value=None):             # <<<<<<<<<<<<<<
- *     """Return a new reference to the value of the context variable,
- *     or the provided default value if no such value was found.
- */
-
-static CYTHON_INLINE PyObject *__pyx_f_7cpython_11contextvars_get_value_no_default(PyObject *__pyx_v_var, struct __pyx_opt_args_7cpython_11contextvars_get_value_no_default *__pyx_optional_args) {
-  PyObject *__pyx_v_default_value = ((PyObject *)Py_None);
-  PyObject *__pyx_v_value;
-  PyObject *__pyx_v_pyvalue = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_value_no_default", 1);
-  if (__pyx_optional_args) {
-    if (__pyx_optional_args->__pyx_n > 0) {
-      __pyx_v_default_value = __pyx_optional_args->default_value;
-    }
-  }
-
-  /* "cpython/contextvars.pxd":135
- *     Ignores the default value of the context variable, if any.
- *     """
- *     cdef PyObject *value = NULL             # <<<<<<<<<<<<<<
- *     PyContextVar_Get(var, <PyObject*>default_value, &value)
- *     # value of context variable or 'default_value'
- */
-  __pyx_v_value = NULL;
-
-  /* "cpython/contextvars.pxd":136
- *     """
- *     cdef PyObject *value = NULL
- *     PyContextVar_Get(var, <PyObject*>default_value, &value)             # <<<<<<<<<<<<<<
- *     # value of context variable or 'default_value'
- *     pyvalue = <object>value
- */
-  __pyx_t_1 = PyContextVar_Get(__pyx_v_var, ((PyObject *)__pyx_v_default_value), (&__pyx_v_value)); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(3, 136, __pyx_L1_error)
-
-  /* "cpython/contextvars.pxd":138
- *     PyContextVar_Get(var, <PyObject*>default_value, &value)
- *     # value of context variable or 'default_value'
- *     pyvalue = <object>value             # <<<<<<<<<<<<<<
- *     Py_XDECREF(value)  # PyContextVar_Get() returned an owned reference as 'PyObject*'
- *     return pyvalue
- */
-  __pyx_t_2 = ((PyObject *)__pyx_v_value);
-  __Pyx_INCREF(__pyx_t_2);
-  __pyx_v_pyvalue = __pyx_t_2;
-  __pyx_t_2 = 0;
-
-  /* "cpython/contextvars.pxd":139
- *     # value of context variable or 'default_value'
- *     pyvalue = <object>value
- *     Py_XDECREF(value)  # PyContextVar_Get() returned an owned reference as 'PyObject*'             # <<<<<<<<<<<<<<
- *     return pyvalue
- */
-  Py_XDECREF(__pyx_v_value);
-
-  /* "cpython/contextvars.pxd":140
- *     pyvalue = <object>value
- *     Py_XDECREF(value)  # PyContextVar_Get() returned an owned reference as 'PyObject*'
- *     return pyvalue             # <<<<<<<<<<<<<<
- */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_pyvalue);
-  __pyx_r = __pyx_v_pyvalue;
-  goto __pyx_L0;
-
-  /* "cpython/contextvars.pxd":129
- * 
- * 
- * cdef inline object get_value_no_default(var, default_value=None):             # <<<<<<<<<<<<<<
- *     """Return a new reference to the value of the context variable,
- *     or the provided default value if no such value was found.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_AddTraceback("cpython.contextvars.get_value_no_default", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_pyvalue);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
+static PyObject *__pyx_int_0;
+static PyObject *__pyx_tuple__2;
+static PyObject *__pyx_tuple__3;
+static PyObject *__pyx_tuple__4;
+static PyObject *__pyx_tuple__5;
+static PyObject *__pyx_tuple__6;
+static PyObject *__pyx_tuple__7;
+static PyObject *__pyx_tuple__8;
+static PyObject *__pyx_tuple__9;
+static PyObject *__pyx_tuple__10;
+static PyObject *__pyx_tuple__11;
+static PyObject *__pyx_tuple__12;
+static PyObject *__pyx_tuple__14;
+static PyObject *__pyx_tuple__16;
+static PyObject *__pyx_tuple__18;
+static PyObject *__pyx_tuple__20;
+static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__24;
+static PyObject *__pyx_tuple__26;
+static PyObject *__pyx_tuple__28;
+static PyObject *__pyx_codeobj__15;
+static PyObject *__pyx_codeobj__17;
+static PyObject *__pyx_codeobj__19;
+static PyObject *__pyx_codeobj__21;
+static PyObject *__pyx_codeobj__23;
+static PyObject *__pyx_codeobj__25;
+static PyObject *__pyx_codeobj__27;
+static PyObject *__pyx_codeobj__29;
+/* Late includes */
 
 /* "dgl/_ffi/_cython/base.pxi":130
  *     void DGLDLManagedTensorCallDeleter(DLManagedTensor* dltensor)
  * 
  * cdef inline py_str(const char* x):             # <<<<<<<<<<<<<<
  *     if PY_MAJOR_VERSION < 3:
  *         return x
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_py_str(char const *__pyx_v_x) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("py_str", 1);
+  __Pyx_RefNannySetupContext("py_str", 0);
 
   /* "dgl/_ffi/_cython/base.pxi":131
  * 
  * cdef inline py_str(const char* x):
  *     if PY_MAJOR_VERSION < 3:             # <<<<<<<<<<<<<<
  *         return x
  *     else:
  */
-  __pyx_t_1 = (PY_MAJOR_VERSION < 3);
+  __pyx_t_1 = ((PY_MAJOR_VERSION < 3) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/base.pxi":132
  * cdef inline py_str(const char* x):
  *     if PY_MAJOR_VERSION < 3:
  *         return x             # <<<<<<<<<<<<<<
  *     else:
  *         return x.decode("utf-8")
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyBytes_FromString(__pyx_v_x); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 132, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyBytes_FromString(__pyx_v_x); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 132, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
     /* "dgl/_ffi/_cython/base.pxi":131
  * 
@@ -4283,16 +2155,15 @@
  *     else:
  *         return x.decode("utf-8")             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_ssize_strlen(__pyx_v_x); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(4, 134, __pyx_L1_error)
-    __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_x, 0, __pyx_t_3, NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 134, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_x, 0, strlen(__pyx_v_x), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 134, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "dgl/_ffi/_cython/base.pxi":130
@@ -4324,52 +2195,44 @@
 
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(PyObject *__pyx_v_pystr) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("c_str", 1);
+  __Pyx_RefNannySetupContext("c_str", 0);
 
   /* "dgl/_ffi/_cython/base.pxi":149
  *         A char pointer that can be passed to C API
  *     """
  *     return pystr.encode("utf-8")             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_pystr, __pyx_n_s_encode); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 149, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_pystr, __pyx_n_s_encode); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 149, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
-  __pyx_t_4 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_2))) {
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_4 = 1;
     }
   }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_3, __pyx_kp_u_utf_8};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_4, 1+__pyx_t_4);
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 149, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_u_utf_8);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 149, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "dgl/_ffi/_cython/base.pxi":137
  * 
  * 
@@ -4403,67 +2266,59 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("CALL", 1);
+  __Pyx_RefNannySetupContext("CALL", 0);
 
   /* "dgl/_ffi/_cython/base.pxi":153
  * 
  * cdef inline CALL(int ret):
  *     if ret != 0:             # <<<<<<<<<<<<<<
  *         raise DGLError(py_str(DGLGetLastError()))
  * 
  */
-  __pyx_t_1 = (__pyx_v_ret != 0);
+  __pyx_t_1 = ((__pyx_v_ret != 0) != 0);
   if (unlikely(__pyx_t_1)) {
 
     /* "dgl/_ffi/_cython/base.pxi":154
  * cdef inline CALL(int ret):
  *     if ret != 0:
  *         raise DGLError(py_str(DGLGetLastError()))             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DGLError); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 154, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DGLError); if (unlikely(!__pyx_t_3)) __PYX_ERR(3, 154, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __pyx_f_3dgl_4_ffi_4_cy3_4core_py_str(DGLGetLastError()); if (unlikely(!__pyx_t_4)) __PYX_ERR(4, 154, __pyx_L1_error)
+    __pyx_t_4 = __pyx_f_3dgl_4_ffi_4_cy3_4core_py_str(DGLGetLastError()); if (unlikely(!__pyx_t_4)) __PYX_ERR(3, 154, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
-    __pyx_t_6 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
-        __pyx_t_6 = 1;
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_4};
-      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 154, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    }
+    __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 154, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(4, 154, __pyx_L1_error)
+    __PYX_ERR(3, 154, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/base.pxi":153
  * 
  * cdef inline CALL(int ret):
  *     if ret != 0:             # <<<<<<<<<<<<<<
  *         raise DGLError(py_str(DGLGetLastError()))
  * 
@@ -4507,63 +2362,89 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("ctypes_handle", 1);
+  __Pyx_RefNannySetupContext("ctypes_handle", 0);
 
   /* "dgl/_ffi/_cython/base.pxi":159
  * cdef inline object ctypes_handle(void* chandle):
  *     """Cast C handle to ctypes handle."""
  *     return ctypes.cast(<unsigned long long>chandle, ctypes.c_void_p)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 159, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_cast); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 159, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_cast); if (unlikely(!__pyx_t_3)) __PYX_ERR(3, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(((unsigned PY_LONG_LONG)__pyx_v_chandle)); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 159, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(((unsigned PY_LONG_LONG)__pyx_v_chandle)); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_4)) __PYX_ERR(4, 159, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_4)) __PYX_ERR(3, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_5)) __PYX_ERR(4, 159, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_5)) __PYX_ERR(3, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_6 = 1;
     }
   }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_2, __pyx_t_5};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 159, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  } else
   #endif
-  {
-    PyObject *__pyx_callargs[3] = {__pyx_t_4, __pyx_t_2, __pyx_t_5};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_2, __pyx_t_5};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 159, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 159, __pyx_L1_error)
+  } else
+  #endif
+  {
+    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(3, 159, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    if (__pyx_t_4) {
+      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
+    }
+    __Pyx_GIVEREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_5);
+    __pyx_t_2 = 0;
+    __pyx_t_5 = 0;
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 159, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "dgl/_ffi/_cython/base.pxi":157
  * 
  * 
@@ -4575,14 +2456,15 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_7);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.ctypes_handle", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -4597,32 +2479,34 @@
 
 static CYTHON_INLINE void *__pyx_f_3dgl_4_ffi_4_cy3_4core_c_handle(PyObject *__pyx_v_handle) {
   unsigned PY_LONG_LONG __pyx_v_v_ptr;
   void *__pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
-  unsigned PY_LONG_LONG __pyx_t_3;
+  int __pyx_t_3;
+  unsigned PY_LONG_LONG __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("c_handle", 1);
+  __Pyx_RefNannySetupContext("c_handle", 0);
 
   /* "dgl/_ffi/_cython/base.pxi":165
  *     """Cast C types handle to c handle."""
  *     cdef unsigned long long v_ptr
  *     if handle.value is None:             # <<<<<<<<<<<<<<
  *         return NULL
  *     else:
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_handle, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 165, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_handle, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 165, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = (__pyx_t_1 == Py_None);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
 
     /* "dgl/_ffi/_cython/base.pxi":166
  *     cdef unsigned long long v_ptr
  *     if handle.value is None:
  *         return NULL             # <<<<<<<<<<<<<<
  *     else:
  *         v_ptr = handle.value
@@ -4642,19 +2526,19 @@
   /* "dgl/_ffi/_cython/base.pxi":168
  *         return NULL
  *     else:
  *         v_ptr = handle.value             # <<<<<<<<<<<<<<
  *         return <void*>(v_ptr)
  */
   /*else*/ {
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_handle, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 168, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_handle, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 168, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_3 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(4, 168, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(3, 168, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_v_v_ptr = __pyx_t_3;
+    __pyx_v_v_ptr = __pyx_t_4;
 
     /* "dgl/_ffi/_cython/base.pxi":169
  *     else:
  *         v_ptr = handle.value
  *         return <void*>(v_ptr)             # <<<<<<<<<<<<<<
  */
     __pyx_r = ((void *)__pyx_v_v_ptr);
@@ -4668,166 +2552,120 @@
  *     """Cast C types handle to c handle."""
  *     cdef unsigned long long v_ptr
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.c_handle", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
+  __Pyx_WriteUnraisable("dgl._ffi._cy3.core.c_handle", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "dgl/_ffi/_cython/object.pxi":8
  * OBJECT_TYPE = []
  * 
  * def _register_object(int index, object cls):             # <<<<<<<<<<<<<<
  *     """register object class"""
  *     while len(OBJECT_TYPE) <= index:
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_1_register_object(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-PyDoc_STRVAR(__pyx_doc_3dgl_4_ffi_4_cy3_4core__register_object, "register object class");
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_1_register_object = {"_register_object", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_1_register_object, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core__register_object};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_1_register_object(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_1_register_object(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3dgl_4_ffi_4_cy3_4core__register_object[] = "register object class";
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_1_register_object = {"_register_object", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_1_register_object, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core__register_object};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_1_register_object(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   int __pyx_v_index;
   PyObject *__pyx_v_cls = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_register_object (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_index,&__pyx_n_s_cls,0};
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_index,&__pyx_n_s_cls,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_index)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_index)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_cls)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("_register_object", 1, 2, 2, 1); __PYX_ERR(0, 8, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_register_object") < 0)) __PYX_ERR(0, 8, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_register_object") < 0)) __PYX_ERR(0, 8, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_index = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_index == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
     __pyx_v_cls = values[1];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_register_object", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 8, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("_register_object", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_AddTraceback("dgl._ffi._cy3.core._register_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core__register_object(__pyx_self, __pyx_v_index, __pyx_v_cls);
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core__register_object(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_index, PyObject *__pyx_v_cls) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_register_object", 1);
+  __Pyx_RefNannySetupContext("_register_object", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":10
  * def _register_object(int index, object cls):
  *     """register object class"""
  *     while len(OBJECT_TYPE) <= index:             # <<<<<<<<<<<<<<
  *         OBJECT_TYPE.append(None)
  *     OBJECT_TYPE[index] = cls
  */
   while (1) {
     __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_OBJECT_TYPE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 10, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_3 = (__pyx_t_2 <= __pyx_v_index);
+    __pyx_t_3 = ((__pyx_t_2 <= __pyx_v_index) != 0);
     if (!__pyx_t_3) break;
 
     /* "dgl/_ffi/_cython/object.pxi":11
  *     """register object class"""
  *     while len(OBJECT_TYPE) <= index:
  *         OBJECT_TYPE.append(None)             # <<<<<<<<<<<<<<
  *     OBJECT_TYPE[index] = cls
@@ -4844,15 +2682,15 @@
  *         OBJECT_TYPE.append(None)
  *     OBJECT_TYPE[index] = cls             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_OBJECT_TYPE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely((__Pyx_SetItemInt(__pyx_t_1, __pyx_v_index, __pyx_v_cls, int, 1, __Pyx_PyInt_From_int, 0, 1, 1) < 0))) __PYX_ERR(0, 12, __pyx_L1_error)
+  if (unlikely(__Pyx_SetItemInt(__pyx_t_1, __pyx_v_index, __pyx_v_cls, int, 1, __Pyx_PyInt_From_int, 0, 1, 1) < 0)) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":8
  * OBJECT_TYPE = []
  * 
  * def _register_object(int index, object cls):             # <<<<<<<<<<<<<<
  *     """register object class"""
@@ -4886,32 +2724,32 @@
   PyObject *__pyx_v_cls = 0;
   PyObject *__pyx_v_obj = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
+  PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("make_ret_object", 1);
+  __Pyx_RefNannySetupContext("make_ret_object", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":20
  *     cdef list object_type
  *     cdef object cls
  *     object_type = OBJECT_TYPE             # <<<<<<<<<<<<<<
  *     CALL(DGLObjectGetTypeIndex(chandle, &tindex))
  *     if tindex < len(object_type):
  */
   __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_OBJECT_TYPE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 20, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(PyList_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None) || __Pyx_RaiseUnexpectedTypeError("list", __pyx_t_1))) __PYX_ERR(0, 20, __pyx_L1_error)
+  if (!(likely(PyList_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "list", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 20, __pyx_L1_error)
   __pyx_v_object_type = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":21
  *     cdef object cls
  *     object_type = OBJECT_TYPE
  *     CALL(DGLObjectGetTypeIndex(chandle, &tindex))             # <<<<<<<<<<<<<<
@@ -4929,16 +2767,16 @@
  *         cls = object_type[tindex]
  *         if cls is not None:
  */
   if (unlikely(__pyx_v_object_type == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(0, 22, __pyx_L1_error)
   }
-  __pyx_t_2 = __Pyx_PyList_GET_SIZE(__pyx_v_object_type); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 22, __pyx_L1_error)
-  __pyx_t_3 = (__pyx_v_tindex < __pyx_t_2);
+  __pyx_t_2 = PyList_GET_SIZE(__pyx_v_object_type); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 22, __pyx_L1_error)
+  __pyx_t_3 = ((__pyx_v_tindex < __pyx_t_2) != 0);
   if (__pyx_t_3) {
 
     /* "dgl/_ffi/_cython/object.pxi":23
  *     CALL(DGLObjectGetTypeIndex(chandle, &tindex))
  *     if tindex < len(object_type):
  *         cls = object_type[tindex]             # <<<<<<<<<<<<<<
  *         if cls is not None:
@@ -4957,47 +2795,41 @@
  *     if tindex < len(object_type):
  *         cls = object_type[tindex]
  *         if cls is not None:             # <<<<<<<<<<<<<<
  *             obj = cls.__new__(cls)
  *         else:
  */
     __pyx_t_3 = (__pyx_v_cls != Py_None);
-    if (__pyx_t_3) {
+    __pyx_t_4 = (__pyx_t_3 != 0);
+    if (__pyx_t_4) {
 
       /* "dgl/_ffi/_cython/object.pxi":25
  *         cls = object_type[tindex]
  *         if cls is not None:
  *             obj = cls.__new__(cls)             # <<<<<<<<<<<<<<
  *         else:
  *             obj = ObjectBase.__new__(ObjectBase)
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_new); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 25, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = NULL;
-      __pyx_t_6 = 0;
-      #if CYTHON_UNPACK_METHODS
-      if (likely(PyMethod_Check(__pyx_t_4))) {
-        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
-        if (likely(__pyx_t_5)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-          __Pyx_INCREF(__pyx_t_5);
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_new); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 25, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
+        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+        if (likely(__pyx_t_6)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+          __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_4, function);
-          __pyx_t_6 = 1;
+          __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
-      #endif
-      {
-        PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_v_cls};
-        __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      }
+      __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_cls) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_cls);
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_obj = __pyx_t_1;
       __pyx_t_1 = 0;
 
       /* "dgl/_ffi/_cython/object.pxi":24
  *     if tindex < len(object_type):
  *         cls = object_type[tindex]
  *         if cls is not None:             # <<<<<<<<<<<<<<
@@ -5012,15 +2844,15 @@
  *         else:
  *             obj = ObjectBase.__new__(ObjectBase)             # <<<<<<<<<<<<<<
  *     else:
  *         obj = ObjectBase.__new__(ObjectBase)
  */
     /*else*/ {
       __pyx_t_1 = ((PyObject *)__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_ObjectBase(((PyTypeObject *)__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase), __pyx_empty_tuple, NULL)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)
-      __Pyx_GOTREF((PyObject *)__pyx_t_1);
+      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
       __pyx_v_obj = ((PyObject *)__pyx_t_1);
       __pyx_t_1 = 0;
     }
     __pyx_L4:;
 
     /* "dgl/_ffi/_cython/object.pxi":22
  *     object_type = OBJECT_TYPE
@@ -5037,15 +2869,15 @@
  *     else:
  *         obj = ObjectBase.__new__(ObjectBase)             # <<<<<<<<<<<<<<
  *     (<ObjectBase>obj).chandle = chandle
  *     return obj
  */
   /*else*/ {
     __pyx_t_1 = ((PyObject *)__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_ObjectBase(((PyTypeObject *)__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase), __pyx_empty_tuple, NULL)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
-    __Pyx_GOTREF((PyObject *)__pyx_t_1);
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
     __pyx_v_obj = ((PyObject *)__pyx_t_1);
     __pyx_t_1 = 0;
   }
   __pyx_L3:;
 
   /* "dgl/_ffi/_cython/object.pxi":30
  *     else:
@@ -5075,16 +2907,16 @@
  *     global OBJECT_TYPE
  *     cdef int tindex
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.make_ret_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_object_type);
   __Pyx_XDECREF(__pyx_v_cls);
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XGIVEREF(__pyx_r);
@@ -5101,30 +2933,32 @@
  */
 
 static PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_10ObjectBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_handle) {
   unsigned PY_LONG_LONG __pyx_v_ptr;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  unsigned PY_LONG_LONG __pyx_t_3;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  unsigned PY_LONG_LONG __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_set_handle", 1);
+  __Pyx_RefNannySetupContext("_set_handle", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":39
  *     cdef _set_handle(self, handle):
  *         cdef unsigned long long ptr
  *         if handle is None:             # <<<<<<<<<<<<<<
  *             self.chandle = NULL
  *         else:
  */
   __pyx_t_1 = (__pyx_v_handle == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/object.pxi":40
  *         cdef unsigned long long ptr
  *         if handle is None:
  *             self.chandle = NULL             # <<<<<<<<<<<<<<
  *         else:
  *             ptr = handle.value
@@ -5145,19 +2979,19 @@
  *             self.chandle = NULL
  *         else:
  *             ptr = handle.value             # <<<<<<<<<<<<<<
  *             self.chandle = <void*>(ptr)
  * 
  */
   /*else*/ {
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_handle, __pyx_n_s_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 42, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_2); if (unlikely((__pyx_t_3 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_ptr = __pyx_t_3;
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_handle, __pyx_n_s_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 42, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_3); if (unlikely((__pyx_t_4 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_v_ptr = __pyx_t_4;
 
     /* "dgl/_ffi/_cython/object.pxi":43
  *         else:
  *             ptr = handle.value
  *             self.chandle = <void*>(ptr)             # <<<<<<<<<<<<<<
  * 
  *     property handle:
@@ -5174,15 +3008,15 @@
  *         if handle is None:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.ObjectBase._set_handle", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -5194,19 +3028,17 @@
  *             if self.chandle == NULL:
  *                 return None
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle___get__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -5214,24 +3046,24 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 1);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":47
  *     property handle:
  *         def __get__(self):
  *             if self.chandle == NULL:             # <<<<<<<<<<<<<<
  *                 return None
  *             else:
  */
-  __pyx_t_1 = (__pyx_v_self->chandle == NULL);
+  __pyx_t_1 = ((__pyx_v_self->chandle == NULL) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/object.pxi":48
  *         def __get__(self):
  *             if self.chandle == NULL:
  *                 return None             # <<<<<<<<<<<<<<
  *             else:
@@ -5292,34 +3124,32 @@
  *             self._set_handle(value)
  * 
  */
 
 /* Python wrapper */
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_2__set__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6handle_2__set__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_value) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__set__", 1);
+  __Pyx_RefNannySetupContext("__set__", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":53
  * 
  *         def __set__(self, value):
  *             self._set_handle(value)             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
@@ -5355,31 +3185,29 @@
  *         CALL(DGLObjectFree(self.chandle))
  * 
  */
 
 /* Python wrapper */
 static void __pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_1__dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_1__dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase___dealloc__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase___dealloc__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__dealloc__", 1);
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":56
  * 
  *     def __dealloc__(self):
  *         CALL(DGLObjectFree(self.chandle))             # <<<<<<<<<<<<<<
  * 
  *     def __getattr__(self, name):
@@ -5412,19 +3240,17 @@
  *         cdef DGLValue ret_val
  *         cdef int ret_type_code, ret_succ
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_3__getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_name); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_3__getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_name) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getattr__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_2__getattr__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self), ((PyObject *)__pyx_v_name));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -5439,15 +3265,15 @@
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   Py_UCS4 __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__getattr__", 1);
+  __Pyx_RefNannySetupContext("__getattr__", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":61
  *         cdef DGLValue ret_val
  *         cdef int ret_type_code, ret_succ
  *         CALL(DGLObjectGetAttr(self.chandle, c_str(name),             # <<<<<<<<<<<<<<
  *                             &ret_val, &ret_type_code, &ret_succ))
  *         if ret_succ == 0:
@@ -5471,15 +3297,15 @@
   /* "dgl/_ffi/_cython/object.pxi":63
  *         CALL(DGLObjectGetAttr(self.chandle, c_str(name),
  *                             &ret_val, &ret_type_code, &ret_succ))
  *         if ret_succ == 0:             # <<<<<<<<<<<<<<
  *             raise AttributeError(
  *                 "'%s' object has no attribute '%s'" % (type(self), name))
  */
-  __pyx_t_4 = (__pyx_v_ret_succ == 0);
+  __pyx_t_4 = ((__pyx_v_ret_succ == 0) != 0);
   if (unlikely(__pyx_t_4)) {
 
     /* "dgl/_ffi/_cython/object.pxi":65
  *         if ret_succ == 0:
  *             raise AttributeError(
  *                 "'%s' object has no attribute '%s'" % (type(self), name))             # <<<<<<<<<<<<<<
  *         return make_ret(ret_val, ret_type_code)
@@ -5581,129 +3407,90 @@
  * 
  *     def __init_handle_by_constructor__(self, fconstructor, *args):             # <<<<<<<<<<<<<<
  *         """Initialize the handle by calling constructor function.
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-PyDoc_STRVAR(__pyx_doc_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__, "Initialize the handle by calling constructor function.\n\n        Parameters\n        ----------\n        fconstructor : Function\n            Constructor function.\n\n        args: list of objects\n            The arguments to the constructor\n\n        Note\n        ----\n        We have a special calling convention to call constructor functions.\n        So the return handle is directly set into the Object object\n        instead of creating a new Object.\n        ");
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__ = {"__init_handle_by_constructor__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__[] = "Initialize the handle by calling constructor function.\n\n        Parameters\n        ----------\n        fconstructor : Function\n            Constructor function.\n\n        args: list of objects\n            The arguments to the constructor\n\n        Note\n        ----\n        We have a special calling convention to call constructor functions.\n        So the return handle is directly set into the Object object\n        instead of creating a new Object.\n        ";
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_fconstructor = 0;
   PyObject *__pyx_v_args = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init_handle_by_constructor__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  __pyx_v_args = __Pyx_ArgsSlice_FASTCALL(__pyx_args, 1, __pyx_nargs);
-  if (unlikely(!__pyx_v_args)) {
-    __Pyx_RefNannyFinishContext();
-    return NULL;
+  if (PyTuple_GET_SIZE(__pyx_args) > 1) {
+    __pyx_v_args = PyTuple_GetSlice(__pyx_args, 1, PyTuple_GET_SIZE(__pyx_args));
+    if (unlikely(!__pyx_v_args)) {
+      __Pyx_RefNannyFinishContext();
+      return NULL;
+    }
+    __Pyx_GOTREF(__pyx_v_args);
+  } else {
+    __pyx_v_args = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);
   }
-  __Pyx_GOTREF(__pyx_v_args);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_fconstructor,0};
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_fconstructor,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
         default:
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_fconstructor)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 68, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fconstructor)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        const Py_ssize_t used_pos_args = (kwd_pos_args < 1) ? kwd_pos_args : 1;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, used_pos_args, "__init_handle_by_constructor__") < 0)) __PYX_ERR(0, 68, __pyx_L3_error)
+        const Py_ssize_t used_pos_args = (pos_args < 1) ? pos_args : 1;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, used_pos_args, "__init_handle_by_constructor__") < 0)) __PYX_ERR(0, 68, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs < 1)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) < 1) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_fconstructor = values[0];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init_handle_by_constructor__", 0, 1, 1, __pyx_nargs); __PYX_ERR(0, 68, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init_handle_by_constructor__", 0, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 68, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_DECREF(__pyx_v_args); __pyx_v_args = 0;
   __Pyx_AddTraceback("dgl._ffi._cy3.core.ObjectBase.__init_handle_by_constructor__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self), __pyx_v_fconstructor, __pyx_v_args);
 
   /* function exit code */
-  __Pyx_DECREF(__pyx_v_args);
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
+  __Pyx_XDECREF(__pyx_v_args);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, PyObject *__pyx_v_fconstructor, PyObject *__pyx_v_args) {
   void *__pyx_v_chandle;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init_handle_by_constructor__", 1);
+  __Pyx_RefNannySetupContext("__init_handle_by_constructor__", 0);
 
   /* "dgl/_ffi/_cython/object.pxi":86
  *         """
  *         cdef void* chandle
  *         ConstructorCall(             # <<<<<<<<<<<<<<
  *             (<FunctionBase>fconstructor).chandle,
  *             kObjectHandle, args, &chandle)
@@ -5737,219 +3524,118 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__ = {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6__reduce_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__reduce_cython__", 1);
+  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_self_chandle_cannot_be_converted, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.ObjectBase.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__ = {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.ObjectBase.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_8__setstate_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_8__setstate_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10ObjectBase_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__setstate_cython__", 1);
+  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_self_chandle_cannot_be_converted, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.ObjectBase.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -5961,15 +3647,15 @@
  *     Py_DECREF(local_pyfunc)
  */
 
 static void __pyx_f_3dgl_4_ffi_4_cy3_4core_dgl_callback_finalize(void *__pyx_v_fhandle) {
   PyObject *__pyx_v_local_pyfunc = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  __Pyx_RefNannySetupContext("dgl_callback_finalize", 1);
+  __Pyx_RefNannySetupContext("dgl_callback_finalize", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":13
  * 
  * cdef void dgl_callback_finalize(void* fhandle):
  *     local_pyfunc = <object>(fhandle)             # <<<<<<<<<<<<<<
  *     Py_DECREF(local_pyfunc)
  * 
@@ -6101,57 +3787,57 @@
     /* "dgl/_ffi/_cython/function.pxi":29
  *         value = args[i]
  *         tcode = type_codes[i]
  *         if (tcode == kObjectHandle or             # <<<<<<<<<<<<<<
  *             tcode == kFuncHandle or
  *             tcode == kModuleHandle or
  */
-    __pyx_t_6 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectHandle);
+    __pyx_t_6 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectHandle) != 0);
     if (!__pyx_t_6) {
     } else {
       __pyx_t_5 = __pyx_t_6;
       goto __pyx_L6_bool_binop_done;
     }
 
     /* "dgl/_ffi/_cython/function.pxi":30
  *         tcode = type_codes[i]
  *         if (tcode == kObjectHandle or
  *             tcode == kFuncHandle or             # <<<<<<<<<<<<<<
  *             tcode == kModuleHandle or
  *             tcode > kExtBegin):
  */
-    __pyx_t_6 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kFuncHandle);
+    __pyx_t_6 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kFuncHandle) != 0);
     if (!__pyx_t_6) {
     } else {
       __pyx_t_5 = __pyx_t_6;
       goto __pyx_L6_bool_binop_done;
     }
 
     /* "dgl/_ffi/_cython/function.pxi":31
  *         if (tcode == kObjectHandle or
  *             tcode == kFuncHandle or
  *             tcode == kModuleHandle or             # <<<<<<<<<<<<<<
  *             tcode > kExtBegin):
  *             CALL(DGLCbArgToReturn(&value, tcode))
  */
-    __pyx_t_6 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kModuleHandle);
+    __pyx_t_6 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kModuleHandle) != 0);
     if (!__pyx_t_6) {
     } else {
       __pyx_t_5 = __pyx_t_6;
       goto __pyx_L6_bool_binop_done;
     }
 
     /* "dgl/_ffi/_cython/function.pxi":32
  *             tcode == kFuncHandle or
  *             tcode == kModuleHandle or
  *             tcode > kExtBegin):             # <<<<<<<<<<<<<<
  *             CALL(DGLCbArgToReturn(&value, tcode))
  * 
  */
-    __pyx_t_6 = (__pyx_v_tcode > __pyx_e_3dgl_4_ffi_4_cy3_4core_kExtBegin);
+    __pyx_t_6 = ((__pyx_v_tcode > __pyx_e_3dgl_4_ffi_4_cy3_4core_kExtBegin) != 0);
     __pyx_t_5 = __pyx_t_6;
     __pyx_L6_bool_binop_done:;
 
     /* "dgl/_ffi/_cython/function.pxi":29
  *         value = args[i]
  *         tcode = type_codes[i]
  *         if (tcode == kObjectHandle or             # <<<<<<<<<<<<<<
@@ -6183,15 +3869,15 @@
     /* "dgl/_ffi/_cython/function.pxi":35
  *             CALL(DGLCbArgToReturn(&value, tcode))
  * 
  *         if tcode != kArrayHandle:             # <<<<<<<<<<<<<<
  *             pyargs.append(make_ret(value, tcode))
  *         else:
  */
-    __pyx_t_5 = (__pyx_v_tcode != __pyx_e_3dgl_4_ffi_4_cy3_4core_kArrayHandle);
+    __pyx_t_5 = ((__pyx_v_tcode != __pyx_e_3dgl_4_ffi_4_cy3_4core_kArrayHandle) != 0);
     if (__pyx_t_5) {
 
       /* "dgl/_ffi/_cython/function.pxi":36
  * 
  *         if tcode != kArrayHandle:
  *             pyargs.append(make_ret(value, tcode))             # <<<<<<<<<<<<<<
  *         else:
@@ -6282,52 +3968,45 @@
  *         msg = traceback.format_exc()
  *         DGLAPISetLastError(c_str(msg))
  */
     __pyx_t_2 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_2) {
       __Pyx_AddTraceback("dgl._ffi._cy3.core.dgl_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_11, &__pyx_t_1, &__pyx_t_12) < 0) __PYX_ERR(2, 41, __pyx_L13_except_error)
-      __Pyx_XGOTREF(__pyx_t_11);
-      __Pyx_XGOTREF(__pyx_t_1);
-      __Pyx_XGOTREF(__pyx_t_12);
+      __Pyx_GOTREF(__pyx_t_11);
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_GOTREF(__pyx_t_12);
 
       /* "dgl/_ffi/_cython/function.pxi":42
  *         rv = local_pyfunc(*pyargs)
  *     except Exception:
  *         msg = traceback.format_exc()             # <<<<<<<<<<<<<<
  *         DGLAPISetLastError(c_str(msg))
  *         return -1
  */
       __Pyx_GetModuleGlobalName(__pyx_t_14, __pyx_n_s_traceback); if (unlikely(!__pyx_t_14)) __PYX_ERR(2, 42, __pyx_L13_except_error)
       __Pyx_GOTREF(__pyx_t_14);
       __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_format_exc); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 42, __pyx_L13_except_error)
       __Pyx_GOTREF(__pyx_t_15);
       __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
       __pyx_t_14 = NULL;
-      __pyx_t_2 = 0;
-      #if CYTHON_UNPACK_METHODS
-      if (unlikely(PyMethod_Check(__pyx_t_15))) {
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_15))) {
         __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_15);
         if (likely(__pyx_t_14)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
           __Pyx_INCREF(__pyx_t_14);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_15, function);
-          __pyx_t_2 = 1;
         }
       }
-      #endif
-      {
-        PyObject *__pyx_callargs[2] = {__pyx_t_14, NULL};
-        __pyx_t_13 = __Pyx_PyObject_FastCall(__pyx_t_15, __pyx_callargs+1-__pyx_t_2, 0+__pyx_t_2);
-        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
-        if (unlikely(!__pyx_t_13)) __PYX_ERR(2, 42, __pyx_L13_except_error)
-        __Pyx_GOTREF(__pyx_t_13);
-        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-      }
+      __pyx_t_13 = (__pyx_t_14) ? __Pyx_PyObject_CallOneArg(__pyx_t_15, __pyx_t_14) : __Pyx_PyObject_CallNoArg(__pyx_t_15);
+      __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
+      if (unlikely(!__pyx_t_13)) __PYX_ERR(2, 42, __pyx_L13_except_error)
+      __Pyx_GOTREF(__pyx_t_13);
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
       __pyx_v_msg = __pyx_t_13;
       __pyx_t_13 = 0;
 
       /* "dgl/_ffi/_cython/function.pxi":43
  *     except Exception:
  *         msg = traceback.format_exc()
  *         DGLAPISetLastError(c_str(msg))             # <<<<<<<<<<<<<<
@@ -6350,23 +4029,23 @@
       __pyx_r = -1;
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
       __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
       goto __pyx_L14_except_return;
     }
     goto __pyx_L13_except_error;
+    __pyx_L13_except_error:;
 
     /* "dgl/_ffi/_cython/function.pxi":39
  *         else:
  *             pyargs.append(c_make_array(value.v_handle, True))
  *     try:             # <<<<<<<<<<<<<<
  *         rv = local_pyfunc(*pyargs)
  *     except Exception:
  */
-    __pyx_L13_except_error:;
     __Pyx_XGIVEREF(__pyx_t_8);
     __Pyx_XGIVEREF(__pyx_t_9);
     __Pyx_XGIVEREF(__pyx_t_10);
     __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
     goto __pyx_L1_error;
     __pyx_L14_except_return:;
     __Pyx_XGIVEREF(__pyx_t_8);
@@ -6381,34 +4060,36 @@
  *         DGLAPISetLastError(c_str(msg))
  *         return -1
  *     if rv is not None:             # <<<<<<<<<<<<<<
  *         if isinstance(rv, tuple):
  *             raise ValueError("PackedFunction can only support one return value")
  */
   __pyx_t_5 = (__pyx_v_rv != Py_None);
-  if (__pyx_t_5) {
+  __pyx_t_6 = (__pyx_t_5 != 0);
+  if (__pyx_t_6) {
 
     /* "dgl/_ffi/_cython/function.pxi":46
  *         return -1
  *     if rv is not None:
  *         if isinstance(rv, tuple):             # <<<<<<<<<<<<<<
  *             raise ValueError("PackedFunction can only support one return value")
  *         temp_args = []
  */
-    __pyx_t_5 = PyTuple_Check(__pyx_v_rv); 
+    __pyx_t_6 = PyTuple_Check(__pyx_v_rv); 
+    __pyx_t_5 = (__pyx_t_6 != 0);
     if (unlikely(__pyx_t_5)) {
 
       /* "dgl/_ffi/_cython/function.pxi":47
  *     if rv is not None:
  *         if isinstance(rv, tuple):
  *             raise ValueError("PackedFunction can only support one return value")             # <<<<<<<<<<<<<<
  *         temp_args = []
  *         make_arg(rv, &value, &tcode, temp_args)
  */
-      __pyx_t_12 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(2, 47, __pyx_L1_error)
+      __pyx_t_12 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(2, 47, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_12);
       __Pyx_Raise(__pyx_t_12, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
       __PYX_ERR(2, 47, __pyx_L1_error)
 
       /* "dgl/_ffi/_cython/function.pxi":46
  *         return -1
@@ -6482,16 +4163,16 @@
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_11);
   __Pyx_XDECREF(__pyx_t_12);
   __Pyx_XDECREF(__pyx_t_13);
   __Pyx_XDECREF(__pyx_t_14);
   __Pyx_XDECREF(__pyx_t_15);
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.dgl_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
+  __Pyx_WriteUnraisable("dgl._ffi._cy3.core.dgl_callback", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_pyargs);
   __Pyx_XDECREF(__pyx_v_local_pyfunc);
   __Pyx_XDECREF(__pyx_v_rv);
   __Pyx_XDECREF(__pyx_v_msg);
   __Pyx_XDECREF(__pyx_v_temp_args);
   __Pyx_RefNannyFinishContext();
@@ -6506,121 +4187,39 @@
  * 
  * def convert_to_dgl_func(object pyfunc):             # <<<<<<<<<<<<<<
  *     """Convert a python function to DGL function
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-PyDoc_STRVAR(__pyx_doc_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func, "Convert a python function to DGL function\n\n    Parameters\n    ----------\n    pyfunc : python function\n        The python function to be converted.\n\n    Returns\n    -------\n    dglfunc: dgl.Function\n        The converted dgl function.\n    ");
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func = {"convert_to_dgl_func", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v_pyfunc = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func(PyObject *__pyx_self, PyObject *__pyx_v_pyfunc); /*proto*/
+static char __pyx_doc_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func[] = "Convert a python function to DGL function\n\n    Parameters\n    ----------\n    pyfunc : python function\n        The python function to be converted.\n\n    Returns\n    -------\n    dglfunc: dgl.Function\n        The converted dgl function.\n    ";
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func = {"convert_to_dgl_func", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func, METH_O, __pyx_doc_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func(PyObject *__pyx_self, PyObject *__pyx_v_pyfunc) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("convert_to_dgl_func (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyfunc,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyfunc)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 54, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "convert_to_dgl_func") < 0)) __PYX_ERR(2, 54, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v_pyfunc = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("convert_to_dgl_func", 1, 1, 1, __pyx_nargs); __PYX_ERR(2, 54, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.convert_to_dgl_func", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func(__pyx_self, __pyx_v_pyfunc);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func(__pyx_self, ((PyObject *)__pyx_v_pyfunc));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_2convert_to_dgl_func(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_pyfunc) {
   __pyx_t_3dgl_4_ffi_4_cy3_4core_DGLFunctionHandle __pyx_v_chandle;
   PyObject *__pyx_v_ret = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("convert_to_dgl_func", 1);
+  __Pyx_RefNannySetupContext("convert_to_dgl_func", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":68
  *     """
  *     cdef DGLFunctionHandle chandle
  *     Py_INCREF(pyfunc)             # <<<<<<<<<<<<<<
  *     CALL(DGLFuncCreateFromCFunc(dgl_callback,
  *                                 <void*>(pyfunc),
@@ -6643,15 +4242,15 @@
  *                                 &chandle))
  *     ret = _CLASS_FUNCTION(None, False)             # <<<<<<<<<<<<<<
  *     (<FunctionBase>ret).chandle = chandle
  *     return ret
  */
   __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_CLASS_FUNCTION); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 73, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 73, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 73, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_ret = __pyx_t_2;
   __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":74
  *                                 &chandle))
@@ -6706,58 +4305,60 @@
 static CYTHON_INLINE int __pyx_f_3dgl_4_ffi_4_cy3_4core_make_arg(PyObject *__pyx_v_arg, DGLValue *__pyx_v_value, int *__pyx_v_tcode, PyObject *__pyx_v_temp_args) {
   unsigned PY_LONG_LONG __pyx_v_ptr;
   PyObject *__pyx_v_tstr = NULL;
   PyObject *__pyx_v_arr = NULL;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  void *__pyx_t_2;
-  DGLArray *__pyx_t_3;
-  enum __pyx_t_3dgl_4_ffi_4_cy3_4core_DGLObjectTypeCode __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  unsigned PY_LONG_LONG __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  int __pyx_t_8;
+  int __pyx_t_2;
+  void *__pyx_t_3;
+  DGLArray *__pyx_t_4;
+  enum __pyx_t_3dgl_4_ffi_4_cy3_4core_DGLObjectTypeCode __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  unsigned PY_LONG_LONG __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
   int __pyx_t_9;
-  int64_t __pyx_t_10;
-  double __pyx_t_11;
-  char const *__pyx_t_12;
-  int __pyx_t_13;
-  PyObject *__pyx_t_14 = NULL;
+  int __pyx_t_10;
+  int64_t __pyx_t_11;
+  double __pyx_t_12;
+  char const *__pyx_t_13;
+  int __pyx_t_14;
   PyObject *__pyx_t_15 = NULL;
   PyObject *__pyx_t_16 = NULL;
-  Py_ssize_t __pyx_t_17;
-  PyObject *__pyx_t_18 = NULL;
+  PyObject *__pyx_t_17 = NULL;
+  Py_ssize_t __pyx_t_18;
   PyObject *__pyx_t_19 = NULL;
-  __pyx_t_3dgl_4_ffi_4_cy3_4core_DGLFunctionHandle __pyx_t_20;
+  PyObject *__pyx_t_20 = NULL;
+  __pyx_t_3dgl_4_ffi_4_cy3_4core_DGLFunctionHandle __pyx_t_21;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("make_arg", 0);
   __Pyx_INCREF(__pyx_v_arg);
 
   /* "dgl/_ffi/_cython/function.pxi":84
  *     """Pack arguments into c args dgl call accept"""
  *     cdef unsigned long long ptr
  *     if isinstance(arg, ObjectBase):             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  *         tcode[0] = kObjectHandle
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_arg, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":85
  *     cdef unsigned long long ptr
  *     if isinstance(arg, ObjectBase):
  *         value[0].v_handle = (<ObjectBase>arg).chandle             # <<<<<<<<<<<<<<
  *         tcode[0] = kObjectHandle
  *     elif isinstance(arg, NDArrayBase):
  */
-    __pyx_t_2 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_arg)->chandle;
-    (__pyx_v_value[0]).v_handle = __pyx_t_2;
+    __pyx_t_3 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_arg)->chandle;
+    (__pyx_v_value[0]).v_handle = __pyx_t_3;
 
     /* "dgl/_ffi/_cython/function.pxi":86
  *     if isinstance(arg, ObjectBase):
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  *         tcode[0] = kObjectHandle             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, NDArrayBase):
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
@@ -6777,65 +4378,65 @@
   /* "dgl/_ffi/_cython/function.pxi":87
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  *         tcode[0] = kObjectHandle
  *     elif isinstance(arg, NDArrayBase):             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
  *         tcode[0] = (kNDArrayContainer if
  */
-  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_arg, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase); 
+  __pyx_t_2 = __Pyx_TypeCheck(__pyx_v_arg, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase); 
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":88
  *         tcode[0] = kObjectHandle
  *     elif isinstance(arg, NDArrayBase):
  *         value[0].v_handle = (<NDArrayBase>arg).chandle             # <<<<<<<<<<<<<<
  *         tcode[0] = (kNDArrayContainer if
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)
  */
-    __pyx_t_3 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_arg)->chandle;
-    (__pyx_v_value[0]).v_handle = __pyx_t_3;
+    __pyx_t_4 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_arg)->chandle;
+    (__pyx_v_value[0]).v_handle = __pyx_t_4;
 
     /* "dgl/_ffi/_cython/function.pxi":90
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
  *         tcode[0] = (kNDArrayContainer if
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, _DGL_COMPATS):
  *         ptr = arg._dgl_handle
  */
-    __pyx_t_1 = (!(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_arg)->c_is_view != 0));
-    if (__pyx_t_1) {
+    if (((!(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_arg)->c_is_view != 0)) != 0)) {
 
       /* "dgl/_ffi/_cython/function.pxi":89
  *     elif isinstance(arg, NDArrayBase):
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
  *         tcode[0] = (kNDArrayContainer if             # <<<<<<<<<<<<<<
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)
  *     elif isinstance(arg, _DGL_COMPATS):
  */
-      __pyx_t_4 = __pyx_e_3dgl_4_ffi_4_cy3_4core_kNDArrayContainer;
+      __pyx_t_5 = __pyx_e_3dgl_4_ffi_4_cy3_4core_kNDArrayContainer;
     } else {
 
       /* "dgl/_ffi/_cython/function.pxi":90
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
  *         tcode[0] = (kNDArrayContainer if
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, _DGL_COMPATS):
  *         ptr = arg._dgl_handle
  */
-      __pyx_t_4 = __pyx_e_3dgl_4_ffi_4_cy3_4core_kArrayHandle;
+      __pyx_t_5 = __pyx_e_3dgl_4_ffi_4_cy3_4core_kArrayHandle;
     }
 
     /* "dgl/_ffi/_cython/function.pxi":89
  *     elif isinstance(arg, NDArrayBase):
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
  *         tcode[0] = (kNDArrayContainer if             # <<<<<<<<<<<<<<
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)
  *     elif isinstance(arg, _DGL_COMPATS):
  */
-    (__pyx_v_tcode[0]) = __pyx_t_4;
+    (__pyx_v_tcode[0]) = __pyx_t_5;
 
     /* "dgl/_ffi/_cython/function.pxi":87
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  *         tcode[0] = kObjectHandle
  *     elif isinstance(arg, NDArrayBase):             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<NDArrayBase>arg).chandle
  *         tcode[0] = (kNDArrayContainer if
@@ -6846,32 +4447,33 @@
   /* "dgl/_ffi/_cython/function.pxi":91
  *         tcode[0] = (kNDArrayContainer if
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)
  *     elif isinstance(arg, _DGL_COMPATS):             # <<<<<<<<<<<<<<
  *         ptr = arg._dgl_handle
  *         value[0].v_handle = (<void*>ptr)
  */
-  __pyx_t_5 = __pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS;
-  __Pyx_INCREF(__pyx_t_5);
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_5); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 91, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (__pyx_t_1) {
+  __pyx_t_6 = __pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS;
+  __Pyx_INCREF(__pyx_t_6);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_6); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 91, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":92
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)
  *     elif isinstance(arg, _DGL_COMPATS):
  *         ptr = arg._dgl_handle             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<void*>ptr)
  *         tcode[0] = arg.__class__._dgl_tcode
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_arg, __pyx_n_s_dgl_handle); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 92, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_5); if (unlikely((__pyx_t_6 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(2, 92, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_v_ptr = __pyx_t_6;
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_arg, __pyx_n_s_dgl_handle); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_7 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_6); if (unlikely((__pyx_t_7 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(2, 92, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_v_ptr = __pyx_t_7;
 
     /* "dgl/_ffi/_cython/function.pxi":93
  *     elif isinstance(arg, _DGL_COMPATS):
  *         ptr = arg._dgl_handle
  *         value[0].v_handle = (<void*>ptr)             # <<<<<<<<<<<<<<
  *         tcode[0] = arg.__class__._dgl_tcode
  *     elif isinstance(arg, (int, long)):
@@ -6881,22 +4483,22 @@
     /* "dgl/_ffi/_cython/function.pxi":94
  *         ptr = arg._dgl_handle
  *         value[0].v_handle = (<void*>ptr)
  *         tcode[0] = arg.__class__._dgl_tcode             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, (int, long)):
  *         value[0].v_int64 = arg
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_arg, __pyx_n_s_class); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 94, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_dgl_tcode); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 94, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_t_7); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 94, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    (__pyx_v_tcode[0]) = __pyx_t_8;
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_arg, __pyx_n_s_class); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 94, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_dgl_tcode); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 94, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_t_8); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 94, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    (__pyx_v_tcode[0]) = __pyx_t_9;
 
     /* "dgl/_ffi/_cython/function.pxi":91
  *         tcode[0] = (kNDArrayContainer if
  *                     not (<NDArrayBase>arg).c_is_view else kArrayHandle)
  *     elif isinstance(arg, _DGL_COMPATS):             # <<<<<<<<<<<<<<
  *         ptr = arg._dgl_handle
  *         value[0].v_handle = (<void*>ptr)
@@ -6907,34 +4509,37 @@
   /* "dgl/_ffi/_cython/function.pxi":95
  *         value[0].v_handle = (<void*>ptr)
  *         tcode[0] = arg.__class__._dgl_tcode
  *     elif isinstance(arg, (int, long)):             # <<<<<<<<<<<<<<
  *         value[0].v_int64 = arg
  *         tcode[0] = kObjectInt
  */
-  __pyx_t_9 = PyInt_Check(__pyx_v_arg); 
-  if (!__pyx_t_9) {
+  __pyx_t_1 = PyInt_Check(__pyx_v_arg); 
+  __pyx_t_10 = (__pyx_t_1 != 0);
+  if (!__pyx_t_10) {
   } else {
-    __pyx_t_1 = __pyx_t_9;
+    __pyx_t_2 = __pyx_t_10;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_9 = PyLong_Check(__pyx_v_arg); 
-  __pyx_t_1 = __pyx_t_9;
+  __pyx_t_10 = PyLong_Check(__pyx_v_arg); 
+  __pyx_t_1 = (__pyx_t_10 != 0);
+  __pyx_t_2 = __pyx_t_1;
   __pyx_L4_bool_binop_done:;
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":96
  *         tcode[0] = arg.__class__._dgl_tcode
  *     elif isinstance(arg, (int, long)):
  *         value[0].v_int64 = arg             # <<<<<<<<<<<<<<
  *         tcode[0] = kObjectInt
  *     elif isinstance(arg, float):
  */
-    __pyx_t_10 = __Pyx_PyInt_As_int64_t(__pyx_v_arg); if (unlikely((__pyx_t_10 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(2, 96, __pyx_L1_error)
-    (__pyx_v_value[0]).v_int64 = __pyx_t_10;
+    __pyx_t_11 = __Pyx_PyInt_As_int64_t(__pyx_v_arg); if (unlikely((__pyx_t_11 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(2, 96, __pyx_L1_error)
+    (__pyx_v_value[0]).v_int64 = __pyx_t_11;
 
     /* "dgl/_ffi/_cython/function.pxi":97
  *     elif isinstance(arg, (int, long)):
  *         value[0].v_int64 = arg
  *         tcode[0] = kObjectInt             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, float):
  *         value[0].v_float64 = arg
@@ -6955,25 +4560,26 @@
  *         value[0].v_int64 = arg
  *         tcode[0] = kObjectInt
  *     elif isinstance(arg, float):             # <<<<<<<<<<<<<<
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat
  */
   __pyx_t_1 = PyFloat_Check(__pyx_v_arg); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":99
  *         tcode[0] = kObjectInt
  *     elif isinstance(arg, float):
  *         value[0].v_float64 = arg             # <<<<<<<<<<<<<<
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, str):
  */
-    __pyx_t_11 = __pyx_PyFloat_AsDouble(__pyx_v_arg); if (unlikely((__pyx_t_11 == (double)-1) && PyErr_Occurred())) __PYX_ERR(2, 99, __pyx_L1_error)
-    (__pyx_v_value[0]).v_float64 = __pyx_t_11;
+    __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_v_arg); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(2, 99, __pyx_L1_error)
+    (__pyx_v_value[0]).v_float64 = __pyx_t_12;
 
     /* "dgl/_ffi/_cython/function.pxi":100
  *     elif isinstance(arg, float):
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, str):
  *         tstr = c_str(arg)
@@ -6993,38 +4599,39 @@
   /* "dgl/_ffi/_cython/function.pxi":101
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, str):             # <<<<<<<<<<<<<<
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr
  */
-  __pyx_t_1 = PyUnicode_Check(__pyx_v_arg); 
+  __pyx_t_2 = PyUnicode_Check(__pyx_v_arg); 
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":102
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, str):
  *         tstr = c_str(arg)             # <<<<<<<<<<<<<<
  *         value[0].v_str = tstr
  *         tcode[0] = kStr
  */
-    __pyx_t_7 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(__pyx_v_arg); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 102, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_v_tstr = __pyx_t_7;
-    __pyx_t_7 = 0;
+    __pyx_t_8 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(__pyx_v_arg); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 102, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_v_tstr = __pyx_t_8;
+    __pyx_t_8 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":103
  *     elif isinstance(arg, str):
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr             # <<<<<<<<<<<<<<
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  */
-    __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_tstr); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(2, 103, __pyx_L1_error)
-    (__pyx_v_value[0]).v_str = __pyx_t_12;
+    __pyx_t_13 = __Pyx_PyObject_AsString(__pyx_v_tstr); if (unlikely((!__pyx_t_13) && PyErr_Occurred())) __PYX_ERR(2, 103, __pyx_L1_error)
+    (__pyx_v_value[0]).v_str = __pyx_t_13;
 
     /* "dgl/_ffi/_cython/function.pxi":104
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr
  *         tcode[0] = kStr             # <<<<<<<<<<<<<<
  *         temp_args.append(tstr)
  *     elif arg is None:
@@ -7038,15 +4645,15 @@
  *     elif arg is None:
  *         value[0].v_handle = NULL
  */
     if (unlikely(__pyx_v_temp_args == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "append");
       __PYX_ERR(2, 105, __pyx_L1_error)
     }
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_tstr); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(2, 105, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_tstr); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(2, 105, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":101
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, str):             # <<<<<<<<<<<<<<
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr
@@ -7058,15 +4665,16 @@
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  *     elif arg is None:             # <<<<<<<<<<<<<<
  *         value[0].v_handle = NULL
  *         tcode[0] = kNull
  */
   __pyx_t_1 = (__pyx_v_arg == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":107
  *         temp_args.append(tstr)
  *     elif arg is None:
  *         value[0].v_handle = NULL             # <<<<<<<<<<<<<<
  *         tcode[0] = kNull
  *     elif isinstance(arg, Number):
@@ -7095,29 +4703,30 @@
   /* "dgl/_ffi/_cython/function.pxi":109
  *         value[0].v_handle = NULL
  *         tcode[0] = kNull
  *     elif isinstance(arg, Number):             # <<<<<<<<<<<<<<
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_Number); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 109, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_7); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 109, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_Number); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 109, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_8); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(2, 109, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":110
  *         tcode[0] = kNull
  *     elif isinstance(arg, Number):
  *         value[0].v_float64 = arg             # <<<<<<<<<<<<<<
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, CTypesDGLDataType):
  */
-    __pyx_t_11 = __pyx_PyFloat_AsDouble(__pyx_v_arg); if (unlikely((__pyx_t_11 == (double)-1) && PyErr_Occurred())) __PYX_ERR(2, 110, __pyx_L1_error)
-    (__pyx_v_value[0]).v_float64 = __pyx_t_11;
+    __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_v_arg); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(2, 110, __pyx_L1_error)
+    (__pyx_v_value[0]).v_float64 = __pyx_t_12;
 
     /* "dgl/_ffi/_cython/function.pxi":111
  *     elif isinstance(arg, Number):
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, CTypesDGLDataType):
  *         tstr = c_str(str(arg))
@@ -7137,44 +4746,45 @@
   /* "dgl/_ffi/_cython/function.pxi":112
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, CTypesDGLDataType):             # <<<<<<<<<<<<<<
  *         tstr = c_str(str(arg))
  *         value[0].v_str = tstr
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_CTypesDGLDataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 112, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_7); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 112, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (__pyx_t_1) {
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_CTypesDGLDataType); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 112, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_8); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 112, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":113
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, CTypesDGLDataType):
  *         tstr = c_str(str(arg))             # <<<<<<<<<<<<<<
  *         value[0].v_str = tstr
  *         tcode[0] = kStr
  */
-    __pyx_t_7 = __Pyx_PyObject_Str(__pyx_v_arg); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 113, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_5 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 113, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_v_tstr = __pyx_t_5;
-    __pyx_t_5 = 0;
+    __pyx_t_8 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_arg); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 113, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_6 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 113, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_v_tstr = __pyx_t_6;
+    __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":114
  *     elif isinstance(arg, CTypesDGLDataType):
  *         tstr = c_str(str(arg))
  *         value[0].v_str = tstr             # <<<<<<<<<<<<<<
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  */
-    __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_tstr); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(2, 114, __pyx_L1_error)
-    (__pyx_v_value[0]).v_str = __pyx_t_12;
+    __pyx_t_13 = __Pyx_PyObject_AsString(__pyx_v_tstr); if (unlikely((!__pyx_t_13) && PyErr_Occurred())) __PYX_ERR(2, 114, __pyx_L1_error)
+    (__pyx_v_value[0]).v_str = __pyx_t_13;
 
     /* "dgl/_ffi/_cython/function.pxi":115
  *         tstr = c_str(str(arg))
  *         value[0].v_str = tstr
  *         tcode[0] = kStr             # <<<<<<<<<<<<<<
  *         temp_args.append(tstr)
  *     elif isinstance(arg, CTypesDGLContext):
@@ -7188,15 +4798,15 @@
  *     elif isinstance(arg, CTypesDGLContext):
  *         value[0].v_ctx = (<DGLContext*>(
  */
     if (unlikely(__pyx_v_temp_args == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "append");
       __PYX_ERR(2, 116, __pyx_L1_error)
     }
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_tstr); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(2, 116, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_tstr); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(2, 116, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":112
  *         value[0].v_float64 = arg
  *         tcode[0] = kObjectFloat
  *     elif isinstance(arg, CTypesDGLDataType):             # <<<<<<<<<<<<<<
  *         tstr = c_str(str(arg))
  *         value[0].v_str = tstr
@@ -7207,65 +4817,59 @@
   /* "dgl/_ffi/_cython/function.pxi":117
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  *     elif isinstance(arg, CTypesDGLContext):             # <<<<<<<<<<<<<<
  *         value[0].v_ctx = (<DGLContext*>(
  *             <unsigned long long>ctypes.addressof(arg)))[0]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CTypesDGLContext); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 117, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_5); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 117, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CTypesDGLContext); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 117, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_6); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(2, 117, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":119
  *     elif isinstance(arg, CTypesDGLContext):
  *         value[0].v_ctx = (<DGLContext*>(
  *             <unsigned long long>ctypes.addressof(arg)))[0]             # <<<<<<<<<<<<<<
  *         tcode[0] = kDGLContext
  *     elif isinstance(arg, bytearray):
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 119, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_addressof); if (unlikely(!__pyx_t_14)) __PYX_ERR(2, 119, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_14);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_14))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_14);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
-        __Pyx_INCREF(__pyx_t_7);
+    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 119, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_addressof); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 119, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_15))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_15);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_14, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_15, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_v_arg};
-      __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_14, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 119, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
-    }
-    __pyx_t_6 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_5); if (unlikely((__pyx_t_6 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(2, 119, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_15, __pyx_t_8, __pyx_v_arg) : __Pyx_PyObject_CallOneArg(__pyx_t_15, __pyx_v_arg);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 119, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __pyx_t_7 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_6); if (unlikely((__pyx_t_7 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(2, 119, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":118
  *         temp_args.append(tstr)
  *     elif isinstance(arg, CTypesDGLContext):
  *         value[0].v_ctx = (<DGLContext*>(             # <<<<<<<<<<<<<<
  *             <unsigned long long>ctypes.addressof(arg)))[0]
  *         tcode[0] = kDGLContext
  */
-    (__pyx_v_value[0]).v_ctx = (((DGLContext *)((unsigned PY_LONG_LONG)__pyx_t_6))[0]);
+    (__pyx_v_value[0]).v_ctx = (((DGLContext *)((unsigned PY_LONG_LONG)__pyx_t_7))[0]);
 
     /* "dgl/_ffi/_cython/function.pxi":120
  *         value[0].v_ctx = (<DGLContext*>(
  *             <unsigned long long>ctypes.addressof(arg)))[0]
  *         tcode[0] = kDGLContext             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, bytearray):
  *         arr = DGLByteArray()
@@ -7286,241 +4890,239 @@
  *             <unsigned long long>ctypes.addressof(arg)))[0]
  *         tcode[0] = kDGLContext
  *     elif isinstance(arg, bytearray):             # <<<<<<<<<<<<<<
  *         arr = DGLByteArray()
  *         arr.data = ctypes.cast(
  */
   __pyx_t_1 = PyByteArray_Check(__pyx_v_arg); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":122
  *         tcode[0] = kDGLContext
  *     elif isinstance(arg, bytearray):
  *         arr = DGLByteArray()             # <<<<<<<<<<<<<<
  *         arr.data = ctypes.cast(
  *             (ctypes.c_byte * len(arg)).from_buffer(arg),
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_14, __pyx_n_s_DGLByteArray); if (unlikely(!__pyx_t_14)) __PYX_ERR(2, 122, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_14);
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_14))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_14);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
-        __Pyx_INCREF(__pyx_t_7);
+    __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_DGLByteArray); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 122, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_15))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_15);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_14, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_15, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, NULL};
-      __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_14, __pyx_callargs+1-__pyx_t_8, 0+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 122, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
-    }
-    __pyx_v_arr = __pyx_t_5;
-    __pyx_t_5 = 0;
+    __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_15, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_15);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 122, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __pyx_v_arr = __pyx_t_6;
+    __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":123
  *     elif isinstance(arg, bytearray):
  *         arr = DGLByteArray()
  *         arr.data = ctypes.cast(             # <<<<<<<<<<<<<<
  *             (ctypes.c_byte * len(arg)).from_buffer(arg),
  *             ctypes.POINTER(ctypes.c_byte))
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_14, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_14)) __PYX_ERR(2, 123, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_14);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_cast); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 123, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+    __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 123, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_15, __pyx_n_s_cast); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 123, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":124
  *         arr = DGLByteArray()
  *         arr.data = ctypes.cast(
  *             (ctypes.c_byte * len(arg)).from_buffer(arg),             # <<<<<<<<<<<<<<
  *             ctypes.POINTER(ctypes.c_byte))
  *         arr.size = len(arg)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 124, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __pyx_t_16 = __Pyx_PyObject_GetAttrStr(__pyx_t_15, __pyx_n_s_c_byte); if (unlikely(!__pyx_t_16)) __PYX_ERR(2, 124, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_16, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_16)) __PYX_ERR(2, 124, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_16);
-    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-    __pyx_t_17 = PyObject_Length(__pyx_v_arg); if (unlikely(__pyx_t_17 == ((Py_ssize_t)-1))) __PYX_ERR(2, 124, __pyx_L1_error)
-    __pyx_t_15 = PyInt_FromSsize_t(__pyx_t_17); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 124, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __pyx_t_18 = PyNumber_Multiply(__pyx_t_16, __pyx_t_15); if (unlikely(!__pyx_t_18)) __PYX_ERR(2, 124, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_18);
+    __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_16, __pyx_n_s_c_byte); if (unlikely(!__pyx_t_17)) __PYX_ERR(2, 124, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_17);
     __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
-    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-    __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_t_18, __pyx_n_s_from_buffer); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 124, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
-    __pyx_t_18 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (likely(PyMethod_Check(__pyx_t_15))) {
-      __pyx_t_18 = PyMethod_GET_SELF(__pyx_t_15);
-      if (likely(__pyx_t_18)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
-        __Pyx_INCREF(__pyx_t_18);
+    __pyx_t_18 = PyObject_Length(__pyx_v_arg); if (unlikely(__pyx_t_18 == ((Py_ssize_t)-1))) __PYX_ERR(2, 124, __pyx_L1_error)
+    __pyx_t_16 = PyInt_FromSsize_t(__pyx_t_18); if (unlikely(!__pyx_t_16)) __PYX_ERR(2, 124, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __pyx_t_19 = PyNumber_Multiply(__pyx_t_17, __pyx_t_16); if (unlikely(!__pyx_t_19)) __PYX_ERR(2, 124, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_19);
+    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+    __pyx_t_16 = __Pyx_PyObject_GetAttrStr(__pyx_t_19, __pyx_n_s_from_buffer); if (unlikely(!__pyx_t_16)) __PYX_ERR(2, 124, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
+    __pyx_t_19 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_16))) {
+      __pyx_t_19 = PyMethod_GET_SELF(__pyx_t_16);
+      if (likely(__pyx_t_19)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_16);
+        __Pyx_INCREF(__pyx_t_19);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_15, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_16, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_18, __pyx_v_arg};
-      __pyx_t_14 = __Pyx_PyObject_FastCall(__pyx_t_15, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
-      if (unlikely(!__pyx_t_14)) __PYX_ERR(2, 124, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_14);
-      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-    }
+    __pyx_t_15 = (__pyx_t_19) ? __Pyx_PyObject_Call2Args(__pyx_t_16, __pyx_t_19, __pyx_v_arg) : __Pyx_PyObject_CallOneArg(__pyx_t_16, __pyx_v_arg);
+    __Pyx_XDECREF(__pyx_t_19); __pyx_t_19 = 0;
+    if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 124, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":125
  *         arr.data = ctypes.cast(
  *             (ctypes.c_byte * len(arg)).from_buffer(arg),
  *             ctypes.POINTER(ctypes.c_byte))             # <<<<<<<<<<<<<<
  *         arr.size = len(arg)
  *         value[0].v_handle = <void*>(
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_18, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_18)) __PYX_ERR(2, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_18);
-    __pyx_t_16 = __Pyx_PyObject_GetAttrStr(__pyx_t_18, __pyx_n_s_POINTER); if (unlikely(!__pyx_t_16)) __PYX_ERR(2, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_16);
-    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
-    __Pyx_GetModuleGlobalName(__pyx_t_18, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_18)) __PYX_ERR(2, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_18);
-    __pyx_t_19 = __Pyx_PyObject_GetAttrStr(__pyx_t_18, __pyx_n_s_c_byte); if (unlikely(!__pyx_t_19)) __PYX_ERR(2, 125, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_19, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_19)) __PYX_ERR(2, 125, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_19);
-    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
-    __pyx_t_18 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_16))) {
-      __pyx_t_18 = PyMethod_GET_SELF(__pyx_t_16);
-      if (likely(__pyx_t_18)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_16);
-        __Pyx_INCREF(__pyx_t_18);
+    __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_19, __pyx_n_s_POINTER); if (unlikely(!__pyx_t_17)) __PYX_ERR(2, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_17);
+    __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
+    __Pyx_GetModuleGlobalName(__pyx_t_19, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_19)) __PYX_ERR(2, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_19);
+    __pyx_t_20 = __Pyx_PyObject_GetAttrStr(__pyx_t_19, __pyx_n_s_c_byte); if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
+    __pyx_t_19 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_17))) {
+      __pyx_t_19 = PyMethod_GET_SELF(__pyx_t_17);
+      if (likely(__pyx_t_19)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_17);
+        __Pyx_INCREF(__pyx_t_19);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_16, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_17, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_18, __pyx_t_19};
-      __pyx_t_15 = __Pyx_PyObject_FastCall(__pyx_t_16, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
-      __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
-      if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 125, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_15);
-      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
-    }
-    __pyx_t_16 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_7))) {
-      __pyx_t_16 = PyMethod_GET_SELF(__pyx_t_7);
-      if (likely(__pyx_t_16)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
-        __Pyx_INCREF(__pyx_t_16);
+    __pyx_t_16 = (__pyx_t_19) ? __Pyx_PyObject_Call2Args(__pyx_t_17, __pyx_t_19, __pyx_t_20) : __Pyx_PyObject_CallOneArg(__pyx_t_17, __pyx_t_20);
+    __Pyx_XDECREF(__pyx_t_19); __pyx_t_19 = 0;
+    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+    if (unlikely(!__pyx_t_16)) __PYX_ERR(2, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
+    __pyx_t_17 = NULL;
+    __pyx_t_9 = 0;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
+      __pyx_t_17 = PyMethod_GET_SELF(__pyx_t_8);
+      if (likely(__pyx_t_17)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+        __Pyx_INCREF(__pyx_t_17);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_7, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_8, function);
+        __pyx_t_9 = 1;
       }
     }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_8)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_17, __pyx_t_15, __pyx_t_16};
+      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 123, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+    } else
     #endif
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_16, __pyx_t_14, __pyx_t_15};
-      __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_7, __pyx_callargs+1-__pyx_t_8, 2+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
-      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_17, __pyx_t_15, __pyx_t_16};
+      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 123, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
+      __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 123, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+    } else
+    #endif
+    {
+      __pyx_t_20 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 123, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_20);
+      if (__pyx_t_17) {
+        __Pyx_GIVEREF(__pyx_t_17); PyTuple_SET_ITEM(__pyx_t_20, 0, __pyx_t_17); __pyx_t_17 = NULL;
+      }
+      __Pyx_GIVEREF(__pyx_t_15);
+      PyTuple_SET_ITEM(__pyx_t_20, 0+__pyx_t_9, __pyx_t_15);
+      __Pyx_GIVEREF(__pyx_t_16);
+      PyTuple_SET_ITEM(__pyx_t_20, 1+__pyx_t_9, __pyx_t_16);
+      __pyx_t_15 = 0;
+      __pyx_t_16 = 0;
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_20, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 123, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
     }
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":123
  *     elif isinstance(arg, bytearray):
  *         arr = DGLByteArray()
  *         arr.data = ctypes.cast(             # <<<<<<<<<<<<<<
  *             (ctypes.c_byte * len(arg)).from_buffer(arg),
  *             ctypes.POINTER(ctypes.c_byte))
  */
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_arr, __pyx_n_s_data, __pyx_t_5) < 0) __PYX_ERR(2, 123, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_arr, __pyx_n_s_data, __pyx_t_6) < 0) __PYX_ERR(2, 123, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":126
  *             (ctypes.c_byte * len(arg)).from_buffer(arg),
  *             ctypes.POINTER(ctypes.c_byte))
  *         arr.size = len(arg)             # <<<<<<<<<<<<<<
  *         value[0].v_handle = <void*>(
  *             <unsigned long long>ctypes.addressof(arr))
  */
-    __pyx_t_17 = PyObject_Length(__pyx_v_arg); if (unlikely(__pyx_t_17 == ((Py_ssize_t)-1))) __PYX_ERR(2, 126, __pyx_L1_error)
-    __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_17); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 126, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_arr, __pyx_n_s_size, __pyx_t_5) < 0) __PYX_ERR(2, 126, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_18 = PyObject_Length(__pyx_v_arg); if (unlikely(__pyx_t_18 == ((Py_ssize_t)-1))) __PYX_ERR(2, 126, __pyx_L1_error)
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_18); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 126, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_arr, __pyx_n_s_size, __pyx_t_6) < 0) __PYX_ERR(2, 126, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":128
  *         arr.size = len(arg)
  *         value[0].v_handle = <void*>(
  *             <unsigned long long>ctypes.addressof(arr))             # <<<<<<<<<<<<<<
  *         tcode[0] = kBytes
  *         temp_args.append(arr)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 128, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_addressof); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 128, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_15))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_15);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
-        __Pyx_INCREF(__pyx_t_7);
+    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 128, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_20 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_addressof); if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 128, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_20))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_20);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_20);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_15, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_20, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_v_arr};
-      __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_15, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 128, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-    }
-    __pyx_t_6 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_5); if (unlikely((__pyx_t_6 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(2, 128, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_20, __pyx_t_8, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_20, __pyx_v_arr);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 128, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+    __pyx_t_7 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_6); if (unlikely((__pyx_t_7 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(2, 128, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":127
  *             ctypes.POINTER(ctypes.c_byte))
  *         arr.size = len(arg)
  *         value[0].v_handle = <void*>(             # <<<<<<<<<<<<<<
  *             <unsigned long long>ctypes.addressof(arr))
  *         tcode[0] = kBytes
  */
-    (__pyx_v_value[0]).v_handle = ((void *)((unsigned PY_LONG_LONG)__pyx_t_6));
+    (__pyx_v_value[0]).v_handle = ((void *)((unsigned PY_LONG_LONG)__pyx_t_7));
 
     /* "dgl/_ffi/_cython/function.pxi":129
  *         value[0].v_handle = <void*>(
  *             <unsigned long long>ctypes.addressof(arr))
  *         tcode[0] = kBytes             # <<<<<<<<<<<<<<
  *         temp_args.append(arr)
  *     elif isinstance(arg, string_types):
@@ -7534,15 +5136,15 @@
  *     elif isinstance(arg, string_types):
  *         tstr = c_str(arg)
  */
     if (unlikely(__pyx_v_temp_args == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "append");
       __PYX_ERR(2, 130, __pyx_L1_error)
     }
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_arr); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(2, 130, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_arr); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(2, 130, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":121
  *             <unsigned long long>ctypes.addressof(arg)))[0]
  *         tcode[0] = kDGLContext
  *     elif isinstance(arg, bytearray):             # <<<<<<<<<<<<<<
  *         arr = DGLByteArray()
  *         arr.data = ctypes.cast(
@@ -7553,41 +5155,42 @@
   /* "dgl/_ffi/_cython/function.pxi":131
  *         tcode[0] = kBytes
  *         temp_args.append(arr)
  *     elif isinstance(arg, string_types):             # <<<<<<<<<<<<<<
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_string_types); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 131, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_5); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 131, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_string_types); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 131, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_6); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(2, 131, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":132
  *         temp_args.append(arr)
  *     elif isinstance(arg, string_types):
  *         tstr = c_str(arg)             # <<<<<<<<<<<<<<
  *         value[0].v_str = tstr
  *         tcode[0] = kStr
  */
-    __pyx_t_5 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(__pyx_v_arg); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 132, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_v_tstr = __pyx_t_5;
-    __pyx_t_5 = 0;
+    __pyx_t_6 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_str(__pyx_v_arg); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 132, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_v_tstr = __pyx_t_6;
+    __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":133
  *     elif isinstance(arg, string_types):
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr             # <<<<<<<<<<<<<<
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  */
-    __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_tstr); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(2, 133, __pyx_L1_error)
-    (__pyx_v_value[0]).v_str = __pyx_t_12;
+    __pyx_t_13 = __Pyx_PyObject_AsString(__pyx_v_tstr); if (unlikely((!__pyx_t_13) && PyErr_Occurred())) __PYX_ERR(2, 133, __pyx_L1_error)
+    (__pyx_v_value[0]).v_str = __pyx_t_13;
 
     /* "dgl/_ffi/_cython/function.pxi":134
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr
  *         tcode[0] = kStr             # <<<<<<<<<<<<<<
  *         temp_args.append(tstr)
  *     elif isinstance(arg, (list, tuple, dict, ObjectGeneric)):
@@ -7601,15 +5204,15 @@
  *     elif isinstance(arg, (list, tuple, dict, ObjectGeneric)):
  *         arg = convert_to_object(arg)
  */
     if (unlikely(__pyx_v_temp_args == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "append");
       __PYX_ERR(2, 135, __pyx_L1_error)
     }
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_tstr); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(2, 135, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_tstr); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(2, 135, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":131
  *         tcode[0] = kBytes
  *         temp_args.append(arr)
  *     elif isinstance(arg, string_types):             # <<<<<<<<<<<<<<
  *         tstr = c_str(arg)
  *         value[0].v_str = tstr
@@ -7620,83 +5223,81 @@
   /* "dgl/_ffi/_cython/function.pxi":136
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  *     elif isinstance(arg, (list, tuple, dict, ObjectGeneric)):             # <<<<<<<<<<<<<<
  *         arg = convert_to_object(arg)
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ObjectGeneric); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 136, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_9 = PyList_Check(__pyx_v_arg); 
-  if (!__pyx_t_9) {
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_ObjectGeneric); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 136, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_t_2 = PyList_Check(__pyx_v_arg); 
+  __pyx_t_10 = (__pyx_t_2 != 0);
+  if (!__pyx_t_10) {
   } else {
-    __pyx_t_1 = __pyx_t_9;
+    __pyx_t_1 = __pyx_t_10;
     goto __pyx_L6_bool_binop_done;
   }
-  __pyx_t_9 = PyTuple_Check(__pyx_v_arg); 
-  if (!__pyx_t_9) {
+  __pyx_t_10 = PyTuple_Check(__pyx_v_arg); 
+  __pyx_t_2 = (__pyx_t_10 != 0);
+  if (!__pyx_t_2) {
   } else {
-    __pyx_t_1 = __pyx_t_9;
+    __pyx_t_1 = __pyx_t_2;
     goto __pyx_L6_bool_binop_done;
   }
-  __pyx_t_9 = PyDict_Check(__pyx_v_arg); 
-  if (!__pyx_t_9) {
+  __pyx_t_2 = PyDict_Check(__pyx_v_arg); 
+  __pyx_t_10 = (__pyx_t_2 != 0);
+  if (!__pyx_t_10) {
   } else {
-    __pyx_t_1 = __pyx_t_9;
+    __pyx_t_1 = __pyx_t_10;
     goto __pyx_L6_bool_binop_done;
   }
-  __pyx_t_9 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_5); 
-  __pyx_t_1 = __pyx_t_9;
+  __pyx_t_10 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_6); 
+  __pyx_t_2 = (__pyx_t_10 != 0);
+  __pyx_t_1 = __pyx_t_2;
   __pyx_L6_bool_binop_done:;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (__pyx_t_1) {
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":137
  *         temp_args.append(tstr)
  *     elif isinstance(arg, (list, tuple, dict, ObjectGeneric)):
  *         arg = convert_to_object(arg)             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  *         tcode[0] = kObjectHandle
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_convert_to_object); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 137, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_15))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_15);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
-        __Pyx_INCREF(__pyx_t_7);
+    __Pyx_GetModuleGlobalName(__pyx_t_20, __pyx_n_s_convert_to_object); if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_20))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_20);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_20);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_15, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_20, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_v_arg};
-      __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_15, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 137, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-    }
-    __Pyx_DECREF_SET(__pyx_v_arg, __pyx_t_5);
-    __pyx_t_5 = 0;
+    __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_20, __pyx_t_8, __pyx_v_arg) : __Pyx_PyObject_CallOneArg(__pyx_t_20, __pyx_v_arg);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+    __Pyx_DECREF_SET(__pyx_v_arg, __pyx_t_6);
+    __pyx_t_6 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":138
  *     elif isinstance(arg, (list, tuple, dict, ObjectGeneric)):
  *         arg = convert_to_object(arg)
  *         value[0].v_handle = (<ObjectBase>arg).chandle             # <<<<<<<<<<<<<<
  *         tcode[0] = kObjectHandle
  *         temp_args.append(arg)
  */
-    __pyx_t_2 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_arg)->chandle;
-    (__pyx_v_value[0]).v_handle = __pyx_t_2;
+    __pyx_t_3 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)__pyx_v_arg)->chandle;
+    (__pyx_v_value[0]).v_handle = __pyx_t_3;
 
     /* "dgl/_ffi/_cython/function.pxi":139
  *         arg = convert_to_object(arg)
  *         value[0].v_handle = (<ObjectBase>arg).chandle
  *         tcode[0] = kObjectHandle             # <<<<<<<<<<<<<<
  *         temp_args.append(arg)
  *     #elif isinstance(arg, _CLASS_MODULE):
@@ -7710,15 +5311,15 @@
  *     #elif isinstance(arg, _CLASS_MODULE):
  *     #    value[0].v_handle = c_handle(arg.handle)
  */
     if (unlikely(__pyx_v_temp_args == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "append");
       __PYX_ERR(2, 140, __pyx_L1_error)
     }
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_arg); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(2, 140, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_arg); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(2, 140, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":136
  *         tcode[0] = kStr
  *         temp_args.append(tstr)
  *     elif isinstance(arg, (list, tuple, dict, ObjectGeneric)):             # <<<<<<<<<<<<<<
  *         arg = convert_to_object(arg)
  *         value[0].v_handle = (<ObjectBase>arg).chandle
@@ -7729,26 +5330,27 @@
   /* "dgl/_ffi/_cython/function.pxi":144
  *     #    value[0].v_handle = c_handle(arg.handle)
  *     #    tcode[0] = kModuleHandle
  *     elif isinstance(arg, FunctionBase):             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<FunctionBase>arg).chandle
  *         tcode[0] = kFuncHandle
  */
-  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_arg, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase); 
+  __pyx_t_2 = __Pyx_TypeCheck(__pyx_v_arg, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase); 
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":145
  *     #    tcode[0] = kModuleHandle
  *     elif isinstance(arg, FunctionBase):
  *         value[0].v_handle = (<FunctionBase>arg).chandle             # <<<<<<<<<<<<<<
  *         tcode[0] = kFuncHandle
  *     elif isinstance(arg, ctypes.c_void_p):
  */
-    __pyx_t_20 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_arg)->chandle;
-    (__pyx_v_value[0]).v_handle = __pyx_t_20;
+    __pyx_t_21 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_arg)->chandle;
+    (__pyx_v_value[0]).v_handle = __pyx_t_21;
 
     /* "dgl/_ffi/_cython/function.pxi":146
  *     elif isinstance(arg, FunctionBase):
  *         value[0].v_handle = (<FunctionBase>arg).chandle
  *         tcode[0] = kFuncHandle             # <<<<<<<<<<<<<<
  *     elif isinstance(arg, ctypes.c_void_p):
  *         value[0].v_handle = c_handle(arg)
@@ -7768,32 +5370,32 @@
   /* "dgl/_ffi/_cython/function.pxi":147
  *         value[0].v_handle = (<FunctionBase>arg).chandle
  *         tcode[0] = kFuncHandle
  *     elif isinstance(arg, ctypes.c_void_p):             # <<<<<<<<<<<<<<
  *         value[0].v_handle = c_handle(arg)
  *         tcode[0] = kHandle
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_15);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_15); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 147, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-  if (__pyx_t_1) {
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 147, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_t_20 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 147, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_20);
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_arg, __pyx_t_20); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 147, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":148
  *         tcode[0] = kFuncHandle
  *     elif isinstance(arg, ctypes.c_void_p):
  *         value[0].v_handle = c_handle(arg)             # <<<<<<<<<<<<<<
  *         tcode[0] = kHandle
  *     elif callable(arg):
  */
-    __pyx_t_2 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_handle(__pyx_v_arg); if (unlikely(__pyx_t_2 == ((void *)NULL) && PyErr_Occurred())) __PYX_ERR(2, 148, __pyx_L1_error)
-    (__pyx_v_value[0]).v_handle = __pyx_t_2;
+    (__pyx_v_value[0]).v_handle = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_handle(__pyx_v_arg);
 
     /* "dgl/_ffi/_cython/function.pxi":149
  *     elif isinstance(arg, ctypes.c_void_p):
  *         value[0].v_handle = c_handle(arg)
  *         tcode[0] = kHandle             # <<<<<<<<<<<<<<
  *     elif callable(arg):
  *         arg = convert_to_dgl_func(arg)
@@ -7813,60 +5415,54 @@
   /* "dgl/_ffi/_cython/function.pxi":150
  *         value[0].v_handle = c_handle(arg)
  *         tcode[0] = kHandle
  *     elif callable(arg):             # <<<<<<<<<<<<<<
  *         arg = convert_to_dgl_func(arg)
  *         value[0].v_handle = (<FunctionBase>arg).chandle
  */
-  __pyx_t_1 = __Pyx_PyCallable_Check(__pyx_v_arg); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 150, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyCallable_Check(__pyx_v_arg); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(2, 150, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_2 != 0);
   if (likely(__pyx_t_1)) {
 
     /* "dgl/_ffi/_cython/function.pxi":151
  *         tcode[0] = kHandle
  *     elif callable(arg):
  *         arg = convert_to_dgl_func(arg)             # <<<<<<<<<<<<<<
  *         value[0].v_handle = (<FunctionBase>arg).chandle
  *         tcode[0] = kFuncHandle
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_convert_to_dgl_func); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 151, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_5))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-        __Pyx_INCREF(__pyx_t_7);
+    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_convert_to_dgl_func); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 151, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_5, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_6, function);
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_v_arg};
-      __pyx_t_15 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 151, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_15);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    }
-    __Pyx_DECREF_SET(__pyx_v_arg, __pyx_t_15);
-    __pyx_t_15 = 0;
+    __pyx_t_20 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_v_arg) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_arg);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 151, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF_SET(__pyx_v_arg, __pyx_t_20);
+    __pyx_t_20 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":152
  *     elif callable(arg):
  *         arg = convert_to_dgl_func(arg)
  *         value[0].v_handle = (<FunctionBase>arg).chandle             # <<<<<<<<<<<<<<
  *         tcode[0] = kFuncHandle
  *         temp_args.append(arg)
  */
-    __pyx_t_20 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_arg)->chandle;
-    (__pyx_v_value[0]).v_handle = __pyx_t_20;
+    __pyx_t_21 = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_arg)->chandle;
+    (__pyx_v_value[0]).v_handle = __pyx_t_21;
 
     /* "dgl/_ffi/_cython/function.pxi":153
  *         arg = convert_to_dgl_func(arg)
  *         value[0].v_handle = (<FunctionBase>arg).chandle
  *         tcode[0] = kFuncHandle             # <<<<<<<<<<<<<<
  *         temp_args.append(arg)
  *     else:
@@ -7880,15 +5476,15 @@
  *     else:
  *         raise TypeError("Don't know how to handle type %s" % type(arg))
  */
     if (unlikely(__pyx_v_temp_args == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "append");
       __PYX_ERR(2, 154, __pyx_L1_error)
     }
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_arg); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(2, 154, __pyx_L1_error)
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_temp_args, __pyx_v_arg); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(2, 154, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":150
  *         value[0].v_handle = c_handle(arg)
  *         tcode[0] = kHandle
  *     elif callable(arg):             # <<<<<<<<<<<<<<
  *         arg = convert_to_dgl_func(arg)
  *         value[0].v_handle = (<FunctionBase>arg).chandle
@@ -7900,21 +5496,21 @@
  *         temp_args.append(arg)
  *     else:
  *         raise TypeError("Don't know how to handle type %s" % type(arg))             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
   /*else*/ {
-    __pyx_t_15 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_Don_t_know_how_to_handle_type_s, ((PyObject *)Py_TYPE(__pyx_v_arg))); if (unlikely(!__pyx_t_15)) __PYX_ERR(2, 156, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_15); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 156, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_20 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_Don_t_know_how_to_handle_type_s, ((PyObject *)Py_TYPE(__pyx_v_arg))); if (unlikely(!__pyx_t_20)) __PYX_ERR(2, 156, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_20); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 156, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __PYX_ERR(2, 156, __pyx_L1_error)
   }
   __pyx_L3:;
 
   /* "dgl/_ffi/_cython/function.pxi":157
  *     else:
  *         raise TypeError("Don't know how to handle type %s" % type(arg))
@@ -7931,21 +5527,21 @@
  * cdef inline int make_arg(object arg,             # <<<<<<<<<<<<<<
  *                          DGLValue* value,
  *                          int* tcode,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_15);
   __Pyx_XDECREF(__pyx_t_16);
-  __Pyx_XDECREF(__pyx_t_18);
+  __Pyx_XDECREF(__pyx_t_17);
   __Pyx_XDECREF(__pyx_t_19);
+  __Pyx_XDECREF(__pyx_t_20);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.make_arg", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_tstr);
   __Pyx_XDECREF(__pyx_v_arr);
   __Pyx_XDECREF(__pyx_v_arg);
   __Pyx_RefNannyFinishContext();
@@ -7976,15 +5572,15 @@
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("make_ret_bytes", 1);
+  __Pyx_RefNannySetupContext("make_ret_bytes", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":160
  * 
  * cdef inline bytearray make_ret_bytes(void* chandle):
  *     handle = ctypes_handle(chandle)             # <<<<<<<<<<<<<<
  *     arr = ctypes.cast(handle, ctypes.POINTER(DGLByteArray))[0]
  *     size = arr.size
@@ -8010,59 +5606,76 @@
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_POINTER); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DGLByteArray); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_6 = NULL;
-  __pyx_t_7 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_5))) {
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_6);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
-      __pyx_t_7 = 1;
     }
   }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_t_4};
-    __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 161, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
+  __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 161, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_5 = NULL;
   __pyx_t_7 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_7 = 1;
     }
   }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_handle, __pyx_t_2};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 161, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  } else
   #endif
-  {
-    PyObject *__pyx_callargs[3] = {__pyx_t_5, __pyx_v_handle, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_handle, __pyx_t_2};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 161, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 161, __pyx_L1_error)
+  } else
+  #endif
+  {
+    __pyx_t_4 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 161, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    if (__pyx_t_5) {
+      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5); __pyx_t_5 = NULL;
+    }
+    __Pyx_INCREF(__pyx_v_handle);
+    __Pyx_GIVEREF(__pyx_v_handle);
+    PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_7, __pyx_v_handle);
+    __Pyx_GIVEREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_7, __pyx_t_2);
+    __pyx_t_2 = 0;
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 161, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_arr = __pyx_t_3;
   __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":162
@@ -8094,98 +5707,118 @@
  *     res = bytearray(size)
  *     rptr = (ctypes.c_byte * size).from_buffer(res)             # <<<<<<<<<<<<<<
  *     if not ctypes.memmove(rptr, arr.data, size):
  *         raise RuntimeError('memmove failed')
  */
   __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_c_byte); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 164, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_c_byte); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 164, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyNumber_Multiply(__pyx_t_2, __pyx_v_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 164, __pyx_L1_error)
+  __pyx_t_1 = PyNumber_Multiply(__pyx_t_4, __pyx_v_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_from_buffer); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 164, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_from_buffer); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 164, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
-  __pyx_t_7 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_1)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_7 = 1;
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_1, __pyx_v_res};
-    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 164, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  }
+  __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_1, __pyx_v_res) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_res);
+  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 164, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_rptr = __pyx_t_3;
   __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":165
  *     res = bytearray(size)
  *     rptr = (ctypes.c_byte * size).from_buffer(res)
  *     if not ctypes.memmove(rptr, arr.data, size):             # <<<<<<<<<<<<<<
  *         raise RuntimeError('memmove failed')
  *     return res
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 165, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_memmove); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 165, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 165, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_memmove); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 165, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_arr, __pyx_n_s_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 165, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = NULL;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_arr, __pyx_n_s_data); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 165, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_2 = NULL;
   __pyx_t_7 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_5)) {
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
+    if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_5);
+      __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_1, function);
       __pyx_t_7 = 1;
     }
   }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_1)) {
+    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_rptr, __pyx_t_4, __pyx_v_size};
+    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_7, 3+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 165, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
+    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_rptr, __pyx_t_4, __pyx_v_size};
+    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_7, 3+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 165, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
   #endif
   {
-    PyObject *__pyx_callargs[4] = {__pyx_t_5, __pyx_v_rptr, __pyx_t_2, __pyx_v_size};
-    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_1, __pyx_callargs+1-__pyx_t_7, 3+__pyx_t_7);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 165, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 165, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__pyx_t_2) {
+      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
+    }
+    __Pyx_INCREF(__pyx_v_rptr);
+    __Pyx_GIVEREF(__pyx_v_rptr);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_v_rptr);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_t_4);
+    __Pyx_INCREF(__pyx_v_size);
+    __Pyx_GIVEREF(__pyx_v_size);
+    PyTuple_SET_ITEM(__pyx_t_5, 2+__pyx_t_7, __pyx_v_size);
+    __pyx_t_4 = 0;
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_8 < 0))) __PYX_ERR(2, 165, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(2, 165, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_9 = (!__pyx_t_8);
+  __pyx_t_9 = ((!__pyx_t_8) != 0);
   if (unlikely(__pyx_t_9)) {
 
     /* "dgl/_ffi/_cython/function.pxi":166
  *     rptr = (ctypes.c_byte * size).from_buffer(res)
  *     if not ctypes.memmove(rptr, arr.data, size):
  *         raise RuntimeError('memmove failed')             # <<<<<<<<<<<<<<
  *     return res
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 166, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 166, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(2, 166, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":165
  *     res = bytearray(size)
@@ -8252,28 +5885,30 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
-  void *__pyx_t_8;
+  PyObject *__pyx_t_8 = NULL;
+  void *__pyx_t_9;
+  int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("make_ret", 1);
+  __Pyx_RefNannySetupContext("make_ret", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":171
  * cdef inline object make_ret(DGLValue value, int tcode):
  *     """convert result to return value."""
  *     if tcode == kObjectHandle:             # <<<<<<<<<<<<<<
  *         return make_ret_object(value.v_handle)
  *     elif tcode == kNull:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectHandle);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectHandle) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":172
  *     """convert result to return value."""
  *     if tcode == kObjectHandle:
  *         return make_ret_object(value.v_handle)             # <<<<<<<<<<<<<<
  *     elif tcode == kNull:
@@ -8298,15 +5933,15 @@
   /* "dgl/_ffi/_cython/function.pxi":173
  *     if tcode == kObjectHandle:
  *         return make_ret_object(value.v_handle)
  *     elif tcode == kNull:             # <<<<<<<<<<<<<<
  *         return None
  *     elif tcode == kObjectInt:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kNull);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kNull) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":174
  *         return make_ret_object(value.v_handle)
  *     elif tcode == kNull:
  *         return None             # <<<<<<<<<<<<<<
  *     elif tcode == kObjectInt:
@@ -8328,15 +5963,15 @@
   /* "dgl/_ffi/_cython/function.pxi":175
  *     elif tcode == kNull:
  *         return None
  *     elif tcode == kObjectInt:             # <<<<<<<<<<<<<<
  *         return value.v_int64
  *     elif tcode == kObjectFloat:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectInt);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectInt) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":176
  *         return None
  *     elif tcode == kObjectInt:
  *         return value.v_int64             # <<<<<<<<<<<<<<
  *     elif tcode == kObjectFloat:
@@ -8361,15 +5996,15 @@
   /* "dgl/_ffi/_cython/function.pxi":177
  *     elif tcode == kObjectInt:
  *         return value.v_int64
  *     elif tcode == kObjectFloat:             # <<<<<<<<<<<<<<
  *         return value.v_float64
  *     elif tcode == kNDArrayContainer:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectFloat);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kObjectFloat) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":178
  *         return value.v_int64
  *     elif tcode == kObjectFloat:
  *         return value.v_float64             # <<<<<<<<<<<<<<
  *     elif tcode == kNDArrayContainer:
@@ -8394,15 +6029,15 @@
   /* "dgl/_ffi/_cython/function.pxi":179
  *     elif tcode == kObjectFloat:
  *         return value.v_float64
  *     elif tcode == kNDArrayContainer:             # <<<<<<<<<<<<<<
  *         return c_make_array(value.v_handle, False)
  *     elif tcode == kStr:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kNDArrayContainer);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kNDArrayContainer) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":180
  *         return value.v_float64
  *     elif tcode == kNDArrayContainer:
  *         return c_make_array(value.v_handle, False)             # <<<<<<<<<<<<<<
  *     elif tcode == kStr:
@@ -8427,15 +6062,15 @@
   /* "dgl/_ffi/_cython/function.pxi":181
  *     elif tcode == kNDArrayContainer:
  *         return c_make_array(value.v_handle, False)
  *     elif tcode == kStr:             # <<<<<<<<<<<<<<
  *         return py_str(value.v_str)
  *     elif tcode == kBytes:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kStr);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kStr) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":182
  *         return c_make_array(value.v_handle, False)
  *     elif tcode == kStr:
  *         return py_str(value.v_str)             # <<<<<<<<<<<<<<
  *     elif tcode == kBytes:
@@ -8460,15 +6095,15 @@
   /* "dgl/_ffi/_cython/function.pxi":183
  *     elif tcode == kStr:
  *         return py_str(value.v_str)
  *     elif tcode == kBytes:             # <<<<<<<<<<<<<<
  *         return make_ret_bytes(value.v_handle)
  *     elif tcode == kHandle:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kBytes);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kBytes) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":184
  *         return py_str(value.v_str)
  *     elif tcode == kBytes:
  *         return make_ret_bytes(value.v_handle)             # <<<<<<<<<<<<<<
  *     elif tcode == kHandle:
@@ -8493,15 +6128,15 @@
   /* "dgl/_ffi/_cython/function.pxi":185
  *     elif tcode == kBytes:
  *         return make_ret_bytes(value.v_handle)
  *     elif tcode == kHandle:             # <<<<<<<<<<<<<<
  *         return ctypes_handle(value.v_handle)
  *     elif tcode == kDGLContext:
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kHandle);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kHandle) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":186
  *         return make_ret_bytes(value.v_handle)
  *     elif tcode == kHandle:
  *         return ctypes_handle(value.v_handle)             # <<<<<<<<<<<<<<
  *     elif tcode == kDGLContext:
@@ -8526,15 +6161,15 @@
   /* "dgl/_ffi/_cython/function.pxi":187
  *     elif tcode == kHandle:
  *         return ctypes_handle(value.v_handle)
  *     elif tcode == kDGLContext:             # <<<<<<<<<<<<<<
  *         return CTypesDGLContext(value.v_ctx.device_type, value.v_ctx.device_id)
  *     # (minjie): class module are not used in DGL.
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kDGLContext);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kDGLContext) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":188
  *         return ctypes_handle(value.v_handle)
  *     elif tcode == kDGLContext:
  *         return CTypesDGLContext(value.v_ctx.device_type, value.v_ctx.device_id)             # <<<<<<<<<<<<<<
  *     # (minjie): class module are not used in DGL.
@@ -8545,36 +6180,61 @@
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_value.v_ctx.device_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 188, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_value.v_ctx.device_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 188, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     __pyx_t_7 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
         __pyx_t_7 = 1;
       }
     }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_3)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_4, __pyx_t_5};
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 188, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    } else
     #endif
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_6, __pyx_t_4, __pyx_t_5};
-      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_4, __pyx_t_5};
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 188, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 188, __pyx_L1_error)
+    } else
+    #endif
+    {
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 188, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__pyx_t_6) {
+        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
+      }
+      __Pyx_GIVEREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_5);
+      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
+      __pyx_t_4 = 0;
+      __pyx_t_5 = 0;
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 188, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
     /* "dgl/_ffi/_cython/function.pxi":187
  *     elif tcode == kHandle:
  *         return ctypes_handle(value.v_handle)
@@ -8587,41 +6247,41 @@
   /* "dgl/_ffi/_cython/function.pxi":192
  *     #elif tcode == kModuleHandle:
  *     #    return _CLASS_MODULE(ctypes_handle(value.v_handle))
  *     elif tcode == kFuncHandle:             # <<<<<<<<<<<<<<
  *         fobj = _CLASS_FUNCTION(None, False)
  *         (<FunctionBase>fobj).chandle = value.v_handle
  */
-  __pyx_t_1 = (__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kFuncHandle);
+  __pyx_t_1 = ((__pyx_v_tcode == __pyx_e_3dgl_4_ffi_4_cy3_4core_kFuncHandle) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":193
  *     #    return _CLASS_MODULE(ctypes_handle(value.v_handle))
  *     elif tcode == kFuncHandle:
  *         fobj = _CLASS_FUNCTION(None, False)             # <<<<<<<<<<<<<<
  *         (<FunctionBase>fobj).chandle = value.v_handle
  *         return fobj
  */
     __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CLASS_FUNCTION); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 193, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 193, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 193, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_v_fobj = __pyx_t_3;
     __pyx_t_3 = 0;
 
     /* "dgl/_ffi/_cython/function.pxi":194
  *     elif tcode == kFuncHandle:
  *         fobj = _CLASS_FUNCTION(None, False)
  *         (<FunctionBase>fobj).chandle = value.v_handle             # <<<<<<<<<<<<<<
  *         return fobj
  *     elif tcode in _DGL_EXT_RET:
  */
-    __pyx_t_8 = __pyx_v_value.v_handle;
-    ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_fobj)->chandle = __pyx_t_8;
+    __pyx_t_9 = __pyx_v_value.v_handle;
+    ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_fobj)->chandle = __pyx_t_9;
 
     /* "dgl/_ffi/_cython/function.pxi":195
  *         fobj = _CLASS_FUNCTION(None, False)
  *         (<FunctionBase>fobj).chandle = value.v_handle
  *         return fobj             # <<<<<<<<<<<<<<
  *     elif tcode in _DGL_EXT_RET:
  *         return _DGL_EXT_RET[tcode](ctypes_handle(value.v_handle))
@@ -8645,53 +6305,47 @@
  *         return fobj
  *     elif tcode in _DGL_EXT_RET:             # <<<<<<<<<<<<<<
  *         return _DGL_EXT_RET[tcode](ctypes_handle(value.v_handle))
  * 
  */
   __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_tcode); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 196, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_t_3, __pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, Py_EQ)); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(2, 196, __pyx_L1_error)
+  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_t_3, __pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 196, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (__pyx_t_1) {
+  __pyx_t_10 = (__pyx_t_1 != 0);
+  if (__pyx_t_10) {
 
     /* "dgl/_ffi/_cython/function.pxi":197
  *         return fobj
  *     elif tcode in _DGL_EXT_RET:
  *         return _DGL_EXT_RET[tcode](ctypes_handle(value.v_handle))             # <<<<<<<<<<<<<<
  * 
  *     raise ValueError("Unhandled type code %d" % tcode)
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, __pyx_v_tcode, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 197, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = __pyx_f_3dgl_4_ffi_4_cy3_4core_ctypes_handle(__pyx_v_value.v_handle); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 197, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_4 = NULL;
-    __pyx_t_7 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_4)) {
+    __pyx_t_8 = __pyx_f_3dgl_4_ffi_4_cy3_4core_ctypes_handle(__pyx_v_value.v_handle); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 197, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
-        __pyx_t_7 = 1;
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_5};
-      __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 197, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    }
+    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 197, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "dgl/_ffi/_cython/function.pxi":196
  *         (<FunctionBase>fobj).chandle = value.v_handle
  *         return fobj
@@ -8731,14 +6385,15 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.make_ret", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_fobj);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
@@ -8769,28 +6424,28 @@
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("FuncCall3", 1);
+  __Pyx_RefNannySetupContext("FuncCall3", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":209
  *     cdef DGLValue[3] values
  *     cdef int[3] tcodes
  *     nargs = len(args)             # <<<<<<<<<<<<<<
  *     temp_args = []
  *     for i in range(nargs):
  */
   if (unlikely(__pyx_v_args == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(2, 209, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 209, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 209, __pyx_L1_error)
   __pyx_v_nargs = __pyx_t_1;
 
   /* "dgl/_ffi/_cython/function.pxi":210
  *     cdef int[3] tcodes
  *     nargs = len(args)
  *     temp_args = []             # <<<<<<<<<<<<<<
  *     for i in range(nargs):
@@ -8836,15 +6491,14 @@
  *     with nogil:             # <<<<<<<<<<<<<<
  *         ret = DGLFuncCall(chandle, &values[0], &tcodes[0],
  *                           nargs, ret_val, ret_tcode)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
-      _save = NULL;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
         /* "dgl/_ffi/_cython/function.pxi":214
  *         make_arg(args[i], &values[i], &tcodes[i], temp_args)
@@ -8878,51 +6532,44 @@
   /* "dgl/_ffi/_cython/function.pxi":216
  *         ret = DGLFuncCall(chandle, &values[0], &tcodes[0],
  *                           nargs, ret_val, ret_tcode)
  *     if ret != 0:             # <<<<<<<<<<<<<<
  *         raise DGLError(py_str(DGLGetLastError()))
  *     return 0
  */
-  __pyx_t_7 = (__pyx_v_ret != 0);
+  __pyx_t_7 = ((__pyx_v_ret != 0) != 0);
   if (unlikely(__pyx_t_7)) {
 
     /* "dgl/_ffi/_cython/function.pxi":217
  *                           nargs, ret_val, ret_tcode)
  *     if ret != 0:
  *         raise DGLError(py_str(DGLGetLastError()))             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
     __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_DGLError); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 217, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __pyx_t_9 = __pyx_f_3dgl_4_ffi_4_cy3_4core_py_str(DGLGetLastError()); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 217, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
     __pyx_t_10 = NULL;
-    __pyx_t_3 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_8))) {
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_10)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_10);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_8, function);
-        __pyx_t_3 = 1;
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_10, __pyx_t_9};
-      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_8, __pyx_callargs+1-__pyx_t_3, 1+__pyx_t_3);
-      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 217, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    }
+    __pyx_t_2 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_10, __pyx_t_9) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
+    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 217, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __PYX_ERR(2, 217, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":216
  *         ret = DGLFuncCall(chandle, &values[0], &tcodes[0],
  *                           nargs, ret_val, ret_tcode)
@@ -8992,38 +6639,38 @@
   int __pyx_t_9;
   PyObject *__pyx_t_10 = NULL;
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("FuncCall", 1);
+  __Pyx_RefNannySetupContext("FuncCall", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":225
  *                          int* ret_tcode) except -1:
  *     cdef int nargs
  *     nargs = len(args)             # <<<<<<<<<<<<<<
  *     if nargs <= 3:
  *         FuncCall3(chandle, args, nargs, ret_val, ret_tcode)
  */
   if (unlikely(__pyx_v_args == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(2, 225, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 225, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 225, __pyx_L1_error)
   __pyx_v_nargs = __pyx_t_1;
 
   /* "dgl/_ffi/_cython/function.pxi":226
  *     cdef int nargs
  *     nargs = len(args)
  *     if nargs <= 3:             # <<<<<<<<<<<<<<
  *         FuncCall3(chandle, args, nargs, ret_val, ret_tcode)
  *         return 0
  */
-  __pyx_t_2 = (__pyx_v_nargs <= 3);
+  __pyx_t_2 = ((__pyx_v_nargs <= 3) != 0);
   if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":227
  *     nargs = len(args)
  *     if nargs <= 3:
  *         FuncCall3(chandle, args, nargs, ret_val, ret_tcode)             # <<<<<<<<<<<<<<
  *         return 0
@@ -9055,16 +6702,15 @@
  *     cdef vector[int] tcodes
  *     values.resize(max(nargs, 1))             # <<<<<<<<<<<<<<
  *     tcodes.resize(max(nargs, 1))
  *     temp_args = []
  */
   __pyx_t_4 = 1;
   __pyx_t_3 = __pyx_v_nargs;
-  __pyx_t_2 = (__pyx_t_4 > __pyx_t_3);
-  if (__pyx_t_2) {
+  if (((__pyx_t_4 > __pyx_t_3) != 0)) {
     __pyx_t_5 = __pyx_t_4;
   } else {
     __pyx_t_5 = __pyx_t_3;
   }
   try {
     __pyx_v_values.resize(__pyx_t_5);
   } catch(...) {
@@ -9077,16 +6723,15 @@
  *     values.resize(max(nargs, 1))
  *     tcodes.resize(max(nargs, 1))             # <<<<<<<<<<<<<<
  *     temp_args = []
  *     for i in range(nargs):
  */
   __pyx_t_5 = 1;
   __pyx_t_3 = __pyx_v_nargs;
-  __pyx_t_2 = (__pyx_t_5 > __pyx_t_3);
-  if (__pyx_t_2) {
+  if (((__pyx_t_5 > __pyx_t_3) != 0)) {
     __pyx_t_4 = __pyx_t_5;
   } else {
     __pyx_t_4 = __pyx_t_3;
   }
   try {
     __pyx_v_tcodes.resize(__pyx_t_4);
   } catch(...) {
@@ -9141,15 +6786,14 @@
  *     with nogil:             # <<<<<<<<<<<<<<
  *         ret = DGLFuncCall(chandle, &values[0], &tcodes[0],
  *                           nargs, ret_val, ret_tcode)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
-      _save = NULL;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
         /* "dgl/_ffi/_cython/function.pxi":238
  *         make_arg(args[i], &values[i], &tcodes[i], temp_args)
@@ -9183,51 +6827,44 @@
   /* "dgl/_ffi/_cython/function.pxi":240
  *         ret = DGLFuncCall(chandle, &values[0], &tcodes[0],
  *                           nargs, ret_val, ret_tcode)
  *     if ret != 0:             # <<<<<<<<<<<<<<
  *         raise DGLError(py_str(DGLGetLastError()))
  *     return 0
  */
-  __pyx_t_2 = (__pyx_v_ret != 0);
+  __pyx_t_2 = ((__pyx_v_ret != 0) != 0);
   if (unlikely(__pyx_t_2)) {
 
     /* "dgl/_ffi/_cython/function.pxi":241
  *                           nargs, ret_val, ret_tcode)
  *     if ret != 0:
  *         raise DGLError(py_str(DGLGetLastError()))             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
     __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_DGLError); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 241, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_11 = __pyx_f_3dgl_4_ffi_4_cy3_4core_py_str(DGLGetLastError()); if (unlikely(!__pyx_t_11)) __PYX_ERR(2, 241, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     __pyx_t_12 = NULL;
-    __pyx_t_3 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_10))) {
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_10))) {
       __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_10);
       if (likely(__pyx_t_12)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
         __Pyx_INCREF(__pyx_t_12);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_10, function);
-        __pyx_t_3 = 1;
       }
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_12, __pyx_t_11};
-      __pyx_t_6 = __Pyx_PyObject_FastCall(__pyx_t_10, __pyx_callargs+1-__pyx_t_3, 1+__pyx_t_3);
-      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-      if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 241, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    }
+    __pyx_t_6 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_10, __pyx_t_12, __pyx_t_11) : __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_t_11);
+    __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_Raise(__pyx_t_6, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __PYX_ERR(2, 241, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/function.pxi":240
  *         ret = DGLFuncCall(chandle, &values[0], &tcodes[0],
  *                           nargs, ret_val, ret_tcode)
@@ -9277,20 +6914,21 @@
  *                                 tuple args,
  */
 
 static CYTHON_INLINE int __pyx_f_3dgl_4_ffi_4_cy3_4core_ConstructorCall(void *__pyx_v_constructor_handle, int __pyx_v_type_code, PyObject *__pyx_v_args, void **__pyx_v_handle) {
   DGLValue __pyx_v_ret_val;
   int __pyx_v_ret_tcode;
   int __pyx_r;
+  __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  int __pyx_t_2;
-  void *__pyx_t_3;
+  void *__pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("ConstructorCall", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":252
  *     cdef DGLValue ret_val
  *     cdef int ret_tcode
  *     FuncCall(constructor_handle, args, &ret_val, &ret_tcode)             # <<<<<<<<<<<<<<
  *     assert ret_tcode == type_code
  *     handle[0] = ret_val.v_handle
@@ -9301,34 +6939,31 @@
  *     cdef int ret_tcode
  *     FuncCall(constructor_handle, args, &ret_val, &ret_tcode)
  *     assert ret_tcode == type_code             # <<<<<<<<<<<<<<
  *     handle[0] = ret_val.v_handle
  *     return 0
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(__pyx_assertions_enabled())) {
-    __pyx_t_2 = (__pyx_v_ret_tcode == __pyx_v_type_code);
-    if (unlikely(!__pyx_t_2)) {
-      __Pyx_Raise(__pyx_builtin_AssertionError, 0, 0, 0);
+  if (unlikely(!Py_OptimizeFlag)) {
+    if (unlikely(!((__pyx_v_ret_tcode == __pyx_v_type_code) != 0))) {
+      PyErr_SetNone(PyExc_AssertionError);
       __PYX_ERR(2, 253, __pyx_L1_error)
     }
   }
-  #else
-  if ((1)); else __PYX_ERR(2, 253, __pyx_L1_error)
   #endif
 
   /* "dgl/_ffi/_cython/function.pxi":254
  *     FuncCall(constructor_handle, args, &ret_val, &ret_tcode)
  *     assert ret_tcode == type_code
  *     handle[0] = ret_val.v_handle             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
-  __pyx_t_3 = __pyx_v_ret_val.v_handle;
-  (__pyx_v_handle[0]) = __pyx_t_3;
+  __pyx_t_2 = __pyx_v_ret_val.v_handle;
+  (__pyx_v_handle[0]) = __pyx_t_2;
 
   /* "dgl/_ffi/_cython/function.pxi":255
  *     assert ret_tcode == type_code
  *     handle[0] = ret_val.v_handle
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * 
@@ -9345,14 +6980,15 @@
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_AddTraceback("dgl._ffi._cy3.core.ConstructorCall", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "dgl/_ffi/_cython/function.pxi":262
  *     cdef int is_global
  * 
  *     cdef inline _set_handle(self, handle):             # <<<<<<<<<<<<<<
@@ -9360,29 +6996,27 @@
  *             self.chandle = NULL
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_12FunctionBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, PyObject *__pyx_v_handle) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  void *__pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_set_handle", 1);
+  int __pyx_t_2;
+  __Pyx_RefNannySetupContext("_set_handle", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":263
  * 
  *     cdef inline _set_handle(self, handle):
  *         if handle is None:             # <<<<<<<<<<<<<<
  *             self.chandle = NULL
  *         else:
  */
   __pyx_t_1 = (__pyx_v_handle == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/function.pxi":264
  *     cdef inline _set_handle(self, handle):
  *         if handle is None:
  *             self.chandle = NULL             # <<<<<<<<<<<<<<
  *         else:
  *             self.chandle = c_handle(handle)
@@ -9403,34 +7037,28 @@
  *             self.chandle = NULL
  *         else:
  *             self.chandle = c_handle(handle)             # <<<<<<<<<<<<<<
  * 
  *     property is_global:
  */
   /*else*/ {
-    __pyx_t_2 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_handle(__pyx_v_handle); if (unlikely(__pyx_t_2 == ((void *)NULL) && PyErr_Occurred())) __PYX_ERR(2, 266, __pyx_L1_error)
-    __pyx_v_self->chandle = __pyx_t_2;
+    __pyx_v_self->chandle = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_handle(__pyx_v_handle);
   }
   __pyx_L3:;
 
   /* "dgl/_ffi/_cython/function.pxi":262
  *     cdef int is_global
  * 
  *     cdef inline _set_handle(self, handle):             # <<<<<<<<<<<<<<
  *         if handle is None:
  *             self.chandle = NULL
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase._set_handle", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "dgl/_ffi/_cython/function.pxi":269
  * 
@@ -9439,19 +7067,17 @@
  *             return self.c_is_global != 0
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global___get__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -9459,15 +7085,15 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 1);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":270
  *     property is_global:
  *         def __get__(self):
  *             return self.c_is_global != 0             # <<<<<<<<<<<<<<
  * 
  *         def __set__(self, value):
@@ -9509,31 +7135,31 @@
  *             self.c_is_global = value
  * 
  */
 
 /* Python wrapper */
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_2__set__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_2__set__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, PyObject *__pyx_v_value) {
   int __pyx_r;
+  __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__set__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":273
  * 
  *         def __set__(self, value):
  *             self.c_is_global = value             # <<<<<<<<<<<<<<
  * 
  *     property handle:
@@ -9551,33 +7177,32 @@
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase.is_global.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "dgl/_ffi/_cython/function.pxi":276
  * 
  *     property handle:
  *         def __get__(self):             # <<<<<<<<<<<<<<
  *             if self.chandle == NULL:
  *                 return None
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle___get__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -9587,27 +7212,28 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 1);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":277
  *     property handle:
  *         def __get__(self):
  *             if self.chandle == NULL:             # <<<<<<<<<<<<<<
  *                 return None
  *             else:
  */
-  __pyx_t_1 = (__pyx_v_self->chandle == NULL);
+  __pyx_t_1 = ((__pyx_v_self->chandle == NULL) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":278
  *         def __get__(self):
  *             if self.chandle == NULL:
  *                 return None             # <<<<<<<<<<<<<<
  *             else:
@@ -9645,36 +7271,61 @@
     __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 280, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 280, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_5 = NULL;
     __pyx_t_7 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_4))) {
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
         __pyx_t_7 = 1;
       }
     }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_4)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_3, __pyx_t_6};
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 280, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    } else
     #endif
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_5, __pyx_t_3, __pyx_t_6};
-      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_3, __pyx_t_6};
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 280, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 280, __pyx_L1_error)
+    } else
+    #endif
+    {
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 280, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__pyx_t_5) {
+        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
+      }
+      __Pyx_GIVEREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_6);
+      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_6);
+      __pyx_t_3 = 0;
+      __pyx_t_6 = 0;
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 280, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "dgl/_ffi/_cython/function.pxi":276
  * 
@@ -9687,14 +7338,15 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase.handle.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -9706,34 +7358,32 @@
  *             self._set_handle(value)
  * 
  */
 
 /* Python wrapper */
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle_2__set__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6handle_2__set__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, PyObject *__pyx_v_value) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__set__", 1);
+  __Pyx_RefNannySetupContext("__set__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":282
  *                 return ctypes.cast(<unsigned long long>self.chandle, ctypes.c_void_p)
  *         def __set__(self, value):
  *             self._set_handle(value)             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, handle, is_global):
@@ -9771,111 +7421,81 @@
  */
 
 /* Python wrapper */
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_handle = 0;
   PyObject *__pyx_v_is_global = 0;
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return -1;
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_handle,&__pyx_n_s_is_global,0};
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_handle,&__pyx_n_s_is_global,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_handle)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 284, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_handle)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_is_global)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 284, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_is_global)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(2, 284, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(2, 284, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(2, 284, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
-      values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_handle = values[0];
     __pyx_v_is_global = values[1];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, __pyx_nargs); __PYX_ERR(2, 284, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 284, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
-    }
-  }
   __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase___init__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self), __pyx_v_handle, __pyx_v_is_global);
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase___init__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, PyObject *__pyx_v_handle, PyObject *__pyx_v_is_global) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init__", 1);
+  __Pyx_RefNannySetupContext("__init__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":285
  * 
  *     def __init__(self, handle, is_global):
  *         self._set_handle(handle)             # <<<<<<<<<<<<<<
  *         self.c_is_global = is_global
  * 
@@ -9920,41 +7540,39 @@
  *         if self.is_global == 0:
  *             CALL(DGLFuncFree(self.chandle))
  */
 
 /* Python wrapper */
 static void __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_3__dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_2__dealloc__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_2__dealloc__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__dealloc__", 1);
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":289
  * 
  *     def __dealloc__(self):
  *         if self.is_global == 0:             # <<<<<<<<<<<<<<
  *             CALL(DGLFuncFree(self.chandle))
  * 
  */
-  __pyx_t_1 = (__pyx_v_self->is_global == 0);
+  __pyx_t_1 = ((__pyx_v_self->is_global == 0) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/function.pxi":290
  *     def __dealloc__(self):
  *         if self.is_global == 0:
  *             CALL(DGLFuncFree(self.chandle))             # <<<<<<<<<<<<<<
  * 
@@ -9998,47 +7616,39 @@
  *         cdef int ret_tcode
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_5__call__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_5__call__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_args = 0;
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__call__ (wrapper)", 0);
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_VARARGS(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__call__", 0))) return NULL;
+  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__call__", 0))) return NULL;
   __Pyx_INCREF(__pyx_args);
   __pyx_v_args = __pyx_args;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_4__call__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self), __pyx_v_args);
 
   /* function exit code */
-  __Pyx_DECREF(__pyx_v_args);
+  __Pyx_XDECREF(__pyx_v_args);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_4__call__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, PyObject *__pyx_v_args) {
   DGLValue __pyx_v_ret_val;
   int __pyx_v_ret_tcode;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__call__", 1);
+  __Pyx_RefNannySetupContext("__call__", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":295
  *         cdef DGLValue ret_val
  *         cdef int ret_tcode
  *         FuncCall(self.chandle, args, &ret_val, &ret_tcode)             # <<<<<<<<<<<<<<
  *         return make_ret(ret_val, ret_tcode)
  * 
@@ -10076,219 +7686,118 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__ = {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6__reduce_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__reduce_cython__", 1);
+  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_self_chandle_cannot_be_converted, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__ = {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_8__setstate_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_8__setstate_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_12FunctionBase_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__setstate_cython__", 1);
+  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_self_chandle_cannot_be_converted, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.FunctionBase.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10297,117 +7806,35 @@
  * 
  * def _set_class_module(module_class):             # <<<<<<<<<<<<<<
  *     """Initialize the module."""
  *     global _CLASS_MODULE
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_5_set_class_module(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-PyDoc_STRVAR(__pyx_doc_3dgl_4_ffi_4_cy3_4core_4_set_class_module, "Initialize the module.");
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_5_set_class_module = {"_set_class_module", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_5_set_class_module, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_4_set_class_module};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_5_set_class_module(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v_module_class = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_5_set_class_module(PyObject *__pyx_self, PyObject *__pyx_v_module_class); /*proto*/
+static char __pyx_doc_3dgl_4_ffi_4_cy3_4core_4_set_class_module[] = "Initialize the module.";
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_5_set_class_module = {"_set_class_module", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_5_set_class_module, METH_O, __pyx_doc_3dgl_4_ffi_4_cy3_4core_4_set_class_module};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_5_set_class_module(PyObject *__pyx_self, PyObject *__pyx_v_module_class) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_set_class_module (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_module_class,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_module_class)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 301, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_set_class_module") < 0)) __PYX_ERR(2, 301, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v_module_class = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_set_class_module", 1, 1, 1, __pyx_nargs); __PYX_ERR(2, 301, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core._set_class_module", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_4_set_class_module(__pyx_self, __pyx_v_module_class);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_4_set_class_module(__pyx_self, ((PyObject *)__pyx_v_module_class));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_4_set_class_module(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_module_class) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_set_class_module", 1);
+  __Pyx_RefNannySetupContext("_set_class_module", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":304
  *     """Initialize the module."""
  *     global _CLASS_MODULE
  *     _CLASS_MODULE = module_class             # <<<<<<<<<<<<<<
  * 
  * def _set_class_function(func_class):
@@ -10439,116 +7866,34 @@
  * 
  * def _set_class_function(func_class):             # <<<<<<<<<<<<<<
  *     global _CLASS_FUNCTION
  *     _CLASS_FUNCTION = func_class
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_7_set_class_function(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_7_set_class_function = {"_set_class_function", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_7_set_class_function, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_7_set_class_function(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v_func_class = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_7_set_class_function(PyObject *__pyx_self, PyObject *__pyx_v_func_class); /*proto*/
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_7_set_class_function = {"_set_class_function", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_7_set_class_function, METH_O, 0};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_7_set_class_function(PyObject *__pyx_self, PyObject *__pyx_v_func_class) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_set_class_function (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func_class,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_func_class)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 306, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_set_class_function") < 0)) __PYX_ERR(2, 306, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v_func_class = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_set_class_function", 1, 1, 1, __pyx_nargs); __PYX_ERR(2, 306, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core._set_class_function", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_6_set_class_function(__pyx_self, __pyx_v_func_class);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_6_set_class_function(__pyx_self, ((PyObject *)__pyx_v_func_class));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_6_set_class_function(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_func_class) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_set_class_function", 1);
+  __Pyx_RefNannySetupContext("_set_class_function", 0);
 
   /* "dgl/_ffi/_cython/function.pxi":308
  * def _set_class_function(func_class):
  *     global _CLASS_FUNCTION
  *     _CLASS_FUNCTION = func_class             # <<<<<<<<<<<<<<
  */
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_CLASS_FUNCTION, __pyx_v_func_class) < 0) __PYX_ERR(2, 308, __pyx_L1_error)
@@ -10586,34 +7931,34 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   void *__pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_c_dlpack_deleter", 1);
+  __Pyx_RefNannySetupContext("_c_dlpack_deleter", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":10
  * cdef _c_dlpack_deleter(object pycaps):
  *     cdef DLManagedTensor* dltensor
  *     if pycapsule.PyCapsule_IsValid(pycaps, _c_str_dltensor):             # <<<<<<<<<<<<<<
  *         dltensor = <DLManagedTensor*>pycapsule.PyCapsule_GetPointer(pycaps, _c_str_dltensor)
  *         DGLDLManagedTensorCallDeleter(dltensor)
  */
-  __pyx_t_1 = PyCapsule_IsValid(__pyx_v_pycaps, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor);
+  __pyx_t_1 = (PyCapsule_IsValid(__pyx_v_pycaps, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":11
  *     cdef DLManagedTensor* dltensor
  *     if pycapsule.PyCapsule_IsValid(pycaps, _c_str_dltensor):
  *         dltensor = <DLManagedTensor*>pycapsule.PyCapsule_GetPointer(pycaps, _c_str_dltensor)             # <<<<<<<<<<<<<<
  *         DGLDLManagedTensorCallDeleter(dltensor)
  * 
  */
-    __pyx_t_2 = PyCapsule_GetPointer(__pyx_v_pycaps, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor); if (unlikely(__pyx_t_2 == ((void *)NULL) && PyErr_Occurred())) __PYX_ERR(6, 11, __pyx_L1_error)
+    __pyx_t_2 = PyCapsule_GetPointer(__pyx_v_pycaps, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor); if (unlikely(__pyx_t_2 == ((void *)NULL) && PyErr_Occurred())) __PYX_ERR(4, 11, __pyx_L1_error)
     __pyx_v_dltensor = ((DLManagedTensor *)__pyx_t_2);
 
     /* "dgl/_ffi/_cython/ndarray.pxi":12
  *     if pycapsule.PyCapsule_IsValid(pycaps, _c_str_dltensor):
  *         dltensor = <DLManagedTensor*>pycapsule.PyCapsule_GetPointer(pycaps, _c_str_dltensor)
  *         DGLDLManagedTensorCallDeleter(dltensor)             # <<<<<<<<<<<<<<
  * 
@@ -10655,105 +8000,23 @@
  * 
  * def _from_dlpack(object dltensor):             # <<<<<<<<<<<<<<
  *     cdef DLManagedTensor* ptr
  *     cdef DGLArrayHandle chandle
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_9_from_dlpack(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_9_from_dlpack = {"_from_dlpack", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_9_from_dlpack, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_9_from_dlpack(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v_dltensor = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_9_from_dlpack(PyObject *__pyx_self, PyObject *__pyx_v_dltensor); /*proto*/
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_9_from_dlpack = {"_from_dlpack", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_9_from_dlpack, METH_O, 0};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_9_from_dlpack(PyObject *__pyx_self, PyObject *__pyx_v_dltensor) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_from_dlpack (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_dltensor,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dltensor)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 15, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_from_dlpack") < 0)) __PYX_ERR(6, 15, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v_dltensor = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_from_dlpack", 1, 1, 1, __pyx_nargs); __PYX_ERR(6, 15, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core._from_dlpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_8_from_dlpack(__pyx_self, __pyx_v_dltensor);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_8_from_dlpack(__pyx_self, ((PyObject *)__pyx_v_dltensor));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_8_from_dlpack(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dltensor) {
   DLManagedTensor *__pyx_v_ptr;
   __pyx_t_3dgl_4_ffi_4_cy3_4core_DGLArrayHandle __pyx_v_chandle;
@@ -10762,74 +8025,74 @@
   int __pyx_t_1;
   void *__pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_from_dlpack", 1);
+  __Pyx_RefNannySetupContext("_from_dlpack", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":18
  *     cdef DLManagedTensor* ptr
  *     cdef DGLArrayHandle chandle
  *     if pycapsule.PyCapsule_IsValid(dltensor, _c_str_dltensor):             # <<<<<<<<<<<<<<
  *         ptr = <DLManagedTensor*>pycapsule.PyCapsule_GetPointer(dltensor, _c_str_dltensor)
  *         CALL(DGLArrayFromDLPack(ptr, &chandle))
  */
-  __pyx_t_1 = PyCapsule_IsValid(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor);
+  __pyx_t_1 = (PyCapsule_IsValid(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":19
  *     cdef DGLArrayHandle chandle
  *     if pycapsule.PyCapsule_IsValid(dltensor, _c_str_dltensor):
  *         ptr = <DLManagedTensor*>pycapsule.PyCapsule_GetPointer(dltensor, _c_str_dltensor)             # <<<<<<<<<<<<<<
  *         CALL(DGLArrayFromDLPack(ptr, &chandle))
  *         # set name and destructor to be empty
  */
-    __pyx_t_2 = PyCapsule_GetPointer(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor); if (unlikely(__pyx_t_2 == ((void *)NULL) && PyErr_Occurred())) __PYX_ERR(6, 19, __pyx_L1_error)
+    __pyx_t_2 = PyCapsule_GetPointer(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor); if (unlikely(__pyx_t_2 == ((void *)NULL) && PyErr_Occurred())) __PYX_ERR(4, 19, __pyx_L1_error)
     __pyx_v_ptr = ((DLManagedTensor *)__pyx_t_2);
 
     /* "dgl/_ffi/_cython/ndarray.pxi":20
  *     if pycapsule.PyCapsule_IsValid(dltensor, _c_str_dltensor):
  *         ptr = <DLManagedTensor*>pycapsule.PyCapsule_GetPointer(dltensor, _c_str_dltensor)
  *         CALL(DGLArrayFromDLPack(ptr, &chandle))             # <<<<<<<<<<<<<<
  *         # set name and destructor to be empty
  *         pycapsule.PyCapsule_SetDestructor(dltensor, NULL)
  */
-    __pyx_t_3 = __pyx_f_3dgl_4_ffi_4_cy3_4core_CALL(DGLArrayFromDLPack(__pyx_v_ptr, (&__pyx_v_chandle))); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 20, __pyx_L1_error)
+    __pyx_t_3 = __pyx_f_3dgl_4_ffi_4_cy3_4core_CALL(DGLArrayFromDLPack(__pyx_v_ptr, (&__pyx_v_chandle))); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 20, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "dgl/_ffi/_cython/ndarray.pxi":22
  *         CALL(DGLArrayFromDLPack(ptr, &chandle))
  *         # set name and destructor to be empty
  *         pycapsule.PyCapsule_SetDestructor(dltensor, NULL)             # <<<<<<<<<<<<<<
  *         pycapsule.PyCapsule_SetName(dltensor, _c_str_used_dltensor)
  *         return c_make_array(chandle, 0)
  */
-    __pyx_t_4 = PyCapsule_SetDestructor(__pyx_v_dltensor, NULL); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(6, 22, __pyx_L1_error)
+    __pyx_t_4 = PyCapsule_SetDestructor(__pyx_v_dltensor, NULL); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(4, 22, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/ndarray.pxi":23
  *         # set name and destructor to be empty
  *         pycapsule.PyCapsule_SetDestructor(dltensor, NULL)
  *         pycapsule.PyCapsule_SetName(dltensor, _c_str_used_dltensor)             # <<<<<<<<<<<<<<
  *         return c_make_array(chandle, 0)
  *     raise ValueError("Expect a dltensor field, pycapsule.PyCapsule can only be consumed once")
  */
-    __pyx_t_4 = PyCapsule_SetName(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_used_dltensor); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(6, 23, __pyx_L1_error)
+    __pyx_t_4 = PyCapsule_SetName(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_used_dltensor); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(4, 23, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/ndarray.pxi":24
  *         pycapsule.PyCapsule_SetDestructor(dltensor, NULL)
  *         pycapsule.PyCapsule_SetName(dltensor, _c_str_used_dltensor)
  *         return c_make_array(chandle, 0)             # <<<<<<<<<<<<<<
  *     raise ValueError("Expect a dltensor field, pycapsule.PyCapsule can only be consumed once")
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_make_array(__pyx_v_chandle, __pyx_int_0); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 24, __pyx_L1_error)
+    __pyx_t_3 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_make_array(__pyx_v_chandle, __pyx_int_0); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 24, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "dgl/_ffi/_cython/ndarray.pxi":18
  *     cdef DLManagedTensor* ptr
@@ -10843,19 +8106,19 @@
   /* "dgl/_ffi/_cython/ndarray.pxi":25
  *         pycapsule.PyCapsule_SetName(dltensor, _c_str_used_dltensor)
  *         return c_make_array(chandle, 0)
  *     raise ValueError("Expect a dltensor field, pycapsule.PyCapsule can only be consumed once")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 25, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 25, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_Raise(__pyx_t_3, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __PYX_ERR(6, 25, __pyx_L1_error)
+  __PYX_ERR(4, 25, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/ndarray.pxi":15
  * 
  * 
  * def _from_dlpack(object dltensor):             # <<<<<<<<<<<<<<
  *     cdef DLManagedTensor* ptr
  *     cdef DGLArrayHandle chandle
@@ -10881,34 +8144,37 @@
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, PyObject *__pyx_v_handle) {
   unsigned PY_LONG_LONG __pyx_v_ptr;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  unsigned PY_LONG_LONG __pyx_t_7;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  unsigned PY_LONG_LONG __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_set_handle", 1);
+  __Pyx_RefNannySetupContext("_set_handle", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":34
  *     cdef inline _set_handle(self, handle):
  *         cdef unsigned long long ptr
  *         if handle is None:             # <<<<<<<<<<<<<<
  *             self.chandle = NULL
  *         else:
  */
   __pyx_t_1 = (__pyx_v_handle == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":35
  *         cdef unsigned long long ptr
  *         if handle is None:
  *             self.chandle = NULL             # <<<<<<<<<<<<<<
  *         else:
  *             ptr = ctypes.cast(handle, ctypes.c_void_p).value
@@ -10929,53 +8195,77 @@
  *             self.chandle = NULL
  *         else:
  *             ptr = ctypes.cast(handle, ctypes.c_void_p).value             # <<<<<<<<<<<<<<
  *             self.chandle = <DGLArray*>(ptr)
  * 
  */
   /*else*/ {
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 37, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_cast); if (unlikely(!__pyx_t_4)) __PYX_ERR(6, 37, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_4)) __PYX_ERR(4, 37, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 37, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_5)) __PYX_ERR(6, 37, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_cast); if (unlikely(!__pyx_t_5)) __PYX_ERR(4, 37, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = NULL;
-    __pyx_t_6 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_4))) {
-      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
-      if (likely(__pyx_t_3)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-        __Pyx_INCREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_4)) __PYX_ERR(4, 37, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_6)) __PYX_ERR(4, 37, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = NULL;
+    __pyx_t_7 = 0;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_4, function);
-        __pyx_t_6 = 1;
+        __Pyx_DECREF_SET(__pyx_t_5, function);
+        __pyx_t_7 = 1;
       }
     }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_5)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_handle, __pyx_t_6};
+      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 37, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_handle, __pyx_t_6};
+      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 37, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    } else
     #endif
     {
-      PyObject *__pyx_callargs[3] = {__pyx_t_3, __pyx_v_handle, __pyx_t_5};
-      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
-      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 37, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(4, 37, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__pyx_t_4) {
+        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4); __pyx_t_4 = NULL;
+      }
+      __Pyx_INCREF(__pyx_v_handle);
+      __Pyx_GIVEREF(__pyx_v_handle);
+      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_v_handle);
+      __Pyx_GIVEREF(__pyx_t_6);
+      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_6);
+      __pyx_t_6 = 0;
+      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 37, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(6, 37, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_7 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_4); if (unlikely((__pyx_t_7 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(6, 37, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_v_ptr = __pyx_t_7;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(4, 37, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_9 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_5); if (unlikely((__pyx_t_9 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(4, 37, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_v_ptr = __pyx_t_9;
 
     /* "dgl/_ffi/_cython/ndarray.pxi":38
  *         else:
  *             ptr = ctypes.cast(handle, ctypes.c_void_p).value
  *             self.chandle = <DGLArray*>(ptr)             # <<<<<<<<<<<<<<
  * 
  *     property _dgl_handle:
@@ -10992,18 +8282,19 @@
  *         if handle is None:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase._set_handle", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -11015,44 +8306,42 @@
  *             return <unsigned long long>self.chandle
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_11_dgl_handle_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_11_dgl_handle_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_11_dgl_handle___get__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_11_dgl_handle___get__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 1);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":42
  *     property _dgl_handle:
  *         def __get__(self):
  *             return <unsigned long long>self.chandle             # <<<<<<<<<<<<<<
  * 
  *     property handle:
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(((unsigned PY_LONG_LONG)__pyx_v_self->chandle)); if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 42, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(((unsigned PY_LONG_LONG)__pyx_v_self->chandle)); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 42, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":41
  * 
@@ -11080,19 +8369,17 @@
  *             if self.chandle == NULL:
  *                 return None
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle___get__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -11102,27 +8389,28 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 1);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":46
  *     property handle:
  *         def __get__(self):
  *             if self.chandle == NULL:             # <<<<<<<<<<<<<<
  *                 return None
  *             else:
  */
-  __pyx_t_1 = (__pyx_v_self->chandle == NULL);
+  __pyx_t_1 = ((__pyx_v_self->chandle == NULL) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":47
  *         def __get__(self):
  *             if self.chandle == NULL:
  *                 return None             # <<<<<<<<<<<<<<
  *             else:
@@ -11146,55 +8434,80 @@
  *             else:
  *                 return ctypes.cast(             # <<<<<<<<<<<<<<
  *                     <unsigned long long>self.chandle, PyDGLArrayHandle)
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 49, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 49, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_cast); if (unlikely(!__pyx_t_4)) __PYX_ERR(6, 49, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_cast); if (unlikely(!__pyx_t_4)) __PYX_ERR(4, 49, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "dgl/_ffi/_cython/ndarray.pxi":50
  *             else:
  *                 return ctypes.cast(
  *                     <unsigned long long>self.chandle, PyDGLArrayHandle)             # <<<<<<<<<<<<<<
  * 
  *         def __set__(self, value):
  */
-    __pyx_t_3 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(((unsigned PY_LONG_LONG)__pyx_v_self->chandle)); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 50, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(((unsigned PY_LONG_LONG)__pyx_v_self->chandle)); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 50, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_PyDGLArrayHandle); if (unlikely(!__pyx_t_5)) __PYX_ERR(6, 50, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_PyDGLArrayHandle); if (unlikely(!__pyx_t_5)) __PYX_ERR(4, 50, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     __pyx_t_7 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_4))) {
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
         __pyx_t_7 = 1;
       }
     }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_4)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_5};
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 49, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    } else
     #endif
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_5};
-      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_5};
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 49, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 49, __pyx_L1_error)
+    } else
+    #endif
+    {
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(4, 49, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__pyx_t_6) {
+        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
+      }
+      __Pyx_GIVEREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_5);
+      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
+      __pyx_t_3 = 0;
+      __pyx_t_5 = 0;
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 49, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "dgl/_ffi/_cython/ndarray.pxi":45
  * 
@@ -11207,14 +8520,15 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase.handle.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -11226,43 +8540,41 @@
  *             self._set_handle(value)
  * 
  */
 
 /* Python wrapper */
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle_2__set__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6handle_2__set__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, PyObject *__pyx_v_value) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__set__", 1);
+  __Pyx_RefNannySetupContext("__set__", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":53
  * 
  *         def __set__(self, value):
  *             self._set_handle(value)             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, handle, is_view):
  */
-  __pyx_t_1 = __pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 53, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 53, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":52
  *                     <unsigned long long>self.chandle, PyDGLArrayHandle)
  * 
  *         def __set__(self, value):             # <<<<<<<<<<<<<<
@@ -11291,132 +8603,102 @@
  */
 
 /* Python wrapper */
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_handle = 0;
   PyObject *__pyx_v_is_view = 0;
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return -1;
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_handle,&__pyx_n_s_is_view,0};
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_handle,&__pyx_n_s_is_view,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_handle)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 55, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_handle)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_is_view)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 55, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_is_view)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(6, 55, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(4, 55, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(6, 55, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(4, 55, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
-      values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_handle = values[0];
     __pyx_v_is_view = values[1];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, __pyx_nargs); __PYX_ERR(6, 55, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(4, 55, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
-    }
-  }
   __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase___init__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self), __pyx_v_handle, __pyx_v_is_view);
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase___init__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, PyObject *__pyx_v_handle, PyObject *__pyx_v_is_view) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init__", 1);
+  __Pyx_RefNannySetupContext("__init__", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":56
  * 
  *     def __init__(self, handle, is_view):
  *         self._set_handle(handle)             # <<<<<<<<<<<<<<
  *         self.c_is_view = is_view
  * 
  */
-  __pyx_t_1 = __pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(__pyx_v_self, __pyx_v_handle); if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 56, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle(__pyx_v_self, __pyx_v_handle); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 56, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":57
  *     def __init__(self, handle, is_view):
  *         self._set_handle(handle)
  *         self.c_is_view = is_view             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
-  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_v_is_view); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(6, 57, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_v_is_view); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(4, 57, __pyx_L1_error)
   __pyx_v_self->c_is_view = __pyx_t_2;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":55
  *             self._set_handle(value)
  * 
  *     def __init__(self, handle, is_view):             # <<<<<<<<<<<<<<
  *         self._set_handle(handle)
@@ -11442,51 +8724,49 @@
  *         if self.c_is_view == 0:
  *             CALL(DGLArrayFree(self.chandle))
  */
 
 /* Python wrapper */
 static void __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_3__dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_2__dealloc__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_2__dealloc__(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__dealloc__", 1);
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":60
  * 
  *     def __dealloc__(self):
  *         if self.c_is_view == 0:             # <<<<<<<<<<<<<<
  *             CALL(DGLArrayFree(self.chandle))
  * 
  */
-  __pyx_t_1 = (__pyx_v_self->c_is_view == 0);
+  __pyx_t_1 = ((__pyx_v_self->c_is_view == 0) != 0);
   if (__pyx_t_1) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":61
  *     def __dealloc__(self):
  *         if self.c_is_view == 0:
  *             CALL(DGLArrayFree(self.chandle))             # <<<<<<<<<<<<<<
  * 
  *     def to_dlpack(self, alignment=0):
  */
-    __pyx_t_2 = __pyx_f_3dgl_4_ffi_4_cy3_4core_CALL(DGLArrayFree(__pyx_v_self->chandle)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 61, __pyx_L1_error)
+    __pyx_t_2 = __pyx_f_3dgl_4_ffi_4_cy3_4core_CALL(DGLArrayFree(__pyx_v_self->chandle)); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 61, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
     /* "dgl/_ffi/_cython/ndarray.pxi":60
  * 
  *     def __dealloc__(self):
  *         if self.c_is_view == 0:             # <<<<<<<<<<<<<<
@@ -11517,147 +8797,107 @@
  * 
  *     def to_dlpack(self, alignment=0):             # <<<<<<<<<<<<<<
  *         """Produce an array from a DLPack Tensor without copying memory
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-PyDoc_STRVAR(__pyx_doc_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack, "Produce an array from a DLPack Tensor without copying memory\n\n        Args\n        -------\n        alignment: int, default to be 0\n        Indicates the alignment requirement when converting to dlpack. Will copy to a \n        new tensor if the alignment requirement is not satisfied. \n        0 means no alignment requirement.\n        \n        Returns\n        -------\n        dlpack : DLPack tensor view of the array data\n        ");
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack = {"to_dlpack", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack[] = "Produce an array from a DLPack Tensor without copying memory\n\n        Args\n        -------\n        alignment: int, default to be 0\n        Indicates the alignment requirement when converting to dlpack. Will copy to a \n        new tensor if the alignment requirement is not satisfied. \n        0 means no alignment requirement.\n        \n        Returns\n        -------\n        dlpack : DLPack tensor view of the array data\n        ";
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_alignment = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("to_dlpack (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_alignment,0};
-    values[0] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)__pyx_int_0));
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_alignment,0};
+    PyObject* values[1] = {0};
+    values[0] = ((PyObject *)__pyx_int_0);
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_alignment);
-          if (value) { values[0] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 63, __pyx_L3_error)
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_alignment);
+          if (value) { values[0] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "to_dlpack") < 0)) __PYX_ERR(6, 63, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "to_dlpack") < 0)) __PYX_ERR(4, 63, __pyx_L3_error)
       }
     } else {
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_alignment = values[0];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("to_dlpack", 0, 0, 1, __pyx_nargs); __PYX_ERR(6, 63, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("to_dlpack", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(4, 63, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase.to_dlpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self), __pyx_v_alignment);
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, PyObject *__pyx_v_alignment) {
   DLManagedTensor *__pyx_v_dltensor;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("to_dlpack", 1);
+  __Pyx_RefNannySetupContext("to_dlpack", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":78
  *         """
  *         cdef DLManagedTensor* dltensor
  *         if self.c_is_view != 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("to_dlpack do not work with memory views")
  *         CALL(DGLArrayToDLPack(self.chandle, &dltensor, alignment))
  */
-  __pyx_t_1 = (__pyx_v_self->c_is_view != 0);
+  __pyx_t_1 = ((__pyx_v_self->c_is_view != 0) != 0);
   if (unlikely(__pyx_t_1)) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":79
  *         cdef DLManagedTensor* dltensor
  *         if self.c_is_view != 0:
  *             raise ValueError("to_dlpack do not work with memory views")             # <<<<<<<<<<<<<<
  *         CALL(DGLArrayToDLPack(self.chandle, &dltensor, alignment))
  *         return pycapsule.PyCapsule_New(dltensor, _c_str_dltensor, <PyCapsule_Destructor>_c_dlpack_deleter)
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 79, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 79, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(6, 79, __pyx_L1_error)
+    __PYX_ERR(4, 79, __pyx_L1_error)
 
     /* "dgl/_ffi/_cython/ndarray.pxi":78
  *         """
  *         cdef DLManagedTensor* dltensor
  *         if self.c_is_view != 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("to_dlpack do not work with memory views")
  *         CALL(DGLArrayToDLPack(self.chandle, &dltensor, alignment))
@@ -11667,28 +8907,28 @@
   /* "dgl/_ffi/_cython/ndarray.pxi":80
  *         if self.c_is_view != 0:
  *             raise ValueError("to_dlpack do not work with memory views")
  *         CALL(DGLArrayToDLPack(self.chandle, &dltensor, alignment))             # <<<<<<<<<<<<<<
  *         return pycapsule.PyCapsule_New(dltensor, _c_str_dltensor, <PyCapsule_Destructor>_c_dlpack_deleter)
  * 
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_alignment); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(6, 80, __pyx_L1_error)
-  __pyx_t_2 = __pyx_f_3dgl_4_ffi_4_cy3_4core_CALL(DGLArrayToDLPack(__pyx_v_self->chandle, (&__pyx_v_dltensor), __pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 80, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_alignment); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(4, 80, __pyx_L1_error)
+  __pyx_t_2 = __pyx_f_3dgl_4_ffi_4_cy3_4core_CALL(DGLArrayToDLPack(__pyx_v_self->chandle, (&__pyx_v_dltensor), __pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 80, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":81
  *             raise ValueError("to_dlpack do not work with memory views")
  *         CALL(DGLArrayToDLPack(self.chandle, &dltensor, alignment))
  *         return pycapsule.PyCapsule_New(dltensor, _c_str_dltensor, <PyCapsule_Destructor>_c_dlpack_deleter)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyCapsule_New(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor, ((PyCapsule_Destructor)__pyx_f_3dgl_4_ffi_4_cy3_4core__c_dlpack_deleter)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 81, __pyx_L1_error)
+  __pyx_t_2 = PyCapsule_New(__pyx_v_dltensor, __pyx_v_3dgl_4_ffi_4_cy3_4core__c_str_dltensor, ((PyCapsule_Destructor)__pyx_f_3dgl_4_ffi_4_cy3_4core__c_dlpack_deleter)); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 81, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":63
  *             CALL(DGLArrayFree(self.chandle))
@@ -11707,219 +8947,118 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__ = {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6__reduce_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__reduce_cython__", 1);
+  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_self_chandle_cannot_be_converted, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__ = {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_8__setstate_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_8__setstate_cython__(((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__setstate_cython__", 1);
+  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_self_chandle_cannot_be_converted, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.NDArrayBase.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -11935,49 +9074,73 @@
   PyObject *__pyx_v_ret = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("c_make_array", 1);
+  __Pyx_RefNannySetupContext("c_make_array", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":85
  * 
  * cdef c_make_array(void* chandle, is_view):
  *     ret = _CLASS_NDARRAY(None, is_view)             # <<<<<<<<<<<<<<
  *     (<NDArrayBase>ret).chandle = <DGLArray*>chandle
  *     return ret
  */
   __Pyx_INCREF(__pyx_v_3dgl_4_ffi_4_cy3_4core__CLASS_NDARRAY);
   __pyx_t_2 = __pyx_v_3dgl_4_ffi_4_cy3_4core__CLASS_NDARRAY; __pyx_t_3 = NULL;
   __pyx_t_4 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_2))) {
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_4 = 1;
     }
   }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, Py_None, __pyx_v_is_view};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 85, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+  } else
   #endif
-  {
-    PyObject *__pyx_callargs[3] = {__pyx_t_3, Py_None, __pyx_v_is_view};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_4, 2+__pyx_t_4);
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, Py_None, __pyx_v_is_view};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 85, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 85, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  } else
+  #endif
+  {
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(4, 85, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__pyx_t_3) {
+      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
+    }
+    __Pyx_INCREF(Py_None);
+    __Pyx_GIVEREF(Py_None);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, Py_None);
+    __Pyx_INCREF(__pyx_v_is_view);
+    __Pyx_GIVEREF(__pyx_v_is_view);
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_is_view);
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 85, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_ret = __pyx_t_1;
   __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":86
  * cdef c_make_array(void* chandle, is_view):
  *     ret = _CLASS_NDARRAY(None, is_view)
  *     (<NDArrayBase>ret).chandle = <DGLArray*>chandle             # <<<<<<<<<<<<<<
@@ -12007,14 +9170,15 @@
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("dgl._ffi._cy3.core.c_make_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_ret);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
@@ -12025,175 +9189,129 @@
  * 
  * def _reg_extension(cls, fcreate):             # <<<<<<<<<<<<<<
  *     global _DGL_COMPATS
  *     _DGL_COMPATS += (cls,)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11_reg_extension(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_11_reg_extension = {"_reg_extension", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11_reg_extension, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11_reg_extension(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11_reg_extension(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_11_reg_extension = {"_reg_extension", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11_reg_extension, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_11_reg_extension(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_cls = 0;
   PyObject *__pyx_v_fcreate = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_reg_extension (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_fcreate,0};
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_fcreate,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_cls)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 94, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_fcreate)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 94, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fcreate)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_reg_extension", 1, 2, 2, 1); __PYX_ERR(6, 94, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_reg_extension", 1, 2, 2, 1); __PYX_ERR(4, 94, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_reg_extension") < 0)) __PYX_ERR(6, 94, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_reg_extension") < 0)) __PYX_ERR(4, 94, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_cls = values[0];
     __pyx_v_fcreate = values[1];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_reg_extension", 1, 2, 2, __pyx_nargs); __PYX_ERR(6, 94, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("_reg_extension", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(4, 94, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_AddTraceback("dgl._ffi._cy3.core._reg_extension", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_10_reg_extension(__pyx_self, __pyx_v_cls, __pyx_v_fcreate);
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_10_reg_extension(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_fcreate) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_reg_extension", 1);
+  __Pyx_RefNannySetupContext("_reg_extension", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":96
  * def _reg_extension(cls, fcreate):
  *     global _DGL_COMPATS
  *     _DGL_COMPATS += (cls,)             # <<<<<<<<<<<<<<
  *     if fcreate:
  *         _DGL_EXT_RET[cls._dgl_tcode] = fcreate
  */
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 96, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_cls);
   __Pyx_GIVEREF(__pyx_v_cls);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_cls)) __PYX_ERR(6, 96, __pyx_L1_error);
-  __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 96, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_cls);
+  __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_XGOTREF(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS);
   __Pyx_DECREF_SET(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_COMPATS, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":97
  *     global _DGL_COMPATS
  *     _DGL_COMPATS += (cls,)
  *     if fcreate:             # <<<<<<<<<<<<<<
  *         _DGL_EXT_RET[cls._dgl_tcode] = fcreate
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_fcreate); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(6, 97, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_fcreate); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(4, 97, __pyx_L1_error)
   if (__pyx_t_3) {
 
     /* "dgl/_ffi/_cython/ndarray.pxi":98
  *     _DGL_COMPATS += (cls,)
  *     if fcreate:
  *         _DGL_EXT_RET[cls._dgl_tcode] = fcreate             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_dgl_tcode); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 98, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_dgl_tcode); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 98, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    if (unlikely((PyObject_SetItem(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, __pyx_t_2, __pyx_v_fcreate) < 0))) __PYX_ERR(6, 98, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, __pyx_t_2, __pyx_v_fcreate) < 0)) __PYX_ERR(4, 98, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
     /* "dgl/_ffi/_cython/ndarray.pxi":97
  *     global _DGL_COMPATS
  *     _DGL_COMPATS += (cls,)
  *     if fcreate:             # <<<<<<<<<<<<<<
  *         _DGL_EXT_RET[cls._dgl_tcode] = fcreate
@@ -12228,195 +9346,174 @@
  * 
  * def _make_array(handle, is_view):             # <<<<<<<<<<<<<<
  *     cdef unsigned long long ptr
  *     ptr = ctypes.cast(handle, ctypes.c_void_p).value
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_13_make_array(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_13_make_array = {"_make_array", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_13_make_array, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_13_make_array(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_13_make_array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_13_make_array = {"_make_array", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_13_make_array, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_13_make_array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_handle = 0;
   PyObject *__pyx_v_is_view = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_make_array (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_handle,&__pyx_n_s_is_view,0};
-    if (__pyx_kwds) {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_handle,&__pyx_n_s_is_view,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_handle)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 101, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_handle)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_is_view)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 101, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_is_view)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_make_array", 1, 2, 2, 1); __PYX_ERR(6, 101, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_make_array", 1, 2, 2, 1); __PYX_ERR(4, 101, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_make_array") < 0)) __PYX_ERR(6, 101, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_make_array") < 0)) __PYX_ERR(4, 101, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_handle = values[0];
     __pyx_v_is_view = values[1];
   }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_make_array", 1, 2, 2, __pyx_nargs); __PYX_ERR(6, 101, __pyx_L3_error)
-  __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("_make_array", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(4, 101, __pyx_L3_error)
   __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_AddTraceback("dgl._ffi._cy3.core._make_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_12_make_array(__pyx_self, __pyx_v_handle, __pyx_v_is_view);
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_12_make_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_handle, PyObject *__pyx_v_is_view) {
   unsigned PY_LONG_LONG __pyx_v_ptr;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
-  unsigned PY_LONG_LONG __pyx_t_6;
+  PyObject *__pyx_t_6 = NULL;
+  unsigned PY_LONG_LONG __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_make_array", 1);
+  __Pyx_RefNannySetupContext("_make_array", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":103
  * def _make_array(handle, is_view):
  *     cdef unsigned long long ptr
  *     ptr = ctypes.cast(handle, ctypes.c_void_p).value             # <<<<<<<<<<<<<<
  *     return c_make_array(<void*>ptr, is_view)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 103, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 103, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_cast); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 103, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_cast); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 103, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 103, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ctypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 103, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_4)) __PYX_ERR(6, 103, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_c_void_p); if (unlikely(!__pyx_t_4)) __PYX_ERR(4, 103, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_5 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_5 = 1;
     }
   }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_handle, __pyx_t_4};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 103, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
   #endif
-  {
-    PyObject *__pyx_callargs[3] = {__pyx_t_2, __pyx_v_handle, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 2+__pyx_t_5);
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_handle, __pyx_t_4};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 103, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 103, __pyx_L1_error)
+  } else
+  #endif
+  {
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(4, 103, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    if (__pyx_t_2) {
+      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2); __pyx_t_2 = NULL;
+    }
+    __Pyx_INCREF(__pyx_v_handle);
+    __Pyx_GIVEREF(__pyx_v_handle);
+    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_handle);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_4);
+    __pyx_t_4 = 0;
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 103, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 103, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 103, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_3); if (unlikely((__pyx_t_6 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(6, 103, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_3); if (unlikely((__pyx_t_7 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(4, 103, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_ptr = __pyx_t_6;
+  __pyx_v_ptr = __pyx_t_7;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":104
  *     cdef unsigned long long ptr
  *     ptr = ctypes.cast(handle, ctypes.c_void_p).value
  *     return c_make_array(<void*>ptr, is_view)             # <<<<<<<<<<<<<<
  * 
  * cdef object _CLASS_NDARRAY = None
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_make_array(((void *)__pyx_v_ptr), __pyx_v_is_view); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 104, __pyx_L1_error)
+  __pyx_t_3 = __pyx_f_3dgl_4_ffi_4_cy3_4core_c_make_array(((void *)__pyx_v_ptr), __pyx_v_is_view); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 104, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":101
  * 
@@ -12428,14 +9525,15 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("dgl._ffi._cy3.core._make_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -12445,113 +9543,31 @@
  * 
  * def _set_class_ndarray(cls):             # <<<<<<<<<<<<<<
  *     global _CLASS_NDARRAY
  *     _CLASS_NDARRAY = cls
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray = {"_set_class_ndarray", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v_cls = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[1] = {0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray(PyObject *__pyx_self, PyObject *__pyx_v_cls); /*proto*/
+static PyMethodDef __pyx_mdef_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray = {"_set_class_ndarray", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray, METH_O, 0};
+static PyObject *__pyx_pw_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray(PyObject *__pyx_self, PyObject *__pyx_v_cls) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("_set_class_ndarray (wrapper)", 0);
-  #if !CYTHON_METH_FASTCALL
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
-  #endif
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_cls)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(6, 108, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_set_class_ndarray") < 0)) __PYX_ERR(6, 108, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v_cls = values[0];
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_set_class_ndarray", 1, 1, 1, __pyx_nargs); __PYX_ERR(6, 108, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
-  __Pyx_AddTraceback("dgl._ffi._cy3.core._set_class_ndarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_14_set_class_ndarray(__pyx_self, __pyx_v_cls);
+  __pyx_r = __pyx_pf_3dgl_4_ffi_4_cy3_4core_14_set_class_ndarray(__pyx_self, ((PyObject *)__pyx_v_cls));
 
   /* function exit code */
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
-    }
-  }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_3dgl_4_ffi_4_cy3_4core_14_set_class_ndarray(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_set_class_ndarray", 1);
+  __Pyx_RefNannySetupContext("_set_class_ndarray", 0);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":110
  * def _set_class_ndarray(cls):
  *     global _CLASS_NDARRAY
  *     _CLASS_NDARRAY = cls             # <<<<<<<<<<<<<<
  */
   __Pyx_INCREF(__pyx_v_cls);
@@ -12574,54 +9590,40 @@
   return __pyx_r;
 }
 static struct __pyx_vtabstruct_3dgl_4_ffi_4_cy3_4core_ObjectBase __pyx_vtable_3dgl_4_ffi_4_cy3_4core_ObjectBase;
 
 static PyObject *__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_ObjectBase(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *)o);
   p->__pyx_vtab = __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_ObjectBase;
   return o;
 }
 
 static void __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_ObjectBase(PyObject *o) {
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_ObjectBase) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
     __pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_1__dealloc__(o);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) - 1);
     PyErr_Restore(etype, eval, etb);
   }
-  #if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
   (*Py_TYPE(o)->tp_free)(o);
-  #else
-  {
-    freefunc tp_free = (freefunc)PyType_GetSlot(Py_TYPE(o), Py_tp_free);
-    if (tp_free) tp_free(o);
-  }
-  #endif
 }
 
 static PyObject *__pyx_tp_getattro_3dgl_4_ffi_4_cy3_4core_ObjectBase(PyObject *o, PyObject *n) {
   PyObject *v = __Pyx_PyObject_GenericGetAttr(o, n);
   if (!v && PyErr_ExceptionMatches(PyExc_AttributeError)) {
     PyErr_Clear();
     v = __pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_3__getattr__(o, n);
@@ -12641,45 +9643,28 @@
     PyErr_SetString(PyExc_NotImplementedError, "__del__");
     return -1;
   }
 }
 
 static PyMethodDef __pyx_methods_3dgl_4_ffi_4_cy3_4core_ObjectBase[] = {
   {"__getattr__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_3__getattr__, METH_O|METH_COEXIST, 0},
-  {"__init_handle_by_constructor__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__init_handle_by_constructor__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_10ObjectBase_4__init_handle_by_constructor__},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_3dgl_4_ffi_4_cy3_4core_ObjectBase[] = {
   {(char *)"handle", __pyx_getprop_3dgl_4_ffi_4_cy3_4core_10ObjectBase_handle, __pyx_setprop_3dgl_4_ffi_4_cy3_4core_10ObjectBase_handle, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_ObjectBase},
-  {Py_tp_getattro, (void *)__pyx_tp_getattro_3dgl_4_ffi_4_cy3_4core_ObjectBase},
-  {Py_tp_methods, (void *)__pyx_methods_3dgl_4_ffi_4_cy3_4core_ObjectBase},
-  {Py_tp_getset, (void *)__pyx_getsets_3dgl_4_ffi_4_cy3_4core_ObjectBase},
-  {Py_tp_new, (void *)__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_ObjectBase},
-  {0, 0},
-};
-static PyType_Spec __pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase_spec = {
-  "dgl._ffi._cy3.core.ObjectBase",
-  sizeof(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE,
-  __pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase_slots,
-};
-#else
 
 static PyTypeObject __pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase = {
   PyVarObject_HEAD_INIT(0, 0)
-  "dgl._ffi._cy3.core.""ObjectBase", /*tp_name*/
+  "dgl._ffi._cy3.core.ObjectBase", /*tp_name*/
   sizeof(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_ObjectBase, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -12714,95 +9699,71 @@
   __pyx_methods_3dgl_4_ffi_4_cy3_4core_ObjectBase, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_3dgl_4_ffi_4_cy3_4core_ObjectBase, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_3dgl_4_ffi_4_cy3_4core_ObjectBase, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
-  #endif
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
   0, /*tp_pypy_flags*/
   #endif
 };
-#endif
 static struct __pyx_vtabstruct_3dgl_4_ffi_4_cy3_4core_FunctionBase __pyx_vtable_3dgl_4_ffi_4_cy3_4core_FunctionBase;
 
 static PyObject *__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_FunctionBase(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *)o);
   p->__pyx_vtab = __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_FunctionBase;
   return o;
 }
 
 static void __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_FunctionBase(PyObject *o) {
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_FunctionBase) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
     __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_3__dealloc__(o);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) - 1);
     PyErr_Restore(etype, eval, etb);
   }
-  #if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
   (*Py_TYPE(o)->tp_free)(o);
-  #else
-  {
-    freefunc tp_free = (freefunc)PyType_GetSlot(Py_TYPE(o), Py_tp_free);
-    if (tp_free) tp_free(o);
-  }
-  #endif
 }
 
 static PyObject *__pyx_getprop_3dgl_4_ffi_4_cy3_4core_12FunctionBase_is_global(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9is_global_1__get__(o);
 }
 
 static int __pyx_setprop_3dgl_4_ffi_4_cy3_4core_12FunctionBase_is_global(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
@@ -12826,46 +9787,28 @@
   else {
     PyErr_SetString(PyExc_NotImplementedError, "__del__");
     return -1;
   }
 }
 
 static PyMethodDef __pyx_methods_3dgl_4_ffi_4_cy3_4core_FunctionBase[] = {
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_3dgl_4_ffi_4_cy3_4core_FunctionBase[] = {
   {(char *)"is_global", __pyx_getprop_3dgl_4_ffi_4_cy3_4core_12FunctionBase_is_global, __pyx_setprop_3dgl_4_ffi_4_cy3_4core_12FunctionBase_is_global, (char *)0, 0},
   {(char *)"handle", __pyx_getprop_3dgl_4_ffi_4_cy3_4core_12FunctionBase_handle, __pyx_setprop_3dgl_4_ffi_4_cy3_4core_12FunctionBase_handle, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_FunctionBase},
-  {Py_tp_call, (void *)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_5__call__},
-  {Py_tp_methods, (void *)__pyx_methods_3dgl_4_ffi_4_cy3_4core_FunctionBase},
-  {Py_tp_getset, (void *)__pyx_getsets_3dgl_4_ffi_4_cy3_4core_FunctionBase},
-  {Py_tp_init, (void *)__pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_1__init__},
-  {Py_tp_new, (void *)__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_FunctionBase},
-  {0, 0},
-};
-static PyType_Spec __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase_spec = {
-  "dgl._ffi._cy3.core.FunctionBase",
-  sizeof(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE,
-  __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase_slots,
-};
-#else
 
 static PyTypeObject __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase = {
   PyVarObject_HEAD_INIT(0, 0)
-  "dgl._ffi._cy3.core.""FunctionBase", /*tp_name*/
+  "dgl._ffi._cy3.core.FunctionBase", /*tp_name*/
   sizeof(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_FunctionBase, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -12900,95 +9843,71 @@
   __pyx_methods_3dgl_4_ffi_4_cy3_4core_FunctionBase, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_3dgl_4_ffi_4_cy3_4core_FunctionBase, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   __pyx_pw_3dgl_4_ffi_4_cy3_4core_12FunctionBase_1__init__, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_3dgl_4_ffi_4_cy3_4core_FunctionBase, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
-  #endif
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
   0, /*tp_pypy_flags*/
   #endif
 };
-#endif
 static struct __pyx_vtabstruct_3dgl_4_ffi_4_cy3_4core_NDArrayBase __pyx_vtable_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
 
 static PyObject *__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_NDArrayBase(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *)o);
   p->__pyx_vtab = __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
   return o;
 }
 
 static void __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_NDArrayBase(PyObject *o) {
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_NDArrayBase) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
     __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_3__dealloc__(o);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) - 1);
     PyErr_Restore(etype, eval, etb);
   }
-  #if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
   (*Py_TYPE(o)->tp_free)(o);
-  #else
-  {
-    freefunc tp_free = (freefunc)PyType_GetSlot(Py_TYPE(o), Py_tp_free);
-    if (tp_free) tp_free(o);
-  }
-  #endif
 }
 
 static PyObject *__pyx_getprop_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__dgl_handle(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_11_dgl_handle_1__get__(o);
 }
 
 static PyObject *__pyx_getprop_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_handle(PyObject *o, CYTHON_UNUSED void *x) {
@@ -13002,46 +9921,29 @@
   else {
     PyErr_SetString(PyExc_NotImplementedError, "__del__");
     return -1;
   }
 }
 
 static PyMethodDef __pyx_methods_3dgl_4_ffi_4_cy3_4core_NDArrayBase[] = {
-  {"to_dlpack", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"to_dlpack", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_4to_dlpack},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_3dgl_4_ffi_4_cy3_4core_NDArrayBase[] = {
   {(char *)"_dgl_handle", __pyx_getprop_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__dgl_handle, 0, (char *)0, 0},
   {(char *)"handle", __pyx_getprop_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_handle, __pyx_setprop_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_handle, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_NDArrayBase},
-  {Py_tp_methods, (void *)__pyx_methods_3dgl_4_ffi_4_cy3_4core_NDArrayBase},
-  {Py_tp_getset, (void *)__pyx_getsets_3dgl_4_ffi_4_cy3_4core_NDArrayBase},
-  {Py_tp_init, (void *)__pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_1__init__},
-  {Py_tp_new, (void *)__pyx_tp_new_3dgl_4_ffi_4_cy3_4core_NDArrayBase},
-  {0, 0},
-};
-static PyType_Spec __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase_spec = {
-  "dgl._ffi._cy3.core.NDArrayBase",
-  sizeof(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE,
-  __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase_slots,
-};
-#else
 
 static PyTypeObject __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase = {
   PyVarObject_HEAD_INIT(0, 0)
-  "dgl._ffi._cy3.core.""NDArrayBase", /*tp_name*/
+  "dgl._ffi._cy3.core.NDArrayBase", /*tp_name*/
   sizeof(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_3dgl_4_ffi_4_cy3_4core_NDArrayBase, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -13076,471 +9978,425 @@
   __pyx_methods_3dgl_4_ffi_4_cy3_4core_NDArrayBase, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_3dgl_4_ffi_4_cy3_4core_NDArrayBase, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   __pyx_pw_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_1__init__, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_3dgl_4_ffi_4_cy3_4core_NDArrayBase, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
-  #endif
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
   0, /*tp_pypy_flags*/
   #endif
 };
-#endif
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
+
+#if PY_MAJOR_VERSION >= 3
+#if CYTHON_PEP489_MULTI_PHASE_INIT
+static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
+static int __pyx_pymod_exec_core(PyObject* module); /*proto*/
+static PyModuleDef_Slot __pyx_moduledef_slots[] = {
+  {Py_mod_create, (void*)__pyx_pymod_create},
+  {Py_mod_exec, (void*)__pyx_pymod_exec_core},
+  {0, NULL}
+};
+#endif
+
+static struct PyModuleDef __pyx_moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "core",
+    0, /* m_doc */
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    0, /* m_size */
+  #else
+    -1, /* m_size */
+  #endif
+    __pyx_methods /* m_methods */,
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    __pyx_moduledef_slots, /* m_slots */
+  #else
+    NULL, /* m_reload */
+  #endif
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
 #ifndef CYTHON_SMALL_CODE
 #if defined(__clang__)
     #define CYTHON_SMALL_CODE
 #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
-/* #### Code section: pystring_table ### */
 
-static int __Pyx_CreateStringTabAndInitStrings(void) {
-  __Pyx_StringTabEntry __pyx_string_tab[] = {
-    {&__pyx_kp_u_, __pyx_k_, sizeof(__pyx_k_), 0, 1, 0, 0},
-    {&__pyx_n_s_AssertionError, __pyx_k_AssertionError, sizeof(__pyx_k_AssertionError), 0, 0, 1, 1},
-    {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
-    {&__pyx_n_s_CLASS_FUNCTION, __pyx_k_CLASS_FUNCTION, sizeof(__pyx_k_CLASS_FUNCTION), 0, 0, 1, 1},
-    {&__pyx_n_s_CLASS_MODULE, __pyx_k_CLASS_MODULE, sizeof(__pyx_k_CLASS_MODULE), 0, 0, 1, 1},
-    {&__pyx_n_s_CTypesDGLContext, __pyx_k_CTypesDGLContext, sizeof(__pyx_k_CTypesDGLContext), 0, 0, 1, 1},
-    {&__pyx_n_s_CTypesDGLDataType, __pyx_k_CTypesDGLDataType, sizeof(__pyx_k_CTypesDGLDataType), 0, 0, 1, 1},
-    {&__pyx_n_s_DGLArrayHandle, __pyx_k_DGLArrayHandle, sizeof(__pyx_k_DGLArrayHandle), 0, 0, 1, 1},
-    {&__pyx_n_s_DGLByteArray, __pyx_k_DGLByteArray, sizeof(__pyx_k_DGLByteArray), 0, 0, 1, 1},
-    {&__pyx_n_s_DGLContext, __pyx_k_DGLContext, sizeof(__pyx_k_DGLContext), 0, 0, 1, 1},
-    {&__pyx_n_s_DGLDataType, __pyx_k_DGLDataType, sizeof(__pyx_k_DGLDataType), 0, 0, 1, 1},
-    {&__pyx_n_s_DGLError, __pyx_k_DGLError, sizeof(__pyx_k_DGLError), 0, 0, 1, 1},
-    {&__pyx_kp_u_Don_t_know_how_to_handle_type_s, __pyx_k_Don_t_know_how_to_handle_type_s, sizeof(__pyx_k_Don_t_know_how_to_handle_type_s), 0, 1, 0, 0},
-    {&__pyx_kp_u_Expect_a_dltensor_field_pycapsul, __pyx_k_Expect_a_dltensor_field_pycapsul, sizeof(__pyx_k_Expect_a_dltensor_field_pycapsul), 0, 1, 0, 0},
-    {&__pyx_n_s_FunctionBase, __pyx_k_FunctionBase, sizeof(__pyx_k_FunctionBase), 0, 0, 1, 1},
-    {&__pyx_n_s_FunctionBase___reduce_cython, __pyx_k_FunctionBase___reduce_cython, sizeof(__pyx_k_FunctionBase___reduce_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_FunctionBase___setstate_cython, __pyx_k_FunctionBase___setstate_cython, sizeof(__pyx_k_FunctionBase___setstate_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_Integral, __pyx_k_Integral, sizeof(__pyx_k_Integral), 0, 0, 1, 1},
-    {&__pyx_n_s_NDArrayBase, __pyx_k_NDArrayBase, sizeof(__pyx_k_NDArrayBase), 0, 0, 1, 1},
-    {&__pyx_n_s_NDArrayBase___reduce_cython, __pyx_k_NDArrayBase___reduce_cython, sizeof(__pyx_k_NDArrayBase___reduce_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_NDArrayBase___setstate_cython, __pyx_k_NDArrayBase___setstate_cython, sizeof(__pyx_k_NDArrayBase___setstate_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_NDArrayBase_to_dlpack, __pyx_k_NDArrayBase_to_dlpack, sizeof(__pyx_k_NDArrayBase_to_dlpack), 0, 0, 1, 1},
-    {&__pyx_n_s_Number, __pyx_k_Number, sizeof(__pyx_k_Number), 0, 0, 1, 1},
-    {&__pyx_n_s_OBJECT_TYPE, __pyx_k_OBJECT_TYPE, sizeof(__pyx_k_OBJECT_TYPE), 0, 0, 1, 1},
-    {&__pyx_n_s_ObjectBase, __pyx_k_ObjectBase, sizeof(__pyx_k_ObjectBase), 0, 0, 1, 1},
-    {&__pyx_n_s_ObjectBase___init_handle_by_cons, __pyx_k_ObjectBase___init_handle_by_cons, sizeof(__pyx_k_ObjectBase___init_handle_by_cons), 0, 0, 1, 1},
-    {&__pyx_n_s_ObjectBase___reduce_cython, __pyx_k_ObjectBase___reduce_cython, sizeof(__pyx_k_ObjectBase___reduce_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_ObjectBase___setstate_cython, __pyx_k_ObjectBase___setstate_cython, sizeof(__pyx_k_ObjectBase___setstate_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_ObjectGeneric, __pyx_k_ObjectGeneric, sizeof(__pyx_k_ObjectGeneric), 0, 0, 1, 1},
-    {&__pyx_n_s_POINTER, __pyx_k_POINTER, sizeof(__pyx_k_POINTER), 0, 0, 1, 1},
-    {&__pyx_kp_u_PackedFunction_can_only_support, __pyx_k_PackedFunction_can_only_support, sizeof(__pyx_k_PackedFunction_can_only_support), 0, 1, 0, 0},
-    {&__pyx_n_s_PyDGLArrayHandle, __pyx_k_PyDGLArrayHandle, sizeof(__pyx_k_PyDGLArrayHandle), 0, 0, 1, 1},
-    {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
-    {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
-    {&__pyx_kp_u_Unhandled_type_code_d, __pyx_k_Unhandled_type_code_d, sizeof(__pyx_k_Unhandled_type_code_d), 0, 1, 0, 0},
-    {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-    {&__pyx_n_s__39, __pyx_k__39, sizeof(__pyx_k__39), 0, 0, 1, 1},
-    {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
-    {&__pyx_n_s__8, __pyx_k__8, sizeof(__pyx_k__8), 0, 0, 1, 1},
-    {&__pyx_n_s__9, __pyx_k__9, sizeof(__pyx_k__9), 0, 0, 1, 1},
-    {&__pyx_n_s_addressof, __pyx_k_addressof, sizeof(__pyx_k_addressof), 0, 0, 1, 1},
-    {&__pyx_n_s_alignment, __pyx_k_alignment, sizeof(__pyx_k_alignment), 0, 0, 1, 1},
-    {&__pyx_n_s_api_internal, __pyx_k_api_internal, sizeof(__pyx_k_api_internal), 0, 0, 1, 1},
-    {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
-    {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
-    {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
-    {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
-    {&__pyx_n_s_c_byte, __pyx_k_c_byte, sizeof(__pyx_k_c_byte), 0, 0, 1, 1},
-    {&__pyx_n_s_c_is_global, __pyx_k_c_is_global, sizeof(__pyx_k_c_is_global), 0, 0, 1, 1},
-    {&__pyx_n_s_c_void_p, __pyx_k_c_void_p, sizeof(__pyx_k_c_void_p), 0, 0, 1, 1},
-    {&__pyx_n_s_cast, __pyx_k_cast, sizeof(__pyx_k_cast), 0, 0, 1, 1},
-    {&__pyx_n_s_chandle, __pyx_k_chandle, sizeof(__pyx_k_chandle), 0, 0, 1, 1},
-    {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
-    {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
-    {&__pyx_n_s_cls, __pyx_k_cls, sizeof(__pyx_k_cls), 0, 0, 1, 1},
-    {&__pyx_n_s_convert_to_dgl_func, __pyx_k_convert_to_dgl_func, sizeof(__pyx_k_convert_to_dgl_func), 0, 0, 1, 1},
-    {&__pyx_n_s_convert_to_object, __pyx_k_convert_to_object, sizeof(__pyx_k_convert_to_object), 0, 0, 1, 1},
-    {&__pyx_n_s_ctypes, __pyx_k_ctypes, sizeof(__pyx_k_ctypes), 0, 0, 1, 1},
-    {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
-    {&__pyx_n_s_dgl__ffi__cy3_core, __pyx_k_dgl__ffi__cy3_core, sizeof(__pyx_k_dgl__ffi__cy3_core), 0, 0, 1, 1},
-    {&__pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_k_dgl__ffi__cython_function_pxi, sizeof(__pyx_k_dgl__ffi__cython_function_pxi), 0, 0, 1, 0},
-    {&__pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_k_dgl__ffi__cython_ndarray_pxi, sizeof(__pyx_k_dgl__ffi__cython_ndarray_pxi), 0, 0, 1, 0},
-    {&__pyx_kp_s_dgl__ffi__cython_object_pxi, __pyx_k_dgl__ffi__cython_object_pxi, sizeof(__pyx_k_dgl__ffi__cython_object_pxi), 0, 0, 1, 0},
-    {&__pyx_n_s_dgl_handle, __pyx_k_dgl_handle, sizeof(__pyx_k_dgl_handle), 0, 0, 1, 1},
-    {&__pyx_n_s_dgl_tcode, __pyx_k_dgl_tcode, sizeof(__pyx_k_dgl_tcode), 0, 0, 1, 1},
-    {&__pyx_kp_u_disable, __pyx_k_disable, sizeof(__pyx_k_disable), 0, 1, 0, 0},
-    {&__pyx_n_s_dltensor, __pyx_k_dltensor, sizeof(__pyx_k_dltensor), 0, 0, 1, 1},
-    {&__pyx_kp_u_enable, __pyx_k_enable, sizeof(__pyx_k_enable), 0, 1, 0, 0},
-    {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
-    {&__pyx_n_s_fconstructor, __pyx_k_fconstructor, sizeof(__pyx_k_fconstructor), 0, 0, 1, 1},
-    {&__pyx_n_s_fcreate, __pyx_k_fcreate, sizeof(__pyx_k_fcreate), 0, 0, 1, 1},
-    {&__pyx_n_s_format_exc, __pyx_k_format_exc, sizeof(__pyx_k_format_exc), 0, 0, 1, 1},
-    {&__pyx_n_s_from_buffer, __pyx_k_from_buffer, sizeof(__pyx_k_from_buffer), 0, 0, 1, 1},
-    {&__pyx_n_s_from_dlpack, __pyx_k_from_dlpack, sizeof(__pyx_k_from_dlpack), 0, 0, 1, 1},
-    {&__pyx_n_s_func_class, __pyx_k_func_class, sizeof(__pyx_k_func_class), 0, 0, 1, 1},
-    {&__pyx_kp_u_gc, __pyx_k_gc, sizeof(__pyx_k_gc), 0, 1, 0, 0},
-    {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
-    {&__pyx_n_s_handle, __pyx_k_handle, sizeof(__pyx_k_handle), 0, 0, 1, 1},
-    {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-    {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
-    {&__pyx_n_s_init_handle_by_constructor, __pyx_k_init_handle_by_constructor, sizeof(__pyx_k_init_handle_by_constructor), 0, 0, 1, 1},
-    {&__pyx_n_s_initializing, __pyx_k_initializing, sizeof(__pyx_k_initializing), 0, 0, 1, 1},
-    {&__pyx_n_s_is_coroutine, __pyx_k_is_coroutine, sizeof(__pyx_k_is_coroutine), 0, 0, 1, 1},
-    {&__pyx_n_s_is_global, __pyx_k_is_global, sizeof(__pyx_k_is_global), 0, 0, 1, 1},
-    {&__pyx_n_s_is_view, __pyx_k_is_view, sizeof(__pyx_k_is_view), 0, 0, 1, 1},
-    {&__pyx_kp_u_isenabled, __pyx_k_isenabled, sizeof(__pyx_k_isenabled), 0, 1, 0, 0},
-    {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-    {&__pyx_n_s_make_array, __pyx_k_make_array, sizeof(__pyx_k_make_array), 0, 0, 1, 1},
-    {&__pyx_n_s_memmove, __pyx_k_memmove, sizeof(__pyx_k_memmove), 0, 0, 1, 1},
-    {&__pyx_kp_u_memmove_failed, __pyx_k_memmove_failed, sizeof(__pyx_k_memmove_failed), 0, 1, 0, 0},
-    {&__pyx_n_s_module_class, __pyx_k_module_class, sizeof(__pyx_k_module_class), 0, 0, 1, 1},
-    {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
-    {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
-    {&__pyx_n_s_numbers, __pyx_k_numbers, sizeof(__pyx_k_numbers), 0, 0, 1, 1},
-    {&__pyx_n_s_object_generic, __pyx_k_object_generic, sizeof(__pyx_k_object_generic), 0, 0, 1, 1},
-    {&__pyx_kp_u_object_has_no_attribute, __pyx_k_object_has_no_attribute, sizeof(__pyx_k_object_has_no_attribute), 0, 1, 0, 0},
-    {&__pyx_n_s_ptr, __pyx_k_ptr, sizeof(__pyx_k_ptr), 0, 0, 1, 1},
-    {&__pyx_n_s_pyfunc, __pyx_k_pyfunc, sizeof(__pyx_k_pyfunc), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
-    {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
-    {&__pyx_n_s_reg_extension, __pyx_k_reg_extension, sizeof(__pyx_k_reg_extension), 0, 0, 1, 1},
-    {&__pyx_n_s_register_object, __pyx_k_register_object, sizeof(__pyx_k_register_object), 0, 0, 1, 1},
-    {&__pyx_n_s_ret, __pyx_k_ret, sizeof(__pyx_k_ret), 0, 0, 1, 1},
-    {&__pyx_n_s_runtime_ctypes, __pyx_k_runtime_ctypes, sizeof(__pyx_k_runtime_ctypes), 0, 0, 1, 1},
-    {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
-    {&__pyx_kp_s_self_chandle_cannot_be_converted, __pyx_k_self_chandle_cannot_be_converted, sizeof(__pyx_k_self_chandle_cannot_be_converted), 0, 0, 1, 0},
-    {&__pyx_n_s_set_class_function, __pyx_k_set_class_function, sizeof(__pyx_k_set_class_function), 0, 0, 1, 1},
-    {&__pyx_n_s_set_class_module, __pyx_k_set_class_module, sizeof(__pyx_k_set_class_module), 0, 0, 1, 1},
-    {&__pyx_n_s_set_class_ndarray, __pyx_k_set_class_ndarray, sizeof(__pyx_k_set_class_ndarray), 0, 0, 1, 1},
-    {&__pyx_n_s_set_class_object_base, __pyx_k_set_class_object_base, sizeof(__pyx_k_set_class_object_base), 0, 0, 1, 1},
-    {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
-    {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
-    {&__pyx_n_s_spec, __pyx_k_spec, sizeof(__pyx_k_spec), 0, 0, 1, 1},
-    {&__pyx_n_s_string_types, __pyx_k_string_types, sizeof(__pyx_k_string_types), 0, 0, 1, 1},
-    {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
-    {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-    {&__pyx_n_s_to_dlpack, __pyx_k_to_dlpack, sizeof(__pyx_k_to_dlpack), 0, 0, 1, 1},
-    {&__pyx_kp_u_to_dlpack_do_not_work_with_memor, __pyx_k_to_dlpack_do_not_work_with_memor, sizeof(__pyx_k_to_dlpack_do_not_work_with_memor), 0, 1, 0, 0},
-    {&__pyx_n_s_traceback, __pyx_k_traceback, sizeof(__pyx_k_traceback), 0, 0, 1, 1},
-    {&__pyx_kp_u_utf_8, __pyx_k_utf_8, sizeof(__pyx_k_utf_8), 0, 1, 0, 0},
-    {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
-    {0, 0, 0, 0, 0, 0, 0}
-  };
-  return __Pyx_InitStrings(__pyx_string_tab);
-}
-/* #### Code section: cached_builtins ### */
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_u_, __pyx_k_, sizeof(__pyx_k_), 0, 1, 0, 0},
+  {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
+  {&__pyx_n_s_CLASS_FUNCTION, __pyx_k_CLASS_FUNCTION, sizeof(__pyx_k_CLASS_FUNCTION), 0, 0, 1, 1},
+  {&__pyx_n_s_CLASS_MODULE, __pyx_k_CLASS_MODULE, sizeof(__pyx_k_CLASS_MODULE), 0, 0, 1, 1},
+  {&__pyx_n_s_CTypesDGLContext, __pyx_k_CTypesDGLContext, sizeof(__pyx_k_CTypesDGLContext), 0, 0, 1, 1},
+  {&__pyx_n_s_CTypesDGLDataType, __pyx_k_CTypesDGLDataType, sizeof(__pyx_k_CTypesDGLDataType), 0, 0, 1, 1},
+  {&__pyx_n_s_DGLArrayHandle, __pyx_k_DGLArrayHandle, sizeof(__pyx_k_DGLArrayHandle), 0, 0, 1, 1},
+  {&__pyx_n_s_DGLByteArray, __pyx_k_DGLByteArray, sizeof(__pyx_k_DGLByteArray), 0, 0, 1, 1},
+  {&__pyx_n_s_DGLContext, __pyx_k_DGLContext, sizeof(__pyx_k_DGLContext), 0, 0, 1, 1},
+  {&__pyx_n_s_DGLDataType, __pyx_k_DGLDataType, sizeof(__pyx_k_DGLDataType), 0, 0, 1, 1},
+  {&__pyx_n_s_DGLError, __pyx_k_DGLError, sizeof(__pyx_k_DGLError), 0, 0, 1, 1},
+  {&__pyx_kp_u_Don_t_know_how_to_handle_type_s, __pyx_k_Don_t_know_how_to_handle_type_s, sizeof(__pyx_k_Don_t_know_how_to_handle_type_s), 0, 1, 0, 0},
+  {&__pyx_kp_u_Expect_a_dltensor_field_pycapsul, __pyx_k_Expect_a_dltensor_field_pycapsul, sizeof(__pyx_k_Expect_a_dltensor_field_pycapsul), 0, 1, 0, 0},
+  {&__pyx_n_s_FunctionBase, __pyx_k_FunctionBase, sizeof(__pyx_k_FunctionBase), 0, 0, 1, 1},
+  {&__pyx_n_s_Integral, __pyx_k_Integral, sizeof(__pyx_k_Integral), 0, 0, 1, 1},
+  {&__pyx_n_s_NDArrayBase, __pyx_k_NDArrayBase, sizeof(__pyx_k_NDArrayBase), 0, 0, 1, 1},
+  {&__pyx_n_s_Number, __pyx_k_Number, sizeof(__pyx_k_Number), 0, 0, 1, 1},
+  {&__pyx_n_s_OBJECT_TYPE, __pyx_k_OBJECT_TYPE, sizeof(__pyx_k_OBJECT_TYPE), 0, 0, 1, 1},
+  {&__pyx_n_s_ObjectBase, __pyx_k_ObjectBase, sizeof(__pyx_k_ObjectBase), 0, 0, 1, 1},
+  {&__pyx_n_s_ObjectGeneric, __pyx_k_ObjectGeneric, sizeof(__pyx_k_ObjectGeneric), 0, 0, 1, 1},
+  {&__pyx_n_s_POINTER, __pyx_k_POINTER, sizeof(__pyx_k_POINTER), 0, 0, 1, 1},
+  {&__pyx_kp_u_PackedFunction_can_only_support, __pyx_k_PackedFunction_can_only_support, sizeof(__pyx_k_PackedFunction_can_only_support), 0, 1, 0, 0},
+  {&__pyx_n_s_PyDGLArrayHandle, __pyx_k_PyDGLArrayHandle, sizeof(__pyx_k_PyDGLArrayHandle), 0, 0, 1, 1},
+  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
+  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
+  {&__pyx_kp_u_Unhandled_type_code_d, __pyx_k_Unhandled_type_code_d, sizeof(__pyx_k_Unhandled_type_code_d), 0, 1, 0, 0},
+  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s__13, __pyx_k__13, sizeof(__pyx_k__13), 0, 0, 1, 1},
+  {&__pyx_n_s_addressof, __pyx_k_addressof, sizeof(__pyx_k_addressof), 0, 0, 1, 1},
+  {&__pyx_n_s_alignment, __pyx_k_alignment, sizeof(__pyx_k_alignment), 0, 0, 1, 1},
+  {&__pyx_n_s_api_internal, __pyx_k_api_internal, sizeof(__pyx_k_api_internal), 0, 0, 1, 1},
+  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
+  {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
+  {&__pyx_n_s_c_byte, __pyx_k_c_byte, sizeof(__pyx_k_c_byte), 0, 0, 1, 1},
+  {&__pyx_n_s_c_is_global, __pyx_k_c_is_global, sizeof(__pyx_k_c_is_global), 0, 0, 1, 1},
+  {&__pyx_n_s_c_void_p, __pyx_k_c_void_p, sizeof(__pyx_k_c_void_p), 0, 0, 1, 1},
+  {&__pyx_n_s_cast, __pyx_k_cast, sizeof(__pyx_k_cast), 0, 0, 1, 1},
+  {&__pyx_n_s_chandle, __pyx_k_chandle, sizeof(__pyx_k_chandle), 0, 0, 1, 1},
+  {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
+  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
+  {&__pyx_n_s_cls, __pyx_k_cls, sizeof(__pyx_k_cls), 0, 0, 1, 1},
+  {&__pyx_n_s_convert_to_dgl_func, __pyx_k_convert_to_dgl_func, sizeof(__pyx_k_convert_to_dgl_func), 0, 0, 1, 1},
+  {&__pyx_n_s_convert_to_object, __pyx_k_convert_to_object, sizeof(__pyx_k_convert_to_object), 0, 0, 1, 1},
+  {&__pyx_n_s_ctypes, __pyx_k_ctypes, sizeof(__pyx_k_ctypes), 0, 0, 1, 1},
+  {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
+  {&__pyx_n_s_dgl__ffi__cy3_core, __pyx_k_dgl__ffi__cy3_core, sizeof(__pyx_k_dgl__ffi__cy3_core), 0, 0, 1, 1},
+  {&__pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_k_dgl__ffi__cython_function_pxi, sizeof(__pyx_k_dgl__ffi__cython_function_pxi), 0, 0, 1, 0},
+  {&__pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_k_dgl__ffi__cython_ndarray_pxi, sizeof(__pyx_k_dgl__ffi__cython_ndarray_pxi), 0, 0, 1, 0},
+  {&__pyx_kp_s_dgl__ffi__cython_object_pxi, __pyx_k_dgl__ffi__cython_object_pxi, sizeof(__pyx_k_dgl__ffi__cython_object_pxi), 0, 0, 1, 0},
+  {&__pyx_n_s_dgl_handle, __pyx_k_dgl_handle, sizeof(__pyx_k_dgl_handle), 0, 0, 1, 1},
+  {&__pyx_n_s_dgl_tcode, __pyx_k_dgl_tcode, sizeof(__pyx_k_dgl_tcode), 0, 0, 1, 1},
+  {&__pyx_n_s_dltensor, __pyx_k_dltensor, sizeof(__pyx_k_dltensor), 0, 0, 1, 1},
+  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
+  {&__pyx_n_s_fconstructor, __pyx_k_fconstructor, sizeof(__pyx_k_fconstructor), 0, 0, 1, 1},
+  {&__pyx_n_s_fcreate, __pyx_k_fcreate, sizeof(__pyx_k_fcreate), 0, 0, 1, 1},
+  {&__pyx_n_s_format_exc, __pyx_k_format_exc, sizeof(__pyx_k_format_exc), 0, 0, 1, 1},
+  {&__pyx_n_s_from_buffer, __pyx_k_from_buffer, sizeof(__pyx_k_from_buffer), 0, 0, 1, 1},
+  {&__pyx_n_s_from_dlpack, __pyx_k_from_dlpack, sizeof(__pyx_k_from_dlpack), 0, 0, 1, 1},
+  {&__pyx_n_s_func_class, __pyx_k_func_class, sizeof(__pyx_k_func_class), 0, 0, 1, 1},
+  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
+  {&__pyx_n_s_handle, __pyx_k_handle, sizeof(__pyx_k_handle), 0, 0, 1, 1},
+  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
+  {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
+  {&__pyx_n_s_is_global, __pyx_k_is_global, sizeof(__pyx_k_is_global), 0, 0, 1, 1},
+  {&__pyx_n_s_is_view, __pyx_k_is_view, sizeof(__pyx_k_is_view), 0, 0, 1, 1},
+  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
+  {&__pyx_n_s_make_array, __pyx_k_make_array, sizeof(__pyx_k_make_array), 0, 0, 1, 1},
+  {&__pyx_n_s_memmove, __pyx_k_memmove, sizeof(__pyx_k_memmove), 0, 0, 1, 1},
+  {&__pyx_kp_u_memmove_failed, __pyx_k_memmove_failed, sizeof(__pyx_k_memmove_failed), 0, 1, 0, 0},
+  {&__pyx_n_s_module_class, __pyx_k_module_class, sizeof(__pyx_k_module_class), 0, 0, 1, 1},
+  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
+  {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
+  {&__pyx_n_s_numbers, __pyx_k_numbers, sizeof(__pyx_k_numbers), 0, 0, 1, 1},
+  {&__pyx_n_s_object_generic, __pyx_k_object_generic, sizeof(__pyx_k_object_generic), 0, 0, 1, 1},
+  {&__pyx_kp_u_object_has_no_attribute, __pyx_k_object_has_no_attribute, sizeof(__pyx_k_object_has_no_attribute), 0, 1, 0, 0},
+  {&__pyx_n_s_ptr, __pyx_k_ptr, sizeof(__pyx_k_ptr), 0, 0, 1, 1},
+  {&__pyx_n_s_pyfunc, __pyx_k_pyfunc, sizeof(__pyx_k_pyfunc), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
+  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
+  {&__pyx_n_s_reg_extension, __pyx_k_reg_extension, sizeof(__pyx_k_reg_extension), 0, 0, 1, 1},
+  {&__pyx_n_s_register_object, __pyx_k_register_object, sizeof(__pyx_k_register_object), 0, 0, 1, 1},
+  {&__pyx_n_s_ret, __pyx_k_ret, sizeof(__pyx_k_ret), 0, 0, 1, 1},
+  {&__pyx_n_s_runtime_ctypes, __pyx_k_runtime_ctypes, sizeof(__pyx_k_runtime_ctypes), 0, 0, 1, 1},
+  {&__pyx_kp_s_self_chandle_cannot_be_converted, __pyx_k_self_chandle_cannot_be_converted, sizeof(__pyx_k_self_chandle_cannot_be_converted), 0, 0, 1, 0},
+  {&__pyx_n_s_set_class_function, __pyx_k_set_class_function, sizeof(__pyx_k_set_class_function), 0, 0, 1, 1},
+  {&__pyx_n_s_set_class_module, __pyx_k_set_class_module, sizeof(__pyx_k_set_class_module), 0, 0, 1, 1},
+  {&__pyx_n_s_set_class_ndarray, __pyx_k_set_class_ndarray, sizeof(__pyx_k_set_class_ndarray), 0, 0, 1, 1},
+  {&__pyx_n_s_set_class_object_base, __pyx_k_set_class_object_base, sizeof(__pyx_k_set_class_object_base), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
+  {&__pyx_n_s_string_types, __pyx_k_string_types, sizeof(__pyx_k_string_types), 0, 0, 1, 1},
+  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+  {&__pyx_kp_u_to_dlpack_do_not_work_with_memor, __pyx_k_to_dlpack_do_not_work_with_memor, sizeof(__pyx_k_to_dlpack_do_not_work_with_memor), 0, 1, 0, 0},
+  {&__pyx_n_s_traceback, __pyx_k_traceback, sizeof(__pyx_k_traceback), 0, 0, 1, 1},
+  {&__pyx_kp_u_utf_8, __pyx_k_utf_8, sizeof(__pyx_k_utf_8), 0, 1, 0, 0},
+  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
   __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 64, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
   __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(2, 26, __pyx_L1_error)
   __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(2, 47, __pyx_L1_error)
   __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(2, 166, __pyx_L1_error)
-  __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(2, 253, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
-/* #### Code section: cached_constants ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
+ */
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_self_chandle_cannot_be_converted); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_self_chandle_cannot_be_converted); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
+
   /* "dgl/_ffi/_cython/function.pxi":47
  *     if rv is not None:
  *         if isinstance(rv, tuple):
  *             raise ValueError("PackedFunction can only support one return value")             # <<<<<<<<<<<<<<
  *         temp_args = []
  *         make_arg(rv, &value, &tcode, temp_args)
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_PackedFunction_can_only_support); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(2, 47, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_PackedFunction_can_only_support); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(2, 47, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
 
   /* "dgl/_ffi/_cython/function.pxi":73
  *                                 dgl_callback_finalize,
  *                                 &chandle))
  *     ret = _CLASS_FUNCTION(None, False)             # <<<<<<<<<<<<<<
  *     (<FunctionBase>ret).chandle = chandle
  *     return ret
  */
-  __pyx_tuple__3 = PyTuple_Pack(2, Py_None, Py_False); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(2, 73, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
+  __pyx_tuple__5 = PyTuple_Pack(2, Py_None, Py_False); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(2, 73, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
 
   /* "dgl/_ffi/_cython/function.pxi":166
  *     rptr = (ctypes.c_byte * size).from_buffer(res)
  *     if not ctypes.memmove(rptr, arr.data, size):
  *         raise RuntimeError('memmove failed')             # <<<<<<<<<<<<<<
  *     return res
  * 
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_memmove_failed); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(2, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_memmove_failed); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(2, 166, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
+ */
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_self_chandle_cannot_be_converted); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_self_chandle_cannot_be_converted); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":25
  *         pycapsule.PyCapsule_SetName(dltensor, _c_str_used_dltensor)
  *         return c_make_array(chandle, 0)
  *     raise ValueError("Expect a dltensor field, pycapsule.PyCapsule can only be consumed once")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_Expect_a_dltensor_field_pycapsul); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(6, 25, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Expect_a_dltensor_field_pycapsul); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(4, 25, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
 
   /* "dgl/_ffi/_cython/ndarray.pxi":79
  *         cdef DLManagedTensor* dltensor
  *         if self.c_is_view != 0:
  *             raise ValueError("to_dlpack do not work with memory views")             # <<<<<<<<<<<<<<
  *         CALL(DGLArrayToDLPack(self.chandle, &dltensor, alignment))
  *         return pycapsule.PyCapsule_New(dltensor, _c_str_dltensor, <PyCapsule_Destructor>_c_dlpack_deleter)
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_to_dlpack_do_not_work_with_memor); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(6, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
-
-  /* "dgl/_ffi/_cython/object.pxi":8
- * OBJECT_TYPE = []
- * 
- * def _register_object(int index, object cls):             # <<<<<<<<<<<<<<
- *     """register object class"""
- *     while len(OBJECT_TYPE) <= index:
- */
-  __pyx_tuple__10 = PyTuple_Pack(2, __pyx_n_s_index, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 8, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_to_dlpack_do_not_work_with_memor); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(4, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
-  __pyx_codeobj__11 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__10, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_object_pxi, __pyx_n_s_register_object, 8, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__11)) __PYX_ERR(0, 8, __pyx_L1_error)
 
-  /* "dgl/_ffi/_cython/object.pxi":68
- *         return make_ret(ret_val, ret_type_code)
- * 
- *     def __init_handle_by_constructor__(self, fconstructor, *args):             # <<<<<<<<<<<<<<
- *         """Initialize the handle by calling constructor function.
- * 
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
  */
-  __pyx_tuple__12 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_fconstructor, __pyx_n_s_args, __pyx_n_s_chandle); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 68, __pyx_L1_error)
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_self_chandle_cannot_be_converted); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.chandle cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_self_chandle_cannot_be_converted); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
-  __pyx_codeobj__13 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__12, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_object_pxi, __pyx_n_s_init_handle_by_constructor, 68, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__13)) __PYX_ERR(0, 68, __pyx_L1_error)
 
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):
+  /* "dgl/_ffi/_cython/object.pxi":8
+ * OBJECT_TYPE = []
+ * 
+ * def _register_object(int index, object cls):             # <<<<<<<<<<<<<<
+ *     """register object class"""
+ *     while len(OBJECT_TYPE) <= index:
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__14 = PyTuple_Pack(2, __pyx_n_s_index, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 8, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__14);
   __Pyx_GIVEREF(__pyx_tuple__14);
-  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(1, 1, __pyx_L1_error)
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- */
-  __pyx_tuple__16 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pyx_state); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
-  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(1, 3, __pyx_L1_error)
+  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_object_pxi, __pyx_n_s_register_object, 8, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 8, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/function.pxi":54
  * 
  * 
  * def convert_to_dgl_func(object pyfunc):             # <<<<<<<<<<<<<<
  *     """Convert a python function to DGL function
  * 
  */
-  __pyx_tuple__18 = PyTuple_Pack(3, __pyx_n_s_pyfunc, __pyx_n_s_chandle, __pyx_n_s_ret); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(2, 54, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
-  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_n_s_convert_to_dgl_func, 54, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(2, 54, __pyx_L1_error)
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):
- */
-  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(1, 1, __pyx_L1_error)
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- */
-  __pyx_codeobj__21 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__21)) __PYX_ERR(1, 3, __pyx_L1_error)
+  __pyx_tuple__16 = PyTuple_Pack(3, __pyx_n_s_pyfunc, __pyx_n_s_chandle, __pyx_n_s_ret); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(2, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_n_s_convert_to_dgl_func, 54, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(2, 54, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/function.pxi":301
  * _CLASS_MODULE = None
  * 
  * def _set_class_module(module_class):             # <<<<<<<<<<<<<<
  *     """Initialize the module."""
  *     global _CLASS_MODULE
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_n_s_module_class); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(2, 301, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__22);
-  __Pyx_GIVEREF(__pyx_tuple__22);
-  __pyx_codeobj__23 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_n_s_set_class_module, 301, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__23)) __PYX_ERR(2, 301, __pyx_L1_error)
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_n_s_module_class); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(2, 301, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_n_s_set_class_module, 301, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(2, 301, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/function.pxi":306
  *     _CLASS_MODULE = module_class
  * 
  * def _set_class_function(func_class):             # <<<<<<<<<<<<<<
  *     global _CLASS_FUNCTION
  *     _CLASS_FUNCTION = func_class
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_n_s_func_class); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(2, 306, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
-  __pyx_codeobj__25 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__24, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_n_s_set_class_function, 306, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__25)) __PYX_ERR(2, 306, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_n_s_func_class); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(2, 306, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_codeobj__21 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_function_pxi, __pyx_n_s_set_class_function, 306, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__21)) __PYX_ERR(2, 306, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/ndarray.pxi":15
  * 
  * 
  * def _from_dlpack(object dltensor):             # <<<<<<<<<<<<<<
  *     cdef DLManagedTensor* ptr
  *     cdef DGLArrayHandle chandle
  */
-  __pyx_tuple__26 = PyTuple_Pack(3, __pyx_n_s_dltensor, __pyx_n_s_ptr, __pyx_n_s_chandle); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(6, 15, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
-  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_from_dlpack, 15, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(6, 15, __pyx_L1_error)
-
-  /* "dgl/_ffi/_cython/ndarray.pxi":63
- *             CALL(DGLArrayFree(self.chandle))
- * 
- *     def to_dlpack(self, alignment=0):             # <<<<<<<<<<<<<<
- *         """Produce an array from a DLPack Tensor without copying memory
- * 
- */
-  __pyx_tuple__28 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_alignment, __pyx_n_s_dltensor); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(6, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
-  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_to_dlpack, 63, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(6, 63, __pyx_L1_error)
-  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_int_0); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(6, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__30);
-  __Pyx_GIVEREF(__pyx_tuple__30);
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):
- */
-  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(1, 1, __pyx_L1_error)
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- */
-  __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(1, 3, __pyx_L1_error)
+  __pyx_tuple__22 = PyTuple_Pack(3, __pyx_n_s_dltensor, __pyx_n_s_ptr, __pyx_n_s_chandle); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(4, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_codeobj__23 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_from_dlpack, 15, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__23)) __PYX_ERR(4, 15, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/ndarray.pxi":94
  * cdef _DGL_EXT_RET = {}
  * 
  * def _reg_extension(cls, fcreate):             # <<<<<<<<<<<<<<
  *     global _DGL_COMPATS
  *     _DGL_COMPATS += (cls,)
  */
-  __pyx_tuple__33 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_fcreate); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(6, 94, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__33);
-  __Pyx_GIVEREF(__pyx_tuple__33);
-  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__33, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_reg_extension, 94, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(6, 94, __pyx_L1_error)
+  __pyx_tuple__24 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_fcreate); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(4, 94, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_codeobj__25 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__24, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_reg_extension, 94, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__25)) __PYX_ERR(4, 94, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/ndarray.pxi":101
  * 
  * 
  * def _make_array(handle, is_view):             # <<<<<<<<<<<<<<
  *     cdef unsigned long long ptr
  *     ptr = ctypes.cast(handle, ctypes.c_void_p).value
  */
-  __pyx_tuple__35 = PyTuple_Pack(3, __pyx_n_s_handle, __pyx_n_s_is_view, __pyx_n_s_ptr); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(6, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__35);
-  __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_make_array, 101, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(6, 101, __pyx_L1_error)
+  __pyx_tuple__26 = PyTuple_Pack(3, __pyx_n_s_handle, __pyx_n_s_is_view, __pyx_n_s_ptr); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(4, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_make_array, 101, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(4, 101, __pyx_L1_error)
 
   /* "dgl/_ffi/_cython/ndarray.pxi":108
  * cdef object _CLASS_NDARRAY = None
  * 
  * def _set_class_ndarray(cls):             # <<<<<<<<<<<<<<
  *     global _CLASS_NDARRAY
  *     _CLASS_NDARRAY = cls
  */
-  __pyx_tuple__37 = PyTuple_Pack(1, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(6, 108, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__37);
-  __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_set_class_ndarray, 108, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(6, 108, __pyx_L1_error)
+  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(4, 108, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__28);
+  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_dgl__ffi__cython_ndarray_pxi, __pyx_n_s_set_class_ndarray, 108, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(4, 108, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
-/* #### Code section: init_constants ### */
-
-static CYTHON_SMALL_CODE int __Pyx_InitConstants(void) {
-  if (__Pyx_CreateStringTabAndInitStrings() < 0) __PYX_ERR(5, 1, __pyx_L1_error);
-  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(5, 1, __pyx_L1_error)
-  return 0;
-  __pyx_L1_error:;
-  return -1;
-}
-/* #### Code section: init_globals ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  /* AssertionsEnabled.init */
-  if (likely(__Pyx_init_assertions_enabled() == 0)); else
-
-if (unlikely(PyErr_Occurred())) __PYX_ERR(5, 1, __pyx_L1_error)
-
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(5, 1, __pyx_L1_error);
+  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(5, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
-/* #### Code section: init_module ### */
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
@@ -13578,94 +10434,48 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_ObjectBase = &__pyx_vtable_3dgl_4_ffi_4_cy3_4core_ObjectBase;
   __pyx_vtable_3dgl_4_ffi_4_cy3_4core_ObjectBase._set_handle = (PyObject *(*)(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_ObjectBase *, PyObject *))__pyx_f_3dgl_4_ffi_4_cy3_4core_10ObjectBase__set_handle;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase_spec, NULL); if (unlikely(!__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase)) __PYX_ERR(0, 34, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase_spec, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-  #else
+  if (PyType_Ready(&__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase.tp_print = 0;
+  #endif
+  if (__Pyx_SetVtable(__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase.tp_dict, __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ObjectBase, (PyObject *)&__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
   __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase = &__pyx_type_3dgl_4_ffi_4_cy3_4core_ObjectBase;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase->tp_print = 0;
-  #endif
-  if (__Pyx_SetVtable(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase, __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-  #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ObjectBase, (PyObject *) __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-  #endif
   __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_FunctionBase = &__pyx_vtable_3dgl_4_ffi_4_cy3_4core_FunctionBase;
   __pyx_vtable_3dgl_4_ffi_4_cy3_4core_FunctionBase._set_handle = (PyObject *(*)(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_FunctionBase *, PyObject *))__pyx_f_3dgl_4_ffi_4_cy3_4core_12FunctionBase__set_handle;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase_spec, NULL); if (unlikely(!__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase)) __PYX_ERR(2, 258, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase_spec, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
-  #else
+  if (PyType_Ready(&__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase.tp_print = 0;
+  #endif
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase.tp_dictoffset && __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_SetVtable(__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase.tp_dict, __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_FunctionBase, (PyObject *)&__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
   __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase = &__pyx_type_3dgl_4_ffi_4_cy3_4core_FunctionBase;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase->tp_dictoffset && __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase->tp_getattro = __Pyx_PyObject_GenericGetAttr;
-  }
-  #endif
-  if (__Pyx_SetVtable(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase, __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
-  #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_FunctionBase, (PyObject *) __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_3dgl_4_ffi_4_cy3_4core_FunctionBase) < 0) __PYX_ERR(2, 258, __pyx_L1_error)
-  #endif
   __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_NDArrayBase = &__pyx_vtable_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
   __pyx_vtable_3dgl_4_ffi_4_cy3_4core_NDArrayBase._set_handle = (PyObject *(*)(struct __pyx_obj_3dgl_4_ffi_4_cy3_4core_NDArrayBase *, PyObject *))__pyx_f_3dgl_4_ffi_4_cy3_4core_11NDArrayBase__set_handle;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase_spec, NULL); if (unlikely(!__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase)) __PYX_ERR(6, 28, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase_spec, __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(6, 28, __pyx_L1_error)
-  #else
+  if (PyType_Ready(&__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(4, 28, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase.tp_print = 0;
+  #endif
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase.tp_dictoffset && __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_SetVtable(__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase.tp_dict, __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(4, 28, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_NDArrayBase, (PyObject *)&__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(4, 28, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(4, 28, __pyx_L1_error)
   __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase = &__pyx_type_3dgl_4_ffi_4_cy3_4core_NDArrayBase;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(6, 28, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase->tp_dictoffset && __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase->tp_getattro = __Pyx_PyObject_GenericGetAttr;
-  }
-  #endif
-  if (__Pyx_SetVtable(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase, __pyx_vtabptr_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(6, 28, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(6, 28, __pyx_L1_error)
-  #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_NDArrayBase, (PyObject *) __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(6, 28, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase) < 0) __PYX_ERR(6, 28, __pyx_L1_error)
-  #endif
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
@@ -13673,33 +10483,34 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
-  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(7, 9, __pyx_L1_error)
+  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_3_0_8(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyTypeObject),
-  #elif CYTHON_COMPILING_IN_LIMITED_API
-  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyTypeObject),
+  sizeof(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(7, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(6, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(8, 8, __pyx_L1_error)
+  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(7, 8, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType_3_0_8(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyBoolObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(8, 8, __pyx_L1_error)
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(7, 8, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(9, 15, __pyx_L1_error)
+  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(8, 15, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType_3_0_8(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyComplexObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(9, 15, __pyx_L1_error)
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(8, 15, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -13718,63 +10529,14 @@
   __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
   /*--- Function import code ---*/
   __Pyx_RefNannyFinishContext();
   return 0;
 }
 
 
-#if PY_MAJOR_VERSION >= 3
-#if CYTHON_PEP489_MULTI_PHASE_INIT
-static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec_core(PyObject* module); /*proto*/
-static PyModuleDef_Slot __pyx_moduledef_slots[] = {
-  {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec_core},
-  {0, NULL}
-};
-#endif
-
-#ifdef __cplusplus
-namespace {
-  struct PyModuleDef __pyx_moduledef =
-  #else
-  static struct PyModuleDef __pyx_moduledef =
-  #endif
-  {
-      PyModuleDef_HEAD_INIT,
-      "core",
-      0, /* m_doc */
-    #if CYTHON_PEP489_MULTI_PHASE_INIT
-      0, /* m_size */
-    #elif CYTHON_USE_MODULE_STATE
-      sizeof(__pyx_mstate), /* m_size */
-    #else
-      -1, /* m_size */
-    #endif
-      __pyx_methods /* m_methods */,
-    #if CYTHON_PEP489_MULTI_PHASE_INIT
-      __pyx_moduledef_slots, /* m_slots */
-    #else
-      NULL, /* m_reload */
-    #endif
-    #if CYTHON_USE_MODULE_STATE
-      __pyx_m_traverse, /* m_traverse */
-      __pyx_m_clear, /* m_clear */
-      NULL /* m_free */
-    #else
-      NULL, /* m_traverse */
-      NULL, /* m_clear */
-      NULL /* m_free */
-    #endif
-  };
-  #ifdef __cplusplus
-} /* anonymous namespace */
-#endif
-#endif
-
 #ifndef CYTHON_NO_PYINIT_EXPORT
 #define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
 #elif PY_MAJOR_VERSION < 3
 #ifdef __cplusplus
 #define __Pyx_PyMODINIT_FUNC extern "C" void
 #else
 #define __Pyx_PyMODINIT_FUNC void
@@ -13817,56 +10579,42 @@
         PyErr_SetString(
             PyExc_ImportError,
             "Interpreter change detected - this module can only be loaded into one interpreter per process.");
         return -1;
     }
     return 0;
 }
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *module, const char* from_name, const char* to_name, int allow_none)
-#else
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none)
-#endif
-{
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
     PyObject *value = PyObject_GetAttrString(spec, from_name);
     int result = 0;
     if (likely(value)) {
         if (allow_none || value != Py_None) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-            result = PyModule_AddObject(module, to_name, value);
-#else
             result = PyDict_SetItemString(moddict, to_name, value);
-#endif
         }
         Py_DECREF(value);
     } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Clear();
     } else {
         result = -1;
     }
     return result;
 }
-static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def) {
+static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
     PyObject *module = NULL, *moddict, *modname;
-    CYTHON_UNUSED_VAR(def);
     if (__Pyx_check_single_interpreter())
         return NULL;
     if (__pyx_m)
         return __Pyx_NewRef(__pyx_m);
     modname = PyObject_GetAttrString(spec, "name");
     if (unlikely(!modname)) goto bad;
     module = PyModule_NewObject(modname);
     Py_DECREF(modname);
     if (unlikely(!module)) goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    moddict = module;
-#else
     moddict = PyModule_GetDict(module);
     if (unlikely(!moddict)) goto bad;
-#endif
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
     return module;
 bad:
     Py_XDECREF(module);
@@ -13874,462 +10622,392 @@
 }
 
 
 static CYTHON_SMALL_CODE int __pyx_pymod_exec_core(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
-  int stringtab_initialized = 0;
-  #if CYTHON_USE_MODULE_STATE
-  int pystate_addmodule_run = 0;
-  #endif
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
     PyErr_SetString(PyExc_RuntimeError, "Module 'core' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
-  /*--- Module creation code ---*/
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  __pyx_m = __pyx_pyinit_module;
-  Py_INCREF(__pyx_m);
-  #else
-  #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("core", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
-  if (unlikely(!__pyx_m)) __PYX_ERR(5, 1, __pyx_L1_error)
-  #elif CYTHON_USE_MODULE_STATE
-  __pyx_t_1 = PyModule_Create(&__pyx_moduledef); if (unlikely(!__pyx_t_1)) __PYX_ERR(5, 1, __pyx_L1_error)
-  {
-    int add_module_result = PyState_AddModule(__pyx_t_1, &__pyx_moduledef);
-    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to "core" pseudovariable */
-    if (unlikely((add_module_result < 0))) __PYX_ERR(5, 1, __pyx_L1_error)
-    pystate_addmodule_run = 1;
-  }
-  #else
-  __pyx_m = PyModule_Create(&__pyx_moduledef);
-  if (unlikely(!__pyx_m)) __PYX_ERR(5, 1, __pyx_L1_error)
-  #endif
-  #endif
-  CYTHON_UNUSED_VAR(__pyx_t_1);
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(5, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_d);
-  __pyx_b = __Pyx_PyImport_AddModuleRef(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(5, 1, __pyx_L1_error)
-  __pyx_cython_runtime = __Pyx_PyImport_AddModuleRef((const char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(5, 1, __pyx_L1_error)
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #if CYTHON_REFNANNY
 __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
   __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_core(void)", 0);
-  if (__Pyx_check_binary_version(__PYX_LIMITED_VERSION_HEX, __Pyx_get_runtime_version(), CYTHON_COMPILING_IN_LIMITED_API) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__Pyx_check_binary_version() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(5, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(5, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(5, 1, __pyx_L1_error)
   #ifdef __Pyx_CyFunction_USED
-  if (__pyx_CyFunction_init(__pyx_m) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__pyx_CyFunction_init() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init(__pyx_m) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Coroutine_USED
-  if (__pyx_Coroutine_init(__pyx_m) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__pyx_Coroutine_init() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init(__pyx_m) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__pyx_Generator_init() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_AsyncGen_USED
-  if (__pyx_AsyncGen_init(__pyx_m) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_StopAsyncIteration_USED
-  if (__pyx_StopAsyncIteration_init(__pyx_m) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   PyEval_InitThreads();
   #endif
+  /*--- Module creation code ---*/
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  __pyx_m = __pyx_pyinit_module;
+  Py_INCREF(__pyx_m);
+  #else
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4("core", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) __PYX_ERR(5, 1, __pyx_L1_error)
+  #endif
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(5, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_d);
+  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(5, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_b);
+  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(5, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_cython_runtime);
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(5, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
-  if (__Pyx_InitConstants() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
-  stringtab_initialized = 1;
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
   if (__pyx_module_is_main_dgl___ffi___cy3__core) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(5, 1, __pyx_L1_error)
     if (!PyDict_GetItemString(modules, "dgl._ffi._cy3.core")) {
-      if (unlikely((PyDict_SetItemString(modules, "dgl._ffi._cy3.core", __pyx_m) < 0))) __PYX_ERR(5, 1, __pyx_L1_error)
+      if (unlikely(PyDict_SetItemString(modules, "dgl._ffi._cy3.core", __pyx_m) < 0)) __PYX_ERR(5, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   /*--- Global type/function init code ---*/
   (void)__Pyx_modinit_global_init_code();
   (void)__Pyx_modinit_variable_export_code();
   (void)__Pyx_modinit_function_export_code();
-  if (unlikely((__Pyx_modinit_type_init_code() < 0))) __PYX_ERR(5, 1, __pyx_L1_error)
-  if (unlikely((__Pyx_modinit_type_import_code() < 0))) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(5, 1, __pyx_L1_error)
+  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(5, 1, __pyx_L1_error)
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(5, 1, __pyx_L1_error)
   #endif
 
   /* "dgl/_ffi/_cython/base.pxi":1
  * from ..base import DGLError             # <<<<<<<<<<<<<<
  * from libcpp.vector cimport vector
  * from libcpp cimport bool
  */
-  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_DGLError);
   __Pyx_GIVEREF(__pyx_n_s_DGLError);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_DGLError)) __PYX_ERR(4, 1, __pyx_L1_error);
-  __pyx_t_3 = __Pyx_Import(__pyx_n_s_base, __pyx_t_2, 2); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_DGLError); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 1, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_DGLError);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_base, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DGLError, __pyx_t_2) < 0) __PYX_ERR(4, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_DGLError); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DGLError, __pyx_t_1) < 0) __PYX_ERR(3, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/base.pxi":7
  * from cpython cimport pycapsule
  * from libc.stdint cimport int32_t, int64_t, uint64_t, uint8_t, uint16_t
  * import ctypes             # <<<<<<<<<<<<<<
  * 
  * cdef enum DGLObjectTypeCode:
  */
-  __pyx_t_3 = __Pyx_ImportDottedModule(__pyx_n_s_ctypes, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(4, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ctypes, __pyx_t_3) < 0) __PYX_ERR(4, 7, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_ctypes, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(3, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ctypes, __pyx_t_2) < 0) __PYX_ERR(3, 7, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":1
  * from ... import _api_internal             # <<<<<<<<<<<<<<
  * from ..base import string_types
  * from ..object_generic import _set_class_object_base
  */
-  __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_api_internal);
   __Pyx_GIVEREF(__pyx_n_s_api_internal);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_api_internal)) __PYX_ERR(0, 1, __pyx_L1_error);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s__9, __pyx_t_3, 3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_api_internal);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s__13, __pyx_t_2, 3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_api_internal); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_api_internal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_api_internal, __pyx_t_3) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_api_internal, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":2
  * from ... import _api_internal
  * from ..base import string_types             # <<<<<<<<<<<<<<
  * from ..object_generic import _set_class_object_base
  * 
  */
-  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_string_types);
   __Pyx_GIVEREF(__pyx_n_s_string_types);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_string_types)) __PYX_ERR(0, 2, __pyx_L1_error);
-  __pyx_t_3 = __Pyx_Import(__pyx_n_s_base, __pyx_t_2, 2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_string_types); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_string_types);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_base, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_string_types, __pyx_t_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_string_types); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_string_types, __pyx_t_1) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":3
  * from ... import _api_internal
  * from ..base import string_types
  * from ..object_generic import _set_class_object_base             # <<<<<<<<<<<<<<
  * 
  * """Maps object type to its constructor"""
  */
-  __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_set_class_object_base);
   __Pyx_GIVEREF(__pyx_n_s_set_class_object_base);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_set_class_object_base)) __PYX_ERR(0, 3, __pyx_L1_error);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_object_generic, __pyx_t_3, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_set_class_object_base);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_object_generic, __pyx_t_2, 2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_set_class_object_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_set_class_object_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_object_base, __pyx_t_3) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_object_base, __pyx_t_2) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":6
  * 
  * """Maps object type to its constructor"""
  * OBJECT_TYPE = []             # <<<<<<<<<<<<<<
  * 
  * def _register_object(int index, object cls):
  */
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OBJECT_TYPE, __pyx_t_2) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OBJECT_TYPE, __pyx_t_1) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":8
  * OBJECT_TYPE = []
  * 
  * def _register_object(int index, object cls):             # <<<<<<<<<<<<<<
  *     """register object class"""
  *     while len(OBJECT_TYPE) <= index:
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_1_register_object, 0, __pyx_n_s_register_object, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__11)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_register_object, __pyx_t_2) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "dgl/_ffi/_cython/object.pxi":68
- *         return make_ret(ret_val, ret_type_code)
- * 
- *     def __init_handle_by_constructor__(self, fconstructor, *args):             # <<<<<<<<<<<<<<
- *         """Initialize the handle by calling constructor function.
- * 
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_10ObjectBase_5__init_handle_by_constructor__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_ObjectBase___init_handle_by_cons, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__13)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase, __pyx_n_s_init_handle_by_constructor, __pyx_t_2) < 0) __PYX_ERR(0, 68, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  PyType_Modified(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase);
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_10ObjectBase_7__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_ObjectBase___reduce_cython, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__15)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_2) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_10ObjectBase_9__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_ObjectBase___setstate_cython, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__17)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_2) < 0) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_1_register_object, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_register_object, __pyx_t_1) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/object.pxi":91
  *         self.chandle = chandle
  * 
  * _set_class_object_base(ObjectBase)             # <<<<<<<<<<<<<<
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_set_class_object_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_set_class_object_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, ((PyObject *)__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_2, ((PyObject *)__pyx_ptype_3dgl_4_ffi_4_cy3_4core_ObjectBase)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 91, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":1
  * import ctypes             # <<<<<<<<<<<<<<
  * import traceback
  * from cpython cimport Py_INCREF, Py_DECREF
  */
-  __pyx_t_3 = __Pyx_ImportDottedModule(__pyx_n_s_ctypes, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ctypes, __pyx_t_3) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_ctypes, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ctypes, __pyx_t_2) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":2
  * import ctypes
  * import traceback             # <<<<<<<<<<<<<<
  * from cpython cimport Py_INCREF, Py_DECREF
  * from numbers import Number, Integral
  */
-  __pyx_t_3 = __Pyx_ImportDottedModule(__pyx_n_s_traceback, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_traceback, __pyx_t_3) < 0) __PYX_ERR(2, 2, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_traceback, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_traceback, __pyx_t_2) < 0) __PYX_ERR(2, 2, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":4
  * import traceback
  * from cpython cimport Py_INCREF, Py_DECREF
  * from numbers import Number, Integral             # <<<<<<<<<<<<<<
  * from ..base import string_types
  * from ..object_generic import convert_to_object, ObjectGeneric
  */
-  __pyx_t_3 = PyList_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_Number);
   __Pyx_GIVEREF(__pyx_n_s_Number);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_Number)) __PYX_ERR(2, 4, __pyx_L1_error);
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Number);
   __Pyx_INCREF(__pyx_n_s_Integral);
   __Pyx_GIVEREF(__pyx_n_s_Integral);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_s_Integral)) __PYX_ERR(2, 4, __pyx_L1_error);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_numbers, __pyx_t_3, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 4, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_Integral);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numbers, __pyx_t_2, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Number); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Number); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Number, __pyx_t_3) < 0) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Integral); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Integral, __pyx_t_3) < 0) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Number, __pyx_t_2) < 0) __PYX_ERR(2, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Integral); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Integral, __pyx_t_2) < 0) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":5
  * from cpython cimport Py_INCREF, Py_DECREF
  * from numbers import Number, Integral
  * from ..base import string_types             # <<<<<<<<<<<<<<
  * from ..object_generic import convert_to_object, ObjectGeneric
  * from ..runtime_ctypes import DGLDataType as CTypesDGLDataType, \
  */
-  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 5, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_string_types);
   __Pyx_GIVEREF(__pyx_n_s_string_types);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_string_types)) __PYX_ERR(2, 5, __pyx_L1_error);
-  __pyx_t_3 = __Pyx_Import(__pyx_n_s_base, __pyx_t_2, 2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 5, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_string_types); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 5, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_string_types);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_base, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_string_types, __pyx_t_2) < 0) __PYX_ERR(2, 5, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_string_types); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_string_types, __pyx_t_1) < 0) __PYX_ERR(2, 5, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":6
  * from numbers import Number, Integral
  * from ..base import string_types
  * from ..object_generic import convert_to_object, ObjectGeneric             # <<<<<<<<<<<<<<
  * from ..runtime_ctypes import DGLDataType as CTypesDGLDataType, \
  *                              DGLContext as CTypesDGLContext, \
  */
-  __pyx_t_3 = PyList_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_convert_to_object);
   __Pyx_GIVEREF(__pyx_n_s_convert_to_object);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_convert_to_object)) __PYX_ERR(2, 6, __pyx_L1_error);
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_convert_to_object);
   __Pyx_INCREF(__pyx_n_s_ObjectGeneric);
   __Pyx_GIVEREF(__pyx_n_s_ObjectGeneric);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_s_ObjectGeneric)) __PYX_ERR(2, 6, __pyx_L1_error);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_object_generic, __pyx_t_3, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 6, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_ObjectGeneric);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_object_generic, __pyx_t_2, 2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_convert_to_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_convert_to_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert_to_object, __pyx_t_3) < 0) __PYX_ERR(2, 6, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_ObjectGeneric); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ObjectGeneric, __pyx_t_3) < 0) __PYX_ERR(2, 6, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert_to_object, __pyx_t_2) < 0) __PYX_ERR(2, 6, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_ObjectGeneric); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ObjectGeneric, __pyx_t_2) < 0) __PYX_ERR(2, 6, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":7
  * from ..base import string_types
  * from ..object_generic import convert_to_object, ObjectGeneric
  * from ..runtime_ctypes import DGLDataType as CTypesDGLDataType, \             # <<<<<<<<<<<<<<
  *                              DGLContext as CTypesDGLContext, \
  *                              DGLByteArray
  */
-  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_DGLDataType);
   __Pyx_GIVEREF(__pyx_n_s_DGLDataType);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_DGLDataType)) __PYX_ERR(2, 7, __pyx_L1_error);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_DGLDataType);
   __Pyx_INCREF(__pyx_n_s_DGLContext);
   __Pyx_GIVEREF(__pyx_n_s_DGLContext);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_DGLContext)) __PYX_ERR(2, 7, __pyx_L1_error);
+  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_DGLContext);
   __Pyx_INCREF(__pyx_n_s_DGLByteArray);
   __Pyx_GIVEREF(__pyx_n_s_DGLByteArray);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_DGLByteArray)) __PYX_ERR(2, 7, __pyx_L1_error);
-  __pyx_t_3 = __Pyx_Import(__pyx_n_s_runtime_ctypes, __pyx_t_2, 2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_DGLDataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 7, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_DGLByteArray);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_runtime_ctypes, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CTypesDGLDataType, __pyx_t_2) < 0) __PYX_ERR(2, 7, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_DGLContext); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CTypesDGLContext, __pyx_t_2) < 0) __PYX_ERR(2, 8, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_DGLByteArray); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DGLByteArray, __pyx_t_2) < 0) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_DGLDataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CTypesDGLDataType, __pyx_t_1) < 0) __PYX_ERR(2, 7, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_DGLContext); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CTypesDGLContext, __pyx_t_1) < 0) __PYX_ERR(2, 8, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_DGLByteArray); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DGLByteArray, __pyx_t_1) < 0) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":54
  * 
  * 
  * def convert_to_dgl_func(object pyfunc):             # <<<<<<<<<<<<<<
  *     """Convert a python function to DGL function
  * 
  */
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func, 0, __pyx_n_s_convert_to_dgl_func, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__19)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 54, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert_to_dgl_func, __pyx_t_3) < 0) __PYX_ERR(2, 54, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):
- */
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_12FunctionBase_7__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_FunctionBase___reduce_cython, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__20)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_3) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- */
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_12FunctionBase_9__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_FunctionBase___setstate_cython, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__21)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_3) < 0) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_3convert_to_dgl_func, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert_to_dgl_func, __pyx_t_2) < 0) __PYX_ERR(2, 54, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":298
  *         return make_ret(ret_val, ret_tcode)
  * 
  * _CLASS_FUNCTION = None             # <<<<<<<<<<<<<<
  * _CLASS_MODULE = None
  * 
@@ -14348,49 +11026,49 @@
   /* "dgl/_ffi/_cython/function.pxi":301
  * _CLASS_MODULE = None
  * 
  * def _set_class_module(module_class):             # <<<<<<<<<<<<<<
  *     """Initialize the module."""
  *     global _CLASS_MODULE
  */
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_5_set_class_module, 0, __pyx_n_s_set_class_module, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__23)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 301, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_module, __pyx_t_3) < 0) __PYX_ERR(2, 301, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_5_set_class_module, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 301, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_module, __pyx_t_2) < 0) __PYX_ERR(2, 301, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/function.pxi":306
  *     _CLASS_MODULE = module_class
  * 
  * def _set_class_function(func_class):             # <<<<<<<<<<<<<<
  *     global _CLASS_FUNCTION
  *     _CLASS_FUNCTION = func_class
  */
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_7_set_class_function, 0, __pyx_n_s_set_class_function, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__25)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 306, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_function, __pyx_t_3) < 0) __PYX_ERR(2, 306, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_7_set_class_function, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 306, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_function, __pyx_t_2) < 0) __PYX_ERR(2, 306, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":1
  * from ..runtime_ctypes import DGLArrayHandle as PyDGLArrayHandle             # <<<<<<<<<<<<<<
  * from cpython cimport PyCapsule_Destructor
  * 
  */
-  __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_DGLArrayHandle);
   __Pyx_GIVEREF(__pyx_n_s_DGLArrayHandle);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_DGLArrayHandle)) __PYX_ERR(6, 1, __pyx_L1_error);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_runtime_ctypes, __pyx_t_3, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 1, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_DGLArrayHandle);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_runtime_ctypes, __pyx_t_2, 2); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_DGLArrayHandle); if (unlikely(!__pyx_t_2)) __PYX_ERR(4, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_DGLArrayHandle); if (unlikely(!__pyx_t_3)) __PYX_ERR(6, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyDGLArrayHandle, __pyx_t_3) < 0) __PYX_ERR(6, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyDGLArrayHandle, __pyx_t_2) < 0) __PYX_ERR(4, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":4
  * from cpython cimport PyCapsule_Destructor
  * 
  * cdef const char* _c_str_dltensor = "dltensor"             # <<<<<<<<<<<<<<
  * cdef const char* _c_str_used_dltensor = "used_dltensor"
  * 
@@ -14409,53 +11087,18 @@
   /* "dgl/_ffi/_cython/ndarray.pxi":15
  * 
  * 
  * def _from_dlpack(object dltensor):             # <<<<<<<<<<<<<<
  *     cdef DLManagedTensor* ptr
  *     cdef DGLArrayHandle chandle
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_9_from_dlpack, 0, __pyx_n_s_from_dlpack, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__27)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 15, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_from_dlpack, __pyx_t_2) < 0) __PYX_ERR(6, 15, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "dgl/_ffi/_cython/ndarray.pxi":63
- *             CALL(DGLArrayFree(self.chandle))
- * 
- *     def to_dlpack(self, alignment=0):             # <<<<<<<<<<<<<<
- *         """Produce an array from a DLPack Tensor without copying memory
- * 
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_5to_dlpack, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_NDArrayBase_to_dlpack, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__29)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__30);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase, __pyx_n_s_to_dlpack, __pyx_t_2) < 0) __PYX_ERR(6, 63, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  PyType_Modified(__pyx_ptype_3dgl_4_ffi_4_cy3_4core_NDArrayBase);
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_7__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_NDArrayBase___reduce_cython, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_2) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "self.chandle cannot be converted to a Python object for pickling"
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_11NDArrayBase_9__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_NDArrayBase___setstate_cython, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__32)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_2) < 0) __PYX_ERR(1, 3, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_9_from_dlpack, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_from_dlpack, __pyx_t_1) < 0) __PYX_ERR(4, 15, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":90
  * 
  * 
  * cdef _DGL_COMPATS = ()             # <<<<<<<<<<<<<<
  * 
  * cdef _DGL_EXT_RET = {}
@@ -14468,44 +11111,44 @@
   /* "dgl/_ffi/_cython/ndarray.pxi":92
  * cdef _DGL_COMPATS = ()
  * 
  * cdef _DGL_EXT_RET = {}             # <<<<<<<<<<<<<<
  * 
  * def _reg_extension(cls, fcreate):
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 92, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET);
-  __Pyx_DECREF_SET(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, __pyx_t_2);
-  __Pyx_GIVEREF(__pyx_t_2);
-  __pyx_t_2 = 0;
+  __Pyx_DECREF_SET(__pyx_v_3dgl_4_ffi_4_cy3_4core__DGL_EXT_RET, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":94
  * cdef _DGL_EXT_RET = {}
  * 
  * def _reg_extension(cls, fcreate):             # <<<<<<<<<<<<<<
  *     global _DGL_COMPATS
  *     _DGL_COMPATS += (cls,)
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_11_reg_extension, 0, __pyx_n_s_reg_extension, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 94, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reg_extension, __pyx_t_2) < 0) __PYX_ERR(6, 94, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_11_reg_extension, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 94, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reg_extension, __pyx_t_1) < 0) __PYX_ERR(4, 94, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":101
  * 
  * 
  * def _make_array(handle, is_view):             # <<<<<<<<<<<<<<
  *     cdef unsigned long long ptr
  *     ptr = ctypes.cast(handle, ctypes.c_void_p).value
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_13_make_array, 0, __pyx_n_s_make_array, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_make_array, __pyx_t_2) < 0) __PYX_ERR(6, 101, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_13_make_array, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_make_array, __pyx_t_1) < 0) __PYX_ERR(4, 101, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/ndarray.pxi":106
  *     return c_make_array(<void*>ptr, is_view)
  * 
  * cdef object _CLASS_NDARRAY = None             # <<<<<<<<<<<<<<
  * 
  * def _set_class_ndarray(cls):
@@ -14518,79 +11161,53 @@
   /* "dgl/_ffi/_cython/ndarray.pxi":108
  * cdef object _CLASS_NDARRAY = None
  * 
  * def _set_class_ndarray(cls):             # <<<<<<<<<<<<<<
  *     global _CLASS_NDARRAY
  *     _CLASS_NDARRAY = cls
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray, 0, __pyx_n_s_set_class_ndarray, NULL, __pyx_n_s_dgl__ffi__cy3_core, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_2)) __PYX_ERR(6, 108, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_ndarray, __pyx_t_2) < 0) __PYX_ERR(6, 108, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3dgl_4_ffi_4_cy3_4core_15_set_class_ndarray, NULL, __pyx_n_s_dgl__ffi__cy3_core); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 108, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_class_ndarray, __pyx_t_1) < 0) __PYX_ERR(4, 108, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "dgl/_ffi/_cython/core.pyx":1
  * include "./base.pxi"             # <<<<<<<<<<<<<<
  * include "./object.pxi"
  * include "./function.pxi"
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(5, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(5, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(5, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
   if (__pyx_m) {
-    if (__pyx_d && stringtab_initialized) {
+    if (__pyx_d) {
       __Pyx_AddTraceback("init dgl._ffi._cy3.core", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
-    #if !CYTHON_USE_MODULE_STATE
     Py_CLEAR(__pyx_m);
-    #else
-    Py_DECREF(__pyx_m);
-    if (pystate_addmodule_run) {
-      PyObject *tp, *value, *tb;
-      PyErr_Fetch(&tp, &value, &tb);
-      PyState_RemoveModule(&__pyx_moduledef);
-      PyErr_Restore(tp, value, tb);
-    }
-    #endif
   } else if (!PyErr_Occurred()) {
     PyErr_SetString(PyExc_ImportError, "init dgl._ffi._cy3.core");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
   #else
   return;
   #endif
 }
-/* #### Code section: cleanup_globals ### */
-/* #### Code section: cleanup_module ### */
-/* #### Code section: main_method ### */
-/* #### Code section: utility_code_pragmas ### */
-#ifdef _MSC_VER
-#pragma warning( push )
-/* Warning 4127: conditional expression is constant
- * Cython uses constant conditional expressions to allow in inline functions to be optimized at
- * compile-time, so this warning is not useful
- */
-#pragma warning( disable : 4127 )
-#endif
-
-
-
-/* #### Code section: utility_code_def ### */
 
 /* --- Runtime support code --- */
 /* Refnanny */
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
@@ -14602,163 +11219,32 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif
 
-/* PyErrExceptionMatches */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
-#endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
-    }
-    return 0;
-}
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    int result;
-    PyObject *exc_type;
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject *current_exception = tstate->current_exception;
-    if (unlikely(!current_exception)) return 0;
-    exc_type = (PyObject*) Py_TYPE(current_exception);
-    if (exc_type == err) return 1;
-#else
-    exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
-#endif
-    #if CYTHON_AVOID_BORROWED_REFS
-    Py_INCREF(exc_type);
-    #endif
-    if (unlikely(PyTuple_Check(err))) {
-        result = __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    } else {
-        result = __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
-    }
-    #if CYTHON_AVOID_BORROWED_REFS
-    Py_DECREF(exc_type);
-    #endif
-    return result;
-}
-#endif
-
-/* PyErrFetchRestore */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject *tmp_value;
-    assert(type == NULL || (value != NULL && type == (PyObject*) Py_TYPE(value)));
-    if (value) {
-        #if CYTHON_COMPILING_IN_CPYTHON
-        if (unlikely(((PyBaseExceptionObject*) value)->traceback != tb))
-        #endif
-            PyException_SetTraceback(value, tb);
-    }
-    tmp_value = tstate->current_exception;
-    tstate->current_exception = value;
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-#else
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    tmp_type = tstate->curexc_type;
-    tmp_value = tstate->curexc_value;
-    tmp_tb = tstate->curexc_traceback;
-    tstate->curexc_type = type;
-    tstate->curexc_value = value;
-    tstate->curexc_traceback = tb;
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-#endif
-}
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject* exc_value;
-    exc_value = tstate->current_exception;
-    tstate->current_exception = 0;
-    *value = exc_value;
-    *type = NULL;
-    *tb = NULL;
-    if (exc_value) {
-        *type = (PyObject*) Py_TYPE(exc_value);
-        Py_INCREF(*type);
-        #if CYTHON_COMPILING_IN_CPYTHON
-        *tb = ((PyBaseExceptionObject*) exc_value)->traceback;
-        Py_XINCREF(*tb);
-        #else
-        *tb = PyException_GetTraceback(exc_value);
-        #endif
-    }
-#else
-    *type = tstate->curexc_type;
-    *value = tstate->curexc_value;
-    *tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-#endif
-}
-#endif
-
 /* PyObjectGetAttrStr */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
     PyTypeObject* tp = Py_TYPE(obj);
     if (likely(tp->tp_getattro))
         return tp->tp_getattro(obj, attr_name);
 #if PY_MAJOR_VERSION < 3
     if (likely(tp->tp_getattr))
         return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
 #endif
     return PyObject_GetAttr(obj, attr_name);
 }
 #endif
 
-/* PyObjectGetAttrStrNoError */
-#if __PYX_LIMITED_VERSION_HEX < 0x030d00A1
-static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        __Pyx_PyErr_Clear();
-}
-#endif
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
-    PyObject *result;
-#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
-    (void) PyObject_GetOptionalAttr(obj, attr_name, &result);
-    return result;
-#else
-#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
-        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
-    }
-#endif
-    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
-    if (unlikely(!result)) {
-        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
-    }
-    return result;
-#endif
-}
-
 /* GetBuiltinName */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStrNoError(__pyx_b, name);
-    if (unlikely(!result) && !PyErr_Occurred()) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
         PyErr_Format(PyExc_NameError,
 #if PY_MAJOR_VERSION >= 3
             "name '%U' is not defined", name);
 #else
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
@@ -14794,16 +11280,39 @@
     if (decode_func) {
         return decode_func(cstring, length, errors);
     } else {
         return PyUnicode_Decode(cstring, length, encoding, errors);
     }
 }
 
+/* PyCFunctionFastCall */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
+    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
+    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
+    PyObject *self = PyCFunction_GET_SELF(func);
+    int flags = PyCFunction_GET_FLAGS(func);
+    assert(PyCFunction_Check(func));
+    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
+    assert(nargs >= 0);
+    assert(nargs == 0 || args != NULL);
+    /* _PyCFunction_FastCallDict() must not be called with an exception set,
+       because it may clear it (directly or indirectly) and so the
+       caller loses its exception */
+    assert(!PyErr_Occurred());
+    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
+        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
+    } else {
+        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
+    }
+}
+#endif
+
 /* PyFunctionFastCall */
-#if CYTHON_FAST_PYCALL && !CYTHON_VECTORCALL
+#if CYTHON_FAST_PYCALL
 static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                                PyObject *globals) {
     PyFrameObject *f;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
     PyObject **fastlocals;
     Py_ssize_t i;
     PyObject *result;
@@ -14824,14 +11333,15 @@
     }
     result = PyEval_EvalFrameEx(f,0);
     ++tstate->recursion_depth;
     Py_DECREF(f);
     --tstate->recursion_depth;
     return result;
 }
+#if 1 || PY_VERSION_HEX < 0x030600B1
 static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
     PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
     PyObject *globals = PyFunction_GET_GLOBALS(func);
     PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
     PyObject *closure;
 #if PY_MAJOR_VERSION >= 3
     PyObject *kwdefs;
@@ -14839,23 +11349,17 @@
     PyObject *kwtuple, **k;
     PyObject **d;
     Py_ssize_t nd;
     Py_ssize_t nk;
     PyObject *result;
     assert(kwargs == NULL || PyDict_Check(kwargs));
     nk = kwargs ? PyDict_Size(kwargs) : 0;
-    #if PY_MAJOR_VERSION < 3
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object"))) {
+    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
         return NULL;
     }
-    #else
-    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object"))) {
-        return NULL;
-    }
-    #endif
     if (
 #if PY_MAJOR_VERSION >= 3
             co->co_kwonlyargcount == 0 &&
 #endif
             likely(kwargs == NULL || nk == 0) &&
             co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
         if (argdefs == NULL && co->co_argcount == nargs) {
@@ -14916,142 +11420,124 @@
 #endif
     Py_XDECREF(kwtuple);
 done:
     Py_LeaveRecursiveCall();
     return result;
 }
 #endif
+#endif
 
 /* PyObjectCall */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
     PyObject *result;
     ternaryfunc call = Py_TYPE(func)->tp_call;
     if (unlikely(!call))
         return PyObject_Call(func, arg, kw);
-    #if PY_MAJOR_VERSION < 3
     if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
         return NULL;
-    #else
-    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object")))
-        return NULL;
-    #endif
     result = (*call)(func, arg, kw);
     Py_LeaveRecursiveCall();
     if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
         PyErr_SetString(
             PyExc_SystemError,
             "NULL result without error in PyObject_Call");
     }
     return result;
 }
 #endif
 
+/* PyObjectCall2Args */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
+    PyObject *args, *result = NULL;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyFunction_FastCall(function, args, 2);
+    }
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyCFunction_FastCall(function, args, 2);
+    }
+    #endif
+    args = PyTuple_New(2);
+    if (unlikely(!args)) goto done;
+    Py_INCREF(arg1);
+    PyTuple_SET_ITEM(args, 0, arg1);
+    Py_INCREF(arg2);
+    PyTuple_SET_ITEM(args, 1, arg2);
+    Py_INCREF(function);
+    result = __Pyx_PyObject_Call(function, args, NULL);
+    Py_DECREF(args);
+    Py_DECREF(function);
+done:
+    return result;
+}
+
 /* PyObjectCallMethO */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
     PyObject *self, *result;
     PyCFunction cfunc;
-    cfunc = __Pyx_CyOrPyCFunction_GET_FUNCTION(func);
-    self = __Pyx_CyOrPyCFunction_GET_SELF(func);
-    #if PY_MAJOR_VERSION < 3
+    cfunc = PyCFunction_GET_FUNCTION(func);
+    self = PyCFunction_GET_SELF(func);
     if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
         return NULL;
-    #else
-    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object")))
-        return NULL;
-    #endif
     result = cfunc(self, arg);
     Py_LeaveRecursiveCall();
     if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
         PyErr_SetString(
             PyExc_SystemError,
             "NULL result without error in PyObject_Call");
     }
     return result;
 }
 #endif
 
-/* PyObjectFastCall */
-#if PY_VERSION_HEX < 0x03090000 || CYTHON_COMPILING_IN_LIMITED_API
-static PyObject* __Pyx_PyObject_FastCall_fallback(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs) {
-    PyObject *argstuple;
-    PyObject *result = 0;
-    size_t i;
-    argstuple = PyTuple_New((Py_ssize_t)nargs);
-    if (unlikely(!argstuple)) return NULL;
-    for (i = 0; i < nargs; i++) {
-        Py_INCREF(args[i]);
-        if (__Pyx_PyTuple_SET_ITEM(argstuple, (Py_ssize_t)i, args[i]) < 0) goto bad;
-    }
-    result = __Pyx_PyObject_Call(func, argstuple, kwargs);
-  bad:
-    Py_DECREF(argstuple);
+/* PyObjectCallOneArg */
+#if CYTHON_COMPILING_IN_CPYTHON
+static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_New(1);
+    if (unlikely(!args)) return NULL;
+    Py_INCREF(arg);
+    PyTuple_SET_ITEM(args, 0, arg);
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
     return result;
 }
-#endif
-static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t _nargs, PyObject *kwargs) {
-    Py_ssize_t nargs = __Pyx_PyVectorcall_NARGS(_nargs);
-#if CYTHON_COMPILING_IN_CPYTHON
-    if (nargs == 0 && kwargs == NULL) {
-        if (__Pyx_CyOrPyCFunction_Check(func) && likely( __Pyx_CyOrPyCFunction_GET_FLAGS(func) & METH_NOARGS))
-            return __Pyx_PyObject_CallMethO(func, NULL);
-    }
-    else if (nargs == 1 && kwargs == NULL) {
-        if (__Pyx_CyOrPyCFunction_Check(func) && likely( __Pyx_CyOrPyCFunction_GET_FLAGS(func) & METH_O))
-            return __Pyx_PyObject_CallMethO(func, args[0]);
-    }
-#endif
-    #if PY_VERSION_HEX < 0x030800B1
-    #if CYTHON_FAST_PYCCALL
-    if (PyCFunction_Check(func)) {
-        if (kwargs) {
-            return _PyCFunction_FastCallDict(func, args, nargs, kwargs);
-        } else {
-            return _PyCFunction_FastCallKeywords(func, args, nargs, NULL);
-        }
-    }
-    #if PY_VERSION_HEX >= 0x030700A1
-    if (!kwargs && __Pyx_IS_TYPE(func, &PyMethodDescr_Type)) {
-        return _PyMethodDescr_FastCallKeywords(func, args, nargs, NULL);
-    }
-    #endif
-    #endif
-    #if CYTHON_FAST_PYCALL
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+#if CYTHON_FAST_PYCALL
     if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs);
+        return __Pyx_PyFunction_FastCall(func, &arg, 1);
     }
-    #endif
-    #endif
-    if (kwargs == NULL) {
-        #if CYTHON_VECTORCALL
-        #if PY_VERSION_HEX < 0x03090000
-        vectorcallfunc f = _PyVectorcall_Function(func);
-        #else
-        vectorcallfunc f = PyVectorcall_Function(func);
-        #endif
-        if (f) {
-            return f(func, args, (size_t)nargs, NULL);
-        }
-        #elif defined(__Pyx_CyFunction_USED) && CYTHON_BACKPORT_VECTORCALL
-        if (__Pyx_CyFunction_CheckExact(func)) {
-            __pyx_vectorcallfunc f = __Pyx_CyFunction_func_vectorcall(func);
-            if (f) return f(func, args, (size_t)nargs, NULL);
+#endif
+    if (likely(PyCFunction_Check(func))) {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
+            return __Pyx_PyObject_CallMethO(func, arg);
+#if CYTHON_FAST_PYCCALL
+        } else if (__Pyx_PyFastCFunction_Check(func)) {
+            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
+#endif
         }
-        #endif
-    }
-    if (nargs == 0) {
-        return __Pyx_PyObject_Call(func, __pyx_empty_tuple, kwargs);
     }
-    #if PY_VERSION_HEX >= 0x03090000 && !CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_VectorcallDict(func, args, (size_t)nargs, kwargs);
-    #else
-    return __Pyx_PyObject_FastCall_fallback(func, args, (size_t)nargs, kwargs);
-    #endif
+    return __Pyx__PyObject_CallOneArg(func, arg);
 }
+#else
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_Pack(1, arg);
+    if (unlikely(!args)) return NULL;
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
+#endif
 
 /* PyDictVersioning */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
     PyObject *dict = Py_TYPE(obj)->tp_dict;
     return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
 }
@@ -15080,30 +11566,22 @@
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
 #else
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
 #endif
 {
     PyObject *result;
 #if !CYTHON_AVOID_BORROWED_REFS
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && PY_VERSION_HEX < 0x030d0000
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
     result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
     __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
     if (likely(result)) {
         return __Pyx_NewRef(result);
     } else if (unlikely(PyErr_Occurred())) {
         return NULL;
     }
-#elif CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(!__pyx_m)) {
-        return NULL;
-    }
-    result = PyObject_GetAttr(__pyx_m, name);
-    if (likely(result)) {
-        return result;
-    }
 #else
     result = PyDict_GetItem(__pyx_d, name);
     __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
     if (likely(result)) {
         return __Pyx_NewRef(result);
     }
 #endif
@@ -15114,19 +11592,43 @@
         return __Pyx_NewRef(result);
     }
     PyErr_Clear();
 #endif
     return __Pyx_GetBuiltinName(name);
 }
 
+/* PyErrFetchRestore */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+}
+#endif
+
 /* RaiseException */
 #if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
     __Pyx_PyThreadState_declare
-    CYTHON_UNUSED_VAR(cause);
     Py_XINCREF(type);
     if (!value || value == Py_None)
         value = NULL;
     else
         Py_INCREF(value);
     if (!tb || tb == Py_None)
         tb = NULL;
@@ -15251,262 +11753,77 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-      #if PY_VERSION_HEX >= 0x030C00A6
-        PyException_SetTraceback(value, tb);
-      #elif CYTHON_FAST_THREAD_STATE
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#else
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
-#else
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
 
-/* TupleAndListFromArray */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE void __Pyx_copy_object_array(PyObject *const *CYTHON_RESTRICT src, PyObject** CYTHON_RESTRICT dest, Py_ssize_t length) {
-    PyObject *v;
-    Py_ssize_t i;
-    for (i = 0; i < length; i++) {
-        v = dest[i] = src[i];
-        Py_INCREF(v);
-    }
-}
-static CYTHON_INLINE PyObject *
-__Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n)
-{
-    PyObject *res;
-    if (n <= 0) {
-        Py_INCREF(__pyx_empty_tuple);
-        return __pyx_empty_tuple;
-    }
-    res = PyTuple_New(n);
-    if (unlikely(res == NULL)) return NULL;
-    __Pyx_copy_object_array(src, ((PyTupleObject*)res)->ob_item, n);
-    return res;
-}
-static CYTHON_INLINE PyObject *
-__Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n)
-{
-    PyObject *res;
-    if (n <= 0) {
-        return PyList_New(0);
-    }
-    res = PyList_New(n);
-    if (unlikely(res == NULL)) return NULL;
-    __Pyx_copy_object_array(src, ((PyListObject*)res)->ob_item, n);
-    return res;
-}
-#endif
-
-/* BytesEquals */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-    if (s1 == s2) {
-        return (equals == Py_EQ);
-    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
-        const char *ps1, *ps2;
-        Py_ssize_t length = PyBytes_GET_SIZE(s1);
-        if (length != PyBytes_GET_SIZE(s2))
-            return (equals == Py_NE);
-        ps1 = PyBytes_AS_STRING(s1);
-        ps2 = PyBytes_AS_STRING(s2);
-        if (ps1[0] != ps2[0]) {
-            return (equals == Py_NE);
-        } else if (length == 1) {
-            return (equals == Py_EQ);
-        } else {
-            int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
-            Py_hash_t hash1, hash2;
-            hash1 = ((PyBytesObject*)s1)->ob_shash;
-            hash2 = ((PyBytesObject*)s2)->ob_shash;
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                return (equals == Py_NE);
-            }
-#endif
-            result = memcmp(ps1, ps2, (size_t)length);
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
-        return (equals == Py_NE);
-    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
-        return (equals == Py_NE);
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
-    }
-#endif
-}
-
-/* UnicodeEquals */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-#if PY_MAJOR_VERSION < 3
-    PyObject* owned_ref = NULL;
-#endif
-    int s1_is_unicode, s2_is_unicode;
-    if (s1 == s2) {
-        goto return_eq;
-    }
-    s1_is_unicode = PyUnicode_CheckExact(s1);
-    s2_is_unicode = PyUnicode_CheckExact(s2);
-#if PY_MAJOR_VERSION < 3
-    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
-        owned_ref = PyUnicode_FromObject(s2);
-        if (unlikely(!owned_ref))
-            return -1;
-        s2 = owned_ref;
-        s2_is_unicode = 1;
-    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
-        owned_ref = PyUnicode_FromObject(s1);
-        if (unlikely(!owned_ref))
-            return -1;
-        s1 = owned_ref;
-        s1_is_unicode = 1;
-    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
-        return __Pyx_PyBytes_Equals(s1, s2, equals);
-    }
+/* WriteUnraisableException */
+static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
+                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
+                                  int full_traceback, CYTHON_UNUSED int nogil) {
+    PyObject *old_exc, *old_val, *old_tb;
+    PyObject *ctx;
+    __Pyx_PyThreadState_declare
+#ifdef WITH_THREAD
+    PyGILState_STATE state;
+    if (nogil)
+        state = PyGILState_Ensure();
+#ifdef _MSC_VER
+    else state = (PyGILState_STATE)-1;
 #endif
-    if (s1_is_unicode & s2_is_unicode) {
-        Py_ssize_t length;
-        int kind;
-        void *data1, *data2;
-        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
-            return -1;
-        length = __Pyx_PyUnicode_GET_LENGTH(s1);
-        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
-            goto return_ne;
-        }
-#if CYTHON_USE_UNICODE_INTERNALS
-        {
-            Py_hash_t hash1, hash2;
-        #if CYTHON_PEP393_ENABLED
-            hash1 = ((PyASCIIObject*)s1)->hash;
-            hash2 = ((PyASCIIObject*)s2)->hash;
-        #else
-            hash1 = ((PyUnicodeObject*)s1)->hash;
-            hash2 = ((PyUnicodeObject*)s2)->hash;
-        #endif
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                goto return_ne;
-            }
-        }
 #endif
-        kind = __Pyx_PyUnicode_KIND(s1);
-        if (kind != __Pyx_PyUnicode_KIND(s2)) {
-            goto return_ne;
-        }
-        data1 = __Pyx_PyUnicode_DATA(s1);
-        data2 = __Pyx_PyUnicode_DATA(s2);
-        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
-            goto return_ne;
-        } else if (length == 1) {
-            goto return_eq;
-        } else {
-            int result = memcmp(data1, data2, (size_t)(length * kind));
-            #if PY_MAJOR_VERSION < 3
-            Py_XDECREF(owned_ref);
-            #endif
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & s2_is_unicode) {
-        goto return_ne;
-    } else if ((s2 == Py_None) & s1_is_unicode) {
-        goto return_ne;
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        #if PY_MAJOR_VERSION < 3
-        Py_XDECREF(owned_ref);
-        #endif
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
+    if (full_traceback) {
+        Py_XINCREF(old_exc);
+        Py_XINCREF(old_val);
+        Py_XINCREF(old_tb);
+        __Pyx_ErrRestore(old_exc, old_val, old_tb);
+        PyErr_PrintEx(1);
     }
-return_eq:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_EQ);
-return_ne:
     #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
+    ctx = PyString_FromString(name);
+    #else
+    ctx = PyUnicode_FromString(name);
     #endif
-    return (equals == Py_NE);
-#endif
-}
-
-/* fastcall */
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s)
-{
-    Py_ssize_t i, n = PyTuple_GET_SIZE(kwnames);
-    for (i = 0; i < n; i++)
-    {
-        if (s == PyTuple_GET_ITEM(kwnames, i)) return kwvalues[i];
-    }
-    for (i = 0; i < n; i++)
-    {
-        int eq = __Pyx_PyUnicode_Equals(s, PyTuple_GET_ITEM(kwnames, i), Py_EQ);
-        if (unlikely(eq != 0)) {
-            if (unlikely(eq < 0)) return NULL;
-            return kwvalues[i];
-        }
-    }
-    return NULL;
-}
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
-CYTHON_UNUSED static PyObject *__Pyx_KwargsAsDict_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues) {
-    Py_ssize_t i, nkwargs = PyTuple_GET_SIZE(kwnames);
-    PyObject *dict;
-    dict = PyDict_New();
-    if (unlikely(!dict))
-        return NULL;
-    for (i=0; i<nkwargs; i++) {
-        PyObject *key = PyTuple_GET_ITEM(kwnames, i);
-        if (unlikely(PyDict_SetItem(dict, key, kwvalues[i]) < 0))
-            goto bad;
+    __Pyx_ErrRestore(old_exc, old_val, old_tb);
+    if (!ctx) {
+        PyErr_WriteUnraisable(Py_None);
+    } else {
+        PyErr_WriteUnraisable(ctx);
+        Py_DECREF(ctx);
     }
-    return dict;
-bad:
-    Py_DECREF(dict);
-    return NULL;
-}
-#endif
+#ifdef WITH_THREAD
+    if (nogil)
+        PyGILState_Release(state);
 #endif
+}
 
 /* RaiseArgTupleInvalid */
 static void __Pyx_RaiseArgtupleInvalid(
     const char* func_name,
     int exact,
     Py_ssize_t num_min,
     Py_ssize_t num_max,
@@ -15543,83 +11860,38 @@
         PyString_AsString(kw_name));
         #endif
 }
 
 /* ParseKeywords */
 static int __Pyx_ParseOptionalKeywords(
     PyObject *kwds,
-    PyObject *const *kwvalues,
     PyObject **argnames[],
     PyObject *kwds2,
     PyObject *values[],
     Py_ssize_t num_pos_args,
     const char* function_name)
 {
     PyObject *key = 0, *value = 0;
     Py_ssize_t pos = 0;
     PyObject*** name;
     PyObject*** first_kw_arg = argnames + num_pos_args;
-    int kwds_is_tuple = CYTHON_METH_FASTCALL && likely(PyTuple_Check(kwds));
-    while (1) {
-        Py_XDECREF(key); key = NULL;
-        Py_XDECREF(value); value = NULL;
-        if (kwds_is_tuple) {
-            Py_ssize_t size;
-#if CYTHON_ASSUME_SAFE_MACROS
-            size = PyTuple_GET_SIZE(kwds);
-#else
-            size = PyTuple_Size(kwds);
-            if (size < 0) goto bad;
-#endif
-            if (pos >= size) break;
-#if CYTHON_AVOID_BORROWED_REFS
-            key = __Pyx_PySequence_ITEM(kwds, pos);
-            if (!key) goto bad;
-#elif CYTHON_ASSUME_SAFE_MACROS
-            key = PyTuple_GET_ITEM(kwds, pos);
-#else
-            key = PyTuple_GetItem(kwds, pos);
-            if (!key) goto bad;
-#endif
-            value = kwvalues[pos];
-            pos++;
-        }
-        else
-        {
-            if (!PyDict_Next(kwds, &pos, &key, &value)) break;
-#if CYTHON_AVOID_BORROWED_REFS
-            Py_INCREF(key);
-#endif
-        }
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
         name = first_kw_arg;
         while (*name && (**name != key)) name++;
         if (*name) {
             values[name-argnames] = value;
-#if CYTHON_AVOID_BORROWED_REFS
-            Py_INCREF(value);
-            Py_DECREF(key);
-#endif
-            key = NULL;
-            value = NULL;
             continue;
         }
-#if !CYTHON_AVOID_BORROWED_REFS
-        Py_INCREF(key);
-#endif
-        Py_INCREF(value);
         name = first_kw_arg;
         #if PY_MAJOR_VERSION < 3
         if (likely(PyString_Check(key))) {
             while (*name) {
                 if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                         && _PyString_Eq(**name, key)) {
                     values[name-argnames] = value;
-#if CYTHON_AVOID_BORROWED_REFS
-                    value = NULL;
-#endif
                     break;
                 }
                 name++;
             }
             if (*name) continue;
             else {
                 PyObject*** argname = argnames;
@@ -15632,26 +11904,22 @@
                     argname++;
                 }
             }
         } else
         #endif
         if (likely(PyUnicode_Check(key))) {
             while (*name) {
-                int cmp = (
+                int cmp = (**name == key) ? 0 :
                 #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                     (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                 #endif
-                    PyUnicode_Compare(**name, key)
-                );
+                    PyUnicode_Compare(**name, key);
                 if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                 if (cmp == 0) {
                     values[name-argnames] = value;
-#if CYTHON_AVOID_BORROWED_REFS
-                    value = NULL;
-#endif
                     break;
                 }
                 name++;
             }
             if (*name) continue;
             else {
                 PyObject*** argname = argnames;
@@ -15670,57 +11938,39 @@
             goto invalid_keyword_type;
         if (kwds2) {
             if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
         } else {
             goto invalid_keyword;
         }
     }
-    Py_XDECREF(key);
-    Py_XDECREF(value);
     return 0;
 arg_passed_twice:
     __Pyx_RaiseDoubleKeywordsError(function_name, key);
     goto bad;
 invalid_keyword_type:
     PyErr_Format(PyExc_TypeError,
         "%.200s() keywords must be strings", function_name);
     goto bad;
 invalid_keyword:
-    #if PY_MAJOR_VERSION < 3
     PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
         "%.200s() got an unexpected keyword argument '%.200s'",
         function_name, PyString_AsString(key));
     #else
-    PyErr_Format(PyExc_TypeError,
         "%s() got an unexpected keyword argument '%U'",
         function_name, key);
     #endif
 bad:
-    Py_XDECREF(key);
-    Py_XDECREF(value);
     return -1;
 }
 
-/* PyObjectCall2Args */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
-    PyObject *args[3] = {NULL, arg1, arg2};
-    return __Pyx_PyObject_FastCall(function, args+1, 2 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
-/* PyObjectCallOneArg */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *args[2] = {NULL, arg};
-    return __Pyx_PyObject_FastCall(func, args+1, 1 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
 /* PyObjectGetMethod */
 static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
     PyObject *attr;
 #if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
-    __Pyx_TypeName type_name;
     PyTypeObject *tp = Py_TYPE(obj);
     PyObject *descr;
     descrgetfunc f = NULL;
     PyObject **dictptr, *dict;
     int meth_found = 0;
     assert (*method == NULL);
     if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
@@ -15729,21 +11979,19 @@
     }
     if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
         return 0;
     }
     descr = _PyType_Lookup(tp, name);
     if (likely(descr != NULL)) {
         Py_INCREF(descr);
-#if defined(Py_TPFLAGS_METHOD_DESCRIPTOR) && Py_TPFLAGS_METHOD_DESCRIPTOR
-        if (__Pyx_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR))
-#elif PY_MAJOR_VERSION >= 3
+#if PY_MAJOR_VERSION >= 3
         #ifdef __Pyx_CyFunction_USED
-        if (likely(PyFunction_Check(descr) || __Pyx_IS_TYPE(descr, &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
+        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
         #else
-        if (likely(PyFunction_Check(descr) || __Pyx_IS_TYPE(descr, &PyMethodDescr_Type)))
+        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type)))
         #endif
 #else
         #ifdef __Pyx_CyFunction_USED
         if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
         #else
         if (likely(PyFunction_Check(descr)))
         #endif
@@ -15776,28 +12024,26 @@
         return 1;
     }
     if (f != NULL) {
         attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
         Py_DECREF(descr);
         goto try_unpack;
     }
-    if (likely(descr != NULL)) {
+    if (descr != NULL) {
         *method = descr;
         return 0;
     }
-    type_name = __Pyx_PyType_GetName(tp);
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, name);
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, name);
 #else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(name));
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(name));
 #endif
-    __Pyx_DECREF_TypeName(type_name);
     return 0;
 #else
     attr = __Pyx_PyObject_GetAttrStr(obj, name);
     goto try_unpack;
 #endif
 try_unpack:
 #if CYTHON_UNPACK_METHODS
@@ -15810,39 +12056,29 @@
     }
 #endif
     *method = attr;
     return 0;
 }
 
 /* PyObjectCallMethod1 */
-#if !(CYTHON_VECTORCALL && __PYX_LIMITED_VERSION_HEX >= 0x030C00A2)
 static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
     PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
     Py_DECREF(method);
     return result;
 }
-#endif
 static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
-#if CYTHON_VECTORCALL && __PYX_LIMITED_VERSION_HEX >= 0x030C00A2
-    PyObject *args[2] = {obj, arg};
-    (void) __Pyx_PyObject_GetMethod;
-    (void) __Pyx_PyObject_CallOneArg;
-    (void) __Pyx_PyObject_Call2Args;
-    return PyObject_VectorcallMethod(method_name, args, 2 | PY_VECTORCALL_ARGUMENTS_OFFSET, NULL);
-#else
     PyObject *method = NULL, *result;
     int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
     if (likely(is_method)) {
         result = __Pyx_PyObject_Call2Args(method, obj, arg);
         Py_DECREF(method);
         return result;
     }
     if (unlikely(!method)) return NULL;
     return __Pyx__PyObject_CallMethod1(method, arg);
-#endif
 }
 
 /* append */
 static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
     if (likely(PyList_CheckExact(L))) {
         if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
     } else {
@@ -15853,15 +12089,15 @@
     }
     return 0;
 }
 
 /* SetItemInt */
 static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
     int r;
-    if (unlikely(!j)) return -1;
+    if (!j) return -1;
     r = PyObject_SetItem(o, j, v);
     Py_DECREF(j);
     return r;
 }
 static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v, int is_list,
                                                CYTHON_NCP_UNUSED int wraparound, CYTHON_NCP_UNUSED int boundscheck) {
 #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
@@ -15871,62 +12107,46 @@
             PyObject* old = PyList_GET_ITEM(o, n);
             Py_INCREF(v);
             PyList_SET_ITEM(o, n, v);
             Py_DECREF(old);
             return 1;
         }
     } else {
-        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
-        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
-        if (mm && mm->mp_ass_subscript) {
-            int r;
-            PyObject *key = PyInt_FromSsize_t(i);
-            if (unlikely(!key)) return -1;
-            r = mm->mp_ass_subscript(o, key, v);
-            Py_DECREF(key);
-            return r;
-        }
-        if (likely(sm && sm->sq_ass_item)) {
-            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
-                Py_ssize_t l = sm->sq_length(o);
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_ass_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
                 if (likely(l >= 0)) {
                     i += l;
                 } else {
                     if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                         return -1;
                     PyErr_Clear();
                 }
             }
-            return sm->sq_ass_item(o, i, v);
+            return m->sq_ass_item(o, i, v);
         }
     }
 #else
-    if (is_list || !PyMapping_Check(o))
+#if CYTHON_COMPILING_IN_PYPY
+    if (is_list || (PySequence_Check(o) && !PyDict_Check(o)))
+#else
+    if (is_list || PySequence_Check(o))
+#endif
     {
         return PySequence_SetItem(o, i, v);
     }
 #endif
     return __Pyx_SetItemInt_Generic(o, PyInt_FromSsize_t(i), v);
 }
 
-/* RaiseUnexpectedTypeError */
-static int
-__Pyx_RaiseUnexpectedTypeError(const char *expected, PyObject *obj)
-{
-    __Pyx_TypeName obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError, "Expected %s, got " __Pyx_FMT_TYPENAME,
-                 expected, obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    return 0;
-}
-
 /* GetItemInt */
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
     PyObject *r;
-    if (unlikely(!j)) return NULL;
+    if (!j) return NULL;
     r = PyObject_GetItem(o, j);
     Py_DECREF(j);
     return r;
 }
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                               CYTHON_NCP_UNUSED int wraparound,
                                                               CYTHON_NCP_UNUSED int boundscheck) {
@@ -15979,154 +12199,94 @@
         Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
         if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
             PyObject *r = PyTuple_GET_ITEM(o, n);
             Py_INCREF(r);
             return r;
         }
     } else {
-        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
-        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
-        if (mm && mm->mp_subscript) {
-            PyObject *r, *key = PyInt_FromSsize_t(i);
-            if (unlikely(!key)) return NULL;
-            r = mm->mp_subscript(o, key);
-            Py_DECREF(key);
-            return r;
-        }
-        if (likely(sm && sm->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
-                Py_ssize_t l = sm->sq_length(o);
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
                 if (likely(l >= 0)) {
                     i += l;
                 } else {
                     if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                         return NULL;
                     PyErr_Clear();
                 }
             }
-            return sm->sq_item(o, i);
+            return m->sq_item(o, i);
         }
     }
 #else
-    if (is_list || !PyMapping_Check(o)) {
+    if (is_list || PySequence_Check(o)) {
         return PySequence_GetItem(o, i);
     }
 #endif
     return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 }
 
-/* WriteUnraisableException */
-static void __Pyx_WriteUnraisable(const char *name, int clineno,
-                                  int lineno, const char *filename,
-                                  int full_traceback, int nogil) {
-    PyObject *old_exc, *old_val, *old_tb;
-    PyObject *ctx;
-    __Pyx_PyThreadState_declare
-#ifdef WITH_THREAD
-    PyGILState_STATE state;
-    if (nogil)
-        state = PyGILState_Ensure();
-    else state = (PyGILState_STATE)0;
-#endif
-    CYTHON_UNUSED_VAR(clineno);
-    CYTHON_UNUSED_VAR(lineno);
-    CYTHON_UNUSED_VAR(filename);
-    CYTHON_MAYBE_UNUSED_VAR(nogil);
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
-    if (full_traceback) {
-        Py_XINCREF(old_exc);
-        Py_XINCREF(old_val);
-        Py_XINCREF(old_tb);
-        __Pyx_ErrRestore(old_exc, old_val, old_tb);
-        PyErr_PrintEx(1);
-    }
-    #if PY_MAJOR_VERSION < 3
-    ctx = PyString_FromString(name);
-    #else
-    ctx = PyUnicode_FromString(name);
-    #endif
-    __Pyx_ErrRestore(old_exc, old_val, old_tb);
-    if (!ctx) {
-        PyErr_WriteUnraisable(Py_None);
-    } else {
-        PyErr_WriteUnraisable(ctx);
-        Py_DECREF(ctx);
-    }
-#ifdef WITH_THREAD
-    if (nogil)
-        PyGILState_Release(state);
-#endif
-}
-
 /* PyObjectFormatAndDecref */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatSimpleAndDecref(PyObject* s, PyObject* f) {
     if (unlikely(!s)) return NULL;
     if (likely(PyUnicode_CheckExact(s))) return s;
     #if PY_MAJOR_VERSION < 3
     if (likely(PyString_CheckExact(s))) {
         PyObject *result = PyUnicode_FromEncodedObject(s, NULL, "strict");
         Py_DECREF(s);
         return result;
     }
     #endif
     return __Pyx_PyObject_FormatAndDecref(s, f);
 }
 static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatAndDecref(PyObject* s, PyObject* f) {
-    PyObject *result;
-    if (unlikely(!s)) return NULL;
-    result = PyObject_Format(s, f);
+    PyObject *result = PyObject_Format(s, f);
     Py_DECREF(s);
     return result;
 }
 
 /* JoinPyUnicode */
 static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char) {
+                                      CYTHON_UNUSED Py_UCS4 max_char) {
 #if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     PyObject *result_uval;
-    int result_ukind, kind_shift;
+    int result_ukind;
     Py_ssize_t i, char_pos;
     void *result_udata;
-    CYTHON_MAYBE_UNUSED_VAR(max_char);
 #if CYTHON_PEP393_ENABLED
     result_uval = PyUnicode_New(result_ulength, max_char);
     if (unlikely(!result_uval)) return NULL;
     result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
-    kind_shift = (result_ukind == PyUnicode_4BYTE_KIND) ? 2 : result_ukind - 1;
     result_udata = PyUnicode_DATA(result_uval);
 #else
     result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
     if (unlikely(!result_uval)) return NULL;
     result_ukind = sizeof(Py_UNICODE);
-    kind_shift = (result_ukind == 4) ? 2 : result_ukind - 1;
     result_udata = PyUnicode_AS_UNICODE(result_uval);
 #endif
-    assert(kind_shift == 2 || kind_shift == 1 || kind_shift == 0);
     char_pos = 0;
     for (i=0; i < value_count; i++) {
         int ukind;
         Py_ssize_t ulength;
         void *udata;
         PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
         if (unlikely(__Pyx_PyUnicode_READY(uval)))
             goto bad;
         ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
         if (unlikely(!ulength))
             continue;
-        if (unlikely((PY_SSIZE_T_MAX >> kind_shift) - ulength < char_pos))
+        if (unlikely(char_pos + ulength < 0))
             goto overflow;
         ukind = __Pyx_PyUnicode_KIND(uval);
         udata = __Pyx_PyUnicode_DATA(uval);
         if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
-            memcpy((char *)result_udata + (char_pos << kind_shift), udata, (size_t) (ulength << kind_shift));
+            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
         } else {
-            #if PY_VERSION_HEX >= 0x030d0000
-            if (unlikely(PyUnicode_CopyCharacters(result_uval, char_pos, uval, 0, ulength) < 0)) goto bad;
-            #elif CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
+            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
             _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
             #else
             Py_ssize_t j;
             for (j=0; j < ulength; j++) {
                 Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
                 __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
             }
@@ -16137,153 +12297,53 @@
     return result_uval;
 overflow:
     PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
 bad:
     Py_DECREF(result_uval);
     return NULL;
 #else
-    CYTHON_UNUSED_VAR(max_char);
-    CYTHON_UNUSED_VAR(result_ulength);
-    CYTHON_UNUSED_VAR(value_count);
+    result_ulength++;
+    value_count++;
     return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
 #endif
 }
 
-/* KeywordStringCheck */
-static int __Pyx_CheckKeywordStrings(
-    PyObject *kw,
-    const char* function_name,
-    int kw_allowed)
-{
-    PyObject* key = 0;
-    Py_ssize_t pos = 0;
-#if CYTHON_COMPILING_IN_PYPY
-    if (!kw_allowed && PyDict_Next(kw, &pos, &key, 0))
-        goto invalid_keyword;
-    return 1;
-#else
-    if (CYTHON_METH_FASTCALL && likely(PyTuple_Check(kw))) {
-        Py_ssize_t kwsize;
-#if CYTHON_ASSUME_SAFE_MACROS
-        kwsize = PyTuple_GET_SIZE(kw);
-#else
-        kwsize = PyTuple_Size(kw);
-        if (kwsize < 0) return 0;
-#endif
-        if (unlikely(kwsize == 0))
-            return 1;
-        if (!kw_allowed) {
-#if CYTHON_ASSUME_SAFE_MACROS
-            key = PyTuple_GET_ITEM(kw, 0);
-#else
-            key = PyTuple_GetItem(kw, pos);
-            if (!key) return 0;
-#endif
-            goto invalid_keyword;
-        }
-#if PY_VERSION_HEX < 0x03090000
-        for (pos = 0; pos < kwsize; pos++) {
-#if CYTHON_ASSUME_SAFE_MACROS
-            key = PyTuple_GET_ITEM(kw, pos);
-#else
-            key = PyTuple_GetItem(kw, pos);
-            if (!key) return 0;
-#endif
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
-        }
-#endif
-        return 1;
-    }
-    while (PyDict_Next(kw, &pos, &key, 0)) {
-        #if PY_MAJOR_VERSION < 3
-        if (unlikely(!PyString_Check(key)))
-        #endif
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
-    }
-    if (!kw_allowed && unlikely(key))
-        goto invalid_keyword;
-    return 1;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    return 0;
-#endif
-invalid_keyword:
-    #if PY_MAJOR_VERSION < 3
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-    PyErr_Format(PyExc_TypeError,
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
-    return 0;
-}
-
 /* GetTopmostException */
-#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
+#if CYTHON_USE_EXC_INFO_STACK
 static _PyErr_StackItem *
 __Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
 {
     _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_value == NULL || exc_info->exc_value == Py_None) &&
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
            exc_info->previous_item != NULL)
     {
         exc_info = exc_info->previous_item;
     }
     return exc_info;
 }
 #endif
 
 /* SaveResetException */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    PyObject *exc_value = exc_info->exc_value;
-    if (exc_value == NULL || exc_value == Py_None) {
-        *value = NULL;
-        *type = NULL;
-        *tb = NULL;
-    } else {
-        *value = exc_value;
-        Py_INCREF(*value);
-        *type = (PyObject*) Py_TYPE(exc_value);
-        Py_INCREF(*type);
-        *tb = PyException_GetTraceback(exc_value);
-    }
-  #elif CYTHON_USE_EXC_INFO_STACK
+    #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
     *type = exc_info->exc_type;
     *value = exc_info->exc_value;
     *tb = exc_info->exc_traceback;
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-  #else
+    #else
     *type = tstate->exc_type;
     *value = tstate->exc_value;
     *tb = tstate->exc_traceback;
+    #endif
     Py_XINCREF(*type);
     Py_XINCREF(*value);
     Py_XINCREF(*tb);
-  #endif
 }
 static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    PyObject *tmp_value = exc_info->exc_value;
-    exc_info->exc_value = value;
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-  #else
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = tstate->exc_info;
     tmp_type = exc_info->exc_type;
     tmp_value = exc_info->exc_value;
     tmp_tb = exc_info->exc_traceback;
     exc_info->exc_type = type;
@@ -16296,51 +12356,63 @@
     tstate->exc_type = type;
     tstate->exc_value = value;
     tstate->exc_traceback = tb;
     #endif
     Py_XDECREF(tmp_type);
     Py_XDECREF(tmp_value);
     Py_XDECREF(tmp_tb);
-  #endif
+}
+#endif
+
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
 }
 #endif
 
 /* GetException */
 #if CYTHON_FAST_THREAD_STATE
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
 #endif
 {
-    PyObject *local_type = NULL, *local_value, *local_tb = NULL;
+    PyObject *local_type, *local_value, *local_tb;
 #if CYTHON_FAST_THREAD_STATE
     PyObject *tmp_type, *tmp_value, *tmp_tb;
-  #if PY_VERSION_HEX >= 0x030C00A6
-    local_value = tstate->current_exception;
-    tstate->current_exception = 0;
-    if (likely(local_value)) {
-        local_type = (PyObject*) Py_TYPE(local_value);
-        Py_INCREF(local_type);
-        local_tb = PyException_GetTraceback(local_value);
-    }
-  #else
     local_type = tstate->curexc_type;
     local_value = tstate->curexc_value;
     local_tb = tstate->curexc_traceback;
     tstate->curexc_type = 0;
     tstate->curexc_value = 0;
     tstate->curexc_traceback = 0;
-  #endif
 #else
     PyErr_Fetch(&local_type, &local_value, &local_tb);
 #endif
     PyErr_NormalizeException(&local_type, &local_value, &local_tb);
-#if CYTHON_FAST_THREAD_STATE && PY_VERSION_HEX >= 0x030C00A6
-    if (unlikely(tstate->current_exception))
-#elif CYTHON_FAST_THREAD_STATE
+#if CYTHON_FAST_THREAD_STATE
     if (unlikely(tstate->curexc_type))
 #else
     if (unlikely(PyErr_Occurred()))
 #endif
         goto bad;
     #if PY_MAJOR_VERSION >= 3
     if (local_tb) {
@@ -16354,29 +12426,20 @@
     *type = local_type;
     *value = local_value;
     *tb = local_tb;
 #if CYTHON_FAST_THREAD_STATE
     #if CYTHON_USE_EXC_INFO_STACK
     {
         _PyErr_StackItem *exc_info = tstate->exc_info;
-      #if PY_VERSION_HEX >= 0x030B00a4
-        tmp_value = exc_info->exc_value;
-        exc_info->exc_value = local_value;
-        tmp_type = NULL;
-        tmp_tb = NULL;
-        Py_XDECREF(local_type);
-        Py_XDECREF(local_tb);
-      #else
         tmp_type = exc_info->exc_type;
         tmp_value = exc_info->exc_value;
         tmp_tb = exc_info->exc_traceback;
         exc_info->exc_type = local_type;
         exc_info->exc_value = local_value;
         exc_info->exc_traceback = local_tb;
-      #endif
     }
     #else
     tmp_type = tstate->exc_type;
     tmp_value = tstate->exc_value;
     tmp_tb = tstate->exc_traceback;
     tstate->exc_type = local_type;
     tstate->exc_value = local_value;
@@ -16395,14 +12458,36 @@
     *tb = 0;
     Py_XDECREF(local_type);
     Py_XDECREF(local_value);
     Py_XDECREF(local_tb);
     return -1;
 }
 
+/* PyObjectCallNoArg */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
+#if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCall(func, NULL, 0);
+    }
+#endif
+#ifdef __Pyx_CyFunction_USED
+    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
+#else
+    if (likely(PyCFunction_Check(func)))
+#endif
+    {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
+            return __Pyx_PyObject_CallMethO(func, NULL);
+        }
+    }
+    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
+}
+#endif
+
 /* PyObjectSetAttrStr */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
     PyTypeObject* tp = Py_TYPE(obj);
     if (likely(tp->tp_setattro))
         return tp->tp_setattro(obj, attr_name, value);
 #if PY_MAJOR_VERSION < 3
@@ -16410,41 +12495,40 @@
         return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
 #endif
     return PyObject_SetAttr(obj, attr_name, value);
 }
 #endif
 
 /* PyIntCompare */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_NeObjC(PyObject *op1, PyObject *op2, long intval, long inplace) {
-    CYTHON_MAYBE_UNUSED_VAR(intval);
-    CYTHON_UNUSED_VAR(inplace);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_NeObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED long inplace) {
     if (op1 == op2) {
         Py_RETURN_FALSE;
     }
     #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_CheckExact(op1))) {
         const long b = intval;
         long a = PyInt_AS_LONG(op1);
         if (a != b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
     }
     #endif
     #if CYTHON_USE_PYLONG_INTERNALS
     if (likely(PyLong_CheckExact(op1))) {
         int unequal;
         unsigned long uintval;
-        Py_ssize_t size = __Pyx_PyLong_DigitCount(op1);
-        const digit* digits = __Pyx_PyLong_Digits(op1);
+        Py_ssize_t size = Py_SIZE(op1);
+        const digit* digits = ((PyLongObject*)op1)->ob_digit;
         if (intval == 0) {
-            if (__Pyx_PyLong_IsZero(op1) != 1) Py_RETURN_TRUE; else Py_RETURN_FALSE;
+            if (size != 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
         } else if (intval < 0) {
-            if (__Pyx_PyLong_IsNonNeg(op1))
+            if (size >= 0)
                 Py_RETURN_TRUE;
             intval = -intval;
+            size = -size;
         } else {
-            if (__Pyx_PyLong_IsNeg(op1))
+            if (size <= 0)
                 Py_RETURN_TRUE;
         }
         uintval = (unsigned long) intval;
 #if PyLong_SHIFT * 4 < SIZEOF_LONG*8
         if (uintval >> (PyLong_SHIFT * 4)) {
             unequal = (size != 5) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                  | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[4] != ((uintval >> (4 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
@@ -16470,38 +12554,72 @@
 #endif
             unequal = (size != 1) || (((unsigned long) digits[0]) != (uintval & (unsigned long) PyLong_MASK));
         if (unequal != 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
     }
     #endif
     if (PyFloat_CheckExact(op1)) {
         const long b = intval;
-#if CYTHON_COMPILING_IN_LIMITED_API
-        double a = __pyx_PyFloat_AsDouble(op1);
-#else
         double a = PyFloat_AS_DOUBLE(op1);
-#endif
         if ((double)a != (double)b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
     }
     return (
         PyObject_RichCompare(op1, op2, Py_NE));
 }
 
+/* KeywordStringCheck */
+static int __Pyx_CheckKeywordStrings(
+    PyObject *kwdict,
+    const char* function_name,
+    int kw_allowed)
+{
+    PyObject* key = 0;
+    Py_ssize_t pos = 0;
+#if CYTHON_COMPILING_IN_PYPY
+    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
+        goto invalid_keyword;
+    return 1;
+#else
+    while (PyDict_Next(kwdict, &pos, &key, 0)) {
+        #if PY_MAJOR_VERSION < 3
+        if (unlikely(!PyString_Check(key)))
+        #endif
+            if (unlikely(!PyUnicode_Check(key)))
+                goto invalid_keyword_type;
+    }
+    if ((!kw_allowed) && unlikely(key))
+        goto invalid_keyword;
+    return 1;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%.200s() keywords must be strings", function_name);
+    return 0;
+#endif
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%.200s() got an unexpected keyword argument '%.200s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+    return 0;
+}
+
 /* PyObject_GenericGetAttrNoDict */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
-    __Pyx_TypeName type_name = __Pyx_PyType_GetName(tp);
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, attr_name);
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, attr_name);
 #else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(attr_name));
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(attr_name));
 #endif
-    __Pyx_DECREF_TypeName(type_name);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
     PyObject *descr;
     PyTypeObject *tp = Py_TYPE(obj);
     if (unlikely(!PyString_Check(attr_name))) {
         return PyObject_GenericGetAttr(obj, attr_name);
@@ -16533,373 +12651,59 @@
     if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
         return PyObject_GenericGetAttr(obj, attr_name);
     }
     return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
 }
 #endif
 
-/* FixUpExtensionType */
-#if CYTHON_USE_TYPE_SPECS
-static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
-#if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-    CYTHON_UNUSED_VAR(spec);
-    CYTHON_UNUSED_VAR(type);
-#else
-    const PyType_Slot *slot = spec->slots;
-    while (slot && slot->slot && slot->slot != Py_tp_members)
-        slot++;
-    if (slot && slot->slot == Py_tp_members) {
-        int changed = 0;
-#if !(PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON)
-        const
-#endif
-            PyMemberDef *memb = (PyMemberDef*) slot->pfunc;
-        while (memb && memb->name) {
-            if (memb->name[0] == '_' && memb->name[1] == '_') {
-#if PY_VERSION_HEX < 0x030900b1
-                if (strcmp(memb->name, "__weaklistoffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-                    type->tp_weaklistoffset = memb->offset;
-                    changed = 1;
-                }
-                else if (strcmp(memb->name, "__dictoffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-                    type->tp_dictoffset = memb->offset;
-                    changed = 1;
-                }
-#if CYTHON_METH_FASTCALL
-                else if (strcmp(memb->name, "__vectorcalloffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-#if PY_VERSION_HEX >= 0x030800b4
-                    type->tp_vectorcall_offset = memb->offset;
-#else
-                    type->tp_print = (printfunc) memb->offset;
-#endif
-                    changed = 1;
-                }
-#endif
-#else
-                if ((0));
-#endif
-#if PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON
-                else if (strcmp(memb->name, "__module__") == 0) {
-                    PyObject *descr;
-                    assert(memb->type == T_OBJECT);
-                    assert(memb->flags == 0 || memb->flags == READONLY);
-                    descr = PyDescr_NewMember(type, memb);
-                    if (unlikely(!descr))
-                        return -1;
-                    if (unlikely(PyDict_SetItem(type->tp_dict, PyDescr_NAME(descr), descr) < 0)) {
-                        Py_DECREF(descr);
-                        return -1;
-                    }
-                    Py_DECREF(descr);
-                    changed = 1;
-                }
-#endif
-            }
-            memb++;
-        }
-        if (changed)
-            PyType_Modified(type);
-    }
-#endif
-    return 0;
-}
-#endif
-
-/* PyObjectCallNoArg */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
-    PyObject *arg[2] = {NULL, NULL};
-    return __Pyx_PyObject_FastCall(func, arg + 1, 0 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
-/* PyObjectCallMethod0 */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
-    PyObject *method = NULL, *result = NULL;
-    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
-    if (likely(is_method)) {
-        result = __Pyx_PyObject_CallOneArg(method, obj);
-        Py_DECREF(method);
-        return result;
-    }
-    if (unlikely(!method)) goto bad;
-    result = __Pyx_PyObject_CallNoArg(method);
-    Py_DECREF(method);
-bad:
-    return result;
-}
-
-/* ValidateBasesTuple */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases) {
-    Py_ssize_t i, n;
-#if CYTHON_ASSUME_SAFE_MACROS
-    n = PyTuple_GET_SIZE(bases);
-#else
-    n = PyTuple_Size(bases);
-    if (n < 0) return -1;
-#endif
-    for (i = 1; i < n; i++)
-    {
-#if CYTHON_AVOID_BORROWED_REFS
-        PyObject *b0 = PySequence_GetItem(bases, i);
-        if (!b0) return -1;
-#elif CYTHON_ASSUME_SAFE_MACROS
-        PyObject *b0 = PyTuple_GET_ITEM(bases, i);
-#else
-        PyObject *b0 = PyTuple_GetItem(bases, i);
-        if (!b0) return -1;
-#endif
-        PyTypeObject *b;
-#if PY_MAJOR_VERSION < 3
-        if (PyClass_Check(b0))
-        {
-            PyErr_Format(PyExc_TypeError, "base class '%.200s' is an old-style class",
-                         PyString_AS_STRING(((PyClassObject*)b0)->cl_name));
-#if CYTHON_AVOID_BORROWED_REFS
-            Py_DECREF(b0);
-#endif
-            return -1;
-        }
-#endif
-        b = (PyTypeObject*) b0;
-        if (!__Pyx_PyType_HasFeature(b, Py_TPFLAGS_HEAPTYPE))
-        {
-            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-            PyErr_Format(PyExc_TypeError,
-                "base class '" __Pyx_FMT_TYPENAME "' is not a heap type", b_name);
-            __Pyx_DECREF_TypeName(b_name);
-#if CYTHON_AVOID_BORROWED_REFS
-            Py_DECREF(b0);
-#endif
-            return -1;
-        }
-        if (dictoffset == 0)
-        {
-            Py_ssize_t b_dictoffset = 0;
-#if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
-            b_dictoffset = b->tp_dictoffset;
-#else
-            PyObject *py_b_dictoffset = PyObject_GetAttrString((PyObject*)b, "__dictoffset__");
-            if (!py_b_dictoffset) goto dictoffset_return;
-            b_dictoffset = PyLong_AsSsize_t(py_b_dictoffset);
-            Py_DECREF(py_b_dictoffset);
-            if (b_dictoffset == -1 && PyErr_Occurred()) goto dictoffset_return;
-#endif
-            if (b_dictoffset) {
-                {
-                    __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-                    PyErr_Format(PyExc_TypeError,
-                        "extension type '%.200s' has no __dict__ slot, "
-                        "but base type '" __Pyx_FMT_TYPENAME "' has: "
-                        "either add 'cdef dict __dict__' to the extension type "
-                        "or add '__slots__ = [...]' to the base type",
-                        type_name, b_name);
-                    __Pyx_DECREF_TypeName(b_name);
-                }
-#if !(CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY)
-              dictoffset_return:
-#endif
-#if CYTHON_AVOID_BORROWED_REFS
-                Py_DECREF(b0);
-#endif
-                return -1;
-            }
-        }
-#if CYTHON_AVOID_BORROWED_REFS
-        Py_DECREF(b0);
-#endif
-    }
-    return 0;
-}
-#endif
-
-/* PyType_Ready */
-static int __Pyx_PyType_Ready(PyTypeObject *t) {
-#if CYTHON_USE_TYPE_SPECS || !(CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API) || defined(PYSTON_MAJOR_VERSION)
-    (void)__Pyx_PyObject_CallMethod0;
-#if CYTHON_USE_TYPE_SPECS
-    (void)__Pyx_validate_bases_tuple;
-#endif
-    return PyType_Ready(t);
-#else
-    int r;
-    PyObject *bases = __Pyx_PyType_GetSlot(t, tp_bases, PyObject*);
-    if (bases && unlikely(__Pyx_validate_bases_tuple(t->tp_name, t->tp_dictoffset, bases) == -1))
-        return -1;
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-    {
-        int gc_was_enabled;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        gc_was_enabled = PyGC_Disable();
-        (void)__Pyx_PyObject_CallMethod0;
-    #else
-        PyObject *ret, *py_status;
-        PyObject *gc = NULL;
-        #if PY_VERSION_HEX >= 0x030700a1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM+0 >= 0x07030400)
-        gc = PyImport_GetModule(__pyx_kp_u_gc);
-        #endif
-        if (unlikely(!gc)) gc = PyImport_Import(__pyx_kp_u_gc);
-        if (unlikely(!gc)) return -1;
-        py_status = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_isenabled);
-        if (unlikely(!py_status)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-        gc_was_enabled = __Pyx_PyObject_IsTrue(py_status);
-        Py_DECREF(py_status);
-        if (gc_was_enabled > 0) {
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_disable);
-            if (unlikely(!ret)) {
-                Py_DECREF(gc);
-                return -1;
-            }
-            Py_DECREF(ret);
-        } else if (unlikely(gc_was_enabled == -1)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-    #endif
-        t->tp_flags |= Py_TPFLAGS_HEAPTYPE;
-#if PY_VERSION_HEX >= 0x030A0000
-        t->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;
-#endif
-#else
-        (void)__Pyx_PyObject_CallMethod0;
-#endif
-    r = PyType_Ready(t);
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-        t->tp_flags &= ~Py_TPFLAGS_HEAPTYPE;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        if (gc_was_enabled)
-            PyGC_Enable();
-    #else
-        if (gc_was_enabled) {
-            PyObject *tp, *v, *tb;
-            PyErr_Fetch(&tp, &v, &tb);
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_enable);
-            if (likely(ret || r == -1)) {
-                Py_XDECREF(ret);
-                PyErr_Restore(tp, v, tb);
-            } else {
-                Py_XDECREF(tp);
-                Py_XDECREF(v);
-                Py_XDECREF(tb);
-                r = -1;
-            }
-        }
-        Py_DECREF(gc);
-    #endif
-    }
-#endif
-    return r;
-#endif
-}
-
 /* SetVTable */
-static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000
     PyObject *ob = PyCapsule_New(vtable, 0, 0);
-    if (unlikely(!ob))
-        goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(PyObject_SetAttr((PyObject *) type, __pyx_n_s_pyx_vtable, ob) < 0))
 #else
-    if (unlikely(PyDict_SetItem(type->tp_dict, __pyx_n_s_pyx_vtable, ob) < 0))
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
 #endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
         goto bad;
     Py_DECREF(ob);
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
-/* GetVTable */
-static void* __Pyx_GetVtable(PyTypeObject *type) {
-    void* ptr;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *ob = PyObject_GetAttr((PyObject *)type, __pyx_n_s_pyx_vtable);
-#else
-    PyObject *ob = PyObject_GetItem(type->tp_dict, __pyx_n_s_pyx_vtable);
-#endif
-    if (!ob)
-        goto bad;
-    ptr = PyCapsule_GetPointer(ob, 0);
-    if (!ptr && !PyErr_Occurred())
-        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
-    Py_DECREF(ob);
-    return ptr;
-bad:
-    Py_XDECREF(ob);
-    return NULL;
+/* PyObjectGetAttrStrNoError */
+static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        __Pyx_PyErr_Clear();
 }
-
-/* MergeVTables */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type) {
-    int i;
-    void** base_vtables;
-    __Pyx_TypeName tp_base_name;
-    __Pyx_TypeName base_name;
-    void* unknown = (void*)-1;
-    PyObject* bases = type->tp_bases;
-    int base_depth = 0;
-    {
-        PyTypeObject* base = type->tp_base;
-        while (base) {
-            base_depth += 1;
-            base = base->tp_base;
-        }
-    }
-    base_vtables = (void**) malloc(sizeof(void*) * (size_t)(base_depth + 1));
-    base_vtables[0] = unknown;
-    for (i = 1; i < PyTuple_GET_SIZE(bases); i++) {
-        void* base_vtable = __Pyx_GetVtable(((PyTypeObject*)PyTuple_GET_ITEM(bases, i)));
-        if (base_vtable != NULL) {
-            int j;
-            PyTypeObject* base = type->tp_base;
-            for (j = 0; j < base_depth; j++) {
-                if (base_vtables[j] == unknown) {
-                    base_vtables[j] = __Pyx_GetVtable(base);
-                    base_vtables[j + 1] = unknown;
-                }
-                if (base_vtables[j] == base_vtable) {
-                    break;
-                } else if (base_vtables[j] == NULL) {
-                    goto bad;
-                }
-                base = base->tp_base;
-            }
-        }
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
+        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
     }
-    PyErr_Clear();
-    free(base_vtables);
-    return 0;
-bad:
-    tp_base_name = __Pyx_PyType_GetName(type->tp_base);
-    base_name = __Pyx_PyType_GetName((PyTypeObject*)PyTuple_GET_ITEM(bases, i));
-    PyErr_Format(PyExc_TypeError,
-        "multiple bases have vtable conflict: '" __Pyx_FMT_TYPENAME "' and '" __Pyx_FMT_TYPENAME "'", tp_base_name, base_name);
-    __Pyx_DECREF_TypeName(tp_base_name);
-    __Pyx_DECREF_TypeName(base_name);
-    free(base_vtables);
-    return -1;
-}
 #endif
+    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
+    if (unlikely(!result)) {
+        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
+    }
+    return result;
+}
 
 /* SetupReduce */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
   int ret;
   PyObject *name_attr;
-  name_attr = __Pyx_PyObject_GetAttrStrNoError(meth, __pyx_n_s_name);
+  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name);
   if (likely(name_attr)) {
       ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
   } else {
       ret = -1;
   }
   if (unlikely(ret < 0)) {
       PyErr_Clear();
@@ -16907,43 +12711,25 @@
   }
   Py_XDECREF(name_attr);
   return ret;
 }
 static int __Pyx_setup_reduce(PyObject* type_obj) {
     int ret = 0;
     PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
     PyObject *object_reduce_ex = NULL;
     PyObject *reduce = NULL;
     PyObject *reduce_ex = NULL;
     PyObject *reduce_cython = NULL;
     PyObject *setstate = NULL;
     PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
 #if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
+    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #endif
-    if (getstate) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
-#else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
-#endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
 #if CYTHON_USE_PYTYPE_LOOKUP
     object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
     object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
     reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
     if (reduce_ex == object_reduce_ex) {
@@ -16957,15 +12743,15 @@
             reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
             if (likely(reduce_cython)) {
                 ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                 ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
             } else if (reduce == object_reduce || PyErr_Occurred()) {
                 goto __PYX_BAD;
             }
-            setstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate);
+            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
             if (!setstate) PyErr_Clear();
             if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                 setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
                 if (likely(setstate_cython)) {
                     ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                     ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                 } else if (!setstate || PyErr_Occurred()) {
@@ -16973,105 +12759,78 @@
                 }
             }
             PyType_Modified((PyTypeObject*)type_obj);
         }
     }
     goto __PYX_GOOD;
 __PYX_BAD:
-    if (!PyErr_Occurred()) {
-        __Pyx_TypeName type_obj_name =
-            __Pyx_PyType_GetName((PyTypeObject*)type_obj);
-        PyErr_Format(PyExc_RuntimeError,
-            "Unable to initialize pickling for " __Pyx_FMT_TYPENAME, type_obj_name);
-        __Pyx_DECREF_TypeName(type_obj_name);
-    }
+    if (!PyErr_Occurred())
+        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
     ret = -1;
 __PYX_GOOD:
 #if !CYTHON_USE_PYTYPE_LOOKUP
     Py_XDECREF(object_reduce);
     Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
 #endif
     Py_XDECREF(reduce);
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
-#endif
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType_3_0_8
-#define __PYX_HAVE_RT_ImportType_3_0_8
-static PyTypeObject *__Pyx_ImportType_3_0_8(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_8 check_size)
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, enum __Pyx_ImportType_CheckSize check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
-    Py_ssize_t itemsize;
-#if CYTHON_COMPILING_IN_LIMITED_API
+#ifdef Py_LIMITED_API
     PyObject *py_basicsize;
-    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
-#if !CYTHON_COMPILING_IN_LIMITED_API
+#ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
-    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
-    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
-    if (!py_itemsize)
-        goto bad;
-    itemsize = PyLong_AsSsize_t(py_itemsize);
-    Py_DECREF(py_itemsize);
-    py_itemsize = 0;
-    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
-        goto bad;
 #endif
-    if (itemsize) {
-        if (size % alignment) {
-            alignment = size % alignment;
-        }
-        if (itemsize < (Py_ssize_t)alignment)
-            itemsize = (Py_ssize_t)alignment;
-    }
-    if ((size_t)(basicsize + itemsize) < size) {
+    if ((size_t)basicsize < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
-            module_name, class_name, size, basicsize+itemsize);
+            module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error_3_0_8 &&
-            ((size_t)basicsize > size || (size_t)(basicsize + itemsize) < size)) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
-            "Expected %zd from C header, got %zd-%zd from PyObject",
-            module_name, class_name, size, basicsize, basicsize+itemsize);
+            "Expected %zd from C header, got %zd from PyObject",
+            module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn_3_0_8 && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -17079,1441 +12838,113 @@
     Py_XDECREF(result);
     return NULL;
 }
 #endif
 
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
     PyObject *module = 0;
+    PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
-    PyObject *empty_list = 0;
+    PyObject *list;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_import;
     py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
-    if (unlikely(!py_import))
+    if (!py_import)
         goto bad;
-    if (!from_list) {
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
         empty_list = PyList_New(0);
-        if (unlikely(!empty_list))
+        if (!empty_list)
             goto bad;
-        from_list = empty_list;
+        list = empty_list;
     }
-    #endif
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
     empty_dict = PyDict_New();
-    if (unlikely(!empty_dict))
+    if (!empty_dict)
         goto bad;
     {
         #if PY_MAJOR_VERSION >= 3
         if (level == -1) {
-            if (strchr(__Pyx_MODULE_NAME, '.') != NULL) {
+            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
                 module = PyImport_ImportModuleLevelObject(
-                    name, __pyx_d, empty_dict, from_list, 1);
-                if (unlikely(!module)) {
-                    if (unlikely(!PyErr_ExceptionMatches(PyExc_ImportError)))
+                    name, global_dict, empty_dict, list, 1);
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                         goto bad;
                     PyErr_Clear();
                 }
             }
             level = 0;
         }
         #endif
         if (!module) {
             #if PY_MAJOR_VERSION < 3
             PyObject *py_level = PyInt_FromLong(level);
-            if (unlikely(!py_level))
+            if (!py_level)
                 goto bad;
             module = PyObject_CallFunctionObjArgs(py_import,
-                name, __pyx_d, empty_dict, from_list, py_level, (PyObject *)NULL);
+                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
             Py_DECREF(py_level);
             #else
             module = PyImport_ImportModuleLevelObject(
-                name, __pyx_d, empty_dict, from_list, level);
+                name, global_dict, empty_dict, list, level);
             #endif
         }
     }
 bad:
-    Py_XDECREF(empty_dict);
-    Py_XDECREF(empty_list);
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_import);
     #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
     return module;
 }
 
 /* ImportFrom */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
     PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
     if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        const char* module_name_str = 0;
-        PyObject* module_name = 0;
-        PyObject* module_dot = 0;
-        PyObject* full_name = 0;
-        PyErr_Clear();
-        module_name_str = PyModule_GetName(module);
-        if (unlikely(!module_name_str)) { goto modbad; }
-        module_name = PyUnicode_FromString(module_name_str);
-        if (unlikely(!module_name)) { goto modbad; }
-        module_dot = PyUnicode_Concat(module_name, __pyx_kp_u__7);
-        if (unlikely(!module_dot)) { goto modbad; }
-        full_name = PyUnicode_Concat(module_dot, name);
-        if (unlikely(!full_name)) { goto modbad; }
-        #if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-        {
-            PyObject *modules = PyImport_GetModuleDict();
-            if (unlikely(!modules))
-                goto modbad;
-            value = PyObject_GetItem(modules, full_name);
-        }
-        #else
-        value = PyImport_GetModule(full_name);
-        #endif
-      modbad:
-        Py_XDECREF(full_name);
-        Py_XDECREF(module_dot);
-        Py_XDECREF(module_name);
-    }
-    if (unlikely(!value)) {
         PyErr_Format(PyExc_ImportError,
         #if PY_MAJOR_VERSION < 3
             "cannot import name %.230s", PyString_AS_STRING(name));
         #else
             "cannot import name %S", name);
         #endif
     }
     return value;
 }
 
-/* ImportDottedModule */
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx__ImportDottedModule_Error(PyObject *name, PyObject *parts_tuple, Py_ssize_t count) {
-    PyObject *partial_name = NULL, *slice = NULL, *sep = NULL;
-    if (unlikely(PyErr_Occurred())) {
-        PyErr_Clear();
-    }
-    if (likely(PyTuple_GET_SIZE(parts_tuple) == count)) {
-        partial_name = name;
-    } else {
-        slice = PySequence_GetSlice(parts_tuple, 0, count);
-        if (unlikely(!slice))
-            goto bad;
-        sep = PyUnicode_FromStringAndSize(".", 1);
-        if (unlikely(!sep))
-            goto bad;
-        partial_name = PyUnicode_Join(sep, slice);
-    }
-    PyErr_Format(
-#if PY_MAJOR_VERSION < 3
-        PyExc_ImportError,
-        "No module named '%s'", PyString_AS_STRING(partial_name));
-#else
-#if PY_VERSION_HEX >= 0x030600B1
-        PyExc_ModuleNotFoundError,
-#else
-        PyExc_ImportError,
-#endif
-        "No module named '%U'", partial_name);
-#endif
-bad:
-    Py_XDECREF(sep);
-    Py_XDECREF(slice);
-    Py_XDECREF(partial_name);
-    return NULL;
-}
-#endif
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx__ImportDottedModule_Lookup(PyObject *name) {
-    PyObject *imported_module;
-#if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-    PyObject *modules = PyImport_GetModuleDict();
-    if (unlikely(!modules))
-        return NULL;
-    imported_module = __Pyx_PyDict_GetItemStr(modules, name);
-    Py_XINCREF(imported_module);
-#else
-    imported_module = PyImport_GetModule(name);
-#endif
-    return imported_module;
-}
-#endif
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple) {
-    Py_ssize_t i, nparts;
-    nparts = PyTuple_GET_SIZE(parts_tuple);
-    for (i=1; i < nparts && module; i++) {
-        PyObject *part, *submodule;
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        part = PyTuple_GET_ITEM(parts_tuple, i);
-#else
-        part = PySequence_ITEM(parts_tuple, i);
-#endif
-        submodule = __Pyx_PyObject_GetAttrStrNoError(module, part);
-#if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-        Py_DECREF(part);
-#endif
-        Py_DECREF(module);
-        module = submodule;
-    }
-    if (unlikely(!module)) {
-        return __Pyx__ImportDottedModule_Error(name, parts_tuple, i);
-    }
-    return module;
-}
-#endif
-static PyObject *__Pyx__ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
-#if PY_MAJOR_VERSION < 3
-    PyObject *module, *from_list, *star = __pyx_n_s__8;
-    CYTHON_UNUSED_VAR(parts_tuple);
-    from_list = PyList_New(1);
-    if (unlikely(!from_list))
-        return NULL;
-    Py_INCREF(star);
-    PyList_SET_ITEM(from_list, 0, star);
-    module = __Pyx_Import(name, from_list, 0);
-    Py_DECREF(from_list);
-    return module;
-#else
-    PyObject *imported_module;
-    PyObject *module = __Pyx_Import(name, NULL, 0);
-    if (!parts_tuple || unlikely(!module))
-        return module;
-    imported_module = __Pyx__ImportDottedModule_Lookup(name);
-    if (likely(imported_module)) {
-        Py_DECREF(module);
-        return imported_module;
-    }
-    PyErr_Clear();
-    return __Pyx_ImportDottedModule_WalkParts(module, name, parts_tuple);
-#endif
-}
-static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030400B1
-    PyObject *module = __Pyx__ImportDottedModule_Lookup(name);
-    if (likely(module)) {
-        PyObject *spec = __Pyx_PyObject_GetAttrStrNoError(module, __pyx_n_s_spec);
-        if (likely(spec)) {
-            PyObject *unsafe = __Pyx_PyObject_GetAttrStrNoError(spec, __pyx_n_s_initializing);
-            if (likely(!unsafe || !__Pyx_PyObject_IsTrue(unsafe))) {
-                Py_DECREF(spec);
-                spec = NULL;
-            }
-            Py_XDECREF(unsafe);
-        }
-        if (likely(!spec)) {
-            PyErr_Clear();
-            return module;
-        }
-        Py_DECREF(spec);
-        Py_DECREF(module);
-    } else if (PyErr_Occurred()) {
-        PyErr_Clear();
-    }
-#endif
-    return __Pyx__ImportDottedModule(name, parts_tuple);
-}
-
-/* FetchSharedCythonModule */
-static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
-    return __Pyx_PyImport_AddModuleRef((char*) __PYX_ABI_MODULE_NAME);
-}
-
-/* FetchCommonType */
-static int __Pyx_VerifyCachedType(PyObject *cached_type,
-                               const char *name,
-                               Py_ssize_t basicsize,
-                               Py_ssize_t expected_basicsize) {
-    if (!PyType_Check(cached_type)) {
-        PyErr_Format(PyExc_TypeError,
-            "Shared Cython type %.200s is not a type object", name);
-        return -1;
-    }
-    if (basicsize != expected_basicsize) {
-        PyErr_Format(PyExc_TypeError,
-            "Shared Cython type %.200s has the wrong size, try recompiling",
-            name);
-        return -1;
-    }
-    return 0;
-}
-#if !CYTHON_USE_TYPE_SPECS
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
-    PyObject* abi_module;
-    const char* object_name;
-    PyTypeObject *cached_type = NULL;
-    abi_module = __Pyx_FetchSharedCythonABIModule();
-    if (!abi_module) return NULL;
-    object_name = strrchr(type->tp_name, '.');
-    object_name = object_name ? object_name+1 : type->tp_name;
-    cached_type = (PyTypeObject*) PyObject_GetAttrString(abi_module, object_name);
-    if (cached_type) {
-        if (__Pyx_VerifyCachedType(
-              (PyObject *)cached_type,
-              object_name,
-              cached_type->tp_basicsize,
-              type->tp_basicsize) < 0) {
-            goto bad;
-        }
-        goto done;
-    }
-    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-    PyErr_Clear();
-    if (PyType_Ready(type) < 0) goto bad;
-    if (PyObject_SetAttrString(abi_module, object_name, (PyObject *)type) < 0)
-        goto bad;
-    Py_INCREF(type);
-    cached_type = type;
-done:
-    Py_DECREF(abi_module);
-    return cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-#else
-static PyTypeObject *__Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases) {
-    PyObject *abi_module, *cached_type = NULL;
-    const char* object_name = strrchr(spec->name, '.');
-    object_name = object_name ? object_name+1 : spec->name;
-    abi_module = __Pyx_FetchSharedCythonABIModule();
-    if (!abi_module) return NULL;
-    cached_type = PyObject_GetAttrString(abi_module, object_name);
-    if (cached_type) {
-        Py_ssize_t basicsize;
-#if CYTHON_COMPILING_IN_LIMITED_API
-        PyObject *py_basicsize;
-        py_basicsize = PyObject_GetAttrString(cached_type, "__basicsize__");
-        if (unlikely(!py_basicsize)) goto bad;
-        basicsize = PyLong_AsSsize_t(py_basicsize);
-        Py_DECREF(py_basicsize);
-        py_basicsize = 0;
-        if (unlikely(basicsize == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
-#else
-        basicsize = likely(PyType_Check(cached_type)) ? ((PyTypeObject*) cached_type)->tp_basicsize : -1;
-#endif
-        if (__Pyx_VerifyCachedType(
-              cached_type,
-              object_name,
-              basicsize,
-              spec->basicsize) < 0) {
-            goto bad;
-        }
-        goto done;
-    }
-    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-    PyErr_Clear();
-    CYTHON_UNUSED_VAR(module);
-    cached_type = __Pyx_PyType_FromModuleAndSpec(abi_module, spec, bases);
-    if (unlikely(!cached_type)) goto bad;
-    if (unlikely(__Pyx_fix_up_extension_type_from_spec(spec, (PyTypeObject *) cached_type) < 0)) goto bad;
-    if (PyObject_SetAttrString(abi_module, object_name, cached_type) < 0) goto bad;
-done:
-    Py_DECREF(abi_module);
-    assert(cached_type == NULL || PyType_Check(cached_type));
-    return (PyTypeObject *) cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-#endif
-
-/* PyVectorcallFastCallDict */
-#if CYTHON_METH_FASTCALL
-static PyObject *__Pyx_PyVectorcall_FastCallDict_kw(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
-{
-    PyObject *res = NULL;
-    PyObject *kwnames;
-    PyObject **newargs;
-    PyObject **kwvalues;
-    Py_ssize_t i, pos;
-    size_t j;
-    PyObject *key, *value;
-    unsigned long keys_are_strings;
-    Py_ssize_t nkw = PyDict_GET_SIZE(kw);
-    newargs = (PyObject **)PyMem_Malloc((nargs + (size_t)nkw) * sizeof(args[0]));
-    if (unlikely(newargs == NULL)) {
-        PyErr_NoMemory();
-        return NULL;
-    }
-    for (j = 0; j < nargs; j++) newargs[j] = args[j];
-    kwnames = PyTuple_New(nkw);
-    if (unlikely(kwnames == NULL)) {
-        PyMem_Free(newargs);
-        return NULL;
-    }
-    kwvalues = newargs + nargs;
-    pos = i = 0;
-    keys_are_strings = Py_TPFLAGS_UNICODE_SUBCLASS;
-    while (PyDict_Next(kw, &pos, &key, &value)) {
-        keys_are_strings &= Py_TYPE(key)->tp_flags;
-        Py_INCREF(key);
-        Py_INCREF(value);
-        PyTuple_SET_ITEM(kwnames, i, key);
-        kwvalues[i] = value;
-        i++;
-    }
-    if (unlikely(!keys_are_strings)) {
-        PyErr_SetString(PyExc_TypeError, "keywords must be strings");
-        goto cleanup;
-    }
-    res = vc(func, newargs, nargs, kwnames);
-cleanup:
-    Py_DECREF(kwnames);
-    for (i = 0; i < nkw; i++)
-        Py_DECREF(kwvalues[i]);
-    PyMem_Free(newargs);
-    return res;
-}
-static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
-{
-    if (likely(kw == NULL) || PyDict_GET_SIZE(kw) == 0) {
-        return vc(func, args, nargs, NULL);
-    }
-    return __Pyx_PyVectorcall_FastCallDict_kw(func, vc, args, nargs, kw);
-}
-#endif
-
-/* CythonFunctionShared */
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc) {
-    if (__Pyx_CyFunction_Check(func)) {
-        return PyCFunction_GetFunction(((__pyx_CyFunctionObject*)func)->func) == (PyCFunction) cfunc;
-    } else if (PyCFunction_Check(func)) {
-        return PyCFunction_GetFunction(func) == (PyCFunction) cfunc;
-    }
-    return 0;
-}
-#else
-static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc) {
-    return __Pyx_CyOrPyCFunction_Check(func) && __Pyx_CyOrPyCFunction_GET_FUNCTION(func) == (PyCFunction) cfunc;
-}
-#endif
-static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj) {
-#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-    __Pyx_Py_XDECREF_SET(
-        __Pyx_CyFunction_GetClassObj(f),
-            ((classobj) ? __Pyx_NewRef(classobj) : NULL));
-#else
-    __Pyx_Py_XDECREF_SET(
-        ((PyCMethodObject *) (f))->mm_class,
-        (PyTypeObject*)((classobj) ? __Pyx_NewRef(classobj) : NULL));
-#endif
-}
-static PyObject *
-__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, void *closure)
-{
-    CYTHON_UNUSED_VAR(closure);
-    if (unlikely(op->func_doc == NULL)) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-        op->func_doc = PyObject_GetAttrString(op->func, "__doc__");
-        if (unlikely(!op->func_doc)) return NULL;
-#else
-        if (((PyCFunctionObject*)op)->m_ml->ml_doc) {
-#if PY_MAJOR_VERSION >= 3
-            op->func_doc = PyUnicode_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
-#else
-            op->func_doc = PyString_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
-#endif
-            if (unlikely(op->func_doc == NULL))
-                return NULL;
-        } else {
-            Py_INCREF(Py_None);
-            return Py_None;
-        }
-#endif
-    }
-    Py_INCREF(op->func_doc);
-    return op->func_doc;
-}
-static int
-__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (value == NULL) {
-        value = Py_None;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_doc, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(op->func_name == NULL)) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-        op->func_name = PyObject_GetAttrString(op->func, "__name__");
-#elif PY_MAJOR_VERSION >= 3
-        op->func_name = PyUnicode_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
-#else
-        op->func_name = PyString_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
-#endif
-        if (unlikely(op->func_name == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_name);
-    return op->func_name;
-}
-static int
-__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__name__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_name, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(op->func_qualname);
-    return op->func_qualname;
-}
-static int
-__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__qualname__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_qualname, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(op->func_dict == NULL)) {
-        op->func_dict = PyDict_New();
-        if (unlikely(op->func_dict == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_dict);
-    return op->func_dict;
-}
-static int
-__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(value == NULL)) {
-        PyErr_SetString(PyExc_TypeError,
-               "function's dictionary may not be deleted");
-        return -1;
-    }
-    if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-               "setting function's dictionary to a non-dict");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_dict, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(op->func_globals);
-    return op->func_globals;
-}
-static PyObject *
-__Pyx_CyFunction_get_closure(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(op);
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-static PyObject *
-__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, void *context)
-{
-    PyObject* result = (op->func_code) ? op->func_code : Py_None;
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
-    int result = 0;
-    PyObject *res = op->defaults_getter((PyObject *) op);
-    if (unlikely(!res))
-        return -1;
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
-    Py_INCREF(op->defaults_tuple);
-    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
-    Py_INCREF(op->defaults_kwdict);
-    #else
-    op->defaults_tuple = __Pyx_PySequence_ITEM(res, 0);
-    if (unlikely(!op->defaults_tuple)) result = -1;
-    else {
-        op->defaults_kwdict = __Pyx_PySequence_ITEM(res, 1);
-        if (unlikely(!op->defaults_kwdict)) result = -1;
-    }
-    #endif
-    Py_DECREF(res);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value) {
-        value = Py_None;
-    } else if (unlikely(value != Py_None && !PyTuple_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__defaults__ must be set to a tuple object");
-        return -1;
-    }
-    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__defaults__ will not "
-                 "currently affect the values used in function calls", 1);
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->defaults_tuple, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->defaults_tuple;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
-            result = op->defaults_tuple;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value) {
-        value = Py_None;
-    } else if (unlikely(value != Py_None && !PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__kwdefaults__ must be set to a dict object");
-        return -1;
-    }
-    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__kwdefaults__ will not "
-                 "currently affect the values used in function calls", 1);
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->defaults_kwdict, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->defaults_kwdict;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
-            result = op->defaults_kwdict;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value || value == Py_None) {
-        value = NULL;
-    } else if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__annotations__ must be set to a dict object");
-        return -1;
-    }
-    Py_XINCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_annotations, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->func_annotations;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        result = PyDict_New();
-        if (unlikely(!result)) return NULL;
-        op->func_annotations = result;
-    }
-    Py_INCREF(result);
-    return result;
-}
-static PyObject *
-__Pyx_CyFunction_get_is_coroutine(__pyx_CyFunctionObject *op, void *context) {
-    int is_coroutine;
-    CYTHON_UNUSED_VAR(context);
-    if (op->func_is_coroutine) {
-        return __Pyx_NewRef(op->func_is_coroutine);
-    }
-    is_coroutine = op->flags & __Pyx_CYFUNCTION_COROUTINE;
-#if PY_VERSION_HEX >= 0x03050000
-    if (is_coroutine) {
-        PyObject *module, *fromlist, *marker = __pyx_n_s_is_coroutine;
-        fromlist = PyList_New(1);
-        if (unlikely(!fromlist)) return NULL;
-        Py_INCREF(marker);
-#if CYTHON_ASSUME_SAFE_MACROS
-        PyList_SET_ITEM(fromlist, 0, marker);
-#else
-        if (unlikely(PyList_SetItem(fromlist, 0, marker) < 0)) {
-            Py_DECREF(marker);
-            Py_DECREF(fromlist);
-            return NULL;
-        }
-#endif
-        module = PyImport_ImportModuleLevelObject(__pyx_n_s_asyncio_coroutines, NULL, NULL, fromlist, 0);
-        Py_DECREF(fromlist);
-        if (unlikely(!module)) goto ignore;
-        op->func_is_coroutine = __Pyx_PyObject_GetAttrStr(module, marker);
-        Py_DECREF(module);
-        if (likely(op->func_is_coroutine)) {
-            return __Pyx_NewRef(op->func_is_coroutine);
-        }
-ignore:
-        PyErr_Clear();
-    }
-#endif
-    op->func_is_coroutine = __Pyx_PyBool_FromLong(is_coroutine);
-    return __Pyx_NewRef(op->func_is_coroutine);
-}
-#if CYTHON_COMPILING_IN_LIMITED_API
-static PyObject *
-__Pyx_CyFunction_get_module(__pyx_CyFunctionObject *op, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    return PyObject_GetAttrString(op->func, "__module__");
-}
-static int
-__Pyx_CyFunction_set_module(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    return PyObject_SetAttrString(op->func, "__module__", value);
-}
-#endif
-static PyGetSetDef __pyx_CyFunction_getsets[] = {
-    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
-    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
-    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
-    {(char *) "_is_coroutine", (getter)__Pyx_CyFunction_get_is_coroutine, 0, 0, 0},
-#if CYTHON_COMPILING_IN_LIMITED_API
-    {"__module__", (getter)__Pyx_CyFunction_get_module, (setter)__Pyx_CyFunction_set_module, 0, 0},
-#endif
-    {0, 0, 0, 0, 0}
-};
-static PyMemberDef __pyx_CyFunction_members[] = {
-#if !CYTHON_COMPILING_IN_LIMITED_API
-    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), 0, 0},
-#endif
-#if CYTHON_USE_TYPE_SPECS
-    {(char *) "__dictoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_dict), READONLY, 0},
-#if CYTHON_METH_FASTCALL
-#if CYTHON_BACKPORT_VECTORCALL
-    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_vectorcall), READONLY, 0},
-#else
-#if !CYTHON_COMPILING_IN_LIMITED_API
-    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(PyCFunctionObject, vectorcall), READONLY, 0},
-#endif
-#endif
-#endif
-#if PY_VERSION_HEX < 0x030500A0 || CYTHON_COMPILING_IN_LIMITED_API
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_weakreflist), READONLY, 0},
-#else
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(PyCFunctionObject, m_weakreflist), READONLY, 0},
-#endif
-#endif
-    {0, 0, 0,  0, 0}
-};
-static PyObject *
-__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, PyObject *args)
-{
-    CYTHON_UNUSED_VAR(args);
-#if PY_MAJOR_VERSION >= 3
-    Py_INCREF(m->func_qualname);
-    return m->func_qualname;
-#else
-    return PyString_FromString(((PyCFunctionObject*)m)->m_ml->ml_name);
-#endif
-}
-static PyMethodDef __pyx_CyFunction_methods[] = {
-    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
-    {0, 0, 0, 0}
-};
-#if PY_VERSION_HEX < 0x030500A0 || CYTHON_COMPILING_IN_LIMITED_API
-#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
-#else
-#define __Pyx_CyFunction_weakreflist(cyfunc) (((PyCFunctionObject*)cyfunc)->m_weakreflist)
-#endif
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
-                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-#if !CYTHON_COMPILING_IN_LIMITED_API
-    PyCFunctionObject *cf = (PyCFunctionObject*) op;
-#endif
-    if (unlikely(op == NULL))
-        return NULL;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    op->func = PyCFunction_NewEx(ml, (PyObject*)op, module);
-    if (unlikely(!op->func)) return NULL;
-#endif
-    op->flags = flags;
-    __Pyx_CyFunction_weakreflist(op) = NULL;
-#if !CYTHON_COMPILING_IN_LIMITED_API
-    cf->m_ml = ml;
-    cf->m_self = (PyObject *) op;
-#endif
-    Py_XINCREF(closure);
-    op->func_closure = closure;
-#if !CYTHON_COMPILING_IN_LIMITED_API
-    Py_XINCREF(module);
-    cf->m_module = module;
-#endif
-    op->func_dict = NULL;
-    op->func_name = NULL;
-    Py_INCREF(qualname);
-    op->func_qualname = qualname;
-    op->func_doc = NULL;
-#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-    op->func_classobj = NULL;
-#else
-    ((PyCMethodObject*)op)->mm_class = NULL;
-#endif
-    op->func_globals = globals;
-    Py_INCREF(op->func_globals);
-    Py_XINCREF(code);
-    op->func_code = code;
-    op->defaults_pyobjects = 0;
-    op->defaults_size = 0;
-    op->defaults = NULL;
-    op->defaults_tuple = NULL;
-    op->defaults_kwdict = NULL;
-    op->defaults_getter = NULL;
-    op->func_annotations = NULL;
-    op->func_is_coroutine = NULL;
-#if CYTHON_METH_FASTCALL
-    switch (ml->ml_flags & (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS | METH_METHOD)) {
-    case METH_NOARGS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_NOARGS;
-        break;
-    case METH_O:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_O;
-        break;
-    case METH_METHOD | METH_FASTCALL | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD;
-        break;
-    case METH_FASTCALL | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS;
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = NULL;
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
-        Py_DECREF(op);
-        return NULL;
-    }
-#endif
-    return (PyObject *) op;
-}
-static int
-__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
-{
-    Py_CLEAR(m->func_closure);
-#if CYTHON_COMPILING_IN_LIMITED_API
-    Py_CLEAR(m->func);
-#else
-    Py_CLEAR(((PyCFunctionObject*)m)->m_module);
-#endif
-    Py_CLEAR(m->func_dict);
-    Py_CLEAR(m->func_name);
-    Py_CLEAR(m->func_qualname);
-    Py_CLEAR(m->func_doc);
-    Py_CLEAR(m->func_globals);
-    Py_CLEAR(m->func_code);
-#if !CYTHON_COMPILING_IN_LIMITED_API
-#if PY_VERSION_HEX < 0x030900B1
-    Py_CLEAR(__Pyx_CyFunction_GetClassObj(m));
-#else
-    {
-        PyObject *cls = (PyObject*) ((PyCMethodObject *) (m))->mm_class;
-        ((PyCMethodObject *) (m))->mm_class = NULL;
-        Py_XDECREF(cls);
-    }
-#endif
-#endif
-    Py_CLEAR(m->defaults_tuple);
-    Py_CLEAR(m->defaults_kwdict);
-    Py_CLEAR(m->func_annotations);
-    Py_CLEAR(m->func_is_coroutine);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_XDECREF(pydefaults[i]);
-        PyObject_Free(m->defaults);
-        m->defaults = NULL;
-    }
-    return 0;
-}
-static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    if (__Pyx_CyFunction_weakreflist(m) != NULL)
-        PyObject_ClearWeakRefs((PyObject *) m);
-    __Pyx_CyFunction_clear(m);
-    __Pyx_PyHeapTypeObject_GC_Del(m);
-}
-static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    PyObject_GC_UnTrack(m);
-    __Pyx__CyFunction_dealloc(m);
-}
-static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
-{
-    Py_VISIT(m->func_closure);
-#if CYTHON_COMPILING_IN_LIMITED_API
-    Py_VISIT(m->func);
-#else
-    Py_VISIT(((PyCFunctionObject*)m)->m_module);
-#endif
-    Py_VISIT(m->func_dict);
-    Py_VISIT(m->func_name);
-    Py_VISIT(m->func_qualname);
-    Py_VISIT(m->func_doc);
-    Py_VISIT(m->func_globals);
-    Py_VISIT(m->func_code);
-#if !CYTHON_COMPILING_IN_LIMITED_API
-    Py_VISIT(__Pyx_CyFunction_GetClassObj(m));
-#endif
-    Py_VISIT(m->defaults_tuple);
-    Py_VISIT(m->defaults_kwdict);
-    Py_VISIT(m->func_is_coroutine);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_VISIT(pydefaults[i]);
-    }
-    return 0;
-}
-static PyObject*
-__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
-{
-#if PY_MAJOR_VERSION >= 3
-    return PyUnicode_FromFormat("<cyfunction %U at %p>",
-                                op->func_qualname, (void *)op);
-#else
-    return PyString_FromFormat("<cyfunction %s at %p>",
-                               PyString_AsString(op->func_qualname), (void *)op);
-#endif
-}
-static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *f = ((__pyx_CyFunctionObject*)func)->func;
-    PyObject *py_name = NULL;
-    PyCFunction meth;
-    int flags;
-    meth = PyCFunction_GetFunction(f);
-    if (unlikely(!meth)) return NULL;
-    flags = PyCFunction_GetFlags(f);
-    if (unlikely(flags < 0)) return NULL;
-#else
-    PyCFunctionObject* f = (PyCFunctionObject*)func;
-    PyCFunction meth = f->m_ml->ml_meth;
-    int flags = f->m_ml->ml_flags;
-#endif
-    Py_ssize_t size;
-    switch (flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
-    case METH_VARARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0))
-            return (*meth)(self, arg);
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
-    case METH_NOARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-#if CYTHON_ASSUME_SAFE_MACROS
-            size = PyTuple_GET_SIZE(arg);
-#else
-            size = PyTuple_Size(arg);
-            if (unlikely(size < 0)) return NULL;
-#endif
-            if (likely(size == 0))
-                return (*meth)(self, NULL);
-#if CYTHON_COMPILING_IN_LIMITED_API
-            py_name = __Pyx_CyFunction_get_name((__pyx_CyFunctionObject*)func, NULL);
-            if (!py_name) return NULL;
-            PyErr_Format(PyExc_TypeError,
-                "%.200S() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                py_name, size);
-            Py_DECREF(py_name);
-#else
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-#endif
-            return NULL;
-        }
-        break;
-    case METH_O:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-#if CYTHON_ASSUME_SAFE_MACROS
-            size = PyTuple_GET_SIZE(arg);
-#else
-            size = PyTuple_Size(arg);
-            if (unlikely(size < 0)) return NULL;
-#endif
-            if (likely(size == 1)) {
-                PyObject *result, *arg0;
-                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-                arg0 = PyTuple_GET_ITEM(arg, 0);
-                #else
-                arg0 = __Pyx_PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
-                #endif
-                result = (*meth)(self, arg0);
-                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-                Py_DECREF(arg0);
-                #endif
-                return result;
-            }
-#if CYTHON_COMPILING_IN_LIMITED_API
-            py_name = __Pyx_CyFunction_get_name((__pyx_CyFunctionObject*)func, NULL);
-            if (!py_name) return NULL;
-            PyErr_Format(PyExc_TypeError,
-                "%.200S() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                py_name, size);
-            Py_DECREF(py_name);
-#else
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-#endif
-            return NULL;
-        }
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
-        return NULL;
-    }
-#if CYTHON_COMPILING_IN_LIMITED_API
-    py_name = __Pyx_CyFunction_get_name((__pyx_CyFunctionObject*)func, NULL);
-    if (!py_name) return NULL;
-    PyErr_Format(PyExc_TypeError, "%.200S() takes no keyword arguments",
-                 py_name);
-    Py_DECREF(py_name);
-#else
-    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
-                 f->m_ml->ml_name);
-#endif
-    return NULL;
-}
-static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *self, *result;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    self = PyCFunction_GetSelf(((__pyx_CyFunctionObject*)func)->func);
-    if (unlikely(!self) && PyErr_Occurred()) return NULL;
-#else
-    self = ((PyCFunctionObject*)func)->m_self;
-#endif
-    result = __Pyx_CyFunction_CallMethod(func, self, arg, kw);
-    return result;
-}
-static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
-    PyObject *result;
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
-#if CYTHON_METH_FASTCALL
-     __pyx_vectorcallfunc vc = __Pyx_CyFunction_func_vectorcall(cyfunc);
-    if (vc) {
-#if CYTHON_ASSUME_SAFE_MACROS
-        return __Pyx_PyVectorcall_FastCallDict(func, vc, &PyTuple_GET_ITEM(args, 0), (size_t)PyTuple_GET_SIZE(args), kw);
-#else
-        (void) &__Pyx_PyVectorcall_FastCallDict;
-        return PyVectorcall_Call(func, args, kw);
-#endif
-    }
-#endif
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        Py_ssize_t argc;
-        PyObject *new_args;
-        PyObject *self;
-#if CYTHON_ASSUME_SAFE_MACROS
-        argc = PyTuple_GET_SIZE(args);
-#else
-        argc = PyTuple_Size(args);
-        if (unlikely(!argc) < 0) return NULL;
-#endif
-        new_args = PyTuple_GetSlice(args, 1, argc);
-        if (unlikely(!new_args))
-            return NULL;
-        self = PyTuple_GetItem(args, 0);
-        if (unlikely(!self)) {
-            Py_DECREF(new_args);
-#if PY_MAJOR_VERSION > 2
-            PyErr_Format(PyExc_TypeError,
-                         "unbound method %.200S() needs an argument",
-                         cyfunc->func_qualname);
-#else
-            PyErr_SetString(PyExc_TypeError,
-                            "unbound method needs an argument");
-#endif
-            return NULL;
-        }
-        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
-        Py_DECREF(new_args);
-    } else {
-        result = __Pyx_CyFunction_Call(func, args, kw);
-    }
-    return result;
-}
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE int __Pyx_CyFunction_Vectorcall_CheckArgs(__pyx_CyFunctionObject *cyfunc, Py_ssize_t nargs, PyObject *kwnames)
-{
-    int ret = 0;
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        if (unlikely(nargs < 1)) {
-            PyErr_Format(PyExc_TypeError, "%.200s() needs an argument",
-                         ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
-            return -1;
-        }
-        ret = 1;
-    }
-    if (unlikely(kwnames) && unlikely(PyTuple_GET_SIZE(kwnames))) {
-        PyErr_Format(PyExc_TypeError,
-                     "%.200s() takes no keyword arguments", ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
-        return -1;
-    }
-    return ret;
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    if (unlikely(nargs != 0)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-            def->ml_name, nargs);
-        return NULL;
-    }
-    return def->ml_meth(self, NULL);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    if (unlikely(nargs != 1)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-            def->ml_name, nargs);
-        return NULL;
-    }
-    return def->ml_meth(self, args[0]);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-    PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    return ((__Pyx_PyCMethod)(void(*)(void))def->ml_meth)(self, cls, args, (size_t)nargs, kwnames);
-}
-#endif
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_CyFunctionType_slots[] = {
-    {Py_tp_dealloc, (void *)__Pyx_CyFunction_dealloc},
-    {Py_tp_repr, (void *)__Pyx_CyFunction_repr},
-    {Py_tp_call, (void *)__Pyx_CyFunction_CallAsMethod},
-    {Py_tp_traverse, (void *)__Pyx_CyFunction_traverse},
-    {Py_tp_clear, (void *)__Pyx_CyFunction_clear},
-    {Py_tp_methods, (void *)__pyx_CyFunction_methods},
-    {Py_tp_members, (void *)__pyx_CyFunction_members},
-    {Py_tp_getset, (void *)__pyx_CyFunction_getsets},
-    {Py_tp_descr_get, (void *)__Pyx_PyMethod_New},
-    {0, 0},
-};
-static PyType_Spec __pyx_CyFunctionType_spec = {
-    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
-    Py_TPFLAGS_METHOD_DESCRIPTOR |
-#endif
-#if (defined(_Py_TPFLAGS_HAVE_VECTORCALL) && CYTHON_METH_FASTCALL)
-    _Py_TPFLAGS_HAVE_VECTORCALL |
-#endif
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
-    __pyx_CyFunctionType_slots
-};
-#else
-static PyTypeObject __pyx_CyFunctionType_type = {
-    PyVarObject_HEAD_INIT(0, 0)
-    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-    (destructor) __Pyx_CyFunction_dealloc,
-#if !CYTHON_METH_FASTCALL
-    0,
-#elif CYTHON_BACKPORT_VECTORCALL
-    (printfunc)offsetof(__pyx_CyFunctionObject, func_vectorcall),
-#else
-    offsetof(PyCFunctionObject, vectorcall),
-#endif
-    0,
-    0,
-#if PY_MAJOR_VERSION < 3
-    0,
-#else
-    0,
-#endif
-    (reprfunc) __Pyx_CyFunction_repr,
-    0,
-    0,
-    0,
-    0,
-    __Pyx_CyFunction_CallAsMethod,
-    0,
-    0,
-    0,
-    0,
-#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
-    Py_TPFLAGS_METHOD_DESCRIPTOR |
-#endif
-#if defined(_Py_TPFLAGS_HAVE_VECTORCALL) && CYTHON_METH_FASTCALL
-    _Py_TPFLAGS_HAVE_VECTORCALL |
-#endif
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
-    0,
-    (traverseproc) __Pyx_CyFunction_traverse,
-    (inquiry) __Pyx_CyFunction_clear,
-    0,
-#if PY_VERSION_HEX < 0x030500A0
-    offsetof(__pyx_CyFunctionObject, func_weakreflist),
-#else
-    offsetof(PyCFunctionObject, m_weakreflist),
-#endif
-    0,
-    0,
-    __pyx_CyFunction_methods,
-    __pyx_CyFunction_members,
-    __pyx_CyFunction_getsets,
-    0,
-    0,
-    __Pyx_PyMethod_New,
-    0,
-    offsetof(__pyx_CyFunctionObject, func_dict),
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-#if PY_VERSION_HEX >= 0x030400a1
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-    0,
-#endif
-#if __PYX_NEED_TP_PRINT_SLOT
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030C0000
-    0,
-#endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-    0,
-#endif
-};
-#endif
-static int __pyx_CyFunction_init(PyObject *module) {
-#if CYTHON_USE_TYPE_SPECS
-    __pyx_CyFunctionType = __Pyx_FetchCommonTypeFromSpec(module, &__pyx_CyFunctionType_spec, NULL);
-#else
-    CYTHON_UNUSED_VAR(module);
-    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
-#endif
-    if (unlikely(__pyx_CyFunctionType == NULL)) {
-        return -1;
-    }
-    return 0;
-}
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults = PyObject_Malloc(size);
-    if (unlikely(!m->defaults))
-        return PyErr_NoMemory();
-    memset(m->defaults, 0, size);
-    m->defaults_pyobjects = pyobjects;
-    m->defaults_size = size;
-    return m->defaults;
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_tuple = tuple;
-    Py_INCREF(tuple);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_kwdict = dict;
-    Py_INCREF(dict);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->func_annotations = dict;
-    Py_INCREF(dict);
-}
-
-/* CythonFunction */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
-                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    PyObject *op = __Pyx_CyFunction_Init(
-        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
-        ml, flags, qualname, closure, module, globals, code
-    );
-    if (likely(op)) {
-        PyObject_GC_Track(op);
-    }
-    return op;
-}
-
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
+static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
-    CYTHON_MAYBE_UNUSED_VAR(tstate);
     if (unlikely(!__pyx_cython_runtime)) {
         return c_line;
     }
     __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
 #if CYTHON_COMPILING_IN_CPYTHON
     cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
     if (likely(cython_runtime_dict)) {
         __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
             use_cline, *cython_runtime_dict,
             __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
     } else
 #endif
     {
-      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStrNoError(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
+      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
       if (use_cline_obj) {
         use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
         Py_DECREF(use_cline_obj);
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
@@ -18527,15 +12958,14 @@
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
 #endif
 
 /* CodeObjectCache */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
     int start = 0, mid = 0, end = count - 1;
     if (end >= 0 && code_line > entries[end].code_line) {
         return count;
     }
     while (start < end) {
         mid = start + (end - start) / 2;
@@ -18606,109 +13036,19 @@
         entries[i] = entries[i-1];
     }
     entries[pos].code_line = code_line;
     entries[pos].code_object = code_object;
     __pyx_code_cache.count++;
     Py_INCREF(code_object);
 }
-#endif
 
 /* AddTraceback */
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6 && !CYTHON_COMPILING_IN_LIMITED_API
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-static PyObject *__Pyx_PyCode_Replace_For_AddTraceback(PyObject *code, PyObject *scratch_dict,
-                                                       PyObject *firstlineno, PyObject *name) {
-    PyObject *replace = NULL;
-    if (unlikely(PyDict_SetItemString(scratch_dict, "co_firstlineno", firstlineno))) return NULL;
-    if (unlikely(PyDict_SetItemString(scratch_dict, "co_name", name))) return NULL;
-    replace = PyObject_GetAttrString(code, "replace");
-    if (likely(replace)) {
-        PyObject *result;
-        result = PyObject_Call(replace, __pyx_empty_tuple, scratch_dict);
-        Py_DECREF(replace);
-        return result;
-    }
-    PyErr_Clear();
-    #if __PYX_LIMITED_VERSION_HEX < 0x030780000
-    {
-        PyObject *compiled = NULL, *result = NULL;
-        if (unlikely(PyDict_SetItemString(scratch_dict, "code", code))) return NULL;
-        if (unlikely(PyDict_SetItemString(scratch_dict, "type", (PyObject*)(&PyType_Type)))) return NULL;
-        compiled = Py_CompileString(
-            "out = type(code)(\n"
-            "  code.co_argcount, code.co_kwonlyargcount, code.co_nlocals, code.co_stacksize,\n"
-            "  code.co_flags, code.co_code, code.co_consts, code.co_names,\n"
-            "  code.co_varnames, code.co_filename, co_name, co_firstlineno,\n"
-            "  code.co_lnotab)\n", "<dummy>", Py_file_input);
-        if (!compiled) return NULL;
-        result = PyEval_EvalCode(compiled, scratch_dict, scratch_dict);
-        Py_DECREF(compiled);
-        if (!result) PyErr_Print();
-        Py_DECREF(result);
-        result = PyDict_GetItemString(scratch_dict, "out");
-        if (result) Py_INCREF(result);
-        return result;
-    }
-    #else
-    return NULL;
-    #endif
-}
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename) {
-    PyObject *code_object = NULL, *py_py_line = NULL, *py_funcname = NULL, *dict = NULL;
-    PyObject *replace = NULL, *getframe = NULL, *frame = NULL;
-    PyObject *exc_type, *exc_value, *exc_traceback;
-    int success = 0;
-    if (c_line) {
-        (void) __pyx_cfilenm;
-        (void) __Pyx_CLineForTraceback(__Pyx_PyThreadState_Current, c_line);
-    }
-    PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
-    code_object = Py_CompileString("_getframe()", filename, Py_eval_input);
-    if (unlikely(!code_object)) goto bad;
-    py_py_line = PyLong_FromLong(py_line);
-    if (unlikely(!py_py_line)) goto bad;
-    py_funcname = PyUnicode_FromString(funcname);
-    if (unlikely(!py_funcname)) goto bad;
-    dict = PyDict_New();
-    if (unlikely(!dict)) goto bad;
-    {
-        PyObject *old_code_object = code_object;
-        code_object = __Pyx_PyCode_Replace_For_AddTraceback(code_object, dict, py_py_line, py_funcname);
-        Py_DECREF(old_code_object);
-    }
-    if (unlikely(!code_object)) goto bad;
-    getframe = PySys_GetObject("_getframe");
-    if (unlikely(!getframe)) goto bad;
-    if (unlikely(PyDict_SetItemString(dict, "_getframe", getframe))) goto bad;
-    frame = PyEval_EvalCode(code_object, dict, dict);
-    if (unlikely(!frame) || frame == Py_None) goto bad;
-    success = 1;
-  bad:
-    PyErr_Restore(exc_type, exc_value, exc_traceback);
-    Py_XDECREF(code_object);
-    Py_XDECREF(py_py_line);
-    Py_XDECREF(py_funcname);
-    Py_XDECREF(dict);
-    Py_XDECREF(replace);
-    if (success) {
-        PyTraceBack_Here(
-            (struct _frame*)frame);
-    }
-    Py_XDECREF(frame);
-}
-#else
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
     PyCodeObject *py_code = NULL;
     PyObject *py_funcname = NULL;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_srcfile = NULL;
@@ -18735,15 +13075,14 @@
     #if PY_MAJOR_VERSION < 3
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
-        0,
         __pyx_empty_bytes, /*PyObject *code,*/
         __pyx_empty_tuple, /*PyObject *consts,*/
         __pyx_empty_tuple, /*PyObject *names,*/
         __pyx_empty_tuple, /*PyObject *varnames,*/
         __pyx_empty_tuple, /*PyObject *freevars,*/
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
@@ -18751,46 +13090,36 @@
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
     #else
     py_code = PyCode_NewEmpty(filename, funcname, py_line);
     #endif
-    Py_XDECREF(py_funcname);
+    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
     return py_code;
 bad:
     Py_XDECREF(py_funcname);
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_srcfile);
     #endif
     return NULL;
 }
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyFrameObject *py_frame = 0;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject *ptype, *pvalue, *ptraceback;
     if (c_line) {
         c_line = __Pyx_CLineForTraceback(tstate, c_line);
     }
     py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
     if (!py_code) {
-        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
         py_code = __Pyx_CreateCodeObjectForTraceback(
             funcname, c_line, py_line, filename);
-        if (!py_code) {
-            /* If the code object creation fails, then we should clear the
-               fetched exception references and propagate the new exception */
-            Py_XDECREF(ptype);
-            Py_XDECREF(pvalue);
-            Py_XDECREF(ptraceback);
-            goto bad;
-        }
-        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+        if (!py_code) goto bad;
         __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
     }
     py_frame = PyFrame_New(
         tstate,            /*PyThreadState *tstate,*/
         py_code,           /*PyCodeObject *code,*/
         __pyx_d,    /*PyObject *globals,*/
         0                  /*PyObject *locals*/
@@ -18798,15 +13127,14 @@
     if (!py_frame) goto bad;
     __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
     PyTraceBack_Here(py_frame);
 bad:
     Py_XDECREF(py_code);
     Py_XDECREF(py_frame);
 }
-#endif
 
 /* CIntFromPyVerify */
 #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
 #define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
 #define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
@@ -18835,254 +13163,177 @@
     const int neg_one = (int) -1, const_zero = (int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(int) < sizeof(long))) {
+        if (sizeof(int) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 2 * PyLong_SHIFT)) {
-                                return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
+                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 3 * PyLong_SHIFT)) {
-                                return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
+                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 4 * PyLong_SHIFT)) {
-                                return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
+                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(int) <= sizeof(unsigned long))) {
+            if (sizeof(int) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(int) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(int) <= sizeof(long))) {
+            if (sizeof(int) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (int) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (int) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (int) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (int) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (int) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(int) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((int) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(int) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((int) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((int) 1) << (sizeof(int) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (int) -1;
         }
     } else {
         int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (int) -1;
         val = __Pyx_PyInt_As_int(tmp);
@@ -19128,42 +13379,16 @@
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
         return _PyLong_FromByteArray(bytes, sizeof(unsigned PY_LONG_LONG),
                                      little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(unsigned PY_LONG_LONG));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
     }
 }
 
 /* CIntFromPy */
 static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_As_unsigned_PY_LONG_LONG(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
@@ -19172,254 +13397,177 @@
     const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG) -1, const_zero = (unsigned PY_LONG_LONG) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(unsigned PY_LONG_LONG) < sizeof(long))) {
+        if (sizeof(unsigned PY_LONG_LONG) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (unsigned PY_LONG_LONG) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) >= 2 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned PY_LONG_LONG) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 2 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) >= 3 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 3 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) >= 4 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 4 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (unsigned PY_LONG_LONG) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned long))) {
+            if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned PY_LONG_LONG) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) ((((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) ((((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) ((((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) ((((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned PY_LONG_LONG) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned PY_LONG_LONG) ((((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned PY_LONG_LONG) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned PY_LONG_LONG) ((((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(unsigned PY_LONG_LONG) <= sizeof(long))) {
+            if (sizeof(unsigned PY_LONG_LONG) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned PY_LONG_LONG) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             unsigned PY_LONG_LONG val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (unsigned PY_LONG_LONG) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (unsigned PY_LONG_LONG) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (unsigned PY_LONG_LONG) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (unsigned PY_LONG_LONG) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (unsigned PY_LONG_LONG) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(unsigned PY_LONG_LONG) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((unsigned PY_LONG_LONG) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(unsigned PY_LONG_LONG) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((unsigned PY_LONG_LONG) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((unsigned PY_LONG_LONG) 1) << (sizeof(unsigned PY_LONG_LONG) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (unsigned PY_LONG_LONG) -1;
         }
     } else {
         unsigned PY_LONG_LONG val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (unsigned PY_LONG_LONG) -1;
         val = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(tmp);
@@ -19465,42 +13613,16 @@
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
         return _PyLong_FromByteArray(bytes, sizeof(int),
                                      little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(int));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
     }
 }
 
 /* CIntFromPy */
 static CYTHON_INLINE int64_t __Pyx_PyInt_As_int64_t(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
@@ -19509,254 +13631,177 @@
     const int64_t neg_one = (int64_t) -1, const_zero = (int64_t) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(int64_t) < sizeof(long))) {
+        if (sizeof(int64_t) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(int64_t, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (int64_t) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int64_t, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(int64_t) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) >= 2 * PyLong_SHIFT)) {
-                                return (int64_t) (((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int64_t) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(int64_t, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(int64_t) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) >= 2 * PyLong_SHIFT) {
+                            return (int64_t) (((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int64_t) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) >= 3 * PyLong_SHIFT)) {
-                                return (int64_t) (((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int64_t) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) >= 3 * PyLong_SHIFT) {
+                            return (int64_t) (((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int64_t) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) >= 4 * PyLong_SHIFT)) {
-                                return (int64_t) (((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int64_t) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) >= 4 * PyLong_SHIFT) {
+                            return (int64_t) (((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (int64_t) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(int64_t) <= sizeof(unsigned long))) {
+            if (sizeof(int64_t) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int64_t, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int64_t) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(int64_t) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int64_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int64_t, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(int64_t) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int64_t) (((int64_t)-1)*(((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int64_t) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(int64_t, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(int64_t,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(int64_t) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
+                            return (int64_t) (((int64_t)-1)*(((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(int64_t) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int64_t) ((((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(int64_t) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
+                            return (int64_t) ((((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int64_t) (((int64_t)-1)*(((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
+                            return (int64_t) (((int64_t)-1)*(((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int64_t) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int64_t) ((((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int64_t) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
+                            return (int64_t) ((((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int64_t) (((int64_t)-1)*(((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT) {
+                            return (int64_t) (((int64_t)-1)*(((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int64_t) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int64_t) ((((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int64_t) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT) {
+                            return (int64_t) ((((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(int64_t) <= sizeof(long))) {
+            if (sizeof(int64_t) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int64_t, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int64_t) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(int64_t) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int64_t, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             int64_t val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (int64_t) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (int64_t) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (int64_t) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (int64_t) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (int64_t) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(int64_t) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((int64_t) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(int64_t) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((int64_t) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((int64_t) 1) << (sizeof(int64_t) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (int64_t) -1;
         }
     } else {
         int64_t val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (int64_t) -1;
         val = __Pyx_PyInt_As_int64_t(tmp);
@@ -19802,42 +13847,16 @@
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
         return _PyLong_FromByteArray(bytes, sizeof(long),
                                      little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(long));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
     }
 }
 
 /* CIntToPy */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int64_t(int64_t value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
@@ -19866,42 +13885,16 @@
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
         return _PyLong_FromByteArray(bytes, sizeof(int64_t),
                                      little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(int64_t));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
     }
 }
 
 /* CIntToPy */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
@@ -19930,314 +13923,195 @@
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
         return _PyLong_FromByteArray(bytes, sizeof(int32_t),
                                      little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(int32_t));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
-    }
-}
-
-/* FormatTypeName */
-#if CYTHON_COMPILING_IN_LIMITED_API
-static __Pyx_TypeName
-__Pyx_PyType_GetName(PyTypeObject* tp)
-{
-    PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
-                                               __pyx_n_s_name);
-    if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
-        PyErr_Clear();
-        Py_XDECREF(name);
-        name = __Pyx_NewRef(__pyx_n_s__39);
     }
-    return name;
 }
-#endif
 
 /* CIntFromPy */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(long) < sizeof(long))) {
+        if (sizeof(long) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (long) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 2 * PyLong_SHIFT)) {
-                                return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
+                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 3 * PyLong_SHIFT)) {
-                                return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
+                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 4 * PyLong_SHIFT)) {
-                                return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
+                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (long) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(long) <= sizeof(unsigned long))) {
+            if (sizeof(long) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(long) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(long) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(long) <= sizeof(long))) {
+            if (sizeof(long) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(long) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             long val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (long) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (long) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (long) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (long) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (long) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(long) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((long) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(long) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((long) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((long) 1) << (sizeof(long) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (long) -1;
         }
     } else {
         long val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (long) -1;
         val = __Pyx_PyInt_As_long(tmp);
@@ -20254,15 +14128,15 @@
     return (long) -1;
 }
 
 /* FastTypeChecks */
 #if CYTHON_COMPILING_IN_CPYTHON
 static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
     while (a) {
-        a = __Pyx_PyType_GetSlot(a, tp_base, PyTypeObject*);
+        a = a->tp_base;
         if (a == b)
             return 1;
     }
     return b == &PyBaseObject_Type;
 }
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
     PyObject *mro;
@@ -20275,30 +14149,14 @@
             if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                 return 1;
         }
         return 0;
     }
     return __Pyx_InBases(a, b);
 }
-static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b) {
-    PyObject *mro;
-    if (cls == a || cls == b) return 1;
-    mro = cls->tp_mro;
-    if (likely(mro)) {
-        Py_ssize_t i, n;
-        n = PyTuple_GET_SIZE(mro);
-        for (i = 0; i < n; i++) {
-            PyObject *base = PyTuple_GET_ITEM(mro, i);
-            if (base == (PyObject *)a || base == (PyObject *)b)
-                return 1;
-        }
-        return 0;
-    }
-    return __Pyx_InBases(cls, a) || __Pyx_InBases(cls, b);
-}
 #if PY_MAJOR_VERSION == 2
 static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
     PyObject *exception, *value, *tb;
     int res;
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ErrFetch(&exception, &value, &tb);
@@ -20315,19 +14173,19 @@
         }
     }
     __Pyx_ErrRestore(exception, value, tb);
     return res;
 }
 #else
 static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
-    if (exc_type1) {
-        return __Pyx_IsAnySubtype2((PyTypeObject*)err, (PyTypeObject*)exc_type1, (PyTypeObject*)exc_type2);
-    } else {
-        return __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
+    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
+    if (!res) {
+        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
     }
+    return res;
 }
 #endif
 static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
     Py_ssize_t i, n;
     assert(PyExceptionClass_Check(exc_type));
     n = PyTuple_GET_SIZE(tuple);
 #if PY_MAJOR_VERSION >= 3
@@ -20367,121 +14225,64 @@
         return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
     }
     return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
 }
 #endif
 
 /* CheckBinaryVersion */
-static unsigned long __Pyx_get_runtime_version(void) {
-#if __PYX_LIMITED_VERSION_HEX >= 0x030B00A4
-    return Py_Version & ~0xFFUL;
-#else
-    const char* rt_version = Py_GetVersion();
-    unsigned long version = 0;
-    unsigned long factor = 0x01000000UL;
-    unsigned int digit = 0;
-    int i = 0;
-    while (factor) {
-        while ('0' <= rt_version[i] && rt_version[i] <= '9') {
-            digit = digit * 10 + (unsigned int) (rt_version[i] - '0');
-            ++i;
-        }
-        version += factor * digit;
-        if (rt_version[i] != '.')
-            break;
-        digit = 0;
-        factor >>= 8;
-        ++i;
-    }
-    return version;
-#endif
-}
-static int __Pyx_check_binary_version(unsigned long ct_version, unsigned long rt_version, int allow_newer) {
-    const unsigned long MAJOR_MINOR = 0xFFFF0000UL;
-    if ((rt_version & MAJOR_MINOR) == (ct_version & MAJOR_MINOR))
-        return 0;
-    if (likely(allow_newer && (rt_version & MAJOR_MINOR) > (ct_version & MAJOR_MINOR)))
-        return 1;
-    {
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
         PyOS_snprintf(message, sizeof(message),
-                      "compile time Python version %d.%d "
-                      "of module '%.100s' "
-                      "%s "
-                      "runtime version %d.%d",
-                       (int) (ct_version >> 24), (int) ((ct_version >> 16) & 0xFF),
-                       __Pyx_MODULE_NAME,
-                       (allow_newer) ? "was newer than" : "does not match",
-                       (int) (rt_version >> 24), (int) ((rt_version >> 16) & 0xFF)
-       );
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
         return PyErr_WarnEx(NULL, message, 1);
     }
+    return 0;
 }
 
 /* InitStrings */
-#if PY_MAJOR_VERSION >= 3
-static int __Pyx_InitString(__Pyx_StringTabEntry t, PyObject **str) {
-    if (t.is_unicode | t.is_str) {
-        if (t.intern) {
-            *str = PyUnicode_InternFromString(t.s);
-        } else if (t.encoding) {
-            *str = PyUnicode_Decode(t.s, t.n - 1, t.encoding, NULL);
-        } else {
-            *str = PyUnicode_FromStringAndSize(t.s, t.n - 1);
-        }
-    } else {
-        *str = PyBytes_FromStringAndSize(t.s, t.n - 1);
-    }
-    if (!*str)
-        return -1;
-    if (PyObject_Hash(*str) == -1)
-        return -1;
-    return 0;
-}
-#endif
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
-        #if PY_MAJOR_VERSION >= 3
-        __Pyx_InitString(*t, t->p);
-        #else
+        #if PY_MAJOR_VERSION < 3
         if (t->is_unicode) {
             *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
         } else if (t->intern) {
             *t->p = PyString_InternFromString(t->s);
         } else {
             *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
         }
+        #else
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
         if (!*t->p)
             return -1;
         if (PyObject_Hash(*t->p) == -1)
             return -1;
-        #endif
         ++t;
     }
     return 0;
 }
 
-#include <string.h>
-static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s) {
-    size_t len = strlen(s);
-    if (unlikely(len > (size_t) PY_SSIZE_T_MAX)) {
-        PyErr_SetString(PyExc_OverflowError, "byte string is too long");
-        return -1;
-    }
-    return (Py_ssize_t) len;
-}
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
-    Py_ssize_t len = __Pyx_ssize_strlen(c_str);
-    if (unlikely(len < 0)) return NULL;
-    return __Pyx_PyUnicode_FromStringAndSize(c_str, len);
-}
-static CYTHON_INLINE PyObject* __Pyx_PyByteArray_FromString(const char* c_str) {
-    Py_ssize_t len = __Pyx_ssize_strlen(c_str);
-    if (unlikely(len < 0)) return NULL;
-    return PyByteArray_FromStringAndSize(c_str, len);
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
 }
 static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
     Py_ssize_t ignore;
     return __Pyx_PyObject_AsStringAndSize(o, &ignore);
 }
 #if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
 #if !CYTHON_PEP393_ENABLED
@@ -20528,15 +14329,15 @@
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
             __Pyx_sys_getdefaultencoding_not_ascii &&
 #endif
             PyUnicode_Check(o)) {
         return __Pyx_PyUnicode_AsStringAndSize(o, length);
     } else
 #endif
-#if (!CYTHON_COMPILING_IN_PYPY && !CYTHON_COMPILING_IN_LIMITED_API) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
+#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
     if (PyByteArray_Check(o)) {
         *length = PyByteArray_GET_SIZE(o);
         return PyByteArray_AS_STRING(o);
     } else
 #endif
     {
         char* result;
@@ -20557,34 +14358,30 @@
     int retval;
     if (unlikely(!x)) return -1;
     retval = __Pyx_PyObject_IsTrue(x);
     Py_DECREF(x);
     return retval;
 }
 static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
-    __Pyx_TypeName result_type_name = __Pyx_PyType_GetName(Py_TYPE(result));
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(result)) {
         if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
-                "__int__ returned non-int (type " __Pyx_FMT_TYPENAME ").  "
-                "The ability to return an instance of a strict subclass of int is deprecated, "
-                "and may be removed in a future version of Python.",
-                result_type_name)) {
-            __Pyx_DECREF_TypeName(result_type_name);
+                "__int__ returned non-int (type %.200s).  "
+                "The ability to return an instance of a strict subclass of int "
+                "is deprecated, and may be removed in a future version of Python.",
+                Py_TYPE(result)->tp_name)) {
             Py_DECREF(result);
             return NULL;
         }
-        __Pyx_DECREF_TypeName(result_type_name);
         return result;
     }
 #endif
     PyErr_Format(PyExc_TypeError,
-                 "__%.4s__ returned non-%.4s (type " __Pyx_FMT_TYPENAME ")",
-                 type_name, type_name, result_type_name);
-    __Pyx_DECREF_TypeName(result_type_name);
+                 "__%.4s__ returned non-%.4s (type %.200s)",
+                 type_name, type_name, Py_TYPE(result)->tp_name);
     Py_DECREF(result);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
 #if CYTHON_USE_TYPE_SLOTS
   PyNumberMethods *m;
 #endif
@@ -20642,19 +14439,21 @@
         return PyInt_AS_LONG(b);
     else
         return PyInt_AsSsize_t(b);
   }
 #endif
   if (likely(PyLong_CheckExact(b))) {
     #if CYTHON_USE_PYLONG_INTERNALS
-    if (likely(__Pyx_PyLong_IsCompact(b))) {
-        return __Pyx_PyLong_CompactValue(b);
+    const digit* digits = ((PyLongObject*)b)->ob_digit;
+    const Py_ssize_t size = Py_SIZE(b);
+    if (likely(__Pyx_sst_abs(size) <= 1)) {
+        ival = likely(size) ? digits[0] : 0;
+        if (size == -1) ival = -ival;
+        return ival;
     } else {
-      const digit* digits = __Pyx_PyLong_Digits(b);
-      const Py_ssize_t size = __Pyx_PyLong_SignedDigitCount(b);
       switch (size) {
          case 2:
            if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
              return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
            }
            break;
          case -2:
@@ -20714,16 +14513,8 @@
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
 
 
-/* #### Code section: utility_code_pragmas_end ### */
-#ifdef _MSC_VER
-#pragma warning( pop )
-#endif
-
-
-
-/* #### Code section: end ### */
 #endif /* Py_PYTHON_H */
```

## dgl/backend/pytorch/tensor.py

```diff
@@ -8,16 +8,16 @@
 import torch as th
 from torch.utils import dlpack
 
 from ... import ndarray as nd
 from ...function.base import TargetCode
 from ...utils import version
 
-if version.parse(th.__version__) < version.parse("1.13.0"):
-    raise RuntimeError("DGL requires PyTorch >= 1.13.0")
+if version.parse(th.__version__) < version.parse("2.0.0"):
+    raise RuntimeError("DGL requires PyTorch >= 2.0.0")
 
 
 def data_type_dict():
     return {
         "bfloat16": th.bfloat16,
         "float16": th.float16,
         "float32": th.float32,
```

## dgl/data/tu.py

```diff
@@ -345,15 +345,15 @@
     Examples
     --------
     >>> data = TUDataset('DD')
 
     The dataset instance is an iterable
 
     >>> len(data)
-    188
+    1178
     >>> g, label = data[1024]
     >>> g
     Graph(num_nodes=88, num_edges=410,
           ndata_schemes={'_ID': Scheme(shape=(), dtype=torch.int64), 'node_labels': Scheme(shape=(1,), dtype=torch.int64)}
           edata_schemes={'_ID': Scheme(shape=(), dtype=torch.int64)})
     >>> label
     tensor([1])
```

## dgl/distributed/dist_tensor.py

```diff
@@ -1,18 +1,17 @@
 """Define distributed tensor."""
 
 import os
 
-from .. import backend as F
+from .. import backend as F, utils
 
 from .dist_context import is_initialized
 from .kvstore import get_kvstore
 from .role import get_role
 from .rpc import get_group_id
-from .utils import totensor
 
 
 def _default_init_data(shape, dtype):
     return F.zeros(shape, dtype, F.cpu())
 
 
 # These IDs can identify the anonymous distributed tensors.
@@ -197,19 +196,21 @@
             os.environ.get("DGL_DIST_MODE", "standalone") == "standalone"
             or is_initialized()
         )
         if not self._persistent and self._owner and initialized:
             self.kvstore.delete_data(self._name)
 
     def __getitem__(self, idx):
-        idx = totensor(idx)
+        idx = utils.toindex(idx)
+        idx = idx.tousertensor()
         return self.kvstore.pull(name=self._name, id_tensor=idx)
 
     def __setitem__(self, idx, val):
-        idx = totensor(idx)
+        idx = utils.toindex(idx)
+        idx = idx.tousertensor()
         # TODO(zhengda) how do we want to support broadcast (e.g., G.ndata['h'][idx] = 1).
         self.kvstore.push(name=self._name, id_tensor=idx, data_tensor=val)
 
     @property
     def kvstore_key(self):
         """Return the key string of this DistTensor in the associated KVStore."""
         return self._name
```

## dgl/distributed/graph_partition_book.py

```diff
@@ -1,16 +1,15 @@
 """Define graph partition book."""
 
 import pickle
 from abc import ABC
 
 import numpy as np
-import torch
 
-from .. import backend as F
+from .. import backend as F, utils
 from .._ffi.ndarray import empty_shared_mem
 from ..base import DGLError
 from ..ndarray import exist_shared_mem_array
 from ..partition import NDArrayPartition
 from .constants import DEFAULT_ETYPE, DEFAULT_NTYPE
 from .id_map import IdMap
 from .shared_mem_utils import (
@@ -758,59 +757,65 @@
         Returns
             type_ids, per_type_ids
         """
         return self._eid_map(ids)
 
     def map_to_homo_nid(self, ids, ntype):
         """Map per-node-type IDs to global node IDs in the homogeneous format."""
+        ids = utils.toindex(ids).tousertensor()
         partids = self.nid2partid(ids, ntype)
         typed_max_nids = F.zerocopy_from_numpy(self._typed_max_node_ids[ntype])
         end_diff = F.gather_row(typed_max_nids, partids) - ids
         typed_nid_range = F.zerocopy_from_numpy(
             self._typed_nid_range[ntype][:, 1]
         )
         return F.gather_row(typed_nid_range, partids) - end_diff
 
     def map_to_homo_eid(self, ids, etype):
         """Map per-edge-type IDs to global edge IDs in the homoenegeous format."""
+        ids = utils.toindex(ids).tousertensor()
         c_etype = self.to_canonical_etype(etype)
         partids = self.eid2partid(ids, c_etype)
         typed_max_eids = F.zerocopy_from_numpy(
             self._typed_max_edge_ids[c_etype]
         )
         end_diff = F.gather_row(typed_max_eids, partids) - ids
         typed_eid_range = F.zerocopy_from_numpy(
             self._typed_eid_range[c_etype][:, 1]
         )
         return F.gather_row(typed_eid_range, partids) - end_diff
 
     def nid2partid(self, nids, ntype=DEFAULT_NTYPE):
         """From global node IDs to partition IDs"""
-        # [TODO][Rui] replace numpy with torch.
-        nids = nids.numpy()
+        nids = utils.toindex(nids)
         if ntype == DEFAULT_NTYPE:
-            ret = np.searchsorted(self._max_node_ids, nids, side="right")
+            ret = np.searchsorted(
+                self._max_node_ids, nids.tonumpy(), side="right"
+            )
         else:
             ret = np.searchsorted(
-                self._typed_max_node_ids[ntype], nids, side="right"
+                self._typed_max_node_ids[ntype], nids.tonumpy(), side="right"
             )
-        return torch.from_numpy(ret)
+        ret = utils.toindex(ret)
+        return ret.tousertensor()
 
     def eid2partid(self, eids, etype=DEFAULT_ETYPE):
         """From global edge IDs to partition IDs"""
-        # [TODO][Rui] replace numpy with torch.
-        eids = eids.numpy()
+        eids = utils.toindex(eids)
         if etype in (DEFAULT_ETYPE, DEFAULT_ETYPE[1]):
-            ret = np.searchsorted(self._max_edge_ids, eids, side="right")
+            ret = np.searchsorted(
+                self._max_edge_ids, eids.tonumpy(), side="right"
+            )
         else:
             c_etype = self.to_canonical_etype(etype)
             ret = np.searchsorted(
-                self._typed_max_edge_ids[c_etype], eids, side="right"
+                self._typed_max_edge_ids[c_etype], eids.tonumpy(), side="right"
             )
-        return torch.from_numpy(ret)
+        ret = utils.toindex(ret)
+        return ret.tousertensor()
 
     def partid2nids(self, partid, ntype=DEFAULT_NTYPE):
         """From partition ID to global node IDs"""
         # TODO do we need to cache it?
         if ntype == DEFAULT_NTYPE:
             start = self._max_node_ids[partid - 1] if partid > 0 else 0
             end = self._max_node_ids[partid]
@@ -843,14 +848,16 @@
         """Get local node IDs within the given partition."""
         if partid != self._partid:
             raise RuntimeError(
                 "Now RangePartitionBook does not support \
                 getting remote tensor of nid2localnid."
             )
 
+        nids = utils.toindex(nids)
+        nids = nids.tousertensor()
         if ntype == DEFAULT_NTYPE:
             start = self._max_node_ids[partid - 1] if partid > 0 else 0
         else:
             start = (
                 self._typed_max_node_ids[ntype][partid - 1] if partid > 0 else 0
             )
         return nids - int(start)
@@ -859,14 +866,16 @@
         """Get the local edge IDs within the given partition."""
         if partid != self._partid:
             raise RuntimeError(
                 "Now RangePartitionBook does not support \
                 getting remote tensor of eid2localeid."
             )
 
+        eids = utils.toindex(eids)
+        eids = eids.tousertensor()
         if etype in (DEFAULT_ETYPE, DEFAULT_ETYPE[1]):
             start = self._max_edge_ids[partid - 1] if partid > 0 else 0
         else:
             c_etype = self.to_canonical_etype(etype)
             start = (
                 self._typed_max_edge_ids[c_etype][partid - 1]
                 if partid > 0
```

## dgl/distributed/graph_services.py

```diff
@@ -10,14 +10,15 @@
 from ..base import EID, ETYPE, NID
 from ..convert import graph, heterograph
 from ..sampling import (
     sample_etype_neighbors as local_sample_etype_neighbors,
     sample_neighbors as local_sample_neighbors,
 )
 from ..subgraph import in_subgraph as local_in_subgraph
+from ..utils import toindex
 from .rpc import (
     recv_responses,
     register_service,
     Request,
     Response,
     send_requests_to_machine,
 )
@@ -125,33 +126,32 @@
     # 1. Map global node IDs to local node IDs.
     nodes = gpb.nid2localnid(nodes, gpb.partid)
     # Local partition may be saved in torch.int32 even though the global graph
     # is in torch.int64.
     nodes = nodes.to(dtype=g.indices.dtype)
 
     # 2. Perform sampling.
-    # [Rui][TODO] `prob` and `replace` are not tested yet. Skip for now.
+    # [Rui][TODO] `prob` is not tested yet. Skip for now.
     assert (
         prob is None
     ), "DistGraphBolt does not support sampling with probability."
-    assert (
-        not replace
-    ), "DistGraphBolt does not support sampling with replacement."
 
     # Sanity checks.
     assert isinstance(
         g, gb.FusedCSCSamplingGraph
     ), "Expect a FusedCSCSamplingGraph."
     assert isinstance(nodes, torch.Tensor), "Expect a tensor of nodes."
     if isinstance(fanout, int):
         fanout = torch.LongTensor([fanout])
     assert isinstance(fanout, torch.Tensor), "Expect a tensor of fanout."
 
     return_eids = g.edge_attributes is not None and EID in g.edge_attributes
-    subgraph = g._sample_neighbors(nodes, fanout, return_eids=return_eids)
+    subgraph = g._sample_neighbors(
+        nodes, None, fanout, replace=replace, return_eids=return_eids
+    )
 
     # 3. Map local node IDs to global node IDs.
     local_src = subgraph.indices
     local_dst = gb.expand_indptr(
         subgraph.indptr,
         dtype=local_src.dtype,
         node_ids=subgraph.original_column_node_ids,
@@ -703,14 +703,16 @@
     Returns
     -------
     DGLGraph
         The subgraph that contains the neighborhoods of all input nodes.
     """
     req_list = []
     partition_book = g.get_partition_book()
+    if not isinstance(nodes, torch.Tensor):
+        nodes = toindex(nodes).tousertensor()
     partition_id = partition_book.nid2partid(nodes)
     local_nids = None
     for pid in range(partition_book.num_partitions()):
         node_id = F.boolean_mask(nodes, partition_id == pid)
         # We optimize the sampling on a local partition if the server and the client
         # run on the same machine. With a good partitioning, most of the seed nodes
         # should reside in the local partition. If the server and the client
@@ -896,15 +898,19 @@
         homo_nids = []
         for ntype in nodes.keys():
             assert (
                 ntype in g.ntypes
             ), "The sampled node type {} does not exist in the input graph".format(
                 ntype
             )
-            homo_nids.append(gpb.map_to_homo_nid(nodes[ntype], ntype))
+            if F.is_tensor(nodes[ntype]):
+                typed_nodes = nodes[ntype]
+            else:
+                typed_nodes = toindex(nodes[ntype]).tousertensor()
+            homo_nids.append(gpb.map_to_homo_nid(typed_nodes, ntype))
         nodes = F.cat(homo_nids, 0)
 
     def issue_remote_req(node_ids):
         if prob is not None:
             # See NOTE 1
             _prob = [
                 # NOTE (BarclayII)
@@ -1021,15 +1027,19 @@
     if not gpb.is_homogeneous:
         assert isinstance(nodes, dict)
         homo_nids = []
         for ntype in nodes:
             assert (
                 ntype in g.ntypes
             ), "The sampled node type does not exist in the input graph"
-            homo_nids.append(gpb.map_to_homo_nid(nodes[ntype], ntype))
+            if F.is_tensor(nodes[ntype]):
+                typed_nodes = nodes[ntype]
+            else:
+                typed_nodes = toindex(nodes[ntype]).tousertensor()
+            homo_nids.append(gpb.map_to_homo_nid(typed_nodes, ntype))
         nodes = F.cat(homo_nids, 0)
     elif isinstance(nodes, dict):
         assert len(nodes) == 1
         nodes = list(nodes.values())[0]
 
     def issue_remote_req(node_ids):
         if prob is not None:
@@ -1091,14 +1101,15 @@
     tensor
         The source node ID array.
     tensor
         The destination node ID array.
     """
     req_list = []
     partition_book = g.get_partition_book()
+    edges = toindex(edges).tousertensor()
     partition_id = partition_book.eid2partid(edges)
     local_eids = None
     reorder_idx = []
     for pid in range(partition_book.num_partitions()):
         mask = partition_id == pid
         edge_id = F.boolean_mask(edges, mask)
         reorder_idx.append(F.nonzero_1d(mask))
@@ -1208,14 +1219,15 @@
 
     return _distributed_access(g, nodes, issue_remote_req, local_access)
 
 
 def _distributed_get_node_property(g, n, issue_remote_req, local_access):
     req_list = []
     partition_book = g.get_partition_book()
+    n = toindex(n).tousertensor()
     partition_id = partition_book.nid2partid(n)
     local_nids = None
     reorder_idx = []
     for pid in range(partition_book.num_partitions()):
         mask = partition_id == pid
         nid = F.boolean_mask(n, mask)
         reorder_idx.append(F.nonzero_1d(mask))
@@ -1252,55 +1264,27 @@
         for result in results:
             val = result.val
             vals = F.scatter_row(vals, reorder_idx[result.order_id], val)
     return vals
 
 
 def in_degrees(g, v):
-    """Get in-degrees
-
-    Parameters
-    ----------
-
-    g : DistGraph
-        The distributed graph.
-    v : tensor
-        The node ID array.
-
-    Returns
-    -------
-    tensor
-        The in-degree array.
-    """
+    """Get in-degrees"""
 
     def issue_remote_req(v, order_id):
         return InDegreeRequest(v, order_id)
 
     def local_access(local_g, partition_book, v):
         return _in_degrees(local_g, partition_book, v)
 
     return _distributed_get_node_property(g, v, issue_remote_req, local_access)
 
 
 def out_degrees(g, u):
-    """Get out-degrees
-
-    Parameters
-    ----------
-
-    g : DistGraph
-        The distributed graph.
-    u : tensor
-        The node ID array.
-
-    Returns
-    -------
-    tensor
-        The out-degree array.
-    """
+    """Get out-degrees"""
 
     def issue_remote_req(u, order_id):
         return OutDegreeRequest(u, order_id)
 
     def local_access(local_g, partition_book, u):
         return _out_degrees(local_g, partition_book, u)
```

## dgl/distributed/kvstore.py

```diff
@@ -1,14 +1,14 @@
 """Define distributed kvstore"""
 
 import os
 
 import numpy as np
 
-from .. import backend as F
+from .. import backend as F, utils
 from .._ffi.ndarray import empty_shared_mem
 
 from . import rpc
 from .graph_partition_book import EdgePartitionPolicy, NodePartitionPolicy
 from .standalone_kvstore import KVClient as SA_KVClient
 
 ############################ Register KVStore Requsts and Responses ###############################
@@ -1372,14 +1372,16 @@
         ----------
         name : str
             data name
         id_tensor : tensor
             a vector storing the global data ID
         """
         assert len(name) > 0, "name cannot be empty."
+        id_tensor = utils.toindex(id_tensor)
+        id_tensor = id_tensor.tousertensor()
         assert F.ndim(id_tensor) == 1, "ID must be a vector."
         # partition data
         machine_id = self._part_policy[name].to_partid(id_tensor)
 
         return machine_id
 
     def push(self, name, id_tensor, data_tensor):
@@ -1393,14 +1395,16 @@
             data name
         id_tensor : tensor
             a vector storing the global data ID
         data_tensor : tensor
             a tensor with the same row size of data ID
         """
         assert len(name) > 0, "name cannot be empty."
+        id_tensor = utils.toindex(id_tensor)
+        id_tensor = id_tensor.tousertensor()
         assert F.ndim(id_tensor) == 1, "ID must be a vector."
         assert (
             F.shape(id_tensor)[0] == F.shape(data_tensor)[0]
         ), "The data must has the same row size with ID."
         # partition data
         machine_id = self._part_policy[name].to_partid(id_tensor)
         # sort index by machine id
@@ -1444,14 +1448,16 @@
 
         Returns
         -------
         tensor
             a data tensor with the same row size of id_tensor.
         """
         assert len(name) > 0, "name cannot be empty."
+        id_tensor = utils.toindex(id_tensor)
+        id_tensor = id_tensor.tousertensor()
         assert F.ndim(id_tensor) == 1, "ID must be a vector."
         if self._pull_handlers[name] is default_pull_handler:  # Use fast-pull
             part_id = self._part_policy[name].to_partid(id_tensor)
             return rpc.fast_pull(
                 name,
                 id_tensor,
                 part_id,
```

## dgl/distributed/nn/pytorch/sparse_emb.py

```diff
@@ -1,12 +1,12 @@
 """Define sparse embedding and optimizer."""
 
 import torch as th
 
-from .... import backend as F
+from .... import backend as F, utils
 from ...dist_tensor import DistTensor
 
 
 class DistEmbedding:
     """Distributed node embeddings.
 
     DGL provides a distributed embedding to support models that require learnable embeddings.
@@ -95,24 +95,25 @@
         # else:
         #     assert 'th.distributed should be initialized'
         self._optm_state = None  # track optimizer state
         self._part_policy = part_policy
 
     def __call__(self, idx, device=th.device("cpu")):
         """
-        idx : th.tensor
+        node_ids : th.tensor
             Index of the embeddings to collect.
         device : th.device
             Target device to put the collected embeddings.
 
         Returns
         -------
         Tensor
             The requested node embeddings
         """
+        idx = utils.toindex(idx).tousertensor()
         emb = self._tensor[idx].to(device, non_blocking=True)
         if F.is_recording():
             emb = F.attach_grad(emb)
             self._trace.append((idx.to(device, non_blocking=True), emb))
         return emb
 
     def reset_trace(self):
```

## dgl/graphbolt/__init__.py

```diff
@@ -1,33 +1,14 @@
 """Graphbolt."""
 import os
 import sys
 
 import torch
 
 from .._ffi import libinfo
-from .base import *
-from .minibatch import *
-from .dataloader import *
-from .dataset import *
-from .feature_fetcher import *
-from .feature_store import *
-from .impl import *
-from .itemset import *
-from .item_sampler import *
-from .minibatch_transformer import *
-from .negative_sampler import *
-from .sampled_subgraph import *
-from .subgraph_sampler import *
-from .internal import (
-    compact_csc_format,
-    unique_and_compact,
-    unique_and_compact_csc_formats,
-)
-from .utils import add_reverse_edges, add_reverse_edges_2, exclude_seed_edges
 
 
 def load_graphbolt():
     """Load Graphbolt C++ library"""
     vers = torch.__version__.split("+", maxsplit=1)[0]
 
     if sys.platform.startswith("linux"):
@@ -49,7 +30,28 @@
     try:
         torch.classes.load_library(path)
     except Exception:  # pylint: disable=W0703
         raise ImportError("Cannot load Graphbolt C++ library")
 
 
 load_graphbolt()
+
+# pylint: disable=wrong-import-position
+from .base import *
+from .minibatch import *
+from .dataloader import *
+from .dataset import *
+from .feature_fetcher import *
+from .feature_store import *
+from .impl import *
+from .itemset import *
+from .item_sampler import *
+from .minibatch_transformer import *
+from .negative_sampler import *
+from .sampled_subgraph import *
+from .subgraph_sampler import *
+from .internal import (
+    compact_csc_format,
+    unique_and_compact,
+    unique_and_compact_csc_formats,
+)
+from .utils import add_reverse_edges, exclude_seed_edges
```

## dgl/graphbolt/base.py

```diff
@@ -1,13 +1,14 @@
 """Base types and utilities for Graph Bolt."""
 
 from collections import deque
 from dataclasses import dataclass
 
 import torch
+from torch.torch_version import TorchVersion
 from torch.utils.data import functional_datapipe
 from torchdata.datapipes.iter import IterDataPipe
 
 from ..utils import recursive_apply
 
 __all__ = [
     "CANONICAL_ETYPE_DELIMITER",
@@ -20,14 +21,15 @@
     "Bufferer",
     "EndMarker",
     "isin",
     "index_select",
     "expand_indptr",
     "CSCFormatBase",
     "seed",
+    "seed_type_str_to_ntypes",
 ]
 
 CANONICAL_ETYPE_DELIMITER = ":"
 ORIGINAL_EDGE_ID = "_ORIGINAL_EDGE_ID"
 
 
 def seed(val):
@@ -59,14 +61,26 @@
     tensor([[False,  True,  True,  False]])
     """
     assert elements.dim() == 1, "Elements should be 1D tensor."
     assert test_elements.dim() == 1, "Test_elements should be 1D tensor."
     return torch.ops.graphbolt.isin(elements, test_elements)
 
 
+if TorchVersion(torch.__version__) >= TorchVersion("2.2.0a0"):
+
+    @torch.library.impl_abstract("graphbolt::expand_indptr")
+    def expand_indptr_abstract(indptr, dtype, node_ids, output_size):
+        """Abstract implementation of expand_indptr for torch.compile() support."""
+        if output_size is None:
+            output_size = torch.library.get_ctx().new_dynamic_size()
+        if dtype is None:
+            dtype = node_ids.dtype
+        return indptr.new_empty(output_size, dtype=dtype)
+
+
 def expand_indptr(indptr, dtype=None, node_ids=None, output_size=None):
     """Converts a given indptr offset tensor to a COO format tensor. If
     node_ids is not given, it is assumed to be equal to
     torch.arange(indptr.size(0) - 1, dtype=dtype, device=indptr.device).
 
     This is equivalent to
 
@@ -168,91 +182,83 @@
     assert len(ret) == 3, (
         "Passed-in canonical etype should be in format of 'str:str:str'. "
         f"But got {c_etype}."
     )
     return ret
 
 
+def seed_type_str_to_ntypes(seed_type, seed_size):
+    """Convert seeds type to node types from string to list.
+
+    Examples
+    --------
+    1. node pairs
+
+    >>> seed_type = "user:like:item"
+    >>> seed_size = 2
+    >>> node_type = seed_type_str_to_ntypes(seed_type, seed_size)
+    >>> print(node_type)
+    ["user", "item"]
+
+    2. hyperlink
+
+    >>> seed_type = "query:user:item"
+    >>> seed_size = 3
+    >>> node_type = seed_type_str_to_ntypes(seed_type, seed_size)
+    >>> print(node_type)
+    ["query", "user", "item"]
+    """
+    assert isinstance(
+        seed_type, str
+    ), f"Passed-in seed type should be string, but got {type(seed_type)}"
+    ntypes = seed_type.split(CANONICAL_ETYPE_DELIMITER)
+    is_hyperlink = len(ntypes) == seed_size
+    if not is_hyperlink:
+        ntypes = ntypes[::2]
+    return ntypes
+
+
 def apply_to(x, device):
     """Apply `to` function to object x only if it has `to`."""
 
     return x.to(device) if hasattr(x, "to") else x
 
 
 @functional_datapipe("copy_to")
 class CopyTo(IterDataPipe):
     """DataPipe that transfers each element yielded from the previous DataPipe
     to the given device. For MiniBatch, only the related attributes
-    (automatically inferred) will be transferred by default. If you want to
-    transfer any other attributes, indicate them in the ``extra_attrs``.
+    (automatically inferred) will be transferred by default.
 
     Functional name: :obj:`copy_to`.
 
     When ``data`` has ``to`` method implemented, ``CopyTo`` will be equivalent
     to
 
     .. code:: python
 
        for data in datapipe:
            yield data.to(device)
 
-    For :class:`~dgl.graphbolt.MiniBatch`, only a part of attributes will be
-    transferred to accelerate the process by default:
-
-    - When ``seed_nodes`` is not None and ``node_pairs`` is None, node related
-    task is inferred. Only ``labels``, ``sampled_subgraphs``, ``node_features``
-    and ``edge_features`` will be transferred.
-
-    - When ``node_pairs`` is not None and ``seed_nodes`` is None, edge/link
-    related task is inferred. Only ``labels``, ``compacted_node_pairs``,
-    ``compacted_negative_srcs``, ``compacted_negative_dsts``,
-    ``sampled_subgraphs``, ``node_features`` and ``edge_features`` will be
-    transferred.
-
-    - Otherwise, all attributes will be transferred.
-
-    - If you want some other attributes to be transferred as well, please
-    specify the name in the ``extra_attrs``. For instance, the following code
-    will copy ``seed_nodes`` to the GPU as well:
-
-    .. code:: python
-
-       datapipe = datapipe.copy_to(device="cuda", extra_attrs=["seed_nodes"])
-
     Parameters
     ----------
     datapipe : DataPipe
         The DataPipe.
     device : torch.device
         The PyTorch CUDA device.
-    extra_attrs: List[string]
-        The extra attributes of the data in the DataPipe you want to be carried
-        to the specific device. The attributes specified in the ``extra_attrs``
-        will be transferred regardless of the task inferred. It could also be
-        applied to classes other than :class:`~dgl.graphbolt.MiniBatch`.
     """
 
-    def __init__(self, datapipe, device, extra_attrs=None):
+    def __init__(self, datapipe, device):
         super().__init__()
         self.datapipe = datapipe
         self.device = device
-        self.extra_attrs = extra_attrs
 
     def __iter__(self):
         for data in self.datapipe:
             data = recursive_apply(data, apply_to, self.device)
-            if self.extra_attrs is not None:
-                for attr in self.extra_attrs:
-                    setattr(
-                        data,
-                        attr,
-                        recursive_apply(
-                            getattr(data, attr), apply_to, self.device
-                        ),
-                    )
             yield data
 
 
 @functional_datapipe("mark_end")
 class EndMarker(IterDataPipe):
     """Used to mark the end of a datapipe and is a no-op."""
```

## dgl/graphbolt/item_sampler.py

```diff
@@ -46,40 +46,70 @@
             "Failed to map item list to `MiniBatch` as the names of items are "
             "not provided. Please provide a customized `MiniBatcher`. "
             "The item list is returned as is."
         )
         return batch
     if len(names) == 1:
         # Handle the case of single item: batch = tensor([0, 1, 2, 3]), names =
-        # ("seed_nodes",) as `zip(batch, names)` will iterate over the tensor
+        # ("seeds",) as `zip(batch, names)` will iterate over the tensor
         # instead of the batch.
         init_data = {names[0]: batch}
     else:
         if isinstance(batch, Mapping):
             init_data = {
                 name: {k: v[i] for k, v in batch.items()}
                 for i, name in enumerate(names)
             }
         else:
             init_data = {name: item for item, name in zip(batch, names)}
     minibatch = MiniBatch()
+    # TODO(#7254): Hacks for original `seed_nodes` and `node_pairs`, which need
+    # to be cleaned up later.
+    if "node_pairs" in names:
+        pos_seeds = init_data["node_pairs"]
+        # Build negative graph.
+        if "negative_srcs" in names and "negative_dsts" in names:
+            neg_srcs = init_data["negative_srcs"]
+            neg_dsts = init_data["negative_dsts"]
+            (
+                init_data["seeds"],
+                init_data["labels"],
+                init_data["indexes"],
+            ) = _construct_seeds(
+                pos_seeds, neg_srcs=neg_srcs, neg_dsts=neg_dsts
+            )
+        elif "negative_srcs" in names:
+            neg_srcs = init_data["negative_srcs"]
+            (
+                init_data["seeds"],
+                init_data["labels"],
+                init_data["indexes"],
+            ) = _construct_seeds(pos_seeds, neg_srcs=neg_srcs)
+        elif "negative_dsts" in names:
+            neg_dsts = init_data["negative_dsts"]
+            (
+                init_data["seeds"],
+                init_data["labels"],
+                init_data["indexes"],
+            ) = _construct_seeds(pos_seeds, neg_dsts=neg_dsts)
+        else:
+            init_data["seeds"] = pos_seeds
     for name, item in init_data.items():
         if not hasattr(minibatch, name):
             dgl_warning(
                 f"Unknown item name '{name}' is detected and added into "
                 "`MiniBatch`. You probably need to provide a customized "
                 "`MiniBatcher`."
             )
-        if name == "node_pairs":
-            # `node_pairs` is passed as a tensor in shape of `(N, 2)` and
-            # should be converted to a tuple of `(src, dst)`.
-            if isinstance(item, Mapping):
-                item = {key: (item[key][:, 0], item[key][:, 1]) for key in item}
-            else:
-                item = (item[:, 0], item[:, 1])
+        # TODO(#7254): Hacks for original `seed_nodes` and `node_pairs`, which
+        # need to be cleaned up later.
+        if name == "seed_nodes":
+            name = "seeds"
+        if name in ("node_pairs", "negative_srcs", "negative_dsts"):
+            continue
         setattr(minibatch, name, item)
     return minibatch
 
 
 class ItemShufflerAndBatcher:
     """A shuffler to shuffle items and create batches.
 
@@ -279,76 +309,69 @@
 
     Examples
     --------
     1. Node IDs.
 
     >>> import torch
     >>> from dgl import graphbolt as gb
-    >>> item_set = gb.ItemSet(torch.arange(0, 10), names="seed_nodes")
+    >>> item_set = gb.ItemSet(torch.arange(0, 10), names="seeds")
     >>> item_sampler = gb.ItemSampler(
     ...     item_set, batch_size=4, shuffle=False, drop_last=False
     ... )
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=tensor([0, 1, 2, 3]), node_pairs=None, labels=None,
-        negative_srcs=None, negative_dsts=None, sampled_subgraphs=None,
-        input_nodes=None, node_features=None, edge_features=None,
-        compacted_node_pairs=None, compacted_negative_srcs=None,
-        compacted_negative_dsts=None)
+    MiniBatch(seeds=tensor([0, 1, 2, 3]), sampled_subgraphs=None,
+        node_features=None, labels=None, input_nodes=None,
+        indexes=None, edge_features=None, compacted_seeds=None,
+        blocks=None,)
 
     2. Node pairs.
 
     >>> item_set = gb.ItemSet(torch.arange(0, 20).reshape(-1, 2),
-    ...     names="node_pairs")
+    ...     names="seeds")
     >>> item_sampler = gb.ItemSampler(
     ...     item_set, batch_size=4, shuffle=False, drop_last=False
     ... )
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=None,
-        node_pairs=(tensor([0, 2, 4, 6]), tensor([1, 3, 5, 7])),
-        labels=None, negative_srcs=None, negative_dsts=None,
-        sampled_subgraphs=None, input_nodes=None, node_features=None,
-        edge_features=None, compacted_node_pairs=None,
-        compacted_negative_srcs=None, compacted_negative_dsts=None)
+    MiniBatch(seeds=tensor([[0, 1], [2, 3], [4, 5], [6, 7]]),
+        sampled_subgraphs=None, node_features=None, labels=None,
+        input_nodes=None, indexes=None, edge_features=None,
+        compacted_seeds=None, blocks=None,)
 
     3. Node pairs and labels.
 
     >>> item_set = gb.ItemSet(
     ...     (torch.arange(0, 20).reshape(-1, 2), torch.arange(10, 20)),
-    ...     names=("node_pairs", "labels")
+    ...     names=("seeds", "labels")
     ... )
     >>> item_sampler = gb.ItemSampler(
     ...     item_set, batch_size=4, shuffle=False, drop_last=False
     ... )
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=None,
-        node_pairs=(tensor([0, 2, 4, 6]), tensor([1, 3, 5, 7])),
-        labels=tensor([10, 11, 12, 13]), negative_srcs=None,
-        negative_dsts=None, sampled_subgraphs=None, input_nodes=None,
-        node_features=None, edge_features=None, compacted_node_pairs=None,
-        compacted_negative_srcs=None, compacted_negative_dsts=None)
-
-    4. Node pairs and negative destinations.
-
-    >>> node_pairs = torch.arange(0, 20).reshape(-1, 2)
-    >>> negative_dsts = torch.arange(10, 30).reshape(-1, 2)
-    >>> item_set = gb.ItemSet((node_pairs, negative_dsts), names=("node_pairs",
-    ...     "negative_dsts"))
+    MiniBatch(seeds=tensor([[0, 1], [2, 3], [4, 5], [6, 7]]),
+        sampled_subgraphs=None, node_features=None,
+        labels=tensor([10, 11, 12, 13]), input_nodes=None,
+        indexes=None, edge_features=None, compacted_seeds=None,
+        blocks=None,)
+
+    4. Node pairs, labels and indexes.
+
+    >>> seeds = torch.arange(0, 20).reshape(-1, 2)
+    >>> labels = torch.tensor([1, 1, 0, 0, 0, 0, 0, 0, 0, 0])
+    >>> indexes = torch.tensor([0, 1, 0, 0, 0, 0, 1, 1, 1, 1])
+    >>> item_set = gb.ItemSet((seeds, labels, indexes), names=("seeds",
+    ...     "labels", "indexes"))
     >>> item_sampler = gb.ItemSampler(
     ...     item_set, batch_size=4, shuffle=False, drop_last=False
     ... )
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=None,
-        node_pairs=(tensor([0, 2, 4, 6]), tensor([1, 3, 5, 7])),
-        labels=None, negative_srcs=None,
-        negative_dsts=tensor([[10, 11],
-        [12, 13],
-        [14, 15],
-        [16, 17]]), sampled_subgraphs=None, input_nodes=None,
-        node_features=None, edge_features=None, compacted_node_pairs=None,
-        compacted_negative_srcs=None, compacted_negative_dsts=None)
+    MiniBatch(seeds=tensor([[0, 1], [2, 3], [4, 5], [6, 7]]),
+        sampled_subgraphs=None, node_features=None,
+        labels=tensor([1, 1, 0, 0]), input_nodes=None,
+        indexes=tensor([0, 1, 0, 0]), edge_features=None,
+        compacted_seeds=None, blocks=None,)
 
     5. DGLGraphs.
 
     >>> import dgl
     >>> graphs = [ dgl.rand_graph(10, 20) for _ in range(5) ]
     >>> item_set = gb.ItemSet(graphs)
     >>> item_sampler = gb.ItemSampler(item_set, 3)
@@ -370,93 +393,82 @@
     >>> data_pipe = data_pipe.map(add_one)
     >>> list(data_pipe)
     [tensor([1, 2, 3, 4]), tensor([5, 6, 7, 8]), tensor([ 9, 10])]
 
     7. Heterogeneous node IDs.
 
     >>> ids = {
-    ...     "user": gb.ItemSet(torch.arange(0, 5), names="seed_nodes"),
-    ...     "item": gb.ItemSet(torch.arange(0, 6), names="seed_nodes"),
+    ...     "user": gb.ItemSet(torch.arange(0, 5), names="seeds"),
+    ...     "item": gb.ItemSet(torch.arange(0, 6), names="seeds"),
     ... }
     >>> item_set = gb.ItemSetDict(ids)
     >>> item_sampler = gb.ItemSampler(item_set, batch_size=4)
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes={'user': tensor([0, 1, 2, 3])}, node_pairs=None,
-    labels=None, negative_srcs=None, negative_dsts=None, sampled_subgraphs=None,
-    input_nodes=None, node_features=None, edge_features=None,
-    compacted_node_pairs=None, compacted_negative_srcs=None,
-    compacted_negative_dsts=None)
+    MiniBatch(seeds={'user': tensor([0, 1, 2, 3])}, sampled_subgraphs=None,
+        node_features=None, labels=None, input_nodes=None, indexes=None,
+        edge_features=None, compacted_seeds=None, blocks=None,)
 
     8. Heterogeneous node pairs.
 
-    >>> node_pairs_like = torch.arange(0, 10).reshape(-1, 2)
-    >>> node_pairs_follow = torch.arange(10, 20).reshape(-1, 2)
+    >>> seeds_like = torch.arange(0, 10).reshape(-1, 2)
+    >>> seeds_follow = torch.arange(10, 20).reshape(-1, 2)
     >>> item_set = gb.ItemSetDict({
     ...     "user:like:item": gb.ItemSet(
-    ...         node_pairs_like, names="node_pairs"),
+    ...         seeds_like, names="seeds"),
     ...     "user:follow:user": gb.ItemSet(
-    ...         node_pairs_follow, names="node_pairs"),
+    ...         seeds_follow, names="seeds"),
     ... })
     >>> item_sampler = gb.ItemSampler(item_set, batch_size=4)
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=None,
-        node_pairs={'user:like:item':
-            (tensor([0, 2, 4, 6]), tensor([1, 3, 5, 7]))},
-        labels=None, negative_srcs=None, negative_dsts=None,
-        sampled_subgraphs=None, input_nodes=None, node_features=None,
-        edge_features=None, compacted_node_pairs=None,
-        compacted_negative_srcs=None, compacted_negative_dsts=None)
+    MiniBatch(seeds={'user:like:item':
+        tensor([[0, 1], [2, 3], [4, 5], [6, 7]])}, sampled_subgraphs=None,
+        node_features=None, labels=None, input_nodes=None, indexes=None,
+        edge_features=None, compacted_seeds=None, blocks=None,)
 
     9. Heterogeneous node pairs and labels.
 
-    >>> node_pairs_like = torch.arange(0, 10).reshape(-1, 2)
-    >>> labels_like = torch.arange(0, 10)
-    >>> node_pairs_follow = torch.arange(10, 20).reshape(-1, 2)
-    >>> labels_follow = torch.arange(10, 20)
+    >>> seeds_like = torch.arange(0, 10).reshape(-1, 2)
+    >>> labels_like = torch.arange(0, 5)
+    >>> seeds_follow = torch.arange(10, 20).reshape(-1, 2)
+    >>> labels_follow = torch.arange(5, 10)
     >>> item_set = gb.ItemSetDict({
-    ...     "user:like:item": gb.ItemSet((node_pairs_like, labels_like),
-    ...         names=("node_pairs", "labels")),
-    ...     "user:follow:user": gb.ItemSet((node_pairs_follow, labels_follow),
-    ...         names=("node_pairs", "labels")),
+    ...     "user:like:item": gb.ItemSet((seeds_like, labels_like),
+    ...         names=("seeds", "labels")),
+    ...     "user:follow:user": gb.ItemSet((seeds_follow, labels_follow),
+    ...         names=("seeds", "labels")),
     ... })
     >>> item_sampler = gb.ItemSampler(item_set, batch_size=4)
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=None,
-        node_pairs={'user:like:item':
-            (tensor([0, 2, 4, 6]), tensor([1, 3, 5, 7]))},
-        labels={'user:like:item': tensor([0, 1, 2, 3])},
-        negative_srcs=None, negative_dsts=None, sampled_subgraphs=None,
-        input_nodes=None, node_features=None, edge_features=None,
-        compacted_node_pairs=None, compacted_negative_srcs=None,
-        compacted_negative_dsts=None)
-
-    10. Heterogeneous node pairs and negative destinations.
-
-    >>> node_pairs_like = torch.arange(0, 10).reshape(-1, 2)
-    >>> negative_dsts_like = torch.arange(10, 20).reshape(-1, 2)
-    >>> node_pairs_follow = torch.arange(20, 30).reshape(-1, 2)
-    >>> negative_dsts_follow = torch.arange(30, 40).reshape(-1, 2)
+    MiniBatch(seeds={'user:like:item':
+        tensor([[0, 1], [2, 3], [4, 5], [6, 7]])}, sampled_subgraphs=None,
+        node_features=None, labels={'user:like:item': tensor([0, 1, 2, 3])},
+        input_nodes=None, indexes=None, edge_features=None,
+        compacted_seeds=None, blocks=None,)
+
+    10. Heterogeneous node pairs, labels and indexes.
+
+    >>> seeds_like = torch.arange(0, 10).reshape(-1, 2)
+    >>> labels_like = torch.tensor([1, 1, 0, 0, 0])
+    >>> indexes_like = torch.tensor([0, 1, 0, 0, 1])
+    >>> seeds_follow = torch.arange(20, 30).reshape(-1, 2)
+    >>> labels_follow = torch.tensor([1, 1, 0, 0, 0])
+    >>> indexes_follow = torch.tensor([0, 1, 0, 0, 1])
     >>> item_set = gb.ItemSetDict({
-    ...     "user:like:item": gb.ItemSet((node_pairs_like, negative_dsts_like),
-    ...         names=("node_pairs", "negative_dsts")),
-    ...     "user:follow:user": gb.ItemSet((node_pairs_follow,
-    ...         negative_dsts_follow), names=("node_pairs", "negative_dsts")),
+    ...     "user:like:item": gb.ItemSet((seeds_like, labels_like,
+    ...         indexes_like), names=("seeds", "labels", "indexes")),
+    ...     "user:follow:user": gb.ItemSet((seeds_follow,labels_follow,
+    ...         indexes_follow), names=("seeds", "labels", "indexes")),
     ... })
     >>> item_sampler = gb.ItemSampler(item_set, batch_size=4)
     >>> next(iter(item_sampler))
-    MiniBatch(seed_nodes=None,
-        node_pairs={'user:like:item':
-            (tensor([0, 2, 4, 6]), tensor([1, 3, 5, 7]))},
-        labels=None, negative_srcs=None,
-        negative_dsts={'user:like:item': tensor([[10, 11],
-        [12, 13],
-        [14, 15],
-        [16, 17]])}, sampled_subgraphs=None, input_nodes=None,
-        node_features=None, edge_features=None, compacted_node_pairs=None,
-        compacted_negative_srcs=None, compacted_negative_dsts=None)
+    MiniBatch(seeds={'user:like:item':
+        tensor([[0, 1], [2, 3], [4, 5], [6, 7]])}, sampled_subgraphs=None,
+        node_features=None, labels={'user:like:item': tensor([1, 1, 0, 0])},
+        input_nodes=None, indexes={'user:like:item': tensor([0, 1, 0, 0])},
+        edge_features=None, compacted_seeds=None, blocks=None,)
     """
 
     def __init__(
         self,
         item_set: Union[ItemSet, ItemSetDict],
         batch_size: int,
         minibatcher: Optional[Callable] = minibatcher_default,
@@ -740,7 +752,84 @@
         self._drop_uneven_inputs = drop_uneven_inputs
         if not dist.is_available():
             raise RuntimeError(
                 "Distributed item sampler requires distributed package."
             )
         self._world_size = dist.get_world_size()
         self._rank = dist.get_rank()
+
+
+def _construct_seeds(pos_seeds, neg_srcs=None, neg_dsts=None):
+    # For homogeneous graph.
+    if isinstance(pos_seeds, torch.Tensor):
+        negative_ratio = neg_srcs.size(1) if neg_srcs else neg_dsts.size(1)
+        neg_srcs = (
+            neg_srcs
+            if neg_srcs is not None
+            else pos_seeds[:, 0].repeat_interleave(negative_ratio)
+        ).view(-1)
+        neg_dsts = (
+            neg_dsts
+            if neg_dsts is not None
+            else pos_seeds[:, 1].repeat_interleave(negative_ratio)
+        ).view(-1)
+        neg_seeds = torch.cat((neg_srcs, neg_dsts)).view(2, -1).T
+        seeds = torch.cat((pos_seeds, neg_seeds))
+        pos_seeds_num = pos_seeds.size(0)
+        labels = torch.empty(seeds.size(0), device=pos_seeds.device)
+        labels[:pos_seeds_num] = 1
+        labels[pos_seeds_num:] = 0
+        pos_indexes = torch.arange(
+            0,
+            pos_seeds_num,
+            device=pos_seeds.device,
+        )
+        neg_indexes = pos_indexes.repeat_interleave(negative_ratio)
+        indexes = torch.cat((pos_indexes, neg_indexes))
+    # For heterogeneous graph.
+    else:
+        negative_ratio = (
+            list(neg_srcs.values())[0].size(1)
+            if neg_srcs
+            else list(neg_dsts.values())[0].size(1)
+        )
+        seeds = {}
+        labels = {}
+        indexes = {}
+        for etype in pos_seeds:
+            neg_src = (
+                neg_srcs[etype]
+                if neg_srcs is not None
+                else pos_seeds[etype][:, 0].repeat_interleave(negative_ratio)
+            ).view(-1)
+            neg_dst = (
+                neg_dsts[etype]
+                if neg_dsts is not None
+                else pos_seeds[etype][:, 1].repeat_interleave(negative_ratio)
+            ).view(-1)
+            seeds[etype] = torch.cat(
+                (
+                    pos_seeds[etype],
+                    torch.cat(
+                        (
+                            neg_src,
+                            neg_dst,
+                        )
+                    )
+                    .view(2, -1)
+                    .T,
+                )
+            )
+            pos_seeds_num = pos_seeds[etype].size(0)
+            labels[etype] = torch.empty(
+                seeds[etype].size(0), device=pos_seeds[etype].device
+            )
+            labels[etype][:pos_seeds_num] = 1
+            labels[etype][pos_seeds_num:] = 0
+            pos_indexes = torch.arange(
+                0,
+                pos_seeds_num,
+                device=pos_seeds[etype].device,
+            )
+            neg_indexes = pos_indexes.repeat_interleave(negative_ratio)
+            indexes[etype] = torch.cat((pos_indexes, neg_indexes))
+    return seeds, labels, indexes
```

## dgl/graphbolt/itemset.py

```diff
@@ -1,11 +1,11 @@
 """GraphBolt Itemset."""
 
 import textwrap
-from typing import Dict, Iterable, Iterator, Sized, Tuple, Union
+from typing import Dict, Iterable, Iterator, Tuple, Union
 
 import torch
 
 __all__ = ["ItemSet", "ItemSetDict"]
 
 
 def is_scalar(x):
@@ -29,191 +29,219 @@
         object will be created and iterated over. If it's multi-dimensional
         iterable such as `torch.Tensor`, it will be iterated over the first
         dimension. If it is a tuple, each item in the tuple is an iterable of
         items.
     names: Union[str, Tuple[str]], optional
         The names of the items. If it is a tuple, each name corresponds to an
         item in the tuple. The naming is arbitrary, but in general practice,
-        the names should be chosen from ['seed_nodes', 'node_pairs', 'labels',
-        'seeds', 'negative_srcs', 'negative_dsts'] to align with the attributes
-        of class `dgl.graphbolt.MiniBatch`.
+        the names should be chosen from ['labels', 'seeds', 'indexes'] to align
+        with the attributes of class `dgl.graphbolt.MiniBatch`.
 
     Examples
     --------
     >>> import torch
     >>> from dgl import graphbolt as gb
 
     1. Integer: number of nodes.
 
     >>> num = 10
-    >>> item_set = gb.ItemSet(num, names="seed_nodes")
+    >>> item_set = gb.ItemSet(num, names="seeds")
     >>> list(item_set)
     [tensor(0), tensor(1), tensor(2), tensor(3), tensor(4), tensor(5),
      tensor(6), tensor(7), tensor(8), tensor(9)]
     >>> item_set[:]
     tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
     >>> item_set.names
-    ('seed_nodes',)
+    ('seeds',)
 
     2. Torch scalar: number of nodes. Customizable dtype compared to Integer.
 
     >>> num = torch.tensor(10, dtype=torch.int32)
-    >>> item_set = gb.ItemSet(num, names="seed_nodes")
+    >>> item_set = gb.ItemSet(num, names="seeds")
     >>> list(item_set)
     [tensor(0, dtype=torch.int32), tensor(1, dtype=torch.int32),
      tensor(2, dtype=torch.int32), tensor(3, dtype=torch.int32),
      tensor(4, dtype=torch.int32), tensor(5, dtype=torch.int32),
      tensor(6, dtype=torch.int32), tensor(7, dtype=torch.int32),
      tensor(8, dtype=torch.int32), tensor(9, dtype=torch.int32)]
     >>> item_set[:]
     tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=torch.int32)
     >>> item_set.names
-    ('seed_nodes',)
+    ('seeds',)
 
     3. Single iterable: seed nodes.
 
     >>> node_ids = torch.arange(0, 5)
-    >>> item_set = gb.ItemSet(node_ids, names="seed_nodes")
+    >>> item_set = gb.ItemSet(node_ids, names="seeds")
     >>> list(item_set)
     [tensor(0), tensor(1), tensor(2), tensor(3), tensor(4)]
     >>> item_set[:]
     tensor([0, 1, 2, 3, 4])
     >>> item_set.names
-    ('seed_nodes',)
+    ('seeds',)
 
     4. Tuple of iterables with same shape: seed nodes and labels.
 
     >>> node_ids = torch.arange(0, 5)
     >>> labels = torch.arange(5, 10)
     >>> item_set = gb.ItemSet(
-    ...     (node_ids, labels), names=("seed_nodes", "labels"))
+    ...     (node_ids, labels), names=("seeds", "labels"))
     >>> list(item_set)
     [(tensor(0), tensor(5)), (tensor(1), tensor(6)), (tensor(2), tensor(7)),
      (tensor(3), tensor(8)), (tensor(4), tensor(9))]
     >>> item_set[:]
     (tensor([0, 1, 2, 3, 4]), tensor([5, 6, 7, 8, 9]))
     >>> item_set.names
-    ('seed_nodes', 'labels')
+    ('seeds', 'labels')
 
-    5. Tuple of iterables with different shape: node pairs and negative dsts.
+    5. Tuple of iterables with different shape: seeds and labels.
 
-    >>> node_pairs = torch.arange(0, 10).reshape(-1, 2)
-    >>> neg_dsts = torch.arange(10, 25).reshape(-1, 3)
+    >>> seeds = torch.arange(0, 10).reshape(-1, 2)
+    >>> labels = torch.tensor([1, 1, 0, 0, 0])
     >>> item_set = gb.ItemSet(
-    ...     (node_pairs, neg_dsts), names=("node_pairs", "negative_dsts"))
+    ...     (seeds, labels), names=("seeds", "lables"))
     >>> list(item_set)
-    [(tensor([0, 1]), tensor([10, 11, 12])),
-     (tensor([2, 3]), tensor([13, 14, 15])),
-     (tensor([4, 5]), tensor([16, 17, 18])),
-     (tensor([6, 7]), tensor([19, 20, 21])),
-     (tensor([8, 9]), tensor([22, 23, 24]))]
+    [(tensor([0, 1]), tensor([1])),
+     (tensor([2, 3]), tensor([1])),
+     (tensor([4, 5]), tensor([0])),
+     (tensor([6, 7]), tensor([0])),
+     (tensor([8, 9]), tensor([0]))]
     >>> item_set[:]
-    (tensor([[0, 1], [2, 3], [4, 5], [6, 7],[8, 9]]),
-     tensor([[10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21],
-        [22, 23, 24]]))
+    (tensor([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),
+     tensor([1, 1, 0, 0, 0]))
     >>> item_set.names
-    ('node_pairs', 'negative_dsts')
+    ('seeds', 'labels')
+
+    6. Tuple of iterables with different shape: hyperlink and labels.
+
+    >>> seeds = torch.arange(0, 10).reshape(-1, 5)
+    >>> labels = torch.tensor([1, 0])
+    >>> item_set = gb.ItemSet(
+    ...     (seeds, labels), names=("seeds", "lables"))
+    >>> list(item_set)
+    [(tensor([0, 1, 2, 3, 4]), tensor([1])),
+     (tensor([5, 6, 7, 8, 9]), tensor([0]))]
+    >>> item_set[:]
+    (tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),
+     tensor([1, 0]))
+    >>> item_set.names
+    ('seeds', 'labels')
     """
 
     def __init__(
         self,
         items: Union[int, torch.Tensor, Iterable, Tuple[Iterable]],
         names: Union[str, Tuple[str]] = None,
     ) -> None:
-        if isinstance(items, tuple) or is_scalar(items):
+        if is_scalar(items):
+            self._length = int(items)
             self._items = items
+            self._num_items = 1
+        elif isinstance(items, tuple):
+            try:
+                self._length = len(items[0])
+            except TypeError:
+                self._length = None
+            if self._length is not None:
+                if any(self._length != len(item) for item in items):
+                    raise ValueError("Size mismatch between items.")
+            self._items = items
+            self._num_items = len(items)
         else:
+            try:
+                self._length = len(items)
+            except TypeError:
+                self._length = None
             self._items = (items,)
+            self._num_items = 1
+
         if names is not None:
-            num_items = (
-                len(self._items) if isinstance(self._items, tuple) else 1
-            )
             if isinstance(names, tuple):
                 self._names = names
             else:
                 self._names = (names,)
-            assert num_items == len(self._names), (
-                f"Number of items ({num_items}) and "
+            assert self._num_items == len(self._names), (
+                f"Number of items ({self._num_items}) and "
                 f"names ({len(self._names)}) must match."
             )
         else:
             self._names = None
 
     def __iter__(self) -> Iterator:
         if is_scalar(self._items):
             dtype = getattr(self._items, "dtype", torch.int64)
             yield from torch.arange(self._items, dtype=dtype)
             return
 
-        if len(self._items) == 1:
+        if self._num_items == 1:
             yield from self._items[0]
             return
 
-        if isinstance(self._items[0], Sized):
-            items_len = len(self._items[0])
+        if self._length is not None:
             # Use for-loop to iterate over the items. It can avoid a long
             # waiting time when the items are torch tensors. Since torch
             # tensors need to call self.unbind(0) to slice themselves.
             # While for-loops are slower than zip, they prevent excessive
             # wait times during the loading phase, and the impact on overall
             # performance during the training/testing stage is minimal.
             # For more details, see https://github.com/dmlc/dgl/pull/6293.
-            for i in range(items_len):
+            for i in range(self._length):
                 yield tuple(item[i] for item in self._items)
         else:
             # If the items are not Sized, we use zip to iterate over them.
             zip_items = zip(*self._items)
             for item in zip_items:
                 yield tuple(item)
 
-    def __len__(self) -> int:
-        if is_scalar(self._items):
-            return int(self._items)
-        if isinstance(self._items[0], Sized):
-            return len(self._items[0])
-        raise TypeError(
-            f"{type(self).__name__} instance doesn't have valid length."
-        )
-
     def __getitem__(self, idx: Union[int, slice, Iterable]) -> Tuple:
-        try:
-            len(self)
-        except TypeError:
+        if self._length is None:
             raise TypeError(
                 f"{type(self).__name__} instance doesn't support indexing."
             )
         if is_scalar(self._items):
             if isinstance(idx, slice):
-                start, stop, step = idx.indices(int(self._items))
+                start, stop, step = idx.indices(self._length)
                 dtype = getattr(self._items, "dtype", torch.int64)
                 return torch.arange(start, stop, step, dtype=dtype)
             if isinstance(idx, int):
                 if idx < 0:
-                    idx += self._items
-                if idx < 0 or idx >= self._items:
+                    idx += self._length
+                if idx < 0 or idx >= self._length:
                     raise IndexError(
                         f"{type(self).__name__} index out of range."
                     )
                 return (
                     torch.tensor(idx, dtype=self._items.dtype)
                     if isinstance(self._items, torch.Tensor)
                     else idx
                 )
             raise TypeError(
                 f"{type(self).__name__} indices must be integer or slice."
             )
-        if len(self._items) == 1:
+        if self._num_items == 1:
             return self._items[0][idx]
         return tuple(item[idx] for item in self._items)
 
     @property
     def names(self) -> Tuple[str]:
         """Return the names of the items."""
         return self._names
 
+    @property
+    def num_items(self) -> int:
+        """Return the number of the items."""
+        return self._num_items
+
+    def __len__(self):
+        if self._length is None:
+            raise TypeError(
+                f"{type(self).__name__} instance doesn't have valid length."
+            )
+        return self._length
+
     def __repr__(self) -> str:
         ret = (
             f"{self.__class__.__name__}(\n"
             f"    items={self._items},\n"
             f"    names={self._names},\n"
             f")"
         )
@@ -237,77 +265,100 @@
     >>> from dgl import graphbolt as gb
 
     1. Single iterable: seed nodes.
 
     >>> node_ids_user = torch.arange(0, 5)
     >>> node_ids_item = torch.arange(5, 10)
     >>> item_set = gb.ItemSetDict({
-    ...     "user": gb.ItemSet(node_ids_user, names="seed_nodes"),
-    ...     "item": gb.ItemSet(node_ids_item, names="seed_nodes")})
+    ...     "user": gb.ItemSet(node_ids_user, names="seeds"),
+    ...     "item": gb.ItemSet(node_ids_item, names="seeds")})
     >>> list(item_set)
     [{"user": tensor(0)}, {"user": tensor(1)}, {"user": tensor(2)},
      {"user": tensor(3)}, {"user": tensor(4)}, {"item": tensor(5)},
      {"item": tensor(6)}, {"item": tensor(7)}, {"item": tensor(8)},
      {"item": tensor(9)}}]
     >>> item_set[:]
     {"user": tensor([0, 1, 2, 3, 4]), "item": tensor([5, 6, 7, 8, 9])}
     >>> item_set.names
-    ('seed_nodes',)
+    ('seeds',)
 
     2. Tuple of iterables with same shape: seed nodes and labels.
 
     >>> node_ids_user = torch.arange(0, 2)
     >>> labels_user = torch.arange(0, 2)
     >>> node_ids_item = torch.arange(2, 5)
     >>> labels_item = torch.arange(2, 5)
     >>> item_set = gb.ItemSetDict({
     ...     "user": gb.ItemSet(
     ...         (node_ids_user, labels_user),
-    ...         names=("seed_nodes", "labels")),
+    ...         names=("seeds", "labels")),
     ...     "item": gb.ItemSet(
     ...         (node_ids_item, labels_item),
-    ...         names=("seed_nodes", "labels"))})
+    ...         names=("seeds", "labels"))})
     >>> list(item_set)
     [{"user": (tensor(0), tensor(0))}, {"user": (tensor(1), tensor(1))},
      {"item": (tensor(2), tensor(2))}, {"item": (tensor(3), tensor(3))},
      {"item": (tensor(4), tensor(4))}}]
     >>> item_set[:]
     {"user": (tensor([0, 1]), tensor([0, 1])),
      "item": (tensor([2, 3, 4]), tensor([2, 3, 4]))}
     >>> item_set.names
-    ('seed_nodes', 'labels')
+    ('seeds', 'labels')
 
-    3. Tuple of iterables with different shape: node pairs and negative dsts.
+    3. Tuple of iterables with different shape: seeds and labels.
 
-    >>> node_pairs_like = torch.arange(0, 4).reshape(-1, 2)
-    >>> neg_dsts_like = torch.arange(4, 10).reshape(-1, 3)
-    >>> node_pairs_follow = torch.arange(0, 6).reshape(-1, 2)
-    >>> neg_dsts_follow = torch.arange(6, 15).reshape(-1, 3)
+    >>> seeds_like = torch.arange(0, 4).reshape(-1, 2)
+    >>> labels_like = torch.tensor([1, 0])
+    >>> seeds_follow = torch.arange(0, 6).reshape(-1, 2)
+    >>> labels_follow = torch.tensor([1, 1, 0])
     >>> item_set = gb.ItemSetDict({
     ...     "user:like:item": gb.ItemSet(
-    ...         (node_pairs_like, neg_dsts_like),
-    ...         names=("node_pairs", "negative_dsts")),
+    ...         (seeds_like, labels_like),
+    ...         names=("seeds", "labels")),
     ...     "user:follow:user": gb.ItemSet(
-    ...         (node_pairs_follow, neg_dsts_follow),
-    ...         names=("node_pairs", "negative_dsts"))})
+    ...         (seeds_follow, labels_follow),
+    ...         names=("seeds", "labels"))})
     >>> list(item_set)
-    [{"user:like:item": (tensor([0, 1]), tensor([4, 5, 6]))},
-     {"user:like:item": (tensor([2, 3]), tensor([7, 8, 9]))},
-     {"user:follow:user": (tensor([0, 1]), tensor([ 6,  7,  8,  9, 10, 11]))},
-     {"user:follow:user": (tensor([2, 3]), tensor([12, 13, 14, 15, 16, 17]))},
-     {"user:follow:user": (tensor([4, 5]), tensor([18, 19, 20, 21, 22, 23]))}]
+    [{'user:like:item': (tensor([0, 1]), tensor(1))},
+     {'user:like:item': (tensor([2, 3]), tensor(0))},
+     {'user:follow:user': (tensor([0, 1]), tensor(1))},
+     {'user:follow:user': (tensor([2, 3]), tensor(1))},
+     {'user:follow:user': (tensor([4, 5]), tensor(0))}]
     >>> item_set[:]
-    {"user:like:item": (tensor([[0, 1], [2, 3]]),
-                        tensor([[4, 5, 6], [7, 8, 9]])),
-     "user:follow:user": (tensor([[0, 1], [2, 3], [4, 5]]),
-                          tensor([[ 6,  7,  8,  9, 10, 11],
-                                  [12, 13, 14, 15, 16, 17],
-                                  [18, 19, 20, 21, 22, 23]]))}
+    {'user:like:item': (tensor([[0, 1], [2, 3]]),
+                        tensor([1, 0])),
+     'user:follow:user': (tensor([[0, 1], [2, 3], [4, 5]]),
+                          tensor([1, 1, 0]))}
     >>> item_set.names
-    ('node_pairs', 'negative_dsts')
+    ('seeds', 'labels')
+
+    4. Tuple of iterables with different shape: hyperlink and labels.
+
+    >>> first_seeds = torch.arange(0, 6).reshape(-1, 3)
+    >>> first_labels = torch.tensor([1, 0])
+    >>> second_seeds = torch.arange(0, 2).reshape(-1, 1)
+    >>> second_labels = torch.tensor([1, 0])
+    >>> item_set = gb.ItemSetDict({
+    ...     "query:user:item": gb.ItemSet(
+    ...         (first_seeds, first_labels),
+    ...         names=("seeds", "labels")),
+    ...     "user": gb.ItemSet(
+    ...         (second_seeds, second_labels),
+    ...         names=("seeds", "labels"))})
+    >>> list(item_set)
+    [{'query:user:item': (tensor([0, 1, 2]), tensor(1))},
+     {'query:user:item': (tensor([3, 4, 5]), tensor(0))},
+     {'user': (tensor([0]), tensor(1))},
+     {'user': (tensor([1]), tensor(0))}]
+    >>> item_set[:]
+    {'query:user:item': (tensor([[0, 1, 2], [3, 4, 5]]),
+                        tensor([1, 0])),
+     'user': (tensor([[0], [1]]),tensor([1, 0]))}
+    >>> item_set.names
+    ('seeds', 'labels')
     """
 
     def __init__(self, itemsets: Dict[str, ItemSet]) -> None:
         self._itemsets = itemsets
         self._names = itemsets[list(itemsets.keys())[0]].names
         assert all(
             self._names == itemset.names for itemset in itemsets.values()
@@ -360,16 +411,18 @@
                 data[key] = self._itemsets[key][
                     max(0, start - self._offsets[offset_idx - 1]) : stop
                     - self._offsets[offset_idx - 1]
                 ]
                 if stop <= self._offsets[offset_idx]:
                     break
             return data
-
-        raise TypeError(f"{type(self).__name__} indices must be int or slice.")
+        else:
+            raise TypeError(
+                f"{type(self).__name__} indices must be int or slice."
+            )
 
     @property
     def names(self) -> Tuple[str]:
         """Return the names of the items."""
         return self._names
 
     def __repr__(self) -> str:
```

## dgl/graphbolt/minibatch.py

```diff
@@ -5,57 +5,36 @@
 
 import torch
 
 import dgl
 from dgl.utils import recursive_apply
 
 from .base import CSCFormatBase, etype_str_to_tuple, expand_indptr
-from .internal import get_attributes
+from .internal import get_attributes, get_nonproperty_attributes
 from .sampled_subgraph import SampledSubgraph
 
 __all__ = ["MiniBatch"]
 
 
 @dataclass
 class MiniBatch:
     r"""A composite data class for data structure in the graphbolt.
 
     It is designed to facilitate the exchange of data among different components
     involved in processing data. The purpose of this class is to unify the
     representation of input and output data across different stages, ensuring
     consistency and ease of use throughout the loading process."""
 
-    seed_nodes: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
-    """
-    Representation of seed nodes used for sampling in the graph.
-    - If `seed_nodes` is a tensor: It indicates the graph is homogeneous.
-    - If `seed_nodes` is a dictionary: The keys should be node type and the
-      value should be corresponding heterogeneous node ids.
-    """
-
-    node_pairs: Union[
-        Tuple[torch.Tensor, torch.Tensor],
-        Dict[str, Tuple[torch.Tensor, torch.Tensor]],
-    ] = None
-    """
-    Representation of seed node pairs utilized in link prediction tasks.
-    - If `node_pairs` is a tuple: It indicates a homogeneous graph where each
-      tuple contains two tensors representing source-destination node pairs.
-    - If `node_pairs` is a dictionary: The keys should be edge type, and the
-      value should be a tuple of tensors representing node pairs of the given
-      type.
-    """
-
     labels: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
     """
-    Labels associated with seed nodes / node pairs in the graph.
+    Labels associated with seeds in the graph.
     - If `labels` is a tensor: It indicates the graph is homogeneous. The value
-      should be corresponding labels to given 'seed_nodes' or 'node_pairs'.
+      should be corresponding labels to given 'seeds'.
     - If `labels` is a dictionary: The keys should be node or edge type and the
-      value should be corresponding labels to given 'seed_nodes' or 'node_pairs'.
+      value should be corresponding labels to given 'seeds'.
     """
 
     seeds: Union[
         torch.Tensor,
         Dict[str, torch.Tensor],
     ] = None
     """
@@ -78,43 +57,22 @@
         - 2-dimensional tensor: Each row designates a seed item of the given
           type, which can encompass various entities such as edges, hyperlinks,
           or other graph components depending on the specific context.
     """
 
     indexes: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
     """
-    Indexes associated with seed nodes / node pairs in the graph, which
-    indicates to which query a seed node / node pair belongs.
+    Indexes associated with seeds in the graph, which
+    indicates to which query a seeds belongs.
     - If `indexes` is a tensor: It indicates the graph is homogeneous. The
-      value should be corresponding query to given 'seed_nodes' or
-      'node_pairs'.
-    - If `indexes` is a dictionary: It indicates the graph is
-      heterogeneous. The keys should be node or edge type and the value should
-      be corresponding query to given 'seed_nodes' or 'node_pairs'. For each
-      key, indexes are consecutive integers starting from zero.
-    """
-
-    negative_srcs: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
-    """
-    Representation of negative samples for the head nodes in the link
-    prediction task.
-    - If `negative_srcs` is a tensor: It indicates a homogeneous graph.
-    - If `negative_srcs` is a dictionary: The key should be edge type, and the
-      value should correspond to the negative samples for head nodes of the
-      given type.
-    """
-
-    negative_dsts: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
-    """
-    Representation of negative samples for the tail nodes in the link
-    prediction task.
-    - If `negative_dsts` is a tensor: It indicates a homogeneous graph.
-    - If `negative_dsts` is a dictionary: The key should be edge type, and the
-      value should correspond to the negative samples for head nodes of the
-      given type.
+      value should be corresponding query to given 'seeds'.
+    - If `indexes` is a dictionary: It indicates the graph is heterogeneous.
+      The keys should be node or edge type and the value should be
+      corresponding query to given 'seeds'. For each key, indexes are
+      consecutive integers starting from zero.
     """
 
     sampled_subgraphs: List[SampledSubgraph] = None
     """A list of 'SampledSubgraph's, each one corresponding to one layer,
     representing a subset of a larger graph structure.
     """
 
@@ -143,44 +101,23 @@
       - If keys are single strings: It means the graph is homogeneous, and the
       keys are feature names.
       - If keys are tuples: It means the graph is heterogeneous, and the keys
       are tuples of '(edge_type, feature_name)'. Note, edge type is single
       string of format 'str:str:str'.
     """
 
-    compacted_node_pairs: Union[
-        Tuple[torch.Tensor, torch.Tensor],
-        Dict[str, Tuple[torch.Tensor, torch.Tensor]],
-    ] = None
-    """
-    Representation of compacted node pairs corresponding to 'node_pairs', where
-    all node ids inside are compacted.
-    """
-
     compacted_seeds: Union[
         torch.Tensor,
         Dict[str, torch.Tensor],
     ] = None
     """
     Representation of compacted seeds corresponding to 'seeds', where
     all node ids inside are compacted.
     """
 
-    compacted_negative_srcs: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
-    """
-    Representation of compacted nodes corresponding to 'negative_srcs', where
-    all node ids inside are compacted.
-    """
-
-    compacted_negative_dsts: Union[torch.Tensor, Dict[str, torch.Tensor]] = None
-    """
-    Representation of compacted nodes corresponding to 'negative_dsts', where
-    all node ids inside are compacted.
-    """
-
     def __repr__(self) -> str:
         return _minibatch_str(self)
 
     def node_ids(self) -> Union[torch.Tensor, Dict[str, torch.Tensor]]:
         """A representation of input nodes in the outermost layer. Contains all
         nodes in the `sampled_subgraphs`.
         - If `input_nodes` is a tensor: It indicates the graph is homogeneous.
@@ -299,14 +236,15 @@
                 num_src_nodes = original_row_node_ids.size(0)
                 num_dst_nodes = original_column_node_ids.size(0)
             blocks.append(
                 dgl.create_block(
                     sampled_csc,
                     num_src_nodes=num_src_nodes,
                     num_dst_nodes=num_dst_nodes,
+                    node_count_check=False,
                 )
             )
 
         if is_heterogeneous:
             # Assign reverse node ids to the outermost layer's source nodes.
             for node_type, reverse_ids in self.sampled_subgraphs[
                 0
@@ -328,171 +266,14 @@
             ].original_row_node_ids
             # Assign reverse edges ids.
             for block, subgraph in zip(blocks, self.sampled_subgraphs):
                 if subgraph.original_edge_ids is not None:
                     block.edata[dgl.EID] = subgraph.original_edge_ids
         return blocks
 
-    @property
-    def positive_node_pairs(self):
-        """`positive_node_pairs` is a representation of positive graphs used for
-        evaluating or computing loss in link prediction tasks.
-        - If `positive_node_pairs` is a tuple: It indicates a homogeneous graph
-        containing two tensors representing source-destination node pairs.
-        - If `positive_node_pairs` is a dictionary: The keys should be edge type,
-        and the value should be a tuple of tensors representing node pairs of the
-        given type.
-        """
-        return self.compacted_node_pairs
-
-    @property
-    def negative_node_pairs(self):
-        """`negative_node_pairs` is a representation of negative graphs used for
-        evaluating or computing loss in link prediction tasks.
-        - If `negative_node_pairs` is a tuple: It indicates a homogeneous graph
-        containing two tensors representing source-destination node pairs.
-        - If `negative_node_pairs` is a dictionary: The keys should be edge type,
-        and the value should be a tuple of tensors representing node pairs of the
-        given type.
-        """
-        # Build negative graph.
-        if (
-            self.compacted_negative_srcs is not None
-            and self.compacted_negative_dsts is not None
-        ):
-            # For homogeneous graph.
-            if isinstance(self.compacted_negative_srcs, torch.Tensor):
-                negative_node_pairs = (
-                    self.compacted_negative_srcs,
-                    self.compacted_negative_dsts,
-                )
-            # For heterogeneous graph.
-            else:
-                negative_node_pairs = {
-                    etype: (
-                        neg_src,
-                        self.compacted_negative_dsts[etype],
-                    )
-                    for etype, neg_src in self.compacted_negative_srcs.items()
-                }
-        elif (
-            self.compacted_negative_srcs is not None
-            and self.compacted_node_pairs is not None
-        ):
-            # For homogeneous graph.
-            if isinstance(self.compacted_negative_srcs, torch.Tensor):
-                negative_ratio = self.compacted_negative_srcs.size(1)
-                negative_node_pairs = (
-                    self.compacted_negative_srcs,
-                    self.compacted_node_pairs[1]
-                    .repeat_interleave(negative_ratio)
-                    .view(-1, negative_ratio),
-                )
-            # For heterogeneous graph.
-            else:
-                negative_ratio = list(self.compacted_negative_srcs.values())[
-                    0
-                ].size(1)
-                negative_node_pairs = {
-                    etype: (
-                        neg_src,
-                        self.compacted_node_pairs[etype][1]
-                        .repeat_interleave(negative_ratio)
-                        .view(-1, negative_ratio),
-                    )
-                    for etype, neg_src in self.compacted_negative_srcs.items()
-                }
-        elif (
-            self.compacted_negative_dsts is not None
-            and self.compacted_node_pairs is not None
-        ):
-            # For homogeneous graph.
-            if isinstance(self.compacted_negative_dsts, torch.Tensor):
-                negative_ratio = self.compacted_negative_dsts.size(1)
-                negative_node_pairs = (
-                    self.compacted_node_pairs[0]
-                    .repeat_interleave(negative_ratio)
-                    .view(-1, negative_ratio),
-                    self.compacted_negative_dsts,
-                )
-            # For heterogeneous graph.
-            else:
-                negative_ratio = list(self.compacted_negative_dsts.values())[
-                    0
-                ].size(1)
-                negative_node_pairs = {
-                    etype: (
-                        self.compacted_node_pairs[etype][0]
-                        .repeat_interleave(negative_ratio)
-                        .view(-1, negative_ratio),
-                        neg_dst,
-                    )
-                    for etype, neg_dst in self.compacted_negative_dsts.items()
-                }
-        else:
-            negative_node_pairs = None
-        return negative_node_pairs
-
-    @property
-    def node_pairs_with_labels(self):
-        """Get a node pair tensor and a label tensor from MiniBatch. They are
-        used for evaluating or computing loss. For homogeneous graph, it will
-        return `(node_pairs, labels)` as result; for heterogeneous graph, the
-        `node_pairs` and `labels` will both be a dict with etype as the key.
-        - If it's a link prediction task, `node_pairs` will contain both
-        negative and positive node pairs and `labels` will consist of 0 and 1,
-        indicating whether the corresponding node pair is negative or positive.
-        - If it's an edge classification task, this function will directly
-        return `compacted_node_pairs` for each etype and the corresponding
-        `labels`.
-        - Otherwise it will return None.
-        """
-        if self.labels is None:
-            # Link prediction.
-            positive_node_pairs = self.positive_node_pairs
-            negative_node_pairs = self.negative_node_pairs
-            if positive_node_pairs is None or negative_node_pairs is None:
-                return None
-            if isinstance(positive_node_pairs, Dict):
-                # Heterogeneous graph.
-                node_pairs_by_etype = {}
-                labels_by_etype = {}
-                for etype in positive_node_pairs:
-                    pos_src, pos_dst = positive_node_pairs[etype]
-                    neg_src, neg_dst = negative_node_pairs[etype]
-                    neg_src, neg_dst = neg_src.view(-1), neg_dst.view(-1)
-                    node_pairs_by_etype[etype] = (
-                        torch.cat((pos_src, neg_src), dim=0),
-                        torch.cat((pos_dst, neg_dst), dim=0),
-                    )
-                    pos_label = torch.ones_like(pos_src)
-                    neg_label = torch.zeros_like(neg_src)
-                    labels_by_etype[etype] = torch.cat(
-                        [pos_label, neg_label], dim=0
-                    )
-                return (node_pairs_by_etype, labels_by_etype)
-            else:
-                # Homogeneous graph.
-                pos_src, pos_dst = positive_node_pairs
-                neg_src, neg_dst = negative_node_pairs
-                neg_src, neg_dst = neg_src.view(-1), neg_dst.view(-1)
-                node_pairs = (
-                    torch.cat((pos_src, neg_src), dim=0),
-                    torch.cat((pos_dst, neg_dst), dim=0),
-                )
-                pos_label = torch.ones_like(pos_src)
-                neg_label = torch.zeros_like(neg_src)
-                labels = torch.cat([pos_label, neg_label], dim=0)
-                return (node_pairs, labels.float())
-        elif self.compacted_node_pairs is not None:
-            # Edge classification.
-            return (self.compacted_node_pairs, self.labels)
-        else:
-            return None
-
     def to_pyg_data(self):
         """Construct a PyG Data from `MiniBatch`. This function only supports
         node classification task on a homogeneous graph and the number of
         features cannot be more than one.
         """
         from torch_geometric.data import Data
 
@@ -522,65 +303,41 @@
             node_features = None
         else:
             assert (
                 len(self.node_features) == 1
             ), "`to_pyg_data` only supports single feature homogeneous graph."
             node_features = next(iter(self.node_features.values()))
 
+        if self.seeds is not None:
+            if isinstance(self.seeds, Dict):
+                batch_size = len(next(iter(self.seeds.values())))
+            else:
+                batch_size = len(self.seeds)
+        else:
+            batch_size = None
         pyg_data = Data(
             x=node_features,
             edge_index=edge_index,
             y=self.labels,
+            batch_size=batch_size,
+            n_id=self.node_ids(),
         )
         return pyg_data
 
     def to(self, device: torch.device):  # pylint: disable=invalid-name
         """Copy `MiniBatch` to the specified device using reflection."""
 
-        def _to(x, device):
+        def _to(x):
             return x.to(device) if hasattr(x, "to") else x
 
-        def apply_to(x, device):
-            return recursive_apply(x, lambda x: _to(x, device))
-
-        if self.seed_nodes is not None and self.compacted_node_pairs is None:
-            # Node related tasks.
-            transfer_attrs = [
-                "labels",
-                "sampled_subgraphs",
-                "node_features",
-                "edge_features",
-            ]
-            if self.labels is None:
-                # Layerwise inference
-                transfer_attrs.append("seed_nodes")
-        elif self.seed_nodes is None and self.compacted_node_pairs is not None:
-            # Link/edge related tasks.
-            transfer_attrs = [
-                "labels",
-                "compacted_node_pairs",
-                "compacted_negative_srcs",
-                "compacted_negative_dsts",
-                "sampled_subgraphs",
-                "node_features",
-                "edge_features",
-            ]
-        else:
-            # Otherwise copy all the attributes to the device.
-            transfer_attrs = get_attributes(self)
+        transfer_attrs = get_nonproperty_attributes(self)
 
         for attr in transfer_attrs:
             # Only copy member variables.
-            try:
-                # For read-only attributes such as blocks and
-                # node_pairs_with_labels, setattr will throw an AttributeError.
-                # We catch these exceptions and skip those attributes.
-                setattr(self, attr, apply_to(getattr(self, attr), device))
-            except AttributeError:
-                continue
+            setattr(self, attr, recursive_apply(getattr(self, attr), _to))
 
         return self
 
 
 def _minibatch_str(minibatch: MiniBatch) -> str:
     final_str = ""
     # Get all attributes in the class except methods.
```

## dgl/graphbolt/negative_sampler.py

```diff
@@ -41,109 +41,64 @@
         Generate a mix of positive and negative samples. If `seeds` in
         minibatch is not None, `labels` and `indexes` will be constructed
         after negative sampling, based on corresponding seeds.
 
         Parameters
         ----------
         minibatch : MiniBatch
-            An instance of 'MiniBatch' class requires the 'node_pairs' field.
-            This function is responsible for generating negative edges
-            corresponding to the positive edges defined by the 'node_pairs'. In
-            cases where negative edges already exist, this function will
-            overwrite them.
+            An instance of 'MiniBatch' class requires the 'seeds' field. This
+            function is responsible for generating negative edges corresponding
+            to the positive edges defined by the 'seeds'.
 
         Returns
         -------
         MiniBatch
             An instance of 'MiniBatch' encompasses both positive and negative
             samples.
         """
-        if minibatch.seeds is None:
-            node_pairs = minibatch.node_pairs
-            assert node_pairs is not None
-            if isinstance(node_pairs, Mapping):
-                minibatch.negative_srcs, minibatch.negative_dsts = {}, {}
-                for etype, pos_pairs in node_pairs.items():
-                    self._collate(
-                        minibatch,
-                        self._sample_with_etype(pos_pairs, etype),
-                        etype,
-                    )
-            else:
-                self._collate(minibatch, self._sample_with_etype(node_pairs))
-        else:
-            seeds = minibatch.seeds
-            if isinstance(seeds, Mapping):
-                if minibatch.indexes is None:
-                    minibatch.indexes = {}
-                if minibatch.labels is None:
-                    minibatch.labels = {}
-                for etype, pos_pairs in seeds.items():
-                    (
-                        minibatch.seeds[etype],
-                        minibatch.labels[etype],
-                        minibatch.indexes[etype],
-                    ) = self._sample_with_etype(
-                        pos_pairs, etype, use_seeds=True
-                    )
-            else:
+        seeds = minibatch.seeds
+        if isinstance(seeds, Mapping):
+            if minibatch.indexes is None:
+                minibatch.indexes = {}
+            if minibatch.labels is None:
+                minibatch.labels = {}
+            for etype, pos_pairs in seeds.items():
                 (
-                    minibatch.seeds,
-                    minibatch.labels,
-                    minibatch.indexes,
-                ) = self._sample_with_etype(seeds, use_seeds=True)
+                    minibatch.seeds[etype],
+                    minibatch.labels[etype],
+                    minibatch.indexes[etype],
+                ) = self._sample_with_etype(pos_pairs, etype)
+        else:
+            (
+                minibatch.seeds,
+                minibatch.labels,
+                minibatch.indexes,
+            ) = self._sample_with_etype(seeds)
         return minibatch
 
-    def _sample_with_etype(self, node_pairs, etype=None, use_seeds=False):
+    def _sample_with_etype(self, seeds, etype=None):
         """Generate negative pairs for a given etype form positive pairs
-        for a given etype. If `node_pairs` is a 2D tensor, which represents
+        for a given etype. If `seeds` is a 2D tensor, which represents
         `seeds` is used in minibatch, corresponding labels and indexes will be
         constructed.
 
         Parameters
         ----------
-        node_pairs : Tuple[Tensor, Tensor]
-            A tuple of tensors that represent source-destination node pairs of
+        seeds : Tensor, Tensor
+            A N*2 tensors that represent source-destination node pairs of
             positive edges, where positive means the edge must exist in the
             graph.
         etype : str
             Canonical edge type.
 
         Returns
         -------
-        Tuple[Tensor, Tensor] or Tensor
-            A collection of negative node pairs.
-        Tensor or None
+        Tensor
+            A collection of postive and negative node pairs.
+        Tensor
             Corresponding labels. If label is True, corresponding edge is
             positive. If label is False, corresponding edge is negative.
-        Tensor or None
+        Tensor
             Corresponding indexes, indicates to which query an edge belongs.
 
         """
         raise NotImplementedError
-
-    def _collate(self, minibatch, neg_pairs, etype=None):
-        """Collates positive and negative samples into minibatch.
-
-        Parameters
-        ----------
-        minibatch : MiniBatch
-            The input minibatch, which contains positive node pairs, will be
-            filled with negative information in this function.
-        neg_pairs : Tuple[Tensor, Tensor]
-            A tuple of tensors represents source-destination node pairs of
-            negative edges, where negative means the edge may not exist in
-            the graph.
-        etype : str
-            Canonical edge type.
-        """
-        neg_src, neg_dst = neg_pairs
-        if neg_src is not None:
-            neg_src = neg_src.view(-1, self.negative_ratio)
-        if neg_dst is not None:
-            neg_dst = neg_dst.view(-1, self.negative_ratio)
-        if etype is not None:
-            minibatch.negative_srcs[etype] = neg_src
-            minibatch.negative_dsts[etype] = neg_dst
-        else:
-            minibatch.negative_srcs = neg_src
-            minibatch.negative_dsts = neg_dst
```

## dgl/graphbolt/sampled_subgraph.py

```diff
@@ -111,17 +111,15 @@
             edge ids.
         """
         return None
 
     def exclude_edges(
         self,
         edges: Union[
-            Dict[str, Tuple[torch.Tensor, torch.Tensor]],
             Dict[str, torch.Tensor],
-            Tuple[torch.Tensor, torch.Tensor],
             torch.Tensor,
         ],
         assume_num_node_within_int32: bool = True,
     ):
         r"""Exclude edges from the sampled subgraph.
 
         This function can be used with sampled subgraphs, regardless of
@@ -129,18 +127,17 @@
         subgraph has compacted row or column nodes, the corresponding row or
         column nodes in the returned subgraph will also be compacted.
 
         Parameters
         ----------
         self : SampledSubgraph
             The sampled subgraph.
-        edges : Union[Tuple[torch.Tensor, torch.Tensor],
-                Dict[str, Tuple[torch.Tensor, torch.Tensor]]]
+        edges : Union[torch.Tensor, Dict[str, torch.Tensor]]
             Edges to exclude. If sampled subgraph is homogeneous, then `edges`
-            should be a pair of tensors representing the edges to exclude. If
+            should be a N*2 tensors representing the edges to exclude. If
             sampled subgraph is heterogeneous, then `edges` should be a
             dictionary of edge types and the corresponding edges to exclude.
         assume_num_node_within_int32: bool
             If True, assumes the value of node IDs in the provided `edges` fall
             within the int32 range, which can significantly enhance computation
             speed. Default: True
 
@@ -161,16 +158,15 @@
         >>> original_edge_ids = {"A:relation:B": torch.tensor([19, 20, 21])}
         >>> subgraph = gb.SampledSubgraphImpl(
         ...     sampled_csc=sampled_csc,
         ...     original_column_node_ids=original_column_node_ids,
         ...     original_row_node_ids=original_row_node_ids,
         ...     original_edge_ids=original_edge_ids
         ... )
-        >>> edges_to_exclude = {"A:relation:B": (torch.tensor([14, 15]),
-        ...     torch.tensor([11, 12]))}
+        >>> edges_to_exclude = {"A:relation:B": torch.tensor([[14, 11], [15, 12]])}
         >>> result = subgraph.exclude_edges(edges_to_exclude)
         >>> print(result.sampled_csc)
         {'A:relation:B': CSCFormatBase(indptr=tensor([0, 1, 1, 1]),
                     indices=tensor([0]),
         )}
         >>> print(result.original_column_node_ids)
         {'B': tensor([10, 11, 12])}
@@ -179,17 +175,17 @@
         >>> print(result.original_edge_ids)
         {'A:relation:B': tensor([19])}
         """
         # TODO: Add support for value > in32, then remove this line.
         assert (
             assume_num_node_within_int32
         ), "Values > int32 are not supported yet."
-        assert (
-            isinstance(self.sampled_csc, (CSCFormatBase, tuple))
-        ) == isinstance(edges, (tuple, torch.Tensor)), (
+        assert (isinstance(self.sampled_csc, CSCFormatBase)) == isinstance(
+            edges, torch.Tensor
+        ), (
             "The sampled subgraph and the edges to exclude should be both "
             "homogeneous or both heterogeneous."
         )
         # Get type of calling class.
         calling_class = type(self)
 
         # Three steps to exclude edges:
@@ -198,22 +194,17 @@
         # 3. Slice the subgraph according to the index.
         if isinstance(self.sampled_csc, CSCFormatBase):
             reverse_edges = _to_reverse_ids(
                 self.sampled_csc,
                 self.original_row_node_ids,
                 self.original_column_node_ids,
             )
-            if isinstance(edges, torch.Tensor):
-                index = _exclude_homo_edges_2(
-                    reverse_edges, edges, assume_num_node_within_int32
-                )
-            else:
-                index = _exclude_homo_edges(
-                    reverse_edges, edges, assume_num_node_within_int32
-                )
+            index = _exclude_homo_edges(
+                reverse_edges, edges, assume_num_node_within_int32
+            )
             return calling_class(*_slice_subgraph(self, index))
         else:
             index = {}
             for etype, pair in self.sampled_csc.items():
                 if etype not in edges:
                     # No edges need to be excluded.
                     index[etype] = None
@@ -230,26 +221,19 @@
                     else self.original_column_node_ids.get(dst_type)
                 )
                 reverse_edges = _to_reverse_ids(
                     pair,
                     original_row_node_ids,
                     original_column_node_ids,
                 )
-                if isinstance(edges[etype], torch.Tensor):
-                    index[etype] = _exclude_homo_edges_2(
-                        reverse_edges,
-                        edges[etype],
-                        assume_num_node_within_int32,
-                    )
-                else:
-                    index[etype] = _exclude_homo_edges(
-                        reverse_edges,
-                        edges[etype],
-                        assume_num_node_within_int32,
-                    )
+                index[etype] = _exclude_homo_edges(
+                    reverse_edges,
+                    edges[etype],
+                    assume_num_node_within_int32,
+                )
             return calling_class(*_slice_subgraph(self, index))
 
     def to(self, device: torch.device) -> None:  # pylint: disable=invalid-name
         """Copy `SampledSubgraph` to the specified device using reflection."""
 
         for attr in dir(self):
             # Only copy member variables.
@@ -283,34 +267,14 @@
     concated = torch.cat([lhs_array, rhs_array])
     _, mapping = torch.unique(concated, return_inverse=True)
     return mapping[: lhs_array.numel()], mapping[lhs_array.numel() :]
 
 
 def _exclude_homo_edges(
     edges: Tuple[torch.Tensor, torch.Tensor],
-    edges_to_exclude: Tuple[torch.Tensor, torch.Tensor],
-    assume_num_node_within_int32: bool,
-):
-    """Return the indices of edges to be included."""
-    if assume_num_node_within_int32:
-        val = edges[0].long() << 32 | edges[1].long()
-        val_to_exclude = (
-            edges_to_exclude[0].long() << 32 | edges_to_exclude[1].long()
-        )
-    else:
-        # TODO: Add support for value > int32.
-        raise NotImplementedError(
-            "Values out of range int32 are not supported yet"
-        )
-    mask = ~isin(val, val_to_exclude)
-    return torch.nonzero(mask, as_tuple=True)[0]
-
-
-def _exclude_homo_edges_2(
-    edges: Tuple[torch.Tensor, torch.Tensor],
     edges_to_exclude: torch.Tensor,
     assume_num_node_within_int32: bool,
 ):
     """Return the indices of edges to be included."""
     if assume_num_node_within_int32:
         val = edges[0].long() << 32 | edges[1].long()
         edges_to_exclude_trans = edges_to_exclude.T
```

## dgl/graphbolt/subgraph_sampler.py

```diff
@@ -2,15 +2,15 @@
 
 from collections import defaultdict
 from typing import Dict
 
 import torch
 from torch.utils.data import functional_datapipe
 
-from .base import etype_str_to_tuple
+from .base import seed_type_str_to_ntypes
 from .internal import compact_temporal_nodes, unique_and_compact
 from .minibatch_transformer import MiniBatchTransformer
 
 __all__ = [
     "SubgraphSampler",
 ]
 
@@ -53,173 +53,28 @@
     def _postprocess(minibatch):
         delattr(minibatch, "_seed_nodes")
         delattr(minibatch, "_seeds_timestamp")
         return minibatch
 
     @staticmethod
     def _preprocess(minibatch):
-        if minibatch.node_pairs is not None:
-            (
-                seeds,
-                seeds_timestamp,
-                minibatch.compacted_node_pairs,
-                minibatch.compacted_negative_srcs,
-                minibatch.compacted_negative_dsts,
-            ) = SubgraphSampler._node_pairs_preprocess(minibatch)
-        elif minibatch.seed_nodes is not None:
-            seeds = minibatch.seed_nodes
-            seeds_timestamp = (
-                minibatch.timestamp if hasattr(minibatch, "timestamp") else None
-            )
-        elif minibatch.seeds is not None:
+        if minibatch.seeds is not None:
             (
                 seeds,
                 seeds_timestamp,
                 minibatch.compacted_seeds,
             ) = SubgraphSampler._seeds_preprocess(minibatch)
         else:
             raise ValueError(
-                f"Invalid minibatch {minibatch}: One of `node_pairs`, "
-                "`seed_nodes` and `seeds` should have a value."
+                f"Invalid minibatch {minibatch}: `seeds` should have a value."
             )
         minibatch._seed_nodes = seeds
         minibatch._seeds_timestamp = seeds_timestamp
         return minibatch
 
-    @staticmethod
-    def _node_pairs_preprocess(minibatch):
-        use_timestamp = hasattr(minibatch, "timestamp")
-        node_pairs = minibatch.node_pairs
-        neg_src, neg_dst = minibatch.negative_srcs, minibatch.negative_dsts
-        has_neg_src = neg_src is not None
-        has_neg_dst = neg_dst is not None
-        is_heterogeneous = isinstance(node_pairs, Dict)
-        if is_heterogeneous:
-            has_neg_src = has_neg_src and all(
-                item is not None for item in neg_src.values()
-            )
-            has_neg_dst = has_neg_dst and all(
-                item is not None for item in neg_dst.values()
-            )
-            # Collect nodes from all types of input.
-            nodes = defaultdict(list)
-            nodes_timestamp = None
-            if use_timestamp:
-                nodes_timestamp = defaultdict(list)
-            for etype, (src, dst) in node_pairs.items():
-                src_type, _, dst_type = etype_str_to_tuple(etype)
-                nodes[src_type].append(src)
-                nodes[dst_type].append(dst)
-                if use_timestamp:
-                    nodes_timestamp[src_type].append(minibatch.timestamp[etype])
-                    nodes_timestamp[dst_type].append(minibatch.timestamp[etype])
-            if has_neg_src:
-                for etype, src in neg_src.items():
-                    src_type, _, _ = etype_str_to_tuple(etype)
-                    nodes[src_type].append(src.view(-1))
-                    if use_timestamp:
-                        nodes_timestamp[src_type].append(
-                            minibatch.timestamp[etype].repeat_interleave(
-                                src.shape[-1]
-                            )
-                        )
-            if has_neg_dst:
-                for etype, dst in neg_dst.items():
-                    _, _, dst_type = etype_str_to_tuple(etype)
-                    nodes[dst_type].append(dst.view(-1))
-                    if use_timestamp:
-                        nodes_timestamp[dst_type].append(
-                            minibatch.timestamp[etype].repeat_interleave(
-                                dst.shape[-1]
-                            )
-                        )
-            # Unique and compact the collected nodes.
-            if use_timestamp:
-                seeds, nodes_timestamp, compacted = compact_temporal_nodes(
-                    nodes, nodes_timestamp
-                )
-            else:
-                seeds, compacted = unique_and_compact(nodes)
-                nodes_timestamp = None
-            (
-                compacted_node_pairs,
-                compacted_negative_srcs,
-                compacted_negative_dsts,
-            ) = ({}, {}, {})
-            # Map back in same order as collect.
-            for etype, _ in node_pairs.items():
-                src_type, _, dst_type = etype_str_to_tuple(etype)
-                src = compacted[src_type].pop(0)
-                dst = compacted[dst_type].pop(0)
-                compacted_node_pairs[etype] = (src, dst)
-            if has_neg_src:
-                for etype, _ in neg_src.items():
-                    src_type, _, _ = etype_str_to_tuple(etype)
-                    compacted_negative_srcs[etype] = compacted[src_type].pop(0)
-                    compacted_negative_srcs[etype] = compacted_negative_srcs[
-                        etype
-                    ].view(neg_src[etype].shape)
-            if has_neg_dst:
-                for etype, _ in neg_dst.items():
-                    _, _, dst_type = etype_str_to_tuple(etype)
-                    compacted_negative_dsts[etype] = compacted[dst_type].pop(0)
-                    compacted_negative_dsts[etype] = compacted_negative_dsts[
-                        etype
-                    ].view(neg_dst[etype].shape)
-        else:
-            # Collect nodes from all types of input.
-            nodes = list(node_pairs)
-            nodes_timestamp = None
-            if use_timestamp:
-                # Timestamp for source and destination nodes are the same.
-                nodes_timestamp = [minibatch.timestamp, minibatch.timestamp]
-            if has_neg_src:
-                nodes.append(neg_src.view(-1))
-                if use_timestamp:
-                    nodes_timestamp.append(
-                        minibatch.timestamp.repeat_interleave(neg_src.shape[-1])
-                    )
-            if has_neg_dst:
-                nodes.append(neg_dst.view(-1))
-                if use_timestamp:
-                    nodes_timestamp.append(
-                        minibatch.timestamp.repeat_interleave(neg_dst.shape[-1])
-                    )
-            # Unique and compact the collected nodes.
-            if use_timestamp:
-                seeds, nodes_timestamp, compacted = compact_temporal_nodes(
-                    nodes, nodes_timestamp
-                )
-            else:
-                seeds, compacted = unique_and_compact(nodes)
-                nodes_timestamp = None
-            # Map back in same order as collect.
-            compacted_node_pairs = tuple(compacted[:2])
-            compacted = compacted[2:]
-            if has_neg_src:
-                compacted_negative_srcs = compacted.pop(0)
-                # Since we need to calculate the neg_ratio according to the
-                # compacted_negatvie_srcs shape, we need to reshape it back.
-                compacted_negative_srcs = compacted_negative_srcs.view(
-                    neg_src.shape
-                )
-            if has_neg_dst:
-                compacted_negative_dsts = compacted.pop(0)
-                # Same as above.
-                compacted_negative_dsts = compacted_negative_dsts.view(
-                    neg_dst.shape
-                )
-        return (
-            seeds,
-            nodes_timestamp,
-            compacted_node_pairs,
-            compacted_negative_srcs if has_neg_src else None,
-            compacted_negative_dsts if has_neg_dst else None,
-        )
-
     def _sample(self, minibatch):
         (
             minibatch.input_nodes,
             minibatch.sampled_subgraphs,
         ) = self.sample_subgraphs(
             minibatch._seed_nodes, minibatch._seeds_timestamp
         )
@@ -234,15 +89,16 @@
         return datapipe.transform(self._sample)
 
     @staticmethod
     def _seeds_preprocess(minibatch):
         """Preprocess `seeds` in a minibatch to construct `unique_seeds`,
         `node_timestamp` and `compacted_seeds` for further sampling. It
         optionally incorporates timestamps for temporal graphs, organizing and
-        compacting seeds based on their types and timestamps.
+        compacting seeds based on their types and timestamps. In heterogeneous
+        graph, `seeds` with same node type will be unqiued together.
 
         Parameters
         ----------
         minibatch: MiniBatch
             The minibatch.
 
         Returns
@@ -262,73 +118,96 @@
         is_heterogeneous = isinstance(seeds, Dict)
         if is_heterogeneous:
             # Collect nodes from all types of input.
             nodes = defaultdict(list)
             nodes_timestamp = None
             if use_timestamp:
                 nodes_timestamp = defaultdict(list)
-            for etype, pair in seeds.items():
-                assert pair.ndim == 1 or (
-                    pair.ndim == 2 and pair.shape[1] == 2
-                ), (
-                    "Only tensor with shape 1*N and N*2 is "
-                    + f"supported now, but got {pair.shape}."
+            for seed_type, typed_seeds in seeds.items():
+                # When typed_seeds is a one-dimensional tensor, it represents
+                # seed nodes, which does not need to do unique and compact.
+                if typed_seeds.ndim == 1:
+                    nodes_timestamp = (
+                        minibatch.timestamp
+                        if hasattr(minibatch, "timestamp")
+                        else None
+                    )
+                    return seeds, nodes_timestamp, None
+                assert typed_seeds.ndim == 2, (
+                    "Only tensor with shape 1*N and N*M is "
+                    + f"supported now, but got {typed_seeds.shape}."
+                )
+                ntypes = seed_type_str_to_ntypes(
+                    seed_type, typed_seeds.shape[1]
                 )
-                ntypes = etype[:].split(":")[::2]
-                pair = pair.view(pair.shape[0], -1)
                 if use_timestamp:
                     negative_ratio = (
-                        pair.shape[0] // minibatch.timestamp[etype].shape[0] - 1
+                        typed_seeds.shape[0]
+                        // minibatch.timestamp[seed_type].shape[0]
+                        - 1
                     )
                     neg_timestamp = minibatch.timestamp[
-                        etype
+                        seed_type
                     ].repeat_interleave(negative_ratio)
                 for i, ntype in enumerate(ntypes):
-                    nodes[ntype].append(pair[:, i])
+                    nodes[ntype].append(typed_seeds[:, i])
                     if use_timestamp:
                         nodes_timestamp[ntype].append(
-                            minibatch.timestamp[etype]
+                            minibatch.timestamp[seed_type]
                         )
                         nodes_timestamp[ntype].append(neg_timestamp)
             # Unique and compact the collected nodes.
             if use_timestamp:
                 (
                     unique_seeds,
                     nodes_timestamp,
                     compacted,
                 ) = compact_temporal_nodes(nodes, nodes_timestamp)
             else:
                 unique_seeds, compacted = unique_and_compact(nodes)
                 nodes_timestamp = None
             compacted_seeds = {}
             # Map back in same order as collect.
-            for etype, pair in seeds.items():
-                if pair.ndim == 1:
-                    compacted_seeds[etype] = compacted[etype].pop(0)
-                else:
-                    src_type, _, dst_type = etype_str_to_tuple(etype)
-                    src = compacted[src_type].pop(0)
-                    dst = compacted[dst_type].pop(0)
-                    compacted_seeds[etype] = torch.cat((src, dst)).view(2, -1).T
+            for seed_type, typed_seeds in seeds.items():
+                ntypes = seed_type_str_to_ntypes(
+                    seed_type, typed_seeds.shape[1]
+                )
+                compacted_seed = []
+                for ntype in ntypes:
+                    compacted_seed.append(compacted[ntype].pop(0))
+                compacted_seeds[seed_type] = (
+                    torch.cat(compacted_seed).view(len(ntypes), -1).T
+                )
         else:
+            # When seeds is a one-dimensional tensor, it represents seed nodes,
+            # which does not need to do unique and compact.
+            if seeds.ndim == 1:
+                nodes_timestamp = (
+                    minibatch.timestamp
+                    if hasattr(minibatch, "timestamp")
+                    else None
+                )
+                return seeds, nodes_timestamp, None
             # Collect nodes from all types of input.
             nodes = [seeds.view(-1)]
             nodes_timestamp = None
             if use_timestamp:
                 # Timestamp for source and destination nodes are the same.
                 negative_ratio = (
                     seeds.shape[0] // minibatch.timestamp.shape[0] - 1
                 )
                 neg_timestamp = minibatch.timestamp.repeat_interleave(
                     negative_ratio
                 )
                 seeds_timestamp = torch.cat(
                     (minibatch.timestamp, neg_timestamp)
                 )
-                nodes_timestamp = [seeds_timestamp for _ in range(seeds.ndim)]
+                nodes_timestamp = [
+                    seeds_timestamp for _ in range(seeds.shape[1])
+                ]
             # Unique and compact the collected nodes.
             if use_timestamp:
                 (
                     unique_seeds,
                     nodes_timestamp,
                     compacted,
                 ) = compact_temporal_nodes(nodes, nodes_timestamp)
```

## dgl/graphbolt/utils.py

```diff
@@ -1,83 +1,17 @@
 """Utility functions for external use."""
 
-from typing import Dict, Tuple, Union
+from typing import Dict, Union
 
 import torch
 
 from .minibatch import MiniBatch
 
 
 def add_reverse_edges(
-    edges: Union[
-        Dict[str, Tuple[torch.Tensor, torch.Tensor]],
-        Tuple[torch.Tensor, torch.Tensor],
-    ],
-    reverse_etypes_mapping: Dict[str, str] = None,
-):
-    r"""
-    This function finds the reverse edges of the given `edges` and returns the
-    composition of them. In a homogeneous graph, reverse edges have inverted
-    source and destination node IDs. While in a heterogeneous graph, reversing
-    also involves swapping node IDs and their types. This function could be
-    used before `exclude_edges` function to help find targeting edges.
-    Note: The found reverse edges may not really exists in the original graph.
-    And repeat edges could be added becasue reverse edges may already exists in
-    the `edges`.
-
-    Parameters
-    ----------
-    edges : Union[Dict[str, Tuple[torch.Tensor, torch.Tensor]],
-                Tuple[torch.Tensor, torch.Tensor]]
-        - If sampled subgraph is homogeneous, then `edges` should be a pair of
-        of tensors.
-        - If sampled subgraph is heterogeneous, then `edges` should be a
-        dictionary of edge types and the corresponding edges to exclude.
-    reverse_etypes_mapping : Dict[str, str], optional
-        The mapping from the original edge types to their reverse edge types.
-
-    Returns
-    -------
-    Union[Dict[str, Tuple[torch.Tensor, torch.Tensor]],
-        Tuple[torch.Tensor, torch.Tensor]]
-        The node pairs contain both the original edges and their reverse
-        counterparts.
-
-    Examples
-    --------
-    >>> edges = {"A:r:B": (torch.tensor([0, 1]), torch.tensor([1, 2]))}
-    >>> print(gb.add_reverse_edges(edges, {"A:r:B": "B:rr:A"}))
-    {'A:r:B': (tensor([0, 1]), tensor([1, 2])),
-    'B:rr:A': (tensor([1, 2]), tensor([0, 1]))}
-
-    >>> edges = (torch.tensor([0, 1]), torch.tensor([2, 1]))
-    >>> print(gb.add_reverse_edges(edges))
-    (tensor([0, 1, 2, 1]), tensor([2, 1, 0, 1]))
-    """
-    if isinstance(edges, tuple):
-        u, v = edges
-        return (torch.cat([u, v]), torch.cat([v, u]))
-    else:
-        combined_edges = edges.copy()
-        for etype, reverse_etype in reverse_etypes_mapping.items():
-            if etype in edges:
-                if reverse_etype in combined_edges:
-                    u, v = combined_edges[reverse_etype]
-                    u = torch.cat([u, edges[etype][1]])
-                    v = torch.cat([v, edges[etype][0]])
-                    combined_edges[reverse_etype] = (u, v)
-                else:
-                    combined_edges[reverse_etype] = (
-                        edges[etype][1],
-                        edges[etype][0],
-                    )
-        return combined_edges
-
-
-def add_reverse_edges_2(
     edges: Union[Dict[str, torch.Tensor], torch.Tensor],
     reverse_etypes_mapping: Dict[str, str] = None,
 ):
     r"""
     This function finds the reverse edges of the given `edges` and returns the
     composition of them. In a homogeneous graph, reverse edges have inverted
     source and destination node IDs. While in a heterogeneous graph, reversing
@@ -153,24 +87,17 @@
     Parameters
     ----------
     minibatch : MiniBatch
         The minibatch.
     reverse_etypes_mapping : Dict[str, str] = None
         The mapping from the original edge types to their reverse edge types.
     """
-    if minibatch.node_pairs is not None:
-        edges_to_exclude = minibatch.node_pairs
-        if include_reverse_edges:
-            edges_to_exclude = add_reverse_edges(
-                minibatch.node_pairs, reverse_etypes_mapping
-            )
-    else:
-        edges_to_exclude = minibatch.seeds
-        if include_reverse_edges:
-            edges_to_exclude = add_reverse_edges_2(
-                edges_to_exclude, reverse_etypes_mapping
-            )
+    edges_to_exclude = minibatch.seeds
+    if include_reverse_edges:
+        edges_to_exclude = add_reverse_edges(
+            edges_to_exclude, reverse_etypes_mapping
+        )
     minibatch.sampled_subgraphs = [
         subgraph.exclude_edges(edges_to_exclude)
         for subgraph in minibatch.sampled_subgraphs
     ]
     return minibatch
```

## dgl/graphbolt/impl/fused_csc_sampling_graph.py

```diff
@@ -287,14 +287,43 @@
         self, node_type_offset: Optional[torch.Tensor]
     ) -> None:
         """Sets the node type offset tensor if present."""
         self._c_csc_graph.set_node_type_offset(node_type_offset)
         self._node_type_offset_cached_list = None
 
     @property
+    def _indptr_node_type_offset_list(self) -> Optional[list]:
+        """Returns the indptr node type offset list which presents the column id
+        space when it does not match the global id space. It is useful when we
+        slice a subgraph from another FusedCSCSamplingGraph.
+
+        Returns
+        -------
+        list or None
+            If present, returns a 1D integer list of shape
+            `(num_node_types + 1,)`. The list is in ascending order as nodes
+            of the same type have continuous IDs, and larger node IDs are
+            paired with larger node type IDs. The first value is 0 and last
+            value is the number of nodes. And nodes with IDs between
+            `node_type_offset_[i]~node_type_offset_[i+1]` are of type id 'i'.
+        """
+        return (
+            self._indptr_node_type_offset_list_
+            if hasattr(self, "_indptr_node_type_offset_list_")
+            else None
+        )
+
+    @_indptr_node_type_offset_list.setter
+    def _indptr_node_type_offset_list(
+        self, indptr_node_type_offset_list: Optional[torch.Tensor]
+    ):
+        """Sets the indptr node type offset list if present."""
+        self._indptr_node_type_offset_list_ = indptr_node_type_offset_list
+
+    @property
     def type_per_edge(self) -> Optional[torch.Tensor]:
         """Returns the edge type tensor if present.
 
         Returns
         -------
         torch.Tensor or None
             If present, returns a 1D integer tensor of shape (total_num_edges,)
@@ -440,99 +469,135 @@
         ), 'N1:R2:N0': CSCFormatBase(indptr=tensor([0, 2]),
                     indices=tensor([0, 1]),
         ), 'N1:R3:N1': CSCFormatBase(indptr=tensor([0, 1, 3]),
                     indices=tensor([0, 1, 2]),
         )}
         """
         if isinstance(nodes, dict):
-            nodes = self._convert_to_homogeneous_nodes(nodes)
+            nodes, _ = self._convert_to_homogeneous_nodes(nodes)
         # Ensure nodes is 1-D tensor.
         assert nodes.dim() == 1, "Nodes should be 1-D tensor."
-        # Ensure that there are no duplicate nodes.
-        assert len(torch.unique(nodes)) == len(
-            nodes
-        ), "Nodes cannot have duplicate values."
 
         _in_subgraph = self._c_csc_graph.in_subgraph(nodes)
         return self._convert_to_sampled_subgraph(_in_subgraph)
 
     def _convert_to_homogeneous_nodes(self, nodes, timestamps=None):
         homogeneous_nodes = []
+        homogeneous_node_offsets = [0]
         homogeneous_timestamps = []
         offset = self._node_type_offset_list
-        for ntype, ids in nodes.items():
-            ntype_id = self.node_type_to_id[ntype]
-            homogeneous_nodes.append(ids + offset[ntype_id])
-            if timestamps is not None:
-                homogeneous_timestamps.append(timestamps[ntype])
+        for ntype, ntype_id in self.node_type_to_id.items():
+            ids = nodes.get(ntype, [])
+            if len(ids) > 0:
+                homogeneous_nodes.append(ids + offset[ntype_id])
+                if timestamps is not None:
+                    homogeneous_timestamps.append(timestamps[ntype])
+            homogeneous_node_offsets.append(
+                homogeneous_node_offsets[-1] + len(ids)
+            )
         if timestamps is not None:
             return torch.cat(homogeneous_nodes), torch.cat(
                 homogeneous_timestamps
             )
-        return torch.cat(homogeneous_nodes)
+        return torch.cat(homogeneous_nodes), homogeneous_node_offsets
 
     def _convert_to_sampled_subgraph(
         self,
         C_sampled_subgraph: torch.ScriptObject,
+        seed_offsets: Optional[list] = None,
     ) -> SampledSubgraphImpl:
         """An internal function used to convert a fused homogeneous sampled
         subgraph to general struct 'SampledSubgraphImpl'."""
         indptr = C_sampled_subgraph.indptr
         indices = C_sampled_subgraph.indices
         type_per_edge = C_sampled_subgraph.type_per_edge
         column = C_sampled_subgraph.original_column_node_ids
         original_edge_ids = C_sampled_subgraph.original_edge_ids
+        etype_offsets = C_sampled_subgraph.etype_offsets
+        if etype_offsets is not None:
+            etype_offsets = etype_offsets.tolist()
 
         has_original_eids = (
             self.edge_attributes is not None
             and ORIGINAL_EDGE_ID in self.edge_attributes
         )
         if has_original_eids:
             original_edge_ids = torch.ops.graphbolt.index_select(
                 self.edge_attributes[ORIGINAL_EDGE_ID], original_edge_ids
             )
-        if type_per_edge is None:
+        if type_per_edge is None and etype_offsets is None:
             # The sampled graph is already a homogeneous graph.
             sampled_csc = CSCFormatBase(indptr=indptr, indices=indices)
         else:
-            # UVA sampling requires us to move node_type_offset to GPU.
-            self.node_type_offset = self.node_type_offset.to(column.device)
-            # 1. Find node types for each nodes in column.
-            node_types = (
-                torch.searchsorted(self.node_type_offset, column, right=True)
-                - 1
-            )
+            offset = self._node_type_offset_list
 
             original_hetero_edge_ids = {}
             sub_indices = {}
             sub_indptr = {}
-            offset = self._node_type_offset_list
-            # 2. For loop each node type.
-            for ntype, ntype_id in self.node_type_to_id.items():
-                # Get all nodes of a specific node type in column.
-                nids = torch.nonzero(node_types == ntype_id).view(-1)
-                nids_original_indptr = indptr[nids + 1]
+            if etype_offsets is None:
+                # UVA sampling requires us to move node_type_offset to GPU.
+                self.node_type_offset = self.node_type_offset.to(column.device)
+                # 1. Find node types for each nodes in column.
+                node_types = (
+                    torch.searchsorted(
+                        self.node_type_offset, column, right=True
+                    )
+                    - 1
+                )
+                for ntype, ntype_id in self.node_type_to_id.items():
+                    # Get all nodes of a specific node type in column.
+                    nids = torch.nonzero(node_types == ntype_id).view(-1)
+                    nids_original_indptr = indptr[nids + 1]
+                    for etype, etype_id in self.edge_type_to_id.items():
+                        src_ntype, _, dst_ntype = etype_str_to_tuple(etype)
+                        if dst_ntype != ntype:
+                            continue
+                        # Get all edge ids of a specific edge type.
+                        eids = torch.nonzero(type_per_edge == etype_id).view(-1)
+                        src_ntype_id = self.node_type_to_id[src_ntype]
+                        sub_indices[etype] = (
+                            indices[eids] - offset[src_ntype_id]
+                        )
+                        cum_edges = torch.searchsorted(
+                            eids, nids_original_indptr, right=False
+                        )
+                        sub_indptr[etype] = torch.cat(
+                            (torch.tensor([0], device=indptr.device), cum_edges)
+                        )
+                        if has_original_eids:
+                            original_hetero_edge_ids[etype] = original_edge_ids[
+                                eids
+                            ]
+            else:
+                edge_offsets = [0]
                 for etype, etype_id in self.edge_type_to_id.items():
                     src_ntype, _, dst_ntype = etype_str_to_tuple(etype)
-                    if dst_ntype != ntype:
-                        continue
-                    # Get all edge ids of a specific edge type.
-                    eids = torch.nonzero(type_per_edge == etype_id).view(-1)
-                    src_ntype_id = self.node_type_to_id[src_ntype]
-                    sub_indices[etype] = indices[eids] - offset[src_ntype_id]
-                    cum_edges = torch.searchsorted(
-                        eids, nids_original_indptr, right=False
-                    )
-                    sub_indptr[etype] = torch.cat(
-                        (torch.tensor([0], device=indptr.device), cum_edges)
+                    ntype_id = self.node_type_to_id[dst_ntype]
+                    edge_offsets.append(
+                        edge_offsets[-1]
+                        + seed_offsets[ntype_id + 1]
+                        - seed_offsets[ntype_id]
+                        + 1
                     )
+                for etype, etype_id in self.edge_type_to_id.items():
+                    src_ntype, _, dst_ntype = etype_str_to_tuple(etype)
+                    ntype_id = self.node_type_to_id[dst_ntype]
+                    sub_indptr[etype] = indptr[
+                        edge_offsets[etype_id] : edge_offsets[etype_id + 1]
+                    ]
+                    sub_indices[etype] = indices[
+                        etype_offsets[etype_id] : etype_offsets[etype_id + 1]
+                    ]
                     if has_original_eids:
                         original_hetero_edge_ids[etype] = original_edge_ids[
-                            eids
+                            etype_offsets[etype_id] : etype_offsets[
+                                etype_id + 1
+                            ]
                         ]
+
             if has_original_eids:
                 original_edge_ids = original_hetero_edge_ids
             sampled_csc = {
                 etype: CSCFormatBase(
                     indptr=sub_indptr[etype],
                     indices=sub_indices[etype],
                 )
@@ -541,25 +606,25 @@
         return SampledSubgraphImpl(
             sampled_csc=sampled_csc,
             original_edge_ids=original_edge_ids,
         )
 
     def sample_neighbors(
         self,
-        nodes: Union[torch.Tensor, Dict[str, torch.Tensor]],
+        seeds: Union[torch.Tensor, Dict[str, torch.Tensor]],
         fanouts: torch.Tensor,
         replace: bool = False,
         probs_name: Optional[str] = None,
     ) -> SampledSubgraphImpl:
         """Sample neighboring edges of the given nodes and return the induced
         subgraph.
 
         Parameters
         ----------
-        nodes: torch.Tensor or Dict[str, torch.Tensor]
+        seeds: torch.Tensor or Dict[str, torch.Tensor]
             IDs of the given seed nodes.
               - If `nodes` is a tensor: It means the graph is homogeneous
                 graph, and ids inside are homogeneous ids.
               - If `nodes` is a dictionary: The keys should be node type and
                 ids inside are heterogeneous ids.
         fanouts: torch.Tensor
             The number of edges to be sampled for each node with or without
@@ -615,29 +680,35 @@
         >>> print(subgraph.sampled_csc)
         {'n1:e1:n2': CSCFormatBase(indptr=tensor([0, 1]),
                     indices=tensor([0]),
         ), 'n2:e2:n1': CSCFormatBase(indptr=tensor([0, 1]),
                     indices=tensor([2]),
         )}
         """
-        if isinstance(nodes, dict):
-            nodes = self._convert_to_homogeneous_nodes(nodes)
-
         return_eids = (
             self.edge_attributes is not None
             and ORIGINAL_EDGE_ID in self.edge_attributes
         )
+
+        seed_offsets = None
+        if isinstance(seeds, dict):
+            seeds, seed_offsets = self._convert_to_homogeneous_nodes(seeds)
+        elif seeds is None:
+            seed_offsets = self._indptr_node_type_offset_list
         C_sampled_subgraph = self._sample_neighbors(
-            nodes,
+            seeds,
+            seed_offsets,
             fanouts,
             replace=replace,
             probs_name=probs_name,
             return_eids=return_eids,
         )
-        return self._convert_to_sampled_subgraph(C_sampled_subgraph)
+        return self._convert_to_sampled_subgraph(
+            C_sampled_subgraph, seed_offsets
+        )
 
     def _check_sampler_arguments(self, nodes, fanouts, probs_name):
         if nodes is not None:
             assert nodes.dim() == 1, "Nodes should be 1-D tensor."
             assert nodes.dtype == self.indices.dtype, (
                 f"Data type of nodes must be consistent with "
                 f"indices.dtype({self.indices.dtype}), but got {nodes.dtype}."
@@ -676,27 +747,31 @@
                 torch.bfloat16,
                 torch.float32,
                 torch.float64,
             ], "Probs should have a floating-point or boolean data type."
 
     def _sample_neighbors(
         self,
-        nodes: torch.Tensor,
+        seeds: torch.Tensor,
+        seed_offsets: Optional[list],
         fanouts: torch.Tensor,
         replace: bool = False,
         probs_name: Optional[str] = None,
         return_eids: bool = False,
     ) -> torch.ScriptObject:
         """Sample neighboring edges of the given nodes and return the induced
         subgraph.
 
         Parameters
         ----------
-        nodes: torch.Tensor
+        seeds: torch.Tensor
             IDs of the given seed nodes.
+        seeds_offsets: list, optional
+            The offsets of the given seeds,
+            seeds[seed_offsets[i]: seed_offsets[i + 1]] has node type i.
         fanouts: torch.Tensor
             The number of edges to be sampled for each node with or without
             considering edge types.
               - When the length is 1, it indicates that the fanout applies to
                 all neighbors of the node as a collective, regardless of the
                 edge type.
               - Otherwise, the length should equal to the number of edge
@@ -726,39 +801,44 @@
 
         Returns
         -------
         torch.classes.graphbolt.SampledSubgraph
             The sampled C subgraph.
         """
         # Ensure nodes is 1-D tensor.
-        self._check_sampler_arguments(nodes, fanouts, probs_name)
+        self._check_sampler_arguments(seeds, fanouts, probs_name)
         return self._c_csc_graph.sample_neighbors(
-            nodes,
+            seeds,
+            seed_offsets,
             fanouts.tolist(),
             replace,
-            False,
+            False,  # is_labor
             return_eids,
             probs_name,
+            None,  # random_seed, labor parameter
+            0,  # seed2_contribution, labor_parameter
         )
 
     def sample_layer_neighbors(
         self,
-        nodes: Union[torch.Tensor, Dict[str, torch.Tensor]],
+        seeds: Union[torch.Tensor, Dict[str, torch.Tensor]],
         fanouts: torch.Tensor,
         replace: bool = False,
         probs_name: Optional[str] = None,
+        random_seed: torch.Tensor = None,
+        seed2_contribution: float = 0.0,
     ) -> SampledSubgraphImpl:
         """Sample neighboring edges of the given nodes and return the induced
         subgraph via layer-neighbor sampling from the NeurIPS 2023 paper
         `Layer-Neighbor Sampling -- Defusing Neighborhood Explosion in GNNs
-        <https://arxiv.org/abs/2210.13339>`__
+        <https://proceedings.neurips.cc/paper_files/paper/2023/file/51f9036d5e7ae822da8f6d4adda1fb39-Paper-Conference.pdf>`__
 
         Parameters
         ----------
-        nodes: torch.Tensor or Dict[str, torch.Tensor]
+        seeds: torch.Tensor or Dict[str, torch.Tensor]
             IDs of the given seed nodes.
               - If `nodes` is a tensor: It means the graph is homogeneous
                 graph, and ids inside are homogeneous ids.
               - If `nodes` is a dictionary: The keys should be node type and
                 ids inside are heterogeneous ids.
         fanouts: torch.Tensor
             The number of edges to be sampled for each node with or without
@@ -783,14 +863,40 @@
             times. Otherwise, each value can be selected only once.
         probs_name: str, optional
             An optional string specifying the name of an edge attribute. This
             attribute tensor should contain (unnormalized) probabilities
             corresponding to each neighboring edge of a node. It must be a 1D
             floating-point or boolean tensor, with the number of elements
             equalling the total number of edges.
+        random_seed: torch.Tensor, optional
+            An int64 tensor with one or two elements.
+
+            The passed random_seed makes it so that for any seed node ``s`` and
+            its neighbor ``t``, the rolled random variate ``r_t`` is the same
+            for any call to this function with the same random seed. When
+            sampling as part of the same batch, one would want identical seeds
+            so that LABOR can globally sample. One example is that for
+            heterogenous graphs, there is a single random seed passed for each
+            edge type. This will sample much fewer nodes compared to having
+            unique random seeds for each edge type. If one called this function
+            individually for each edge type for a heterogenous graph with
+            different random seeds, then it would run LABOR locally for each
+            edge type, resulting into a larger number of nodes being sampled.
+
+            If this function is called without a ``random_seed``, we get the
+            random seed by getting a random number from GraphBolt. Use this
+            argument with identical random_seed if multiple calls to this
+            function are used to sample as part of a single batch.
+
+            If given two numbers, then the ``seed2_contribution`` argument
+            determines the interpolation between the two random seeds.
+        seed2_contribution: float, optional
+            A float value between [0, 1) that determines the contribution of the
+            second random seed, ``random_seed[-1]``, to generate the random
+            variates.
 
         Returns
         -------
         SampledSubgraphImpl
             The sampled subgraph.
 
         Examples
@@ -814,31 +920,48 @@
         >>> print(subgraph.sampled_csc)
         {'n1:e1:n2': CSCFormatBase(indptr=tensor([0, 1]),
                     indices=tensor([0]),
         ), 'n2:e2:n1': CSCFormatBase(indptr=tensor([0, 1]),
                     indices=tensor([2]),
         )}
         """
-        if isinstance(nodes, dict):
-            nodes = self._convert_to_homogeneous_nodes(nodes)
+        if random_seed is not None:
+            assert (
+                1 <= len(random_seed) <= 2
+            ), "There should be a 1 or 2 random seeds."
+            if len(random_seed) == 2:
+                assert (
+                    0 <= seed2_contribution <= 1
+                ), "seed2_contribution should be in [0, 1]."
 
-        self._check_sampler_arguments(nodes, fanouts, probs_name)
         has_original_eids = (
             self.edge_attributes is not None
             and ORIGINAL_EDGE_ID in self.edge_attributes
         )
+
+        seed_offsets = None
+        if isinstance(seeds, dict):
+            seeds, seed_offsets = self._convert_to_homogeneous_nodes(seeds)
+        elif seeds is None:
+            seed_offsets = self._indptr_node_type_offset_list
+        self._check_sampler_arguments(seeds, fanouts, probs_name)
         C_sampled_subgraph = self._c_csc_graph.sample_neighbors(
-            nodes,
+            seeds,
+            seed_offsets,
             fanouts.tolist(),
             replace,
             True,
             has_original_eids,
             probs_name,
+            random_seed,
+            seed2_contribution,
+        )
+        return self._convert_to_sampled_subgraph(
+            C_sampled_subgraph, seed_offsets
         )
-        return self._convert_to_sampled_subgraph(C_sampled_subgraph)
 
     def temporal_sample_neighbors(
         self,
         nodes: Union[torch.Tensor, Dict[str, torch.Tensor]],
         input_nodes_timestamp: Union[torch.Tensor, Dict[str, torch.Tensor]],
         fanouts: torch.Tensor,
         replace: bool = False,
@@ -921,68 +1044,14 @@
         return self._convert_to_sampled_subgraph(C_sampled_subgraph)
 
     def sample_negative_edges_uniform(
         self, edge_type, node_pairs, negative_ratio
     ):
         """
         Sample negative edges by randomly choosing negative source-destination
-        pairs according to a uniform distribution. For each edge ``(u, v)``,
-        it is supposed to generate `negative_ratio` pairs of negative edges
-        ``(u, v')``, where ``v'`` is chosen uniformly from all the nodes in
-        the graph. As ``u`` is exactly same as the corresponding positive edges,
-        it returns None for negative sources.
-
-        Parameters
-        ----------
-        edge_type: str
-            The type of edges in the provided node_pairs. Any negative edges
-            sampled will also have the same type. If set to None, it will be
-            considered as a homogeneous graph.
-        node_pairs : Tuple[Tensor, Tensor]
-            A tuple of two 1D tensors that represent the source and destination
-            of positive edges, with 'positive' indicating that these edges are
-            present in the graph. It's important to note that within the
-            context of a heterogeneous graph, the ids in these tensors signify
-            heterogeneous ids.
-        negative_ratio: int
-            The ratio of the number of negative samples to positive samples.
-
-        Returns
-        -------
-        Tuple[Tensor, Tensor]
-            A tuple consisting of two 1D tensors represents the source and
-            destination of negative edges. In the context of a heterogeneous
-            graph, both the input nodes and the selected nodes are represented
-            by heterogeneous IDs, and the formed edges are of the input type
-            `edge_type`. Note that negative refers to false negatives, which
-            means the edge could be present or not present in the graph.
-        """
-        if edge_type:
-            _, _, dst_ntype = etype_str_to_tuple(edge_type)
-            max_node_id = self.num_nodes[dst_ntype]
-        else:
-            max_node_id = self.total_num_nodes
-        pos_src, _ = node_pairs
-        num_negative = pos_src.size(0) * negative_ratio
-        return (
-            None,
-            torch.randint(
-                0,
-                max_node_id,
-                (num_negative,),
-                dtype=pos_src.dtype,
-                device=pos_src.device,
-            ),
-        )
-
-    def sample_negative_edges_uniform_2(
-        self, edge_type, node_pairs, negative_ratio
-    ):
-        """
-        Sample negative edges by randomly choosing negative source-destination
         edges according to a uniform distribution. For each edge ``(u, v)``,
         it is supposed to generate `negative_ratio` pairs of negative edges
         ``(u, v')``, where ``v'`` is chosen uniformly from all the nodes in
         the graph. ``u`` is exactly same as the corresponding positive edges.
         It returns positive edges concatenated with negative edges. In
         negative edges, negative sources are constructed from the
         corresponding positive edges.
```

## dgl/graphbolt/impl/in_subgraph_sampler.py

```diff
@@ -30,15 +30,15 @@
     Examples
     -------
     >>> import dgl.graphbolt as gb
     >>> import torch
     >>> indptr = torch.LongTensor([0, 3, 5, 7, 9, 12, 14])
     >>> indices = torch.LongTensor([0, 1, 4, 2, 3, 0, 5, 1, 2, 0, 3, 5, 1, 4])
     >>> graph = gb.fused_csc_sampling_graph(indptr, indices)
-    >>> item_set = gb.ItemSet(len(indptr) - 1, names="seed_nodes")
+    >>> item_set = gb.ItemSet(len(indptr) - 1, names="seeds")
     >>> item_sampler = gb.ItemSampler(item_set, batch_size=2)
     >>> insubgraph_sampler = gb.InSubgraphSampler(item_sampler, graph)
     >>> for _, data in enumerate(insubgraph_sampler):
     ...     print(data.sampled_subgraphs[0].sampled_csc)
     ...     print(data.sampled_subgraphs[0].original_row_node_ids)
     ...     print(data.sampled_subgraphs[0].original_column_node_ids)
     CSCFormatBase(indptr=tensor([0, 3, 5]),
```

## dgl/graphbolt/impl/legacy_dataset.py

```diff
@@ -29,15 +29,15 @@
 
     def _init_as_heterogeneous_node_pred(self, legacy: DGLDataset):
         def _init_item_set_dict(idx, labels):
             item_set_dict = {}
             for key in idx.keys():
                 item_set = ItemSet(
                     (idx[key], labels[key][idx[key]]),
-                    names=("seed_nodes", "labels"),
+                    names=("seeds", "labels"),
                 )
                 item_set_dict[key] = item_set
             return ItemSetDict(item_set_dict)
 
         # OGB Dataset has the idx split.
         if hasattr(legacy, "get_idx_split"):
             graph, labels = legacy[0]
@@ -54,15 +54,15 @@
             test_set = _init_item_set_dict(split_idx["test"], labels)
             task = OnDiskTask(metadata, train_set, validation_set, test_set)
             tasks.append(task)
             self._tasks = tasks
 
             item_set_dict = {}
             for ntype in graph.ntypes:
-                item_set = ItemSet(graph.num_nodes(ntype), names="seed_nodes")
+                item_set = ItemSet(graph.num_nodes(ntype), names="seeds")
                 item_set_dict[ntype] = item_set
             self._all_nodes_set = ItemSetDict(item_set_dict)
 
             features = {}
             for ntype in graph.ntypes:
                 for name in graph.nodes[ntype].data.keys():
                     tensor = graph.nodes[ntype].data[name]
@@ -96,29 +96,29 @@
             "name": "node_classification",
         }
         train_labels = legacy[0].ndata["label"][legacy.train_idx]
         validation_labels = legacy[0].ndata["label"][legacy.val_idx]
         test_labels = legacy[0].ndata["label"][legacy.test_idx]
         train_set = ItemSet(
             (legacy.train_idx, train_labels),
-            names=("seed_nodes", "labels"),
+            names=("seeds", "labels"),
         )
         validation_set = ItemSet(
             (legacy.val_idx, validation_labels),
-            names=("seed_nodes", "labels"),
+            names=("seeds", "labels"),
         )
         test_set = ItemSet(
-            (legacy.test_idx, test_labels), names=("seed_nodes", "labels")
+            (legacy.test_idx, test_labels), names=("seeds", "labels")
         )
         task = OnDiskTask(metadata, train_set, validation_set, test_set)
         tasks.append(task)
         self._tasks = tasks
 
         num_nodes = legacy[0].num_nodes()
-        self._all_nodes_set = ItemSet(num_nodes, names="seed_nodes")
+        self._all_nodes_set = ItemSet(num_nodes, names="seeds")
         features = {}
         for name in legacy[0].ndata.keys():
             tensor = legacy[0].ndata[name]
             if tensor.dim() == 1:
                 tensor = tensor.view(-1, 1)
             features[("node", None, name)] = TorchBasedFeature(tensor)
         for name in legacy[0].edata.keys():
```

## dgl/graphbolt/impl/neighbor_sampler.py

```diff
@@ -42,85 +42,73 @@
         if executor is None:
             self.executor = ThreadPoolExecutor(max_workers=1)
         else:
             self.executor = executor
 
     def _fetch_per_layer_impl(self, minibatch, stream):
         with torch.cuda.stream(self.stream):
-            index = minibatch._seed_nodes
-            if isinstance(index, dict):
-                for idx in index.values():
+            seeds = minibatch._seed_nodes
+            is_hetero = isinstance(seeds, dict)
+            if is_hetero:
+                for idx in seeds.values():
                     idx.record_stream(torch.cuda.current_stream())
-                index = self.graph._convert_to_homogeneous_nodes(index)
+                (
+                    seeds,
+                    seed_offsets,
+                ) = self.graph._convert_to_homogeneous_nodes(seeds)
             else:
-                index.record_stream(torch.cuda.current_stream())
+                seeds.record_stream(torch.cuda.current_stream())
+                seed_offsets = None
 
             def record_stream(tensor):
                 if stream is not None and tensor.is_cuda:
                     tensor.record_stream(stream)
                 return tensor
 
-            if self.graph.node_type_offset is None:
-                # sorting not needed.
-                minibatch._subgraph_seed_nodes = None
-            else:
-                index, original_positions = index.sort()
-                if (original_positions.diff() == 1).all().item():
-                    # already sorted.
-                    minibatch._subgraph_seed_nodes = None
-                else:
-                    minibatch._subgraph_seed_nodes = record_stream(
-                        original_positions.sort()[1]
-                    )
             index_select_csc_with_indptr = partial(
                 torch.ops.graphbolt.index_select_csc, self.graph.csc_indptr
             )
 
             indptr, indices = index_select_csc_with_indptr(
-                self.graph.indices, index, None
+                self.graph.indices, seeds, None
             )
             record_stream(indptr)
             record_stream(indices)
             output_size = len(indices)
             if self.graph.type_per_edge is not None:
                 _, type_per_edge = index_select_csc_with_indptr(
-                    self.graph.type_per_edge, index, output_size
+                    self.graph.type_per_edge, seeds, output_size
                 )
                 record_stream(type_per_edge)
             else:
                 type_per_edge = None
             if self.graph.edge_attributes is not None:
                 probs_or_mask = self.graph.edge_attributes.get(
                     self.prob_name, None
                 )
                 if probs_or_mask is not None:
                     _, probs_or_mask = index_select_csc_with_indptr(
-                        probs_or_mask, index, output_size
+                        probs_or_mask, seeds, output_size
                     )
                     record_stream(probs_or_mask)
             else:
                 probs_or_mask = None
-            if self.graph.node_type_offset is not None:
-                node_type_offset = torch.searchsorted(
-                    index, self.graph.node_type_offset
-                )
-            else:
-                node_type_offset = None
             subgraph = fused_csc_sampling_graph(
                 indptr,
                 indices,
-                node_type_offset=node_type_offset,
+                node_type_offset=self.graph.node_type_offset,
                 type_per_edge=type_per_edge,
                 node_type_to_id=self.graph.node_type_to_id,
                 edge_type_to_id=self.graph.edge_type_to_id,
             )
             if self.prob_name is not None and probs_or_mask is not None:
                 subgraph.edge_attributes = {self.prob_name: probs_or_mask}
 
-            minibatch.sampled_subgraphs.insert(0, subgraph)
+            subgraph._indptr_node_type_offset_list = seed_offsets
+            minibatch._sliced_sampling_graph = subgraph
 
             if self.stream is not None:
                 minibatch.wait = torch.cuda.current_stream().record_event().wait
 
             return minibatch
 
     def _fetch_per_layer(self, minibatch):
@@ -141,25 +129,29 @@
         super().__init__(datapipe, self._sample_per_layer_from_fetched_subgraph)
         self.sampler_name = sample_per_layer_obj.sampler.__name__
         self.fanout = sample_per_layer_obj.fanout
         self.replace = sample_per_layer_obj.replace
         self.prob_name = sample_per_layer_obj.prob_name
 
     def _sample_per_layer_from_fetched_subgraph(self, minibatch):
-        subgraph = minibatch.sampled_subgraphs[0]
-
+        subgraph = minibatch._sliced_sampling_graph
+        delattr(minibatch, "_sliced_sampling_graph")
+        kwargs = {
+            key[1:]: getattr(minibatch, key)
+            for key in ["_random_seed", "_seed2_contribution"]
+            if hasattr(minibatch, key)
+        }
         sampled_subgraph = getattr(subgraph, self.sampler_name)(
-            minibatch._subgraph_seed_nodes,
+            None,
             self.fanout,
             self.replace,
             self.prob_name,
+            **kwargs,
         )
-        delattr(minibatch, "_subgraph_seed_nodes")
-        sampled_subgraph.original_column_node_ids = minibatch._seed_nodes
-        minibatch.sampled_subgraphs[0] = sampled_subgraph
+        minibatch.sampled_subgraphs.insert(0, sampled_subgraph)
 
         return minibatch
 
 
 @functional_datapipe("sample_per_layer")
 class SamplePerLayer(MiniBatchTransformer):
     """Sample neighbor edges from a graph for a single layer."""
@@ -168,16 +160,25 @@
         super().__init__(datapipe, self._sample_per_layer)
         self.sampler = sampler
         self.fanout = fanout
         self.replace = replace
         self.prob_name = prob_name
 
     def _sample_per_layer(self, minibatch):
+        kwargs = {
+            key[1:]: getattr(minibatch, key)
+            for key in ["_random_seed", "_seed2_contribution"]
+            if hasattr(minibatch, key)
+        }
         subgraph = self.sampler(
-            minibatch._seed_nodes, self.fanout, self.replace, self.prob_name
+            minibatch._seed_nodes,
+            self.fanout,
+            self.replace,
+            self.prob_name,
+            **kwargs,
         )
         minibatch.sampled_subgraphs.insert(0, subgraph)
         return minibatch
 
 
 @functional_datapipe("compact_per_layer")
 class CompactPerLayer(MiniBatchTransformer):
@@ -226,16 +227,140 @@
             sampler, stream, executor
         )
         datapipe = datapipe.buffer(buffer_size).wait_future().wait()
         datapipe = datapipe.sample_per_layer_from_fetched_subgraph(sampler)
         super().__init__(datapipe)
 
 
+class NeighborSamplerImpl(SubgraphSampler):
+    # pylint: disable=abstract-method
+    """Base class for NeighborSamplers."""
+
+    # pylint: disable=useless-super-delegation
+    def __init__(
+        self,
+        datapipe,
+        graph,
+        fanouts,
+        replace,
+        prob_name,
+        deduplicate,
+        sampler,
+        layer_dependency=None,
+        batch_dependency=None,
+    ):
+        if sampler.__name__ == "sample_layer_neighbors":
+            self._init_seed(batch_dependency)
+        super().__init__(
+            datapipe,
+            graph,
+            fanouts,
+            replace,
+            prob_name,
+            deduplicate,
+            sampler,
+            layer_dependency,
+        )
+
+    def _init_seed(self, batch_dependency):
+        self.rng = torch.random.manual_seed(
+            torch.randint(0, int(1e18), size=tuple())
+        )
+        self.cnt = [-1, int(batch_dependency)]
+        self.random_seed = torch.empty(
+            2 if self.cnt[1] > 1 else 1, dtype=torch.int64
+        )
+        self.random_seed.random_(generator=self.rng)
+
+    def _set_seed(self, minibatch):
+        self.cnt[0] += 1
+        if self.cnt[1] > 0 and self.cnt[0] % self.cnt[1] == 0:
+            self.random_seed[0] = self.random_seed[-1]
+            self.random_seed[-1:].random_(generator=self.rng)
+        minibatch._random_seed = self.random_seed.clone()
+        minibatch._seed2_contribution = (
+            0.0
+            if self.cnt[1] <= 1
+            else (self.cnt[0] % self.cnt[1]) / self.cnt[1]
+        )
+        minibatch._iter = self.cnt[0]
+        return minibatch
+
+    @staticmethod
+    def _increment_seed(minibatch):
+        minibatch._random_seed = 1 + minibatch._random_seed
+        return minibatch
+
+    @staticmethod
+    def _delattr_dependency(minibatch):
+        delattr(minibatch, "_random_seed")
+        delattr(minibatch, "_seed2_contribution")
+        return minibatch
+
+    @staticmethod
+    def _prepare(node_type_to_id, minibatch):
+        seeds = minibatch._seed_nodes
+        # Enrich seeds with all node types.
+        if isinstance(seeds, dict):
+            ntypes = list(node_type_to_id.keys())
+            # Loop over different seeds to extract the device they are on.
+            device = None
+            dtype = None
+            for _, seed in seeds.items():
+                device = seed.device
+                dtype = seed.dtype
+                break
+            default_tensor = torch.tensor([], dtype=dtype, device=device)
+            seeds = {
+                ntype: seeds.get(ntype, default_tensor) for ntype in ntypes
+            }
+        minibatch._seed_nodes = seeds
+        minibatch.sampled_subgraphs = []
+        return minibatch
+
+    @staticmethod
+    def _set_input_nodes(minibatch):
+        minibatch.input_nodes = minibatch._seed_nodes
+        return minibatch
+
+    # pylint: disable=arguments-differ
+    def sampling_stages(
+        self,
+        datapipe,
+        graph,
+        fanouts,
+        replace,
+        prob_name,
+        deduplicate,
+        sampler,
+        layer_dependency,
+    ):
+        datapipe = datapipe.transform(
+            partial(self._prepare, graph.node_type_to_id)
+        )
+        is_labor = sampler.__name__ == "sample_layer_neighbors"
+        if is_labor:
+            datapipe = datapipe.transform(self._set_seed)
+        for fanout in reversed(fanouts):
+            # Convert fanout to tensor.
+            if not isinstance(fanout, torch.Tensor):
+                fanout = torch.LongTensor([int(fanout)])
+            datapipe = datapipe.sample_per_layer(
+                sampler, fanout, replace, prob_name
+            )
+            datapipe = datapipe.compact_per_layer(deduplicate)
+            if is_labor and not layer_dependency:
+                datapipe = datapipe.transform(self._increment_seed)
+        if is_labor:
+            datapipe = datapipe.transform(self._delattr_dependency)
+        return datapipe.transform(self._set_input_nodes)
+
+
 @functional_datapipe("sample_neighbor")
-class NeighborSampler(SubgraphSampler):
+class NeighborSampler(NeighborSamplerImpl):
     # pylint: disable=abstract-method
     """Sample neighbor edges from a graph and return a subgraph.
 
     Functional name: :obj:`sample_neighbor`.
 
     Neighbor sampler is responsible for sampling a subgraph from given data. It
     returns an induced subgraph along with compacted information. In the
@@ -278,16 +403,16 @@
     Examples
     -------
     >>> import torch
     >>> import dgl.graphbolt as gb
     >>> indptr = torch.LongTensor([0, 2, 4, 5, 6, 7 ,8])
     >>> indices = torch.LongTensor([1, 2, 0, 3, 5, 4, 3, 5])
     >>> graph = gb.fused_csc_sampling_graph(indptr, indices)
-    >>> node_pairs = torch.LongTensor([[0, 1], [1, 2]])
-    >>> item_set = gb.ItemSet(node_pairs, names="node_pairs")
+    >>> seeds = torch.LongTensor([[0, 1], [1, 2]])
+    >>> item_set = gb.ItemSet(seeds, names="seeds")
     >>> datapipe = gb.ItemSampler(item_set, batch_size=1)
     >>> datapipe = datapipe.sample_uniform_negative(graph, 2)
     >>> datapipe = datapipe.sample_neighbor(graph, [5, 10, 15])
     >>> next(iter(datapipe)).sampled_subgraphs
     [SampledSubgraphImpl(sampled_csc=CSCFormatBase(
             indptr=tensor([0, 2, 4, 5, 6, 7, 8]),
             indices=tensor([1, 4, 0, 5, 5, 3, 3, 2]),
@@ -319,78 +444,37 @@
         self,
         datapipe,
         graph,
         fanouts,
         replace=False,
         prob_name=None,
         deduplicate=True,
-        sampler=None,
     ):
-        if sampler is None:
-            sampler = graph.sample_neighbors
         super().__init__(
-            datapipe, graph, fanouts, replace, prob_name, deduplicate, sampler
-        )
-
-    @staticmethod
-    def _prepare(node_type_to_id, minibatch):
-        seeds = minibatch._seed_nodes
-        # Enrich seeds with all node types.
-        if isinstance(seeds, dict):
-            ntypes = list(node_type_to_id.keys())
-            # Loop over different seeds to extract the device they are on.
-            device = None
-            dtype = None
-            for _, seed in seeds.items():
-                device = seed.device
-                dtype = seed.dtype
-                break
-            default_tensor = torch.tensor([], dtype=dtype, device=device)
-            seeds = {
-                ntype: seeds.get(ntype, default_tensor) for ntype in ntypes
-            }
-        minibatch._seed_nodes = seeds
-        minibatch.sampled_subgraphs = []
-        return minibatch
-
-    @staticmethod
-    def _set_input_nodes(minibatch):
-        minibatch.input_nodes = minibatch._seed_nodes
-        return minibatch
-
-    # pylint: disable=arguments-differ
-    def sampling_stages(
-        self, datapipe, graph, fanouts, replace, prob_name, deduplicate, sampler
-    ):
-        datapipe = datapipe.transform(
-            partial(self._prepare, graph.node_type_to_id)
+            datapipe,
+            graph,
+            fanouts,
+            replace,
+            prob_name,
+            deduplicate,
+            graph.sample_neighbors,
         )
-        for fanout in reversed(fanouts):
-            # Convert fanout to tensor.
-            if not isinstance(fanout, torch.Tensor):
-                fanout = torch.LongTensor([int(fanout)])
-            datapipe = datapipe.sample_per_layer(
-                sampler, fanout, replace, prob_name
-            )
-            datapipe = datapipe.compact_per_layer(deduplicate)
-
-        return datapipe.transform(self._set_input_nodes)
 
 
 @functional_datapipe("sample_layer_neighbor")
-class LayerNeighborSampler(NeighborSampler):
+class LayerNeighborSampler(NeighborSamplerImpl):
     # pylint: disable=abstract-method
     """Sample layer neighbor edges from a graph and return a subgraph.
 
     Functional name: :obj:`sample_layer_neighbor`.
 
     Sampler that builds computational dependency of node representations via
     labor sampling for multilayer GNN from the NeurIPS 2023 paper
     `Layer-Neighbor Sampling -- Defusing Neighborhood Explosion in GNNs
-    <https://arxiv.org/abs/2210.13339>`__
+    <https://proceedings.neurips.cc/paper_files/paper/2023/file/51f9036d5e7ae822da8f6d4adda1fb39-Paper-Conference.pdf>`__
 
     Layer-Neighbor sampler is responsible for sampling a subgraph from given
     data. It returns an induced subgraph along with compacted information. In
     the context of a node classification task, the neighbor sampler directly
     utilizes the nodes provided as seed nodes. However, in scenarios involving
     link prediction, the process needs another pre-process operation. That is,
     gathering unique nodes from the given node pairs, encompassing both
@@ -425,24 +509,37 @@
         probabilities corresponding to each neighboring edge of a node.
         It must be a 1D floating-point or boolean tensor, with the number
         of elements equalling the total number of edges.
     deduplicate: bool
         Boolean indicating whether seeds between hops will be deduplicated.
         If True, the same elements in seeds will be deleted to only one.
         Otherwise, the same elements will be remained.
+    layer_dependency: bool
+        Boolean indicating whether different layers should use the same random
+        variates. Results in a reduction in the number of nodes sampled and
+        turns LayerNeighborSampler into a subgraph sampling method. Later layers
+        will be guaranteed to sample overlapping neighbors as the previous
+        layers.
+    batch_dependency: int
+        Specifies whether consecutive minibatches should use similar random
+        variates. Results in a higher temporal access locality of sampled
+        nodes and edges. Setting it to :math:`\\kappa` slows down the change in
+        the random variates proportional to :math:`\\frac{1}{\\kappa}`. Implements
+        the dependent minibatching approach in `arXiv:2310.12403
+        <https://arxiv.org/abs/2310.12403>`__.
 
     Examples
     -------
     >>> import dgl.graphbolt as gb
     >>> import torch
     >>> indptr = torch.LongTensor([0, 2, 4, 5, 6, 7 ,8])
     >>> indices = torch.LongTensor([1, 2, 0, 3, 5, 4, 3, 5])
     >>> graph = gb.fused_csc_sampling_graph(indptr, indices)
-    >>> node_pairs = torch.LongTensor([[0, 1], [1, 2]])
-    >>> item_set = gb.ItemSet(node_pairs, names="node_pairs")
+    >>> seeds = torch.LongTensor([[0, 1], [1, 2]])
+    >>> item_set = gb.ItemSet(seeds, names="seeds")
     >>> item_sampler = gb.ItemSampler(item_set, batch_size=1,)
     >>> neg_sampler = gb.UniformNegativeSampler(item_sampler, graph, 2)
     >>> fanouts = [torch.LongTensor([5]),
     ...     torch.LongTensor([10]),torch.LongTensor([15])]
     >>> subgraph_sampler = gb.LayerNeighborSampler(neg_sampler, graph, fanouts)
     >>> next(iter(subgraph_sampler)).sampled_subgraphs
     [SampledSubgraphImpl(sampled_csc=CSCFormatBase(
@@ -465,29 +562,37 @@
             indptr=tensor([0, 2, 4, 5, 6]),
             indices=tensor([1, 3, 0, 4, 2, 2]),
         ),
         original_row_node_ids=tensor([0, 1, 5, 2, 3]),
         original_edge_ids=None,
         original_column_node_ids=tensor([0, 1, 5, 2]),
     )]
-    >>> next(iter(subgraph_sampler)).compacted_node_pairs
-    (tensor([0]), tensor([1]))
+    >>> next(iter(subgraph_sampler)).compacted_seeds
+    tensor([[0, 1], [0, 2], [0, 3]])
+    >>> next(iter(subgraph_sampler)).labels
+    tensor([1., 0., 0.])
+    >>> next(iter(subgraph_sampler)).indexes
+    tensor([0, 0, 0])
     """
 
     def __init__(
         self,
         datapipe,
         graph,
         fanouts,
         replace=False,
         prob_name=None,
         deduplicate=True,
+        layer_dependency=False,
+        batch_dependency=1,
     ):
         super().__init__(
             datapipe,
             graph,
             fanouts,
             replace,
             prob_name,
             deduplicate,
             graph.sample_layer_neighbors,
+            layer_dependency,
+            batch_dependency,
         )
```

## dgl/graphbolt/impl/ondisk_dataset.py

```diff
@@ -38,19 +38,15 @@
     OnDiskTVTSet,
 )
 from .torch_based_feature_store import TorchBasedFeatureStore
 
 __all__ = ["OnDiskDataset", "preprocess_ondisk_dataset", "BuiltinDataset"]
 
 NAMES_INDICATING_NODE_IDS = [
-    "seed_nodes",
-    "node_pairs",
     "seeds",
-    "negative_srcs",
-    "negative_dsts",
 ]
 
 
 def _graph_data_to_fused_csc_sampling_graph(
     dataset_dir: str,
     graph_data: Dict,
     include_original_edge_id: bool,
@@ -632,36 +628,36 @@
             path: edge_data/author-writes-paper-feat.npy
         tasks:
           - name: "edge_classification"
             num_classes: 10
             train_set:
               - type: paper # could be omitted for homogeneous graph.
                 data: # multiple data sources could be specified.
-                  - name: node_pairs
+                  - name: seeds
                     format: numpy # Can be numpy or torch.
                     in_memory: true # If not specified, default to true.
-                    path: set/paper-train-node_pairs.npy
+                    path: set/paper-train-seeds.npy
                   - name: labels
                     format: numpy
                     path: set/paper-train-labels.npy
             validation_set:
               - type: paper
                 data:
-                  - name: node_pairs
+                  - name: seeds
                     format: numpy
-                    path: set/paper-validation-node_pairs.npy
+                    path: set/paper-validation-seeds.npy
                   - name: labels
                     format: numpy
                     path: set/paper-validation-labels.npy
             test_set:
               - type: paper
                 data:
-                  - name: node_pairs
+                  - name: seeds
                     format: numpy
-                    path: set/paper-test-node_pairs.npy
+                    path: set/paper-test-seeds.npy
                   - name: labels
                     format: numpy
                     path: set/paper-test-labels.npy
 
     Parameters
     ----------
     path: str
@@ -873,44 +869,44 @@
                 tuple(
                     read_data(data.path, data.format, data.in_memory)
                     for data in tvt_set[0].data
                 ),
                 names=tuple(data.name for data in tvt_set[0].data),
             )
         else:
-            data = {}
+            itemsets = {}
             for tvt in tvt_set:
-                data[tvt.type] = ItemSet(
+                itemsets[tvt.type] = ItemSet(
                     tuple(
                         read_data(data.path, data.format, data.in_memory)
                         for data in tvt.data
                     ),
                     names=tuple(data.name for data in tvt.data),
                 )
-            ret = ItemSetDict(data)
+            ret = ItemSetDict(itemsets)
         return ret
 
     def _init_all_nodes_set(self, graph) -> Union[ItemSet, ItemSetDict]:
         if graph is None:
             dgl_warning(
                 "`all_nodes_set` is returned as None, since graph is None."
             )
             return None
         num_nodes = graph.num_nodes
         dtype = graph.indices.dtype
         if isinstance(num_nodes, int):
             return ItemSet(
                 torch.tensor(num_nodes, dtype=dtype),
-                names="seed_nodes",
+                names="seeds",
             )
         else:
             data = {
                 node_type: ItemSet(
                     torch.tensor(num_node, dtype=dtype),
-                    names="seed_nodes",
+                    names="seeds",
                 )
                 for node_type, num_node in num_nodes.items()
             }
             return ItemSetDict(data)
 
 
 class BuiltinDataset(OnDiskDataset):
@@ -992,23 +988,38 @@
     # Otherwise, we use the accelerated url.
     _base_url = "https://data.dgl.ai/dataset/graphbolt/"
     _accelerated_url = (
         "https://dgl-data.s3-accelerate.amazonaws.com/dataset/graphbolt/"
     )
     _datasets = [
         "cora",
+        "cora-seeds",
         "ogbn-mag",
+        "ogbn-mag-seeds",
         "ogbl-citation2",
+        "ogbl-citation2-seeds",
         "ogbn-products",
+        "ogbn-products-seeds",
         "ogbn-arxiv",
+        "ogbn-arxiv-seeds",
+    ]
+    _large_datasets = [
+        "ogb-lsc-mag240m",
+        "ogb-lsc-mag240m-seeds",
+        "ogbn-papers100M",
+        "ogbn-papers100M-seeds",
     ]
-    _large_datasets = ["ogb-lsc-mag240m", "ogbn-papers100M"]
     _all_datasets = _datasets + _large_datasets
 
     def __init__(self, name: str, root: str = "datasets") -> OnDiskDataset:
+        # For user using DGL 2.2 or later version, we prefer them to use
+        # datasets with `seeds` suffix. This hack should be removed, when the
+        # datasets with `seeds` suffix have covered previous ones.
+        if "seeds" not in name:
+            name += "-seeds"
         dataset_dir = os.path.join(root, name)
         if not os.path.exists(dataset_dir):
             if name not in self._all_datasets:
                 raise RuntimeError(
                     f"Dataset {name} is not available. Available datasets are "
                     f"{self._all_datasets}."
                 )
```

## dgl/graphbolt/impl/temporal_neighbor_sampler.py

```diff
@@ -91,19 +91,26 @@
 
     def sample_subgraphs(self, seeds, seeds_timestamp):
         assert (
             seeds_timestamp is not None
         ), "seeds_timestamp must be provided for temporal neighbor sampling."
         subgraphs = []
         num_layers = len(self.fanouts)
-        # Enrich seeds with all node types.
+        # Enrich seeds with all node types. Ensure that the dtype and device
+        # remain consistent with those of the existing seeds.
         if isinstance(seeds, dict):
+            first_val = next(iter(seeds.items()))[1]
             ntypes = list(self.graph.node_type_to_id.keys())
             seeds = {
-                ntype: seeds.get(ntype, torch.LongTensor([]))
+                ntype: seeds.get(
+                    ntype,
+                    torch.tensor(
+                        [], dtype=first_val.dtype, device=first_val.device
+                    ),
+                )
                 for ntype in ntypes
             }
             seeds_timestamp = {
                 ntype: seeds_timestamp.get(ntype, torch.LongTensor([]))
                 for ntype in ntypes
             }
         for hop in range(num_layers):
```

## dgl/graphbolt/impl/torch_based_feature_store.py

```diff
@@ -1,22 +1,23 @@
 """Torch-based feature store for GraphBolt."""
 
 import copy
+import platform
 import textwrap
 from typing import Dict, List
 
 import numpy as np
 import torch
 
 from ..base import index_select
 from ..feature_store import Feature
 from .basic_feature_store import BasicFeatureStore
 from .ondisk_metadata import OnDiskFeatureData
 
-__all__ = ["TorchBasedFeature", "TorchBasedFeatureStore"]
+__all__ = ["TorchBasedFeature", "DiskBasedFeature", "TorchBasedFeatureStore"]
 
 
 class TorchBasedFeature(Feature):
     r"""A wrapper of pytorch based feature.
 
     Initialize a torch based feature store by a torch feature.
     Note that the feature can be either in memory or on disk.
@@ -214,14 +215,129 @@
 
     def __repr__(self) -> str:
         ret = (
             "{Classname}(\n"
             "    feature={feature},\n"
             "    metadata={metadata},\n"
             ")"
+        )
+
+        feature_str = textwrap.indent(
+            str(self._tensor), " " * len("    feature=")
+        ).strip()
+        metadata_str = textwrap.indent(
+            str(self.metadata()), " " * len("    metadata=")
+        ).strip()
+
+        return ret.format(
+            Classname=self.__class__.__name__,
+            feature=feature_str,
+            metadata=metadata_str,
+        )
+
+
+class DiskBasedFeature(Feature):
+    r"""A wrapper of disk based feature.
+
+    Initialize a disk based feature fetcher by a numpy file.
+
+    Parameters
+    ----------
+    path : string
+        The path to the numpy feature file.
+        Note that the dimension of the numpy should be greater than 1.
+    Examples
+    --------
+    >>> import torch
+    >>> from dgl import graphbolt as gb
+    >>> torch_feat = torch.arange(10).reshape(2, -1)
+    >>> pth = "path/to/feat.npy"
+    >>> np.save(pth,torch_feat)
+    >>> feature = gb.DiskBasedFeature(pth)
+    >>> feature.read(torch.tensor([0]))
+    tensor([[0, 1, 2, 3, 4]])
+    >>> feature.size()
+    torch.Size([5])
+    """
+
+    def __init__(self, path: str, metadata: Dict = None):
+        super().__init__()
+        mmap_mode = "r+"
+        ondisk_data = np.load(path, mmap_mode=mmap_mode)
+        assert ondisk_data.flags[
+            "C_CONTIGUOUS"
+        ], "DiskBasedFeature only supports C_CONTIGUOUS array."
+        self._tensor = torch.from_numpy(ondisk_data)
+
+        self._metadata = metadata
+        self._ondisk_npy_array = torch.ops.graphbolt.ondisk_npy_array(
+            path, self._tensor.dtype, torch.tensor(self._tensor.shape)
+        )
+
+    def read(self, ids: torch.Tensor = None):
+        """Read the feature by index.
+        The returned tensor will be on CPU.
+        Parameters
+        ----------
+        ids : torch.Tensor
+            The index of the feature. Only the specified indices of the
+            feature are read.
+        Returns
+        -------
+        torch.Tensor
+            The read feature.
+        """
+        if ids is None:
+            if self._tensor.is_pinned():
+                return self._tensor.cuda()
+            return self._tensor
+        elif platform.system() == "Linux":
+            try:
+                return self._ondisk_npy_array.index_select(ids.cpu()).to(
+                    ids.device
+                )
+            except RuntimeError:
+                raise IndexError
+        else:
+            return index_select(self._tensor, ids)
+
+    def size(self):
+        """Get the size of the feature.
+        Returns
+        -------
+        torch.Size
+            The size of the feature.
+        """
+        return self._tensor.size()[1:]
+
+    def update(self, value: torch.Tensor, ids: torch.Tensor = None):
+        """Disk based feature does not support update for now."""
+        raise NotImplementedError
+
+    def metadata(self):
+        """Get the metadata of the feature.
+        Returns
+        -------
+        Dict
+            The metadata of the feature.
+        """
+        return (
+            self._metadata if self._metadata is not None else super().metadata()
+        )
+
+    def read_into_memory(self) -> TorchBasedFeature:
+        """Change disk-based feature to torch-based feature."""
+        return TorchBasedFeature(self._tensor, self._metadata)
+
+    def __repr__(self) -> str:
+        ret = (
+            "{Classname}(\n"
+            "    feature={feature},\n"
+            "    metadata={metadata},\n"
+            ")"
         )
 
         feature_str = textwrap.indent(
             str(self._tensor), " " * len("    feature=")
         ).strip()
         metadata_str = textwrap.indent(
             str(self.metadata()), " " * len("    metadata=")
```

## dgl/graphbolt/impl/uniform_negative_sampler.py

```diff
@@ -32,78 +32,55 @@
 
     Examples
     --------
     >>> from dgl import graphbolt as gb
     >>> indptr = torch.LongTensor([0, 1, 2, 3, 4])
     >>> indices = torch.LongTensor([1, 2, 3, 0])
     >>> graph = gb.fused_csc_sampling_graph(indptr, indices)
-    >>> node_pairs = torch.tensor([[0, 1], [1, 2], [2, 3], [3, 0]])
-    >>> item_set = gb.ItemSet(node_pairs, names="node_pairs")
+    >>> seeds = torch.tensor([[0, 1], [1, 2], [2, 3], [3, 0]])
+    >>> item_set = gb.ItemSet(seeds, names="seeds")
     >>> item_sampler = gb.ItemSampler(
     ...     item_set, batch_size=4,)
     >>> neg_sampler = gb.UniformNegativeSampler(
     ...     item_sampler, graph, 2)
     >>> for minibatch in neg_sampler:
-    ...       print(minibatch.negative_srcs)
-    ...       print(minibatch.negative_dsts)
-    None
-    tensor([[2, 1],
-        [2, 1],
-        [3, 2],
-        [1, 3]])
+    ...       print(minibatch.seeds)
+    ...       print(minibatch.labels)
+    ...       print(minibatch.indexes)
+    tensor([[0, 1], [1, 2], [2, 3], [3, 0], [0, 1], [0, 3], [1, 1], [1, 2],
+        [2, 1], [2, 0], [3, 0], [3, 2]])
+    tensor([1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0.])
+    tensor([0, 1, 2, 3, 0, 0, 1, 1, 2, 2, 3, 3])
     """
 
     def __init__(
         self,
         datapipe,
         graph,
         negative_ratio,
     ):
         super().__init__(datapipe, negative_ratio)
         self.graph = graph
 
-    def _sample_with_etype(self, node_pairs, etype=None, use_seeds=False):
-        if use_seeds:
-            assert node_pairs.ndim == 2 and node_pairs.shape[1] == 2, (
-                "Only tensor with shape N*2 is supported for negative"
-                + f" sampling, but got {node_pairs.shape}."
-            )
-            # Sample negative edges, and concatenate positive edges with them.
-            seeds = self.graph.sample_negative_edges_uniform_2(
-                etype,
-                node_pairs,
-                self.negative_ratio,
-            )
-            # Construct indexes for all node pairs.
-            num_pos_node_pairs = node_pairs.shape[0]
-            negative_ratio = self.negative_ratio
-            pos_indexes = torch.arange(
-                0,
-                num_pos_node_pairs,
-                device=seeds.device,
-            )
-            neg_indexes = pos_indexes.repeat_interleave(negative_ratio)
-            indexes = torch.cat((pos_indexes, neg_indexes))
-            # Construct labels for all node pairs.
-            pos_num = node_pairs.shape[0]
-            neg_num = seeds.shape[0] - pos_num
-            labels = torch.cat(
-                (
-                    torch.ones(
-                        pos_num,
-                        dtype=torch.bool,
-                        device=seeds.device,
-                    ),
-                    torch.zeros(
-                        neg_num,
-                        dtype=torch.bool,
-                        device=seeds.device,
-                    ),
-                ),
-            )
-            return seeds, labels, indexes
-        else:
-            return self.graph.sample_negative_edges_uniform(
-                etype,
-                node_pairs,
-                self.negative_ratio,
-            )
+    def _sample_with_etype(self, seeds, etype=None):
+        assert seeds.ndim == 2 and seeds.shape[1] == 2, (
+            "Only tensor with shape N*2 is supported for negative"
+            + f" sampling, but got {seeds.shape}."
+        )
+        # Sample negative edges, and concatenate positive edges with them.
+        all_seeds = self.graph.sample_negative_edges_uniform(
+            etype,
+            seeds,
+            self.negative_ratio,
+        )
+        # Construct indexes for all node pairs.
+        pos_num = seeds.shape[0]
+        negative_ratio = self.negative_ratio
+        pos_indexes = torch.arange(0, pos_num, device=all_seeds.device)
+        neg_indexes = pos_indexes.repeat_interleave(negative_ratio)
+        indexes = torch.cat((pos_indexes, neg_indexes))
+        # Construct labels for all node pairs.
+        neg_num = all_seeds.shape[0] - pos_num
+        labels = torch.empty(pos_num + neg_num, device=all_seeds.device)
+        labels[:pos_num] = 1
+        labels[pos_num:] = 0
+        return all_seeds, labels, indexes
```

## dgl/graphbolt/internal/sample_utils.py

```diff
@@ -200,26 +200,27 @@
     indices = {ntype: torch.cat(nodes) for ntype, nodes in indices.items()}
 
     ntypes = set(indices.keys())
     unique_nodes = {}
     compacted_indices = {}
     dtype = list(indices.values())[0].dtype
     default_tensor = torch.tensor([], dtype=dtype, device=device)
+    indice_list = []
+    unique_dst_list = []
     for ntype in ntypes:
-        indice = indices.get(ntype, default_tensor)
-        unique_dst = unique_dst_nodes.get(ntype, default_tensor)
-        (
-            unique_nodes[ntype],
-            compacted_indices[ntype],
-            _,
-        ) = torch.ops.graphbolt.unique_and_compact(
-            indice,
-            torch.tensor([], dtype=indice.dtype, device=device),
-            unique_dst,
-        )
+        indice_list.append(indices.get(ntype, default_tensor))
+        unique_dst_list.append(unique_dst_nodes.get(ntype, default_tensor))
+    dst_list = [torch.tensor([], dtype=dtype, device=device)] * len(
+        unique_dst_list
+    )
+    results = torch.ops.graphbolt.unique_and_compact_batched(
+        indice_list, dst_list, unique_dst_list
+    )
+    for i, ntype in enumerate(ntypes):
+        unique_nodes[ntype], compacted_indices[ntype], _ = results[i]
 
     compacted_csc_formats = {}
     # Map back with the same order.
     for etype, csc_format in csc_formats.items():
         num_elem = csc_format.indices.size(0)
         src_type, _, _ = etype_str_to_tuple(etype)
         indice = compacted_indices[src_type][:num_elem]
```

## dgl/graphbolt/internal/utils.py

```diff
@@ -125,14 +125,29 @@
     else:
         # If dim of the data is 1, reshape it to n * 1 and save it to output_path.
         if is_feature and data.dim() == 1:
             data = data.reshape(-1, 1)
     save_data(data, output_path, output_format)
 
 
+def get_nonproperty_attributes(_obj) -> list:
+    """Get attributes of the class except for the properties."""
+    attributes = [
+        attribute
+        for attribute in dir(_obj)
+        if not attribute.startswith("__")
+        and (
+            not hasattr(type(_obj), attribute)
+            or not isinstance(getattr(type(_obj), attribute), property)
+        )
+        and not callable(getattr(_obj, attribute))
+    ]
+    return attributes
+
+
 def get_attributes(_obj) -> list:
     """Get attributes of the class."""
     attributes = [
         attribute
         for attribute in dir(_obj)
         if not attribute.startswith("__")
         and not callable(getattr(_obj, attribute))
```

## dgl/utils/data.py

```diff
@@ -112,15 +112,17 @@
     dst = F.tensor(dst, idtype)
     return src, dst
 
 
 SparseAdjTuple = namedtuple("SparseAdjTuple", ["format", "arrays"])
 
 
-def graphdata2tensors(data, idtype=None, bipartite=False, **kwargs):
+def graphdata2tensors(
+    data, idtype=None, bipartite=False, infer_node_count=True, **kwargs
+):
     """Function to convert various types of data to edge tensors and infer
     the number of nodes.
 
     Parameters
     ----------
     data : graph data
         Various kinds of graph data.  Possible data types are:
@@ -133,14 +135,17 @@
         - NetworkX graph
     idtype : int32, int64, optional
         Integer ID type. If None, try infer from the data and if fail use
         int64.
     bipartite : bool, optional
         Whether infer number of nodes of a bipartite graph --
         num_src and num_dst can be different.
+    infer_node_count : bool, optional
+        Whether infer number of nodes at all. If False, num_src and num_dst
+        are returned as None.
     kwargs
 
         - edge_id_attr_name : The name (str) of the edge attribute that stores the edge
           IDs in the NetworkX graph.
         - top_map : The dictionary mapping the original IDs of the source nodes to the
           new ones.
         - bottom_map : The dictionary mapping the original IDs of the destination nodes
@@ -182,31 +187,36 @@
         else:
             # convert the iterable to tensor and keep its native data type so we can check
             # its validity later
             data = SparseAdjTuple(
                 data.format, tuple(F.tensor(a) for a in data.arrays)
             )
 
+    num_src, num_dst = None, None
     if isinstance(data, SparseAdjTuple):
         if idtype is not None:
             data = SparseAdjTuple(
                 data.format, tuple(F.astype(a, idtype) for a in data.arrays)
             )
-        num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
+        if infer_node_count:
+            num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
     elif isinstance(data, list):
         src, dst = elist2tensor(data, idtype)
         data = SparseAdjTuple("coo", (src, dst))
-        num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
+        if infer_node_count:
+            num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
     elif isinstance(data, sp.sparse.spmatrix):
         # We can get scipy matrix's number of rows and columns easily.
-        num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
+        if infer_node_count:
+            num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
         data = scipy2tensor(data, idtype)
     elif isinstance(data, nx.Graph):
         # We can get networkx graph's number of sources and destinations easily.
-        num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
+        if infer_node_count:
+            num_src, num_dst = infer_num_nodes(data, bipartite=bipartite)
         edge_id_attr_name = kwargs.get("edge_id_attr_name", None)
         if bipartite:
             top_map = kwargs.get("top_map")
             bottom_map = kwargs.get("bottom_map")
             src, dst = networkxbipartite2tensors(
                 data,
                 idtype,
```

## Comparing `dgl-2.1.0.dist-info/METADATA` & `dgl-2.2.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,22 +1,24 @@
 Metadata-Version: 2.1
 Name: dgl
-Version: 2.1.0
+Version: 2.2.0
 Summary: Deep Graph Library
 Home-page: https://github.com/dmlc/dgl
 Maintainer: DGL Team
 Maintainer-email: wmjlyjemaine@gmail.com
 License: APACHE
 Platform: UNKNOWN
 Classifier: Development Status :: 3 - Alpha
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
-Requires-Dist: numpy >=1.14.0
-Requires-Dist: scipy >=1.1.0
-Requires-Dist: networkx >=2.1
-Requires-Dist: requests >=2.19.0
+Requires-Dist: numpy (>=1.14.0)
+Requires-Dist: scipy (>=1.1.0)
+Requires-Dist: networkx (>=2.1)
+Requires-Dist: requests (>=2.19.0)
 Requires-Dist: tqdm
-Requires-Dist: psutil >=5.8.0
-Requires-Dist: torchdata >=0.5.0
+Requires-Dist: psutil (>=5.8.0)
+Requires-Dist: torchdata (>=0.5.0)
+Requires-Dist: pandas
 
 UNKNOWN
 
+
```

## Comparing `dgl-2.1.0.dist-info/RECORD` & `dgl-2.2.0.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 dgl/__init__.py,sha256=CE4RYU1V6sPyEdsthgDZWUVZs_vSY7zH6k_TjKPAXoY,1696
 dgl/_api_internal.py,sha256=Tyg95icCBxd718nz5rYx4mRB0_sj2PsL4B5GRfD_Bt4,35
 dgl/_sparse_ops.py,sha256=QcUxGFptmKAUFNDjcyTekb1cjO1-eQwJbUoE7RlOwkw,32827
 dgl/base.py,sha256=qZoCrT2SdG_cop-6-hx4r0PE2yU6t2oLhcpzmwepNjQ,1608
 dgl/batch.py,sha256=S6TfrO9N-9T2TEc0hK-uUNcznA6UgmQjEo6mHM7ryF0,18719
 dgl/container.py,sha256=rnyUzhjn5DmJaj1GVMziVBk-GKHUeCMltwa3KUraMzE,2993
-dgl/convert.py,sha256=9onUBEvFH2U6VgaUN-AJPnI32Q7j3yL8Iad9H5oC_iA,80379
+dgl/convert.py,sha256=mt2erqtlzY6Uq6J06n4N_ZQovHCp7QZzPh_QJHOoBB0,80695
 dgl/core.py,sha256=FqQM9pSfUYlxhv0jzyMe8RTaZNmyaBSStXYACOMUH64,14371
 dgl/frame.py,sha256=IPcTEeMI8hWAyy_UR7cl7qyTcSHN1Ik7ZaXQOn8nKL8,33811
 dgl/generators.py,sha256=fAfRbaNwtJXxlfZFUxvUgy0IlQHpPD5KO0y3fRvz2L4,4264
 dgl/global_config.py,sha256=HjsjJ0QcNOqxde7tfx2PB8Keo-il8UcVNKDtRVTxpHU,813
 dgl/graph_index.py,sha256=3RyEBPYhuCcGl1agPF1SOyGMw63epMj9zwhbFV3Xltw,38125
 dgl/heterograph.py,sha256=NPGCb5lZ97R9orA9GPjztcss1kPAr0OK9QyPtnZXm54,244965
 dgl/heterograph_index.py,sha256=TgTJswl4kJ7jHgau7S68lK09kPc4sfUy7eB6E0X01yE,48047
 dgl/homophily.py,sha256=DuMlBXb5oFigFaYN0CXpmi_4IpLHIj0Fj3zRqwpogwM,8309
 dgl/init.py,sha256=3WIDzQ70_irbVOZrNyJ1CZi6eQf4lJgW_WFK7rQA1rg,1823
 dgl/label_informativeness.py,sha256=0DkfOovT5K4VXYP3x-W_7Xj0FIq5iW9WFzi2X9Di_1I,8245
-dgl/libdgl.so,sha256=hZgB_mXmdaL_gdmMGveDam_4e5G81sfaHQHDihnMdpI,9024609
+dgl/libdgl.dylib,sha256=HsK5sATG2lFJ5mM7F7TODRil8Yo5AxvSJj6FMqUJEsM,9498864
 dgl/logging.py,sha256=BclCEBQU70kUSI323CdxoQQO4F3Vq7tZ-sH94E0vkWs,863
 dgl/merge.py,sha256=-vfMvedO8DEKzx-pOqu55EPMvPzadPfcmF6lQwqILAY,3741
 dgl/ndarray.py,sha256=InigWGtXVChTwB3voOoyEsktunefmZuc54jsLXVD_wQ,6524
 dgl/partition.py,sha256=8Y_g8iQoGfljjVxrzfcLGxqhH3Kd8lNUa4hah0uKtfw,24432
 dgl/propagate.py,sha256=cFlfIZ7xjSwUOJaNyjLfu-Rt0X-1RSWwyevteccuCCQ,5788
 dgl/random.py,sha256=IK0PZNn6d-v-UoUbAjr0sBhDape7Rn717cDZERD_gNE,2725
 dgl/readout.py,sha256=DOYM6E65PWRPyHLAeSt7dxfLcwO0h9WzeyPP8xemLc4,29015
@@ -27,39 +27,39 @@
 dgl/traversal.py,sha256=iImvKRh3Nr095CthzqqHnhaaXEalvlJVF3_bbkZ-19Q,10086
 dgl/udf.py,sha256=UwbpDvuDz52oc3O-x7iN2lhh9ch4QAjdvd_cZwkOQqw,12633
 dgl/view.py,sha256=5q87aGbgdGuLpuKNXjaY3vuBrDnmAxRQtOuAR9cUndM,8741
 dgl/_ffi/__init__.py,sha256=iL6be84mN7ugukvO__rYZ6QYpATtkgV4NvABp5vJ-bE,350
 dgl/_ffi/base.py,sha256=VftA03rs-vmwnvaGAxgkAHC4eEVPQ-ckTAZaL6o5GhM,3982
 dgl/_ffi/capi.py,sha256=H08pVFffvbXS9Z-7TTo-5noabvRa4eBe113-f6xDIxQ,123
 dgl/_ffi/function.py,sha256=0Ns2azgMPHDCsGwM0zEQ991iYMYYS5UXoN51IbaR2hU,9350
-dgl/_ffi/libinfo.py,sha256=FOw6Smlg4tZMVc-pRXsB4gXZDvMsSM_qBEjspeRZ_pg,3255
+dgl/_ffi/libinfo.py,sha256=w49-IkdaQbA8XqWpe1e5c2MjbQh_jqnn-BXTJ_wWTqI,3239
 dgl/_ffi/ndarray.py,sha256=GxEwtk8ubiwgxyrk-nZjT0nlvwAjWOIKXZN7wywCb-Q,12436
 dgl/_ffi/object.py,sha256=jz-JoiZoyvaqpFIcVCazgg2UufcMjghOi3hE6paENx4,3750
 dgl/_ffi/object_generic.py,sha256=DQmUnAmBBSt3ZD2hS3yGoPrLE8QlgpPvaP-8Spa1iCU,1622
 dgl/_ffi/runtime_ctypes.py,sha256=O4JJLGzFYVjWNu1o-0vpzdAJifgX4BPxM-O1Zv3d73c,7253
 dgl/_ffi/streams.py,sha256=CNjS2p5J6sKRcdSrQ1YzBHdAtTxzyCz3EuZU9NaFPU8,1126
 dgl/_ffi/_ctypes/__init__.py,sha256=MaHmc-jEIpozRSG9f8NDZ85apbg69a1Zx2jfYSKA3iE,44
 dgl/_ffi/_ctypes/function.py,sha256=CoTY02J-IM6--RqlWLrVymWWjr456NQR1J4lNyOJ0kY,9417
 dgl/_ffi/_ctypes/ndarray.py,sha256=LZVuer5MPNDn_cGSO4Qw5yraXg9QY4DVMDRdAgjuwcg,4229
 dgl/_ffi/_ctypes/object.py,sha256=PJ8FDOTOE-ooIr3fUMLHxL0D3ZNJBvWE9L8YnRvN8WA,3153
 dgl/_ffi/_ctypes/types.py,sha256=ePo7LzfvbBdTv-0FL-tYH9KwVPx54q9cOMdD1QrV2vw,2338
 dgl/_ffi/_cy2/__init__.py,sha256=bRydCazovWKmvE9pMp-ePEAOrowmCimHmwi_06d3kg0,24
 dgl/_ffi/_cy3/__init__.py,sha256=8BeIXQdCkzXQHHqf5pc6ckzNO5WTM7F59u8DNPHZYCI,24
-dgl/_ffi/_cy3/core.cpython-39-aarch64-linux-gnu.so,sha256=yNSVvF6VpUU0d5qboGQKqigdPZa7De9n_B4AT7FF_GU,1304544
-dgl/_ffi/_cython/core.cpp,sha256=uckih_s7AvaPz68yUUtvWrn1hBmW2Tf87Ejhf6QUZy0,824696
+dgl/_ffi/_cy3/core.cpython-39-darwin.so,sha256=6PSXkxmo4sicF7s_OObRlyYWjEc0pRiY5MDMeGW3EDU,207656
+dgl/_ffi/_cython/core.cpp,sha256=Ipgzt74kTWnsMj6_e0idQr8fG_fPDR8N7_K9HczatJs,580421
 dgl/backend/__init__.py,sha256=L3qblGTEGsiqN86bNqbv-PbCft6Yl0o9e_Xq85-A2X8,4465
 dgl/backend/backend.py,sha256=Gxl1SeEasWQvJWfLEi3AjUg2QUl1krDwVU97g-YS3e0,47280
 dgl/backend/set_default_backend.py,sha256=6LwrrEn9vS7oMJEgevR-1mRYAkuT5hAGGSzrMQVIhQM,1063
 dgl/backend/mxnet/__init__.py,sha256=yntGFDU84B6paQMWUDsTrjL_ombpL1QaUGYClRmxseY,44
 dgl/backend/mxnet/sparse.py,sha256=CKa-wo5zKo3LClbtZsuZw_RAYwwV061RGOsLOHE2Z_U,17803
 dgl/backend/mxnet/sparse_optim.py,sha256=ZhVtIPD3xr9jgv5wQfzMrT9fyqxQmK3Y5ZL76AlxFHI,50
 dgl/backend/mxnet/tensor.py,sha256=UEDHimnvXRf47rpniKcBRFBTK5XZDkc3p8hCi5MeAqI,13279
 dgl/backend/pytorch/__init__.py,sha256=yntGFDU84B6paQMWUDsTrjL_ombpL1QaUGYClRmxseY,44
 dgl/backend/pytorch/sparse.py,sha256=LR73t-DEwo1lU9T1GBMfwI2nIVIn32JUCerYB6fifH4,40333
-dgl/backend/pytorch/tensor.py,sha256=V8J72-Fxv3JhXr0catb6f0E3I492CGU9ZcKI5E3Sx1s,12203
+dgl/backend/pytorch/tensor.py,sha256=C0Ew2v1THcB8ct7jDXDghJgOfkf7M8DMZHWskXcFauI,12201
 dgl/backend/tensorflow/__init__.py,sha256=4VEZgXoof_BiAR1IATE52uMbrL5KT8qC3UU_kxmFdVU,105
 dgl/backend/tensorflow/sparse.py,sha256=GSqqmM-8cYovFAbubJyULFMvdq3tVBaP97zDpxiru_A,13781
 dgl/backend/tensorflow/sparse_optim.py,sha256=4hAXfbQqWMvsY8Q5IYIfTYyUxLHQ2XZxqWg-vxvlY-E,55
 dgl/backend/tensorflow/tensor.py,sha256=ssFS4GJvFjgOn6VDVGTidyRwJQo_kQe2Y36v6wZi_6s,14521
 dgl/cuda/__init__.py,sha256=akSfECXtWGn26Z7tyw5rWvRAVa4SQSH75PH470EUK_Y,150
 dgl/cuda/gpu_cache.py,sha256=6Ilb-gIwts9yHKvwCC4atxu6FAFWaz5a0NlzHF5wXjg,2854
 dgl/cuda/nccl.py,sha256=ASYiVt_OHON-k1M48o9RBGIZMWL3gj0H9YXVL-42_8w,6801
@@ -96,15 +96,15 @@
 dgl/data/rdf.py,sha256=p0hRz1lNZqr9-apCRkx7XI6t3F74JMmuY9QvS4iRcH0,36099
 dgl/data/reddit.py,sha256=QJJPZBRwgEfxsn5uuRmit8MERBpl5MHZXCx6jrBObnk,7109
 dgl/data/sbm.py,sha256=66P0KU4rWbSXAA3KQo_Z7d4TeZF0dP0UvweBAvC5ASM,8508
 dgl/data/superpixel.py,sha256=Gjg-ICIui5epsZIT5sO_4bQWRICj8lEX5XQS10zIkos,13298
 dgl/data/synthetic.py,sha256=tuKuNoDwAzJIHMc96ALs1hM8s-PlgK5c3iPwZb588_g,27587
 dgl/data/tensor_serialize.py,sha256=cuoCLUeXJlIyoRZ4347tfqQ-Xj4l3QcnKt3_QbbDw90,1883
 dgl/data/tree.py,sha256=qtlQ549QfCVda6FkTcWb7g4wcJgc-lB130aNO_gNvx8,9293
-dgl/data/tu.py,sha256=G4aC1mx99UTi1qwIZUEviyLjD2WxBAycbASaQ_-aAm0,18212
+dgl/data/tu.py,sha256=bupRCUN16-9BILMLfF0jNPz6OaA_yuPHsUYsUdKt_rk,18213
 dgl/data/utils.py,sha256=0_iH_xThXZx4QrNuPSVDbtTb-7fx46WdLtHMRWpi3js,22314
 dgl/data/wikics.py,sha256=LiB71UpG5gNYYZHcezWcDFx4RNOimF3mRc9OBi0O8QM,5893
 dgl/data/yelp.py,sha256=nPLQ_18XKCVPmuNw7ejYmKVCFBO5hlqUg0EeYTyjAQI,5227
 dgl/data/zinc.py,sha256=BZNGCpkoqnMV7quDLP6x9GQY8jhH7YWpF0brhdHjPGc,3695
 dgl/dataloading/__init__.py,sha256=shBZJikO_gS2vc9onnOq83gYukvHQe_Mzdt4yEQqRHU,399
 dgl/dataloading/base.py,sha256=IihO1RKAkJtmpc4lIL6RNh1y1Q-Z6wXGXNN6-N2RrrY,24179
 dgl/dataloading/cluster_gcn.py,sha256=ysoFAjyiOHLtcjr2WzyJ0KzVIaMM1BIqX6VGPXZT9go,5741
@@ -112,49 +112,47 @@
 dgl/dataloading/dist_dataloader.py,sha256=4dy52qg986iWF7AYruL6RZnMsu2WgHksYUb3Rpt8R-M,26307
 dgl/dataloading/graphsaint.py,sha256=9c6ezyPlg-6lmE6JQIeYW5NvsphYJyQTdomhc4xYvWA,5955
 dgl/dataloading/labor_sampler.py,sha256=2N6dHP0Yr9w6TagBbIGdO_Q-wg9tVNVwmLe1e9-JgEg,11316
 dgl/dataloading/negative_sampler.py,sha256=cNnOgq1JCLwN6MRV4rXmqf2hrx3xbLKACtd7xC3eoXc,4347
 dgl/dataloading/neighbor_sampler.py,sha256=TLFa-bEeW84wxsUPqwLMkOoVdpnY9dF-7QOWbnAPKiw,9889
 dgl/dataloading/shadow.py,sha256=F5WdJlXNrWsfD7ml7QvRFylNPJxWWkKA1vd4erHQMDw,5215
 dgl/dataloading/spot_target.py,sha256=go411we_IhyRaj0fW0pGdgXHwH63nKtugtt05qIkVCg,3542
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.0.0.so,sha256=c3B5osVAdYXnrS7-EoPkWQxwPtqmQVh_dwmCIAMrWZk,883560
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.0.1.so,sha256=y774bidzzKCE8rjD4_rg_P2kMPYUD7aNJ9Fs7PaMX3A,883560
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.0.so,sha256=y_faWHJGdZZETS1j6RM2ANLJgCHmCrR4wfg6uDcCVHg,889104
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.1.so,sha256=DnXVsZfN7Y8N1aBF2vRaP_wn-ySjDwm9FtQAf_8K3vQ,889104
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.2.so,sha256=8QkOqLTQye_UubTVDoZesczPCTcnW6DJkCdnpibbnN0,889104
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.0.so,sha256=KRDQxVCX8LwUDYNaWCYTEXymXQef5tKrkfZEAtwbol0,899688
-dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.1.so,sha256=7QwhUKj657Wqw4QHSvGzKbFntayJ9hrUBYgr4WwVu4k,899688
+dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.0.dylib,sha256=Htvh8AjFVEHoI7Yzk48pKhVf6-3IfpeWQgi1tlUhFcs,1015568
+dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.1.dylib,sha256=OcGdUZNfarYFI4jzzKujycAq0neAhVPL0cYoVD8To24,1015568
+dgl/dgl_sparse/libdgl_sparse_pytorch_2.1.2.dylib,sha256=OtuRfg-40liR_JyUeio_d_O1Nz_x9_tmMlZcrVKjHBs,1015568
+dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.0.dylib,sha256=RQGrQQtrvQgb1BnyDRcRhV2S3Bh3ExYjAwxU-8pBTQQ,1050328
+dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.1.dylib,sha256=O1Y9mYtSt548zi7nd7-J6V20pzWdr8o3fktehbuGh7k,1050328
+dgl/dgl_sparse/libdgl_sparse_pytorch_2.2.2.dylib,sha256=4ZB_Q6TIs6ECOQwH-l_etNUz-UM1ZUwy2KquQ9gk4SQ,1050328
 dgl/distgnn/__init__.py,sha256=Yukew-kUsyrTMjXNDurnBWJ29MJlZ8St1zFgg7Oodck,111
 dgl/distgnn/partition/__init__.py,sha256=ljHPZ96L2H_plSixPs3S3SBVyRy40cyoI3ZOKrh9Y_M,100
 dgl/distgnn/partition/libra_partition.py,sha256=udCm4coWNeW-Mo2HwtbhPVA3HuwojPseeEafkm-qSfM,11682
 dgl/distgnn/tools/__init__.py,sha256=xgtKqy5w-Fq9foaXz2Op9r1plnaHSD8e9he-M5n03_c,114
 dgl/distgnn/tools/tools.py,sha256=Vl_BE2814gAqS95EtboMmmULlMs90tXW5-GYxtyg1OA,4252
 dgl/distributed/__init__.py,sha256=YNg1stgxKjgvHEN7_UWT1GEgjvx3xCgWPNxxwdtVMNc,724
 dgl/distributed/constants.py,sha256=6DLStObsX_bi-CXy70ZGS3UFDvpBA3WxhowBosKS4sY,234
 dgl/distributed/dist_context.py,sha256=PyYxh2ZA_YeLDQk66LPyGj6u-tbNatsI6RvubX9JLHg,12936
 dgl/distributed/dist_dataloader.py,sha256=7bw-YN-WuPOkMvT_E4rASX3XiZDHobsh3DWXsDLKE58,6396
 dgl/distributed/dist_graph.py,sha256=Y2Xan8LQAQgVYvO5IqZa8FYkEop1gkvjGzFqPLpNzzk,64123
-dgl/distributed/dist_tensor.py,sha256=R9UhyKZYC0CTEtXIFgbNLo06xtuZ7kFDQx45AQUbKrg,11917
-dgl/distributed/graph_partition_book.py,sha256=PVGj5qX1NkBskHmg1wVYzdOUuGAii8QbzAg2oFs8oBw,39814
-dgl/distributed/graph_services.py,sha256=wV670emkWNegFe7giKsXBXxvA0latVkMJ-iWRiOeF9w,42400
+dgl/distributed/dist_tensor.py,sha256=KRwmsRn2cl28g3zt2Ilo9t5vjT0iL3KWgtPURi-7wRw,11972
+dgl/distributed/graph_partition_book.py,sha256=a3b8hZ5wGTf8sENbWP8AXd2NEWm7dwdIVMlivGmH7_0,40122
+dgl/distributed/graph_services.py,sha256=XuRgxbsUMWjEFZ5W_XeARX6l0os1yNCX0E_A7SwhNdY,42467
 dgl/distributed/id_map.py,sha256=3Lar8wZEUSKo2IKkqff9CJNyGpP7yMUmRXMgKLTVEaE,7163
-dgl/distributed/kvstore.py,sha256=V8ke5TqXXd4GwECSt-rpzI1bLIhgZiVACpQTCmbikfs,50147
+dgl/distributed/kvstore.py,sha256=MrZffCs2VTv4EqMLobOTRZdxrN4eJXj3upttWlbAiUU,50424
 dgl/distributed/partition.py,sha256=DKelZnDtIlzImNXciGshz_Qpie1K0YK5qifQT3DTYpk,61976
 dgl/distributed/role.py,sha256=m_sg9Rd3CQJMA3BAhpeFqhvvpzuybSsGBPiWz4m4lFQ,7175
 dgl/distributed/rpc.py,sha256=eQPAGDfNn4-28a2X7T3UvJqhNOmCnMXDD_7TzyBDKTE,37523
 dgl/distributed/rpc_client.py,sha256=0pmucgW3Nm4EBz_SO4SwM5alwYadog1_C0jaQH2d8i4,7248
 dgl/distributed/rpc_server.py,sha256=P60woAyBukgONzFKn_3q4i5KJxgGcEzdFYXipsjEU4I,5698
 dgl/distributed/server_state.py,sha256=Mq-GNKuxNzDDp23YzlUnKxLF_zDH0dVJqFgxljLsNhI,2518
 dgl/distributed/shared_mem_utils.py,sha256=Bej3WLIk3y1elbKh4ywszDEzA_aw5vez_uWDp4j6yR0,740
 dgl/distributed/standalone_kvstore.py,sha256=ru45e8SsWLEZFNUej2xCRHjvg9XdiQUUR0dQYaMm7SM,3859
-dgl/distributed/utils.py,sha256=eVSNWdmK--0RLEliAMFPSclD4Sz5IIrKc-SvyngFmSo,429
 dgl/distributed/nn/__init__.py,sha256=FMoPQhIaBVjGKsvlYg9dETnGZJmT80eTXQlGv5_NRrg,377
 dgl/distributed/nn/mxnet/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dgl/distributed/nn/pytorch/__init__.py,sha256=XliuTeHOC8Siukpk4RUvIBftbzOQ75RmnL-j6fc4DX0,90
-dgl/distributed/nn/pytorch/sparse_emb.py,sha256=z87ePYOkPmBq2O7oRHgq1HyZPx9JlH-CJ6Zj_ely1S4,6520
+dgl/distributed/nn/pytorch/sparse_emb.py,sha256=wS7e0Ub--b28LPma49hryi5dv8bnypJcpB01zS11CrU,6580
 dgl/distributed/nn/tensorflow/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dgl/distributed/optim/__init__.py,sha256=FMoPQhIaBVjGKsvlYg9dETnGZJmT80eTXQlGv5_NRrg,377
 dgl/distributed/optim/mxnet/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dgl/distributed/optim/pytorch/__init__.py,sha256=0hn211h0ukzkvENplX_rzN9scpUe6231yRePHMqLrpw,104
 dgl/distributed/optim/pytorch/sparse_optim.py,sha256=9KVkBdeR61LsdDGdNhmkgMkv_YPAsB1Y12peHRBBXqs,27827
 dgl/distributed/optim/pytorch/utils.py,sha256=eU5E5NKF8an8mjL_ffe1-iA8AE60oWomHdwyROAJ6h8,3878
 dgl/distributed/optim/tensorflow/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
@@ -162,55 +160,54 @@
 dgl/function/base.py,sha256=DGAqGNwo6xHTMLTG147zKf-j9tOncIv0HVEKCDMDVVw,604
 dgl/function/message.py,sha256=DyV55Nv985lMyoIf2F9X4BEvjwZk8-o12eSHXaXPqCw,4968
 dgl/function/reducer.py,sha256=0W6huubE8Yf6dX07X2_PfUpm9CXPGGpCOq7w1y16YB8,1983
 dgl/geometry/__init__.py,sha256=I2YinqcKTehf4y7cXCOtCHT6gp-AOfoNE6hXanu6SIk,329
 dgl/geometry/capi.py,sha256=TzGDZIpMjhqxEl-K4C02XvEl07O-Rhdib0EGVW5HEgo,3930
 dgl/geometry/edge_coarsening.py,sha256=aUcTyRx0uq_-diK35uoeA22dCA8KYn4-MHcSyOJElME,2294
 dgl/geometry/fps.py,sha256=T3tcxjy3GtEAV5TahAjo4ob0suHqtkCRAeoy3G7SyVQ,2162
-dgl/graphbolt/__init__.py,sha256=dLQo70EN9A6KJ4SFM1H6Faaof4O2qyEsOs9EVedJIqw,1548
-dgl/graphbolt/base.py,sha256=4gMr1rawQEo30r-oP3rqPRre-52CX4tnKoXtLMkm_gs,11822
+dgl/graphbolt/__init__.py,sha256=jfyXt7818_K5Lts2fSbO8OsFBKVmHxMPAMoJrJ8xwwg,1568
+dgl/graphbolt/base.py,sha256=aVkyuXBnvnBWjC85O5SzSl5yk_MzK5JMn-OBExEbDKw,11403
 dgl/graphbolt/dataloader.py,sha256=ic_33eBDX9iRv-DcJZKhgLQ1PTFgrVgOJeUOnVL8h80,7616
 dgl/graphbolt/dataset.py,sha256=N9kbIfDcsFiKPv7ynHzBT4YfsxVBGyWAjAdpntIVYtY,2740
 dgl/graphbolt/feature_fetcher.py,sha256=g-3msOZ94IhPArLdL-_g0y8XnIZpmHWC-hfR_8gnrJQ,6790
 dgl/graphbolt/feature_store.py,sha256=H6uktMi7Ubs0RNwxiwDqHqGXOnvWzmikR0yLWlarpVs,4913
-dgl/graphbolt/item_sampler.py,sha256=dMOIYM0k3K4lz7uOB8Epr-BBeop31xBOWh-hyUlqR4s,30036
-dgl/graphbolt/itemset.py,sha256=6hGgsBcJTPAqttN4UyETHoq44vqU7F9z-4-p3Crc2qE,14570
-dgl/graphbolt/libgraphbolt_pytorch_2.0.0.so,sha256=YGhmNhiWWVz6YR4t-OmPeM9E7AD4PE7uX3gpX39ZSns,1109400
-dgl/graphbolt/libgraphbolt_pytorch_2.0.1.so,sha256=PgiR30VASC-pU5tkUI84PObjeGqUnbaIOWuS1s6A8k4,1109400
-dgl/graphbolt/libgraphbolt_pytorch_2.1.0.so,sha256=2ZQJi8CGVU9JzkUHSfeReU726nCiCBAQ8oqRDHN6j64,1112672
-dgl/graphbolt/libgraphbolt_pytorch_2.1.1.so,sha256=TLkDYTgWaWdAmkVfQgsqdH8u7vtJue1kpDRLtUZhqXw,1112672
-dgl/graphbolt/libgraphbolt_pytorch_2.1.2.so,sha256=T9DyTOq3V5S2kw9N4GxffcrNUhkWRUDAO1ZjGiL_rUc,1112672
-dgl/graphbolt/libgraphbolt_pytorch_2.2.0.so,sha256=b0o__2PB6JVTMB6eG4keHo6GowOPTNyBp84XZ72TVYY,1108328
-dgl/graphbolt/libgraphbolt_pytorch_2.2.1.so,sha256=fMBBFwBwxpf9-Mirad6eL-ytg380F26hIqwSHfODwLM,1108328
-dgl/graphbolt/minibatch.py,sha256=LFe5X_iFXDZSjZXfMooySr5Z6JaZlU_P4ntAzoBJuF8,24948
+dgl/graphbolt/item_sampler.py,sha256=SkanzudGetIdu9K552d4RvzYvbREGKN-BwA8S9GrDao,32950
+dgl/graphbolt/itemset.py,sha256=HIoKYf5pI5e4UHVMFagTwGor_X45hSz2mrmzQEcpiXg,15948
+dgl/graphbolt/libgraphbolt_pytorch_2.1.0.dylib,sha256=y7NBC_bWuPPY1LzrvKvpSGl4dPe2OY5rNnxjPgAc3uo,2095160
+dgl/graphbolt/libgraphbolt_pytorch_2.1.1.dylib,sha256=iIpo7iMLDcdqP0kPOuxAZzlihuJDejE0E0gE-9Pre4A,2095160
+dgl/graphbolt/libgraphbolt_pytorch_2.1.2.dylib,sha256=cMf2lfbQjKcNMIXa08Fptj0G-0YOKDk0cJKpu18AC4A,2095160
+dgl/graphbolt/libgraphbolt_pytorch_2.2.0.dylib,sha256=yHjK4L17RJDN2CA5cc40GvNgmd5niGj7iFJK-PxpGLg,2063248
+dgl/graphbolt/libgraphbolt_pytorch_2.2.1.dylib,sha256=c5Vqf1Z9n1v_WIUKfHCX7-hR0RCTsdC_J_HgF38yLtI,2063248
+dgl/graphbolt/libgraphbolt_pytorch_2.2.2.dylib,sha256=tk5A_dgwMDp5WSQN3Z-2vfBnoegJx96UQCxeMB5aXis,2063248
+dgl/graphbolt/minibatch.py,sha256=SJ8tMa7CnhFrF-ndNHSpNIVZ7ZteGOCO9UxEb_2X1sA,14320
 dgl/graphbolt/minibatch_transformer.py,sha256=rPYLTSZETfYA01A758dWDIJHhml1PaM-1JYhKtGEqqs,1102
-dgl/graphbolt/negative_sampler.py,sha256=EslSy2UwQ0JYs9I3E7i05qneWhVW9aPrnqIPzpshA5Y,5312
-dgl/graphbolt/sampled_subgraph.py,sha256=BiteNGrxLjvt4unUCcJ7GRf4NAmgF7iNSrHvLEyfEkY,13737
+dgl/graphbolt/negative_sampler.py,sha256=qLr0BMctghQo0R9JZ6xhzLIFqsKZ2hMNgxmVvpstBv0,3292
+dgl/graphbolt/sampled_subgraph.py,sha256=MgS-IR4rFhCXPz17Q6UMNgkXTK0c3cVf_4fuPhDHd6c,12314
 dgl/graphbolt/sampling_graph.py,sha256=xQQU9d-BoY75ihLzOe0nQq05sriG0gii9YjtM5D8Lzo,2295
-dgl/graphbolt/subgraph_sampler.py,sha256=AT8YJ3XrGMRIwSibU4aHwPBV3XCF2omiacxG-8b2-HM,15876
-dgl/graphbolt/utils.py,sha256=KBrRWbrEFDSb12sMYFZNPNBe8ioLoWTi2o9FI8EoIVE,6716
+dgl/graphbolt/subgraph_sampler.py,sha256=x-QRYNwYK3ZOOA-73bNYp4krlH2N0r99vgmKN_-dOc8,10379
+dgl/graphbolt/utils.py,sha256=q4sZy6q5WbiRvZrvTB4lGg09tO_KNBk5hDj3jKIZT0s,3751
 dgl/graphbolt/impl/__init__.py,sha256=ycTsuCmZpoYuBNhzfS2bsitB0jDwN6Ml33toYR0b9XY,486
 dgl/graphbolt/impl/basic_feature_store.py,sha256=85P7M4OxOEHRVAv8SQwabAAQwHR5HiZT6mkAmqyevno,4197
-dgl/graphbolt/impl/fused_csc_sampling_graph.py,sha256=tFStKBc4wcK_0T60KJuCcnddC5ymLJWvxSSvBlElHM8,52939
+dgl/graphbolt/impl/fused_csc_sampling_graph.py,sha256=BWaezuZ9WHPwqKYeS_pPWAtjoZxWJsprbDDxDY36DL8,56491
 dgl/graphbolt/impl/gpu_cache.py,sha256=2Qf0sF_yyONUMgnuwcey4w3LTxKRBT7kNS3XdjQjN08,1759
 dgl/graphbolt/impl/gpu_cached_feature.py,sha256=XolXzxUz3uP8ZWflX8TZE6U-2AhflPLbcBHHFSukyf0,3968
-dgl/graphbolt/impl/in_subgraph_sampler.py,sha256=YXkccFQzap-nYYUhlIWw1mUhbJIQqOnR5RpxJRJG6Wo,2740
-dgl/graphbolt/impl/legacy_dataset.py,sha256=f49AKCypo3321ZKVIo8Xgb_LebN26be1ETg_sRRJ6XY,5889
-dgl/graphbolt/impl/neighbor_sampler.py,sha256=ohwNjhn091E1zuZbWQlcpRXjo8IHLKUF4mLihYguL5M,19716
-dgl/graphbolt/impl/ondisk_dataset.py,sha256=lcDVvzSiXDZV59dYZS8J319kwPCGZECLvDKkB8PaSqg,38443
+dgl/graphbolt/impl/in_subgraph_sampler.py,sha256=2G6dYt7W3VSSnYdYxp0KHeQw28wfRYcumsaj0xT-qT4,2735
+dgl/graphbolt/impl/legacy_dataset.py,sha256=DhVb3jkgK5FM03eLeZpbQtXaUWpUbJ7FSMQPtZLxRYA,5859
+dgl/graphbolt/impl/neighbor_sampler.py,sha256=IQtgav8qYKxh0TFYIBRA0wneUZAwT9uLQiqrqn4pZSI,22956
+dgl/graphbolt/impl/ondisk_dataset.py,sha256=bT2JNYGk1beIwKuFjY3YPV0ofVh5Z5U0lx0RBYZCH2I,38844
 dgl/graphbolt/impl/ondisk_metadata.py,sha256=fRpCfOiHG7rekfT6QLPJLZCZftfsQKJrYGr2Qrz_OTw,3491
 dgl/graphbolt/impl/sampled_subgraph_impl.py,sha256=jXyC82OTUiSt9-6vkuv1tTioja4wQwGlNk_NvH4uwkU,3688
-dgl/graphbolt/impl/temporal_neighbor_sampler.py,sha256=0cMQ6EOY6IAZQf5NtjZMShX55kh7CRaMlvgKRPYOC2w,5395
-dgl/graphbolt/impl/torch_based_feature_store.py,sha256=9Ml531PQp3s8jxbdW1AD6oDQFddSid5Vo1Ywo51ssa4,11317
-dgl/graphbolt/impl/uniform_negative_sampler.py,sha256=o2w5Vof7NQlwehZqwX6x688n_YFbcnGr3TbI197Ip-w,3741
+dgl/graphbolt/impl/temporal_neighbor_sampler.py,sha256=WL4cD17IjfFNhvUZt3L2dR2xBwOj9ZQUleJV4Vnwg2g,5692
+dgl/graphbolt/impl/torch_based_feature_store.py,sha256=Sb1ukq_iQHGKXLZ_lveuGu6yS-dzb5T2_3KNvyW0r-c,14798
+dgl/graphbolt/impl/uniform_negative_sampler.py,sha256=EvuPY0UiqN42hZOkQxlkzpygiXUghXNm6wNzFtkuhu8,3161
 dgl/graphbolt/internal/__init__.py,sha256=3zGpAOBUrUcQ8PHkLQaTCfeJlusUEAOxtYc3OF_Njr0,152
 dgl/graphbolt/internal/datapipe_utils.py,sha256=PGktTfmfKRJvkWSTeqhafLNnIjuACI9tjBuVWR1s1AA,1384
 dgl/graphbolt/internal/item_sampler_utils.py,sha256=Hccav2gYc0nkst9bNtjpO0nFTz3EnHHdYxx29dawxs8,4512
-dgl/graphbolt/internal/sample_utils.py,sha256=dSDdme7YvMXo7g0nKK6rOfeG9mwzQnapg_2vY_SOdh8,17295
-dgl/graphbolt/internal/utils.py,sha256=ndnYNAl6S11n4jfrm4l6z8RpXFvHfcRIghmKTT60VVQ,6894
+dgl/graphbolt/internal/sample_utils.py,sha256=_srV_rUkZTGWzm6JhrlTXuC5IxVX3Yc8m1MmNXiE4KU,17419
+dgl/graphbolt/internal/utils.py,sha256=X4lDMX6Rn8nmAKIVwipvnmf3EBFuFlsPuhalIftQoCQ,7343
 dgl/mpops/__init__.py,sha256=u6MiqduaNh_JRHN6CTlh27YiPAGWtSm0ya4yjuqYWrs,113
 dgl/mpops/edgewise.py,sha256=98jDvrFV80YhmWnIvzSO31bfmOeyLracspsqivEKu9U,6596
 dgl/mpops/fused.py,sha256=2pfy5U8BLXiO620JA2C6Txq6bvUwlf-5P7x8AUkxaD4,72
 dgl/mpops/nodewise.py,sha256=sLVUYcWKTh2UpzZIJdz4sKV-1KoMP1eTme-VD0T6L-M,65
 dgl/multiprocessing/__init__.py,sha256=jwz_9xHGx-kmaouSfkUUHnLB95UhV4-yOupfINCIRKg,714
 dgl/multiprocessing/pytorch.py,sha256=HL8s7UfVybwndVLVGlcIO89WIk1AMn_LfVEo7uWehB4,3893
 dgl/nn/__init__.py,sha256=PWJKN8E37MxL_eE8U88s8E1svsNiznGWJJ5d9CxUNEg,1362
@@ -347,30 +344,29 @@
 dgl/sparse/unary_op.py,sha256=V8Z8kWEziiiaz4VVy_0STv-LY3hvM7AIO1AW3dwaAYg,1673
 dgl/sparse/utils.py,sha256=2smIQ76xcTHHoGsc0eBGDSjlndGJLumNybWqZIaSF3c,305
 dgl/storages/__init__.py,sha256=lOs1t2c9iwuNKaJnsvu4ZBuJ9qHNk6VInvcUUC4NlyI,327
 dgl/storages/base.py,sha256=WIf0eBhN69e9OTF4ZNiPEUBdju55qHlJMzZzU2n4nLk,2538
 dgl/storages/numpy.py,sha256=K4CaTZuLB5M6nX0-xEN-jicgG42eZR4pVbybMbUhpNo,826
 dgl/storages/pytorch_tensor.py,sha256=xxUREWnnHI0AKHzAqXzli9Ls8nybezl7FqgdmDIfad0,2114
 dgl/storages/tensor.py,sha256=1CQ-G-hsLAOKpYghurytGXhmo2Z8_eUJbbniG73qMTk,548
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.0.0.so,sha256=JlIkiozqIVurnD1zmESA468wxFYoo8Fcj9aH1oTpxoY,75568
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.0.1.so,sha256=ltlW_0Bc6k5X4RSKJhR5cVvuXPdz1t4Y2uEewum4cqc,75568
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.0.so,sha256=2o4Gof2oQTm9kxYFfs0RLURFl7NBTwV-GFozhdMZCJk,75568
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.1.so,sha256=1z0u4A6NJvkque9Lzfft5L69o42HeFW-52L1XvN1qFA,75568
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.2.so,sha256=PCoa9OMbdghlzTZVrPd66pF6rQKQt7kz_Z0hkRt0frM,75568
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.0.so,sha256=nteBEnmLtnzbNZn9fKJJpv0oTDx4WYVP419C78tph4Q,75368
-dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.1.so,sha256=1cZeqshxhN7W1OSTgyBUD9Io1gYf2R3wwOqGl30S3fs,75368
+dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.0.dylib,sha256=YNpfZDAlWpiEbnmGx5LsPvL0JQDSGOmEFdSyFeoz7Co,52608
+dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.1.dylib,sha256=Fwjv81007E-9ZcVtQIkRvtuudhIaB6yweFct88Ttj_w,52608
+dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.1.2.dylib,sha256=I-uegInG6SBXhD3IimWKILPzIxOnCWiqg9nGRd04yw8,52608
+dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.0.dylib,sha256=h9QgMdUPY02kJK-Omec07DZCDr18o6q4TCEnyl0DMmk,52608
+dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.1.dylib,sha256=jHaIdgJNhdDeOD1JhANfGDV3utUuZHnFozHBX-AyJAw,52608
+dgl/tensoradapter/pytorch/libtensoradapter_pytorch_2.2.2.dylib,sha256=sh4zF6bIUQvH-L20e0Nese97XAUH-Hr00ahu_LdyzT0,52608
 dgl/transforms/__init__.py,sha256=-STsRDZ-Trh1Qt65nS5jycNFXL2CSd2wPkmpk6NZ59o,116
 dgl/transforms/functional.py,sha256=cx2d3dqch8CQJtOFWdeE8PIGf45j3abFFAmTfD_XHTs,143516
 dgl/transforms/module.py,sha256=edZzm9jOZ4ZKr3tTR_FWStcBuEEyEUFnKIglVb-w2Qo,67187
 dgl/transforms/to_block.py,sha256=_A_ErUhZkW1Xb1zqUW4HTgJpV1Gpc9mFN2y47-po0ns,9180
 dgl/utils/__init__.py,sha256=VBBPNl0JdnepIXTef718UYRizPlD7vbYdLMpCRY2cuI,383
 dgl/utils/checks.py,sha256=Mi9FGCnqraxLjNTA0Ix7y2FVNySzIbaLyuG7rjE8K-8,8167
-dgl/utils/data.py,sha256=d1Yav870EfAtZ3hpgiW2GQfoWg6h2W8HhVfZU934KIM,13141
+dgl/utils/data.py,sha256=xmfeMBcZV-Q74Qd6aTkRxHDddY0ndt81yUToL2Ii0OM,13480
 dgl/utils/exception.py,sha256=gaOKdzLkFWib_LVZNIo9bOAsbreNwhfakv8QAKdDFM4,2582
 dgl/utils/filter.py,sha256=CuOPgVp9vGVxuvSavbuoaVmhzNabGC0TibqTCZF9kVc,2163
 dgl/utils/internal.py,sha256=1sTPWuXj8JaJsZSjsrDsR6nT5JtSoGo_li028vmZFLg,36858
 dgl/utils/pin_memory.py,sha256=ue9mzGNzAKhd0ZGMJGwbg3yFfDovUwjz90bv_MnIysA,2293
 dgl/utils/shared_mem.py,sha256=PIaeHOWz8i0Flzrq_QWkSx2AJBCNAxam-mRil1qU8ws,281
-dgl-2.1.0.dist-info/METADATA,sha256=HIcaVChFMb4vS-p-BBiKHqhNWOncd1x_SsuFt0AcfEY,580
-dgl-2.1.0.dist-info/WHEEL,sha256=EnVwRB6pbTxTcFEic7pEftI8f952LezL3jkuDRMmuQs,112
-dgl-2.1.0.dist-info/top_level.txt,sha256=LqU3RnL9LDl-4PJKX4dxW4qIGHyHVZ4_vTxFKmyZqkE,4
-dgl-2.1.0.dist-info/RECORD,,
+dgl-2.2.0.dist-info/METADATA,sha256=3NonlDjCBOsln3MZyQiEj0Uyt46F3m50Yy2deWrIqmg,615
+dgl-2.2.0.dist-info/WHEEL,sha256=FJuHhoVUZj62yWAYw46S3u8syVVmWwUzAGz6OK32Q1A,109
+dgl-2.2.0.dist-info/top_level.txt,sha256=LqU3RnL9LDl-4PJKX4dxW4qIGHyHVZ4_vTxFKmyZqkE,4
+dgl-2.2.0.dist-info/RECORD,,
```

