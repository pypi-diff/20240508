# Comparing `tmp/neo3-boa-1.1.1.tar.gz` & `tmp/neo3_boa-1.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "neo3-boa-1.1.1.tar", last modified: Fri Feb  2 15:59:10 2024, max compression
+gzip compressed data, was "neo3_boa-1.2.0.tar", last modified: Wed May  8 20:20:49 2024, max compression
```

## Comparing `neo3-boa-1.1.1.tar` & `neo3_boa-1.2.0.tar`

### file list

```diff
@@ -1,875 +1,900 @@
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.948921 neo3-boa-1.1.1/
--rw-r--r--   0 circleci  (1001) circleci  (1002)    11357 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/LICENSE
--rw-r--r--   0 circleci  (1001) circleci  (1002)    18229 2024-02-02 15:59:10.948921 neo3-boa-1.1.1/PKG-INFO
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3838 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/README.md
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3048 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/README.rst
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      116 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2639 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/boa3.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1199 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/compile_time/
--rw-r--r--   0 circleci  (1001) circleci  (1002)    14274 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/compile_time/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      468 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/contract/Nep17Contract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5116 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/contract/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/interop/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      435 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/interop/blockchain/
--rw-r--r--   0 circleci  (1001) circleci  (1002)    10773 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/blockchain/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1643 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/blockchain/block.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1965 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/blockchain/signer.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1531 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/blockchain/transaction.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       65 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/blockchain/vmstate.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/interop/contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6174 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       76 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/contract/callflagstype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1071 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/contract/contract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6750 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/contract/contractmanifest.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/interop/crypto/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     7048 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/crypto/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       55 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/crypto/ibls12381.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       89 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/crypto/namedcurve.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/interop/iterator/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      967 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/iterator/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.560922 neo3-boa-1.1.1/boa3/builtin/interop/json/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      960 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/json/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/interop/oracle/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      199 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/oracle/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      101 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/oracle/oracleresponsecode.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/interop/policy/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1230 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/policy/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/interop/role/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      543 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/role/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       73 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/role/roletype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/interop/runtime/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6715 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/runtime/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      544 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/runtime/notification.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       80 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/runtime/triggertype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/interop/stdlib/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5564 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/stdlib/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/interop/storage/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3240 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/storage/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)       80 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/storage/findoptions.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1055 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/storage/storagecontext.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1379 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/interop/storage/storagemap.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1154 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/math.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/nativecontract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6777 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/contractmanagement.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5322 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/cryptolib.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3409 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/gas.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     9158 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/ledger.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     8874 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/neo.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2291 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/oracle.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1679 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/policy.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      931 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/rolemanagement.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     7876 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/nativecontract/stdlib.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/type/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2733 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/type/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      795 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/type/helper.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/builtin/vm/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       76 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/builtin/vm/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1090 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/cli.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1936 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/cpm.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.564921 neo3-boa-1.1.1/boa3/internal/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.568921 neo3-boa-1.1.1/boa3/internal/analyser/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    10786 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/analyser.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    11125 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/astanalyser.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      308 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/asthelper.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    17897 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/astoptimizer.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4737 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/builtinfunctioncallanalyser.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2799 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/constructanalyser.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    10834 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/importanalyser.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.568921 neo3-boa-1.1.1/boa3/internal/analyser/model/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      464 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/model/ManifestSymbol.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/model/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1221 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/model/functionarguments.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.568921 neo3-boa-1.1.1/boa3/internal/analyser/model/optimizer/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1181 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/model/optimizer/Operation.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3056 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/model/optimizer/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1517 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/model/symbolscope.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    70531 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/moduleanalyser.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.568921 neo3-boa-1.1.1/boa3/internal/analyser/supportedstandard/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      446 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/supportedstandard/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     9202 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/supportedstandard/standardanalyser.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    87455 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/analyser/typeanalyser.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.568921 neo3-boa-1.1.1/boa3/internal/cli_commands/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      106 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/cli_commands/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3813 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/cli_commands/compile_command.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      462 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/cli_commands/icommand.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.568921 neo3-boa-1.1.1/boa3/internal/compiler/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.572922 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      883 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)   103002 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/codegenerator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    56656 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/codegeneratorvisitor.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1445 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/codeoptimizer.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.572922 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1816 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/executionscript.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1269 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/istack.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2513 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/neoengine.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3127 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/stackmemento.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1663 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/generatordata.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4244 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/initstatementsvisitor.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3537 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/methodtokencollection.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      674 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/optimizerhelper.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      367 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/variablegenerationdata.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6725 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/vmcodemap.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    11331 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/vmcodemapping.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3244 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/compiledmetadata.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     8515 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/compiler.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      487 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/compileroutput.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.572922 neo3-boa-1.1.1/boa3/internal/compiler/filegenerator/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/filegenerator/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    35236 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/filegenerator/filegenerator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      925 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/compiler/filegenerator/importdata.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1752 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/constants.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      489 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/env.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.572922 neo3-boa-1.1.1/boa3/internal/exception/
--rw-r--r--   0 circleci  (1001) circleci  (1002)    13198 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/exception/CompilerError.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4670 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/exception/CompilerWarning.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      180 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/exception/InvalidPathException.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      334 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/exception/NotLoadedException.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/exception/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.572922 neo3-boa-1.1.1/boa3/internal/helpers/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      368 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/helpers/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.576922 neo3-boa-1.1.1/boa3/internal/model/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      153 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1705 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/attribute.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.576922 neo3-boa-1.1.1/boa3/internal/model/builtin/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    12113 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/builtin.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2204 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/builtincallable.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      726 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/builtinproperty.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      514 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/builtinsymbol.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.580922 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2980 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3217 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/appendmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2482 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/clearmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      606 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/copydictmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      389 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/copylistmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2617 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/copymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3724 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4164 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countsequencegenericmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4241 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countsequencemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      678 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countsequenceprimitivemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6449 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countstrmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4385 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/extendmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5582 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/indexbytesstringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2613 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/indexmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     7604 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/indexsequencemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4609 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/insertmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4219 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/isdigitmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5355 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/joinmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4799 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/lowermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1840 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/mapkeysmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1850 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/mapvaluesmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1860 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popdictdefaultmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      643 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popdictmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3657 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      948 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popsequencemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3569 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/removemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6764 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/replacemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1717 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/reversemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     7034 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/sortmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5055 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/startswithmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     9815 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/stripmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4800 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/uppermethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.580922 neo3-boa-1.1.1/boa3/internal/model/builtin/compile_time/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      141 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/compile_time/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      456 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/compile_time/neometadatatype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.580922 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      578 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3187 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/abortmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3166 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/neoaccountstatetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      854 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep11transferevent.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.604921 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      856 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      756 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacebalanceofmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      557 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacedecimalsmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1927 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      553 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacesymbolmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      597 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetotalsupplymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1025 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetransfermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1264 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17contract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      738 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17transferevent.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.608921 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      999 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      814 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/builtindecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1367 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/classmethoddecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2817 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/contractdecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3441 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/displaynamedecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      352 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/instancemethoddecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      224 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/metadatadecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1467 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/propertydecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3203 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/publicdecorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      232 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/staticmethoddecorator.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.608921 neo3-boa-1.1.1/boa3/internal/model/builtin/internal/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      238 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/internal/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1856 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/internal/getenvmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2389 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/internal/innerdeploymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      890 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/internal/internalmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.608921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.612922 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2484 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3860 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/blocktype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      764 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/currenthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      730 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/currentindexmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      800 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/getblockmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      791 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/getcontractmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      976 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionfromblockmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      609 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionheightmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      745 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      740 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionsignersmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      674 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionvmstatemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3477 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/signertype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3655 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/transactiontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1495 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/vmstatetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1682 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessconditionenumtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2892 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessconditiontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1652 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessruleactiontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3239 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessruletype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1587 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessscopeenumtype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.612922 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1496 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1754 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/callflagstype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2058 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/callmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.616922 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1521 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2052 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractabitype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1951 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1755 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractgrouptype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1997 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2236 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1905 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2070 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparametertype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2009 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1741 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3380 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contracttype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      883 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/createmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      821 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/createmultisigaccountmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      698 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/createstandardaccountmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      474 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/destroymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      543 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getcallflagsmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      798 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getgasscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      515 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getminimumdeploymentfeemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      798 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getneoscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      766 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/updatemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      961 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contractgethashmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.660921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1856 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      649 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381addmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      644 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381deserializemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      706 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381equalmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      743 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381mulmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      664 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381pairingmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      635 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381serializemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1160 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381type.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      735 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/checkmultisigmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      901 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/checksigmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1125 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/hash160method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1121 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/hash256method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      562 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/murmur32method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1614 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/namedcurvetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      499 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/ripemd160method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      489 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/sha256method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      881 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/verifywithecdsa.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    18978 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interop.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1000 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interopevent.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      571 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interopinterfacetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1854 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interopmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.660921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      507 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1960 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/getiteratorvalue.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1520 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/iteratorinitmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      587 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/iteratornextmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3057 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/iteratortype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.660921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/json/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      273 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/json/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      510 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/json/jsondeserializemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      504 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/json/jsonserializemethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.660921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.660921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      133 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      809 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1106 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.660921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      105 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      749 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1068 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Ledger/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       93 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Ledger/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1054 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      779 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Ledger/ledgermethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Neo/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       97 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Neo/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      834 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Neo/getneoscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      772 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Neo/neocontractmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Nep17/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       89 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Nep17/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1108 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Nep17/getnep17scripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      875 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Nep17/nep17method.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Oracle/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       93 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Oracle/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1030 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      734 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Oracle/oraclemethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      117 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1070 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      803 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      117 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1074 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      764 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/StdLib/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       93 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/StdLib/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1033 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/StdLib/getstdlibscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      734 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      506 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4115 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/nativecontractmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      249 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      617 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/oraclegetpricemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      930 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/oraclerequestmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1742 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/oracleresponsecodetype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.664921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      532 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      506 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/getexecfeefactormethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      497 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/getfeeperbytemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      502 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/getstoragepricemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      636 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/isblockedmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.668921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/role/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      252 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/role/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      822 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/role/getdesignatedbyrolemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1555 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/role/roletype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.668921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2551 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      483 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/burngasmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      905 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/checkwitnessmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      762 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getaddressversionmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      715 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getblocktimemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      827 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getcallingscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      815 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getentryscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      839 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getexecutingscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      717 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getgasleftmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      780 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getinvocationcountermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      466 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getnetworkmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2032 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getnotificationsmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      721 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getplatformmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      463 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getrandommethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      522 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/gettriggermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1693 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/loadscriptmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      474 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/logmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2993 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/notificationtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1090 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/notifymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      762 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/scriptcontainermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1784 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/triggertype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.704921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1528 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      657 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/atoimethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      519 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base58checkdecodemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      519 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base58checkencodemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      503 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base58decodemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      503 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base58encodemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      503 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base64decodemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      503 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base64encodemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      500 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/deserializemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      718 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/itoamethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      634 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/memorycomparemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1217 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/memorysearchmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      494 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/serializemethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.708921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1184 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1835 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/findoptionstype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.708921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       51 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      581 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1241 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2188 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2916 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagedeletemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4441 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagefindmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      601 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3387 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagegetmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      619 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.708921 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       43 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1730 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1887 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2032 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemapputmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3936 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemaptype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3282 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storageputmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.708921 neo3-boa-1.1.1/boa3/internal/model/builtin/math/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      418 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/math/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2781 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/math/decimalceil.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2634 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/math/decimalfloor.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1038 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/math/powmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      746 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/math/sqrtmethod.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.764921 neo3-boa-1.1.1/boa3/internal/model/builtin/method/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4025 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      748 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/absmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2466 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/boolmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      949 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/builtinevent.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6500 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/builtinmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      744 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/bytearrayencodingmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3735 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/bytearraymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1574 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/createeventmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3482 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/ecpointmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1880 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/ecpointtoscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2325 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/exceptionmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      715 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/exitmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    12434 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/intbytestringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      729 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/intintmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1585 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/intmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5036 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/isinstancemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1757 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/lenmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2287 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/listbytesstringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3734 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/listgenericmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      937 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/listmappingmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3407 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/listmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      949 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/listsequencemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4475 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/maxbytestringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      377 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/maxintmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5594 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/maxmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4467 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/minbytestringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      377 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/minintmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5821 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/minmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      579 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/printboolmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      516 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/printbytestringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      731 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/printclassmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      533 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/printintmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5253 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/printmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      630 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/printsequencemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5103 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/rangemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3982 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/reversedmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      850 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strboolmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      601 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strbytestringmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2103 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strclassmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      613 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strintmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1935 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1109 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strsequencemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3663 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/strsplitmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2303 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/summethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1572 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/supermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2460 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/toboolmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4256 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/tobytesmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4546 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/tohexstrmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2447 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/tointmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5025 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/toscripthashmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2447 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/tostrmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5515 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/uint160method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5515 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/method/uint256method.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.764921 neo3-boa-1.1.1/boa3/internal/model/builtin/native/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      841 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.764921 neo3-boa-1.1.1/boa3/internal/model/builtin/native/contract_management/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      125 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/contract_management/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      709 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/contract_management/hasmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1566 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/contractmanagementclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1638 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/cryptolibclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1484 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/gasclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1392 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/inativecontractclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1517 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/ledgerclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2513 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nativecontract.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.768921 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1730 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      711 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getaccountstatemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      825 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getallcandidatesmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      783 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatesmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      675 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatevotemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      606 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getcommitteemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      495 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getgasperblockmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      638 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getnextblockvalidators.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      653 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/registercandidatemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      677 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/unclaimedgasmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      659 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/unregistercandidatemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1215 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/unvote.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      757 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/vote.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3024 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/neoclass.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.768921 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      620 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      657 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/balanceofmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      525 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/decimalsmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      519 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/symbolmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      534 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/totalsupplymethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1004 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/transfermethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1274 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/oracleclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1280 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/policyclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1180 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/rolemanagementclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1804 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/builtin/native/stdlibclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     7272 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/callable.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1222 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/debuginstruction.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1139 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/decorator.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1308 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/event.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      823 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/expression.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      833 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/identifiedsymbol.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.768921 neo3-boa-1.1.1/boa3/internal/model/imports/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       43 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/imports/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6500 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/imports/builtin.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2849 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/imports/importsymbol.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4942 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/imports/package.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5833 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/method.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4285 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/module.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.768921 neo3-boa-1.1.1/boa3/internal/model/operation/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.768921 neo3-boa-1.1.1/boa3/internal/model/operation/binary/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.768921 neo3-boa-1.1.1/boa3/internal/model/operation/binary/additional/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      276 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/additional/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6662 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/additional/membership.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2965 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/additional/notmembership.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.808921 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1098 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1554 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/addition.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2478 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/concat.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1444 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/division.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1491 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/floordivision.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3696 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/listaddition.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3038 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/modulo.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1566 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/multiplication.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1476 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/power.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2787 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/strbytesmultiplication.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1490 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/subtraction.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3191 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/binaryoperation.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.808921 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      833 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1491 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/booleanand.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1488 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/booleanor.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1892 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/elvisoperatoror.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1523 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/leftshift.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1495 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/logicand.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1491 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/logicor.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1495 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/logicxor.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1527 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/rightshift.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.812921 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1182 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1503 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/greaterthan.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1520 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/greaterthanorequal.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1272 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/identity.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1497 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/lessthan.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1514 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/lessthanorequal.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1353 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/notidentity.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1510 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/numericequality.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1520 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/numericinequality.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1624 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/objectequality.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1601 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/objectinequality.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4230 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/binaryop.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3173 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/operation.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2300 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/operator.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.812921 neo3-boa-1.1.1/boa3/internal/model/operation/unary/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      453 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1318 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/booleannot.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1334 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/logicnot.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1322 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/negative.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1579 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/noneidentity.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1727 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/nonenotidentity.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1360 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/positive.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1485 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unary/unaryoperation.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1973 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/operation/unaryop.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      928 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/property.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.812921 neo3-boa-1.1.1/boa3/internal/model/standards/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/standards/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2243 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/standards/neostandard.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3220 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/standards/nep11divisiblestandard.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2533 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/standards/nep11nondivisiblestandard.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1435 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/standards/nep17standard.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      830 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/standards/standardmethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      322 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/symbol.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.816921 neo3-boa-1.1.1/boa3/internal/model/type/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.816921 neo3-boa-1.1.1/boa3/internal/model/type/annotation/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/annotation/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1546 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/annotation/metatype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1710 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/annotation/optionaltype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4093 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/annotation/uniontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      782 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/anytype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      639 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/baseexceptiontype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.816921 neo3-boa-1.1.1/boa3/internal/model/type/classes/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      537 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/classarraytype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1596 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/classinitmethoddefault.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      119 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/classscope.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      538 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/classstructtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    12061 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/classtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1202 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/contractinterfaceclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1035 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/contractinterfacehash.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4611 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/pythonclass.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5666 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/classes/userclass.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.816921 neo3-boa-1.1.1/boa3/internal/model/type/collection/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1470 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/genericcollectiontype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6127 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/icollection.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.816921 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      892 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/genericmappingtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4114 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mappingtype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.816921 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mutable/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mutable/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1347 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mutable/dicttype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      782 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mutable/mutablemappingtype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.820921 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      627 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/buffertype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2955 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/ecpointtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1128 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/genericsequencetype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.820921 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1186 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/genericmutablesequencetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1755 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/listtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1433 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/mutablesequencetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1412 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/rangetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1498 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/reversedtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1513 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/sequencetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1353 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/tupletype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2534 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/uint160type.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2610 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/uint256type.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5293 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/itype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1119 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/math.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.820921 neo3-boa-1.1.1/boa3/internal/model/type/neo/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      684 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      503 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/addresstype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      540 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/blockhashtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1699 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/opcodetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      540 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/publickeytype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      622 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/scripthashlittleendiantype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      550 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/scripthashtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      568 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/neo/transactionidtype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.820921 neo3-boa-1.1.1/boa3/internal/model/type/primitive/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1209 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/booltype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1023 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/bytearraytype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      740 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/bytestringtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1042 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/bytestype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1964 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/ibytestringtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1246 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/inttype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      945 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/nonetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      193 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/primitivetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1733 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/primitive/strtype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4639 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/type.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1874 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/typeutils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.852921 neo3-boa-1.1.1/boa3/internal/model/type/typingmethod/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/typingmethod/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4387 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/type/typingmethod/casttypemethod.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2314 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/model/variable.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.852921 neo3-boa-1.1.1/boa3/internal/neo/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2541 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.852921 neo3-boa-1.1.1/boa3/internal/neo/contracts/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       98 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/contracts/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2016 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/contracts/neffile.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.852921 neo3-boa-1.1.1/boa3/internal/neo/core/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      131 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/core/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/core/types/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      103 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/core/types/InteropInterface.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/core/types/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/cryptography/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      603 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/cryptography/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/smart_contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      112 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/smart_contract/VoidType.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/smart_contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2267 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/smart_contract/notification.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/utils/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4096 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/utils/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/vm/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      743 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/CallCode.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3476 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/TryCode.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3502 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/VMCode.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/
--rw-r--r--   0 circleci  (1001) circleci  (1002)    29385 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/Opcode.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    10712 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/OpcodeHelper.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    27753 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/OpcodeInfo.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1209 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/OpcodeInformation.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo/vm/type/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1984 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/type/AbiType.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      516 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/type/ContractParameterType.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1214 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/type/Integer.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2516 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/type/StackItem.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      492 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/type/String.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo/vm/type/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo3/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo3/contracts/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      220 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2843 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/contracttypes.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1697 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/findoptions.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      499 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/namedcurve.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.856921 neo3-boa-1.1.1/boa3/internal/neo3/contracts/native/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       85 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/native/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      512 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/native/nativetypes.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     9076 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/contracts/nef.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.860921 neo3-boa-1.1.1/boa3/internal/neo3/core/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      195 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/core/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    23279 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/core/serialization.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.860921 neo3-boa-1.1.1/boa3/internal/neo3/core/types/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      103 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/core/types/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4432 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/core/types/biginteger.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     8211 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/core/types/uint.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2232 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/core/utils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.860921 neo3-boa-1.1.1/boa3/internal/neo3/network/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/network/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.860921 neo3-boa-1.1.1/boa3/internal/neo3/network/payloads/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      120 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/network/payloads/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1468 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/network/payloads/oracleresponsecode.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1448 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/network/payloads/verification.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.860921 neo3-boa-1.1.1/boa3/internal/neo3/vm/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       29 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/vm/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      843 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/neo3/vm/vmstate.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      485 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3/internal/utils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.860921 neo3-boa-1.1.1/boa3_test/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/interface/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/interface/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1156 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/interface/itransactionobject.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      456 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/invokeresult.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2245 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neobatchinvoke.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1741 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neoinvoke.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2429 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neoinvokecollection.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1915 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neoinvokeresult.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/network/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      971 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/oracleresponse.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2069 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/signer.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1915 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/testblock.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4805 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/testtransaction.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      826 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/transactionattribute.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      968 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/witness.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1200 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/witnessscope.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5316 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/contractcollection.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2733 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/testcontract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      936 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/triggertype.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.900921 neo3-boa-1.1.1/boa3_test/test_drive/model/wallet/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/wallet/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1977 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/wallet/account.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      530 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/model/wallet/utils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       45 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     9447 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/batch.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      844 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1102 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      294 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      762 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/create.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      434 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/icheckpointcommand.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      764 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/restore.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      528 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1727 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/deploy.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      430 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/icontractcommand.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1910 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/invoke.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      577 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/list.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2264 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/run.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1227 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      948 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1644 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/neoexpresscommand.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      525 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      749 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/enable.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      427 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/ioraclecommand.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      442 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/list.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      450 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/requests.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      896 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/response.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.904921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      944 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      267 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1041 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/block.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      422 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/ishowcommand.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      694 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/transaction.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1414 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1288 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoxp.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1448 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoxp_contract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      717 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoxp_oracle.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/utils/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      757 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/utils/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     7821 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/executor.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/model/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/model/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      969 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/model/neoxpaccount.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3326 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/model/neoxpconfig.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5163 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/neoxp/utils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3361 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/block.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1250 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/contract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1554 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/log.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1460 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/notification.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4193 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/storage.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2322 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/storagecollection.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2616 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/transaction.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      934 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/transactionlog.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    19740 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/neo_test_runner.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2107 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/testrunner/utils.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      335 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/test_drive/utils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.908921 neo3-boa-1.1.1/boa3_test/tests/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)    17432 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/boa_test.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2601 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/run_unit_tests.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.912921 neo3-boa-1.1.1/boa3_test/tests/test_classes/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       50 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/TestExecutionException.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.912921 neo3-boa-1.1.1/boa3_test/tests/test_classes/binaryserializer/
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1974 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/binaryserializer/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1699 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/block.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.912921 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1198 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neoabistruct.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      668 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neoeventstruct.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1749 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neomanifeststruct.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1174 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neomethodstruct.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1423 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neopermissionsstruct.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      975 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neostruct.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1558 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/contractcollection.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      529 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/nativeaccountstate.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     1129 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/nativecontractprefix.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2542 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/signer.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     6453 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/storage.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3160 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/testcontract.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2412 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/transaction.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.944921 neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/
--rw-r--r--   0 circleci  (1001) circleci  (1002)      118 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2202 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      681 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      112 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/transactionattributetype.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      319 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_classes/witness.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.944921 neo3-boa-1.1.1/boa3_test/tests/test_drive/
--rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_drive/__init__.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.944921 neo3-boa-1.1.1/boa3_test/tests/test_drive/neoxp/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       78 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_drive/neoxp/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     4085 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_drive/neoxp/utils.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.944921 neo3-boa-1.1.1/boa3_test/tests/test_drive/testrunner/
--rw-r--r--   0 circleci  (1001) circleci  (1002)       78 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_drive/testrunner/__init__.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)      451 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_drive/testrunner/boa_neoxp_batch.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     5080 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_drive/testrunner/boa_test_runner.py
--rw-r--r--   0 circleci  (1001) circleci  (1002)     3047 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/boa3_test/tests/test_suite.py
-drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-02-02 15:59:10.948921 neo3-boa-1.1.1/neo3_boa.egg-info/
--rw-r--r--   0 circleci  (1001) circleci  (1002)    18229 2024-02-02 15:59:10.000000 neo3-boa-1.1.1/neo3_boa.egg-info/PKG-INFO
--rw-r--r--   0 circleci  (1001) circleci  (1002)    40463 2024-02-02 15:59:10.000000 neo3-boa-1.1.1/neo3_boa.egg-info/SOURCES.txt
--rw-r--r--   0 circleci  (1001) circleci  (1002)        1 2024-02-02 15:59:10.000000 neo3-boa-1.1.1/neo3_boa.egg-info/dependency_links.txt
--rw-r--r--   0 circleci  (1001) circleci  (1002)       71 2024-02-02 15:59:10.000000 neo3-boa-1.1.1/neo3_boa.egg-info/entry_points.txt
--rw-r--r--   0 circleci  (1001) circleci  (1002)      232 2024-02-02 15:59:10.000000 neo3-boa-1.1.1/neo3_boa.egg-info/requires.txt
--rw-r--r--   0 circleci  (1001) circleci  (1002)       15 2024-02-02 15:59:10.000000 neo3-boa-1.1.1/neo3_boa.egg-info/top_level.txt
--rw-r--r--   0 circleci  (1001) circleci  (1002)     2238 2024-02-02 15:58:48.000000 neo3-boa-1.1.1/pyproject.toml
--rw-r--r--   0 circleci  (1001) circleci  (1002)       38 2024-02-02 15:59:10.948921 neo3-boa-1.1.1/setup.cfg
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.124292 neo3_boa-1.2.0/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    11357 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/LICENSE
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    18285 2024-05-08 20:20:49.120292 neo3_boa-1.2.0/PKG-INFO
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3838 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/README.md
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3048 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/README.rst
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.016292 neo3_boa-1.2.0/boa3/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      116 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2724 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/boa3.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.016292 neo3_boa-1.2.0/boa3/builtin/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1199 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.016292 neo3_boa-1.2.0/boa3/builtin/compile_time/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    14106 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/compile_time/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.016292 neo3_boa-1.2.0/boa3/builtin/contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      468 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/contract/Nep17Contract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5106 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/contract/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.016292 neo3_boa-1.2.0/boa3/builtin/interop/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      435 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.016292 neo3_boa-1.2.0/boa3/builtin/interop/blockchain/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    10707 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/blockchain/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1457 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/blockchain/block.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1940 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/blockchain/signer.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1531 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/blockchain/transaction.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       65 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/blockchain/vmstate.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6195 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       76 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/contract/callflagstype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1071 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/contract/contract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6700 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/contract/contractmanifest.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/crypto/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7042 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/crypto/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       55 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/crypto/ibls12381.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       89 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/crypto/namedcurve.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/iterator/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      967 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/iterator/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/json/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      960 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/json/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/oracle/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      199 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/oracle/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      101 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/oracle/oracleresponsecode.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/policy/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1230 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/policy/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/role/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      543 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/role/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       73 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/role/roletype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/runtime/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6796 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/runtime/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      544 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/runtime/notification.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       80 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/runtime/triggertype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/stdlib/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5533 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/stdlib/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.020292 neo3_boa-1.2.0/boa3/builtin/interop/storage/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    10926 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/storage/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       80 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/storage/findoptions.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1055 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/storage/storagecontext.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1348 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/interop/storage/storagemap.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1154 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/math.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/builtin/nativecontract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6764 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/contractmanagement.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5322 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/cryptolib.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3409 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/gas.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     9094 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/ledger.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     8861 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/neo.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2278 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/oracle.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1679 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/policy.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      931 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/rolemanagement.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7845 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/nativecontract/stdlib.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/builtin/type/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2751 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/type/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      763 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/type/helper.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/builtin/vm/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       76 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/builtin/vm/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1090 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/cli.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1936 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/cpm.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/internal/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/internal/analyser/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    10780 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/analyser.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    11116 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/astanalyser.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      308 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/asthelper.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    17861 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/astoptimizer.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4730 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/builtinfunctioncallanalyser.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2775 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/constructanalyser.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    11296 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/importanalyser.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/internal/analyser/model/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      464 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/model/ManifestSymbol.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/model/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1170 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/model/functionarguments.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.024292 neo3_boa-1.2.0/boa3/internal/analyser/model/optimizer/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1120 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/model/optimizer/Operation.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3060 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/model/optimizer/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1474 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/model/symbolscope.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    72235 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/moduleanalyser.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.028292 neo3_boa-1.2.0/boa3/internal/analyser/supportedstandard/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      446 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/supportedstandard/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     9172 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/supportedstandard/standardanalyser.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    88319 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/analyser/typeanalyser.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.028292 neo3_boa-1.2.0/boa3/internal/cli_commands/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      106 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/cli_commands/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3782 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/cli_commands/compile_command.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      462 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/cli_commands/icommand.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.028292 neo3_boa-1.2.0/boa3/internal/compiler/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.028292 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      851 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)   103125 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/codegenerator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    56448 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/codegeneratorvisitor.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1445 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/codeoptimizer.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.028292 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1793 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/executionscript.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1218 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/istack.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2512 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/neoengine.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3636 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/stackmemento.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1631 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/generatordata.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4207 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/initstatementsvisitor.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3496 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/methodtokencollection.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      674 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/optimizerhelper.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      333 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/variablegenerationdata.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6678 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/vmcodemap.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    11251 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/vmcodemapping.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3190 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/compiledmetadata.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     8523 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/compiler.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      462 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/compileroutput.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.028292 neo3_boa-1.2.0/boa3/internal/compiler/filegenerator/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/filegenerator/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    35192 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/filegenerator/filegenerator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      900 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/compiler/filegenerator/importdata.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1755 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/constants.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      489 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/env.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.032292 neo3_boa-1.2.0/boa3/internal/exception/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    13097 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/exception/CompilerError.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4856 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/exception/CompilerWarning.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      180 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/exception/InvalidPathException.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      334 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/exception/NotLoadedException.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/exception/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.032292 neo3_boa-1.2.0/boa3/internal/helpers/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      368 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/helpers/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.032292 neo3_boa-1.2.0/boa3/internal/model/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      153 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1759 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/attribute.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.032292 neo3_boa-1.2.0/boa3/internal/model/builtin/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     9869 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/builtin.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2925 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/builtincallable.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      861 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/builtinproperty.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      492 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/builtinsymbol.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.036292 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2980 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3225 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/appendmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2463 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/clearmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      574 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/copydictmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      357 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/copylistmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2592 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/copymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3699 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4116 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countsequencegenericmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4187 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countsequencemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      643 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countsequenceprimitivemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6425 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countstrmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4366 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/extendmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5545 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/indexbytesstringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2588 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/indexmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7564 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/indexsequencemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4584 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/insertmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4200 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/isdigitmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5350 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/joinmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4780 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/lowermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1821 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/mapkeysmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1831 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/mapvaluesmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1822 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popdictdefaultmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      605 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popdictmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3632 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      911 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popsequencemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3550 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/removemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6745 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/replacemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1698 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/reversemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7012 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/sortmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5036 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/startswithmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     9796 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/stripmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4781 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/uppermethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.036292 neo3_boa-1.2.0/boa3/internal/model/builtin/compile_time/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      141 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/compile_time/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      456 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/compile_time/neometadatatype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.040292 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      578 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3192 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/abortmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3190 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/neoaccountstatetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      829 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep11transferevent.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.040292 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      856 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      731 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacebalanceofmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      532 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacedecimalsmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1884 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      528 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacesymbolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      572 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetotalsupplymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1001 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetransfermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1233 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17contract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      713 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17transferevent.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.040292 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      881 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      990 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/builtindecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1336 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/classmethoddecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2832 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/contractdecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3456 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/displaynamedecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      352 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/instancemethoddecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1436 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/propertydecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3205 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/publicdecorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      232 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/staticmethoddecorator.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.040292 neo3_boa-1.2.0/boa3/internal/model/builtin/internal/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      238 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/internal/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1843 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/internal/getenvmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2314 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/internal/innerdeploymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      952 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/internal/internalmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.044292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.044292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2484 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3694 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/blocktype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      739 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/currenthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      705 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/currentindexmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      775 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/getblockmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      766 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/getcontractmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      951 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionfromblockmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      584 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionheightmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      720 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      715 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionsignersmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      649 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionvmstatemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3419 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/signertype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3592 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/transactiontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1452 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/vmstatetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1630 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessconditionenumtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2824 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessconditiontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1599 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessruleactiontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3176 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessruletype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1539 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessscopeenumtype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.048292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1496 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1748 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/callflagstype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2028 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/callmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.048292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1521 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1992 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractabitype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1879 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1693 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractgrouptype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1932 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2163 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1829 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2064 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparametertype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1932 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1674 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3320 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contracttype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      859 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/createmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      796 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/createmultisigaccountmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      673 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/createstandardaccountmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      449 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/destroymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      518 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/getcallflagsmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      766 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/getgasscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      490 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/getminimumdeploymentfeemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      766 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/getneoscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      742 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/updatemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      872 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contractgethashmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1856 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      624 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381addmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      619 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381deserializemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      681 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381equalmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      718 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381mulmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      639 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381pairingmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      610 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381serializemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1160 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381type.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      710 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/checkmultisigmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      876 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/checksigmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1100 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/hash160method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1096 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/hash256method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      537 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/murmur32method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1608 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/namedcurvetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      474 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/ripemd160method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      464 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/sha256method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      856 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/verifywithecdsa.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    20164 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interop.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1105 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interopevent.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      571 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interopinterfacetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1963 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interopmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      507 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1935 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/getiteratorvalue.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1528 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/iteratorinitmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      562 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/iteratornextmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2993 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/iteratortype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/json/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      273 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/json/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      485 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/json/jsondeserializemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      479 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/json/jsonserializemethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      133 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      779 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1068 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      105 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      719 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1030 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.052292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       93 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1016 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      749 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/ledgermethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Neo/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       97 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Neo/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      802 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Neo/getneoscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      742 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Neo/neocontractmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       89 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1070 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/getnep17scripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      845 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/nep17method.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       93 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      992 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      704 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/oraclemethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      117 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1032 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      779 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      117 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1036 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      734 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       93 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      995 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/getstdlibscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      704 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      506 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4072 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/nativecontractmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      249 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      579 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/oraclegetpricemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      892 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/oraclerequestmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1736 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/oracleresponsecodetype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      532 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      481 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/getexecfeefactormethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      472 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/getfeeperbytemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      477 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/getstoragepricemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      611 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/isblockedmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.056292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/role/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      252 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/role/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      797 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/role/getdesignatedbyrolemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1549 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/role/roletype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.060292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2551 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      458 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/burngasmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      880 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/checkwitnessmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      737 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getaddressversionmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      690 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getblocktimemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      802 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getcallingscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      790 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getentryscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      814 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getexecutingscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      692 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getgasleftmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      755 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getinvocationcountermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      441 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getnetworkmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2008 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getnotificationsmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      696 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getplatformmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      438 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getrandommethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      497 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/gettriggermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1663 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/loadscriptmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      449 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/logmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2929 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/notificationtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1065 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/notifymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      780 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/scriptcontainermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1778 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/triggertype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.064292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1528 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      633 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/atoimethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      494 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/base58checkdecodemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      494 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/base58checkencodemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      478 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/base58decodemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      478 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/base58encodemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      478 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/base64decodemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      478 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/base64encodemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      475 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/deserializemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      694 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/itoamethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      609 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/memorycomparemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1193 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/memorysearchmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      469 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/serializemethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.064292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1572 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1829 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/findoptionstype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.064292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      730 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4065 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/istoragegetmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      787 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetboolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      619 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetbytesmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      733 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetecpointmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      781 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      783 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetstrmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      733 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetuint160method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      733 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetuint256method.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.068292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      730 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3831 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/istorageputmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      498 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputboolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      478 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputbytesmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      557 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputecpointmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      495 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      495 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputstrmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      557 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputuint160method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      557 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputuint256method.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.068292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       51 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      556 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1203 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2125 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2931 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagedeletemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4456 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagefindmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      576 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      594 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.068292 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       43 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1692 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1849 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1994 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapputmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3874 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemaptype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.068292 neo3_boa-1.2.0/boa3/internal/model/builtin/math/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      418 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/math/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2743 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/math/decimalceil.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2596 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/math/decimalfloor.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1000 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/math/powmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      708 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/math/sqrtmethod.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.076292 neo3_boa-1.2.0/boa3/internal/model/builtin/method/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4025 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      710 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/absmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2428 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/boolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1003 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/builtinevent.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6540 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/builtinmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      706 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/bytearrayencodingmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3703 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/bytearraymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1884 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/createeventmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3463 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/ecpointmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1880 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/ecpointtoscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2306 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/exceptionmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      677 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/exitmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    12410 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/intbytestringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      705 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/intintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1560 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/intmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4998 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/isinstancemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1765 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/lenmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2262 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/listbytesstringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3710 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/listgenericmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      912 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/listmappingmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3382 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/listmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      925 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/listsequencemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4443 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/maxbytestringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      345 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/maxintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5624 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/maxmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4435 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/minbytestringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      345 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/minintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5851 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/minmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      579 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/printboolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      516 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/printbytestringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      731 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/printclassmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      533 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/printintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5231 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/printmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      630 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/printsequencemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5065 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/rangemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3990 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/reversedmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      825 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strboolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      577 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strbytestringmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2084 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strclassmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      588 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strintmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1910 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1090 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strsequencemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3840 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/strsplitmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2266 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/summethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1586 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/supermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2441 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/toboolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4264 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/tobytesmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4508 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/tohexstrmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2428 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/tointmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5033 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/toscripthashmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2428 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/tostrmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5496 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/uint160method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5496 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/method/uint256method.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.076292 neo3_boa-1.2.0/boa3/internal/model/builtin/native/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      841 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.076292 neo3_boa-1.2.0/boa3/internal/model/builtin/native/contract_management/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      125 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/contract_management/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      684 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/contract_management/hasmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1511 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/contractmanagementclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1592 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/cryptolibclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1444 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/gasclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1355 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/inativecontractclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1474 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/ledgerclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2488 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nativecontract.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.080292 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1730 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      686 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getaccountstatemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      800 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getallcandidatesmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      758 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatesmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      650 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatevotemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      581 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getcommitteemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      470 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getgasperblockmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      613 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getnextblockvalidators.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      628 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/registercandidatemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      652 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/unclaimedgasmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      634 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/unregistercandidatemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1190 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/unvote.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      732 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/vote.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2984 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/neoclass.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.080292 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      620 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      632 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/balanceofmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      500 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/decimalsmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      494 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/symbolmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      509 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/totalsupplymethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      980 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/transfermethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1231 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/oracleclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1237 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/policyclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1129 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/rolemanagementclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1761 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/builtin/native/stdlibclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7253 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/callable.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1198 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/debuginstruction.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1108 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/decorator.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1353 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/event.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1024 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/expression.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1318 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/identifiedsymbol.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.080292 neo3_boa-1.2.0/boa3/internal/model/imports/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       51 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/imports/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7035 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/imports/compilerbuiltin.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3034 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/imports/importsymbol.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6777 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/imports/package.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6106 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/method.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4561 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/module.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.080292 neo3_boa-1.2.0/boa3/internal/model/operation/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.080292 neo3_boa-1.2.0/boa3/internal/model/operation/binary/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.080292 neo3_boa-1.2.0/boa3/internal/model/operation/binary/additional/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      277 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/additional/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6614 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/additional/membership.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2917 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/additional/notmembership.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.084292 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1098 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1529 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/addition.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2440 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/concat.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1419 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/division.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1466 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/floordivision.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3671 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/listaddition.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3013 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/modulo.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1541 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/multiplication.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1451 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/power.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2710 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/strbytesmultiplication.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1465 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/subtraction.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3090 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/binaryoperation.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.084292 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      833 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1466 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/booleanand.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1463 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/booleanor.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1867 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/elvisoperatoror.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1498 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/leftshift.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1470 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/logicand.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1466 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/logicor.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1470 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/logicxor.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1502 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/rightshift.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.088292 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1743 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1468 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/greaterthan.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1485 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/greaterthanorequal.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1272 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/identity.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1462 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/lessthan.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1479 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/lessthanorequal.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1328 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/notidentity.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1485 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/numericequality.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1495 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/numericinequality.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1599 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/objectequality.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1576 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/objectinequality.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2132 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/strbytesgreaterthan.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2147 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/strbytesgreaterthanorequal.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2121 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/strbyteslessthan.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2146 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/strbyteslessthanorequal.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4349 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/binaryop.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3362 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/operation.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2241 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/operator.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.088292 neo3_boa-1.2.0/boa3/internal/model/operation/unary/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      453 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1293 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/booleannot.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1309 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/logicnot.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1297 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/negative.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1579 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/noneidentity.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1727 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/nonenotidentity.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1335 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/positive.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1426 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unary/unaryoperation.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1935 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/operation/unaryop.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1015 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/property.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.088292 neo3_boa-1.2.0/boa3/internal/model/standards/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/standards/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2175 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/standards/neostandard.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3220 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/standards/nep11divisiblestandard.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2533 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/standards/nep11nondivisiblestandard.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1435 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/standards/nep17standard.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      963 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/standards/standardmethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      821 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/symbol.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.088292 neo3_boa-1.2.0/boa3/internal/model/type/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.092292 neo3_boa-1.2.0/boa3/internal/model/type/annotation/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/annotation/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      735 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/annotation/ellipsistype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1526 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/annotation/metatype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1726 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/annotation/optionaltype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4109 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/annotation/uniontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      782 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/anytype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      639 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/baseexceptiontype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.092292 neo3_boa-1.2.0/boa3/internal/model/type/classes/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      537 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/classarraytype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1636 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/classinitmethoddefault.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      119 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/classscope.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      538 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/classstructtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    11990 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/classtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1177 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/contractinterfaceclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      997 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/contractinterfacehash.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4580 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/pythonclass.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5641 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/classes/userclass.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.092292 neo3_boa-1.2.0/boa3/internal/model/type/collection/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1465 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/genericcollectiontype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6346 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/icollection.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.092292 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      887 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/genericmappingtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4136 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mappingtype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.092292 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mutable/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mutable/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1342 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mutable/dicttype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      777 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mutable/mutablemappingtype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      627 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/buffertype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3919 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/ecpointtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1123 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/genericsequencetype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1181 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/genericmutablesequencetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1750 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/listtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1428 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/mutablesequencetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1412 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/rangetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1498 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/reversedtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1508 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/sequencetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5298 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/tupletype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3572 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/uint160type.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3648 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/uint256type.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5306 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/itype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1094 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/math.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/model/type/neo/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      684 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      503 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/addresstype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      540 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/blockhashtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1693 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/opcodetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      540 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/publickeytype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      622 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/scripthashlittleendiantype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      550 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/scripthashtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      568 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/neo/transactionidtype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/model/type/primitive/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1209 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/booltype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1023 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/bytearraytype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      740 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/bytestringtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1042 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/bytestype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1958 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/ibytestringtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1246 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/inttype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      945 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/nonetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      193 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/primitivetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1733 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/primitive/strtype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4735 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/type.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3525 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/typeutils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/model/type/typingmethod/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/typingmethod/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4379 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/type/typingmethod/casttypemethod.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2355 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/model/variable.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/neo/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2508 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/neo/contracts/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       98 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/contracts/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1977 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/contracts/neffile.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.096292 neo3_boa-1.2.0/boa3/internal/neo/core/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      131 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/core/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/core/types/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      103 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/core/types/InteropInterface.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/core/types/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/cryptography/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      603 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/cryptography/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/smart_contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      112 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/smart_contract/VoidType.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/smart_contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2211 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/smart_contract/notification.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/utils/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4104 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/utils/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/vm/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      743 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/CallCode.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3435 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/TryCode.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3457 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/VMCode.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    29349 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/Opcode.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    10606 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/OpcodeHelper.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    27736 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/OpcodeInfo.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1153 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/OpcodeInformation.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo/vm/type/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1946 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/type/AbiType.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      516 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/type/ContractParameterType.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1214 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/type/Integer.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2461 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/type/StackItem.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      492 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/type/String.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo/vm/type/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.100292 neo3_boa-1.2.0/boa3/internal/neo3/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/contracts/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      220 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2843 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/contracttypes.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1697 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/findoptions.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      499 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/namedcurve.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/contracts/native/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       85 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/native/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      512 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/native/nativetypes.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     9029 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/contracts/nef.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/core/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      195 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/core/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    23206 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/core/serialization.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/core/types/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      103 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/core/types/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4360 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/core/types/biginteger.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     8126 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/core/types/uint.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2241 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/core/utils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/network/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/network/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/network/payloads/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      120 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/network/payloads/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1468 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/network/payloads/oracleresponsecode.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1448 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/network/payloads/verification.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3/internal/neo3/vm/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       29 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/vm/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      807 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/neo3/vm/vmstate.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      485 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3/internal/utils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3_test/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3_test/test_drive/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3_test/test_drive/model/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3_test/test_drive/model/interface/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/interface/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1156 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/interface/itransactionobject.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      456 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/invokeresult.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2248 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neobatchinvoke.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1725 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neoinvoke.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2404 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neoinvokecollection.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1918 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neoinvokeresult.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.104292 neo3_boa-1.2.0/boa3_test/test_drive/model/network/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      929 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/oracleresponse.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2025 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/signer.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1855 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/testblock.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4710 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/testtransaction.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      778 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/transactionattribute.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      929 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/witness.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1184 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/witnessscope.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5291 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/contractcollection.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2695 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/testcontract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      921 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/triggertype.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/model/wallet/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/wallet/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1913 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/wallet/account.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      530 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/model/wallet/utils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       45 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     9416 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/batch.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      844 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1064 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.108292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      294 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      724 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/create.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      410 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/icheckpointcommand.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      726 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/restore.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      528 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1721 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/deploy.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      406 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/icontractcommand.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1885 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/invoke.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      552 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/list.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2245 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/run.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1189 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      923 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1614 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/neoexpresscommand.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      525 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      724 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/enable.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      403 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/ioraclecommand.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      417 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/list.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      425 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/requests.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      858 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/response.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      906 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      267 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1004 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/block.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      398 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/ishowcommand.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      656 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/transaction.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1408 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1275 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoxp.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1448 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoxp_contract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      717 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoxp_oracle.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/utils/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      725 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/utils/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     7777 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/executor.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/model/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/model/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      951 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/model/neoxpaccount.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3302 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/model/neoxpconfig.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5119 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/neoxp/utils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.112292 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.116292 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3297 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/block.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1218 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/contract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1509 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/log.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1500 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/notification.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4118 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/storage.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2284 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/storagecollection.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2527 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/transaction.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      872 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/transactionlog.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    19669 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/neo_test_runner.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2134 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/testrunner/utils.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      351 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/test_drive/utils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.116292 neo3_boa-1.2.0/boa3_test/tests/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3431 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/annotation.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    39565 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/boatestcase.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1259 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/event.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2842 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/run_unit_tests.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2934 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/stackitem.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.116292 neo3_boa-1.2.0/boa3_test/tests/test_classes/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       50 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/TestExecutionException.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.116292 neo3_boa-1.2.0/boa3_test/tests/test_classes/binaryserializer/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1974 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/binaryserializer/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1642 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/block.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.116292 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1148 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neoabistruct.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      622 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neoeventstruct.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1700 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neomanifeststruct.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1127 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neomethodstruct.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1342 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neopermissionsstruct.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      928 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neostruct.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1533 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/contractcollection.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      529 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/nativeaccountstate.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     1085 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/nativecontractprefix.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2481 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/signer.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     6379 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/storage.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3126 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/testcontract.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2343 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/transaction.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.120292 neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      118 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2156 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      686 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      112 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/transactionattributetype.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      283 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_classes/witness.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.120292 neo3_boa-1.2.0/boa3_test/tests/test_drive/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_drive/__init__.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.120292 neo3_boa-1.2.0/boa3_test/tests/test_drive/neoxp/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       78 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_drive/neoxp/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     4042 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_drive/neoxp/utils.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.120292 neo3_boa-1.2.0/boa3_test/tests/test_drive/testrunner/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       78 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_drive/testrunner/__init__.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      451 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_drive/testrunner/boa_neoxp_batch.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     5041 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_drive/testrunner/boa_test_runner.py
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     3047 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/boa3_test/tests/test_suite.py
+drwxr-xr-x   0 circleci  (1001) circleci  (1002)        0 2024-05-08 20:20:49.120292 neo3_boa-1.2.0/neo3_boa.egg-info/
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    18285 2024-05-08 20:20:48.000000 neo3_boa-1.2.0/neo3_boa.egg-info/PKG-INFO
+-rw-r--r--   0 circleci  (1001) circleci  (1002)    41997 2024-05-08 20:20:49.000000 neo3_boa-1.2.0/neo3_boa.egg-info/SOURCES.txt
+-rw-r--r--   0 circleci  (1001) circleci  (1002)        1 2024-05-08 20:20:48.000000 neo3_boa-1.2.0/neo3_boa.egg-info/dependency_links.txt
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       71 2024-05-08 20:20:48.000000 neo3_boa-1.2.0/neo3_boa.egg-info/entry_points.txt
+-rw-r--r--   0 circleci  (1001) circleci  (1002)      260 2024-05-08 20:20:48.000000 neo3_boa-1.2.0/neo3_boa.egg-info/requires.txt
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       15 2024-05-08 20:20:48.000000 neo3_boa-1.2.0/neo3_boa.egg-info/top_level.txt
+-rw-r--r--   0 circleci  (1001) circleci  (1002)     2271 2024-05-08 20:20:21.000000 neo3_boa-1.2.0/pyproject.toml
+-rw-r--r--   0 circleci  (1001) circleci  (1002)       38 2024-05-08 20:20:49.124292 neo3_boa-1.2.0/setup.cfg
```

### Comparing `neo3-boa-1.1.1/LICENSE` & `neo3_boa-1.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/PKG-INFO` & `neo3_boa-1.2.0/PKG-INFO`

 * *Files identical despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: neo3-boa
-Version: 1.1.1
+Version: 1.2.0
 Summary: A Python compiler for the Neo3 Virtual Machine
 License:                                  Apache License
                                    Version 2.0, January 2004
                                 http://www.apache.org/licenses/
         
            TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
         
@@ -208,30 +208,31 @@
 Project-URL: documentation, https://dojo.coz.io/neo3/boa/index.html
 Project-URL: changelog, https://github.com/CityOfZion/neo3-boa/blob/master/CHANGELOG.md
 Keywords: compiler,NEO,.nef,blockchain,smartcontract,development,dApp
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Topic :: Software Development :: Build Tools
 Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
-Requires-Python: <=3.12,>=3.10.0
+Classifier: Programming Language :: Python :: 3.12
+Requires-Python: <=3.12,>=3.11
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: base58>=1.0.3
 Requires-Dist: wheel>=0.30.0
 Requires-Dist: requests==2.31.0
 Provides-Extra: dev
 Requires-Dist: autopep8>=1.4.4; extra == "dev"
 Requires-Dist: bump-my-version==0.10.0; extra == "dev"
+Requires-Dist: coverage>=6.0.1; extra == "dev"
+Requires-Dist: filelock>=3.10.7; extra == "dev"
 Requires-Dist: pycodestyle>=2.11.1; extra == "dev"
 Requires-Dist: twine>=1.10.0; extra == "dev"
 Provides-Extra: test
-Requires-Dist: filelock>=3.10.7; extra == "test"
-Requires-Dist: coverage>=6.0.1; extra == "test"
+Requires-Dist: boa-test-constructor==0.3.0; extra == "test"
 Provides-Extra: docs
 Requires-Dist: myst-parser==1.0.0; extra == "docs"
 Requires-Dist: Sphinx==5.0.0; extra == "docs"
 Requires-Dist: sphinx-rtd-theme==1.2.1; extra == "docs"
 
 <p align="center">
   <img
```

### Comparing `neo3-boa-1.1.1/README.md` & `neo3_boa-1.2.0/README.md`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/README.rst` & `neo3_boa-1.2.0/README.rst`

 * *Files 2% similar despite different names*

```diff
@@ -38,15 +38,15 @@
 Maintenance
 ^^^^^^^^^^^
 Create a product that is easy to maintain and upgrade. Use Unit tests, typed and documented code to ensure its maintainability.
 
 Quickstart
 ----------
 
-Installation requires Python 3.10 or later.
+Installation requires Python 3.11 or later.
 
 Compiling your Smart Contract
 =============================
 
 Using CLI
 ^^^^^^^^^
```

### Comparing `neo3-boa-1.1.1/boa3/boa3.py` & `neo3_boa-1.2.0/boa3/boa3.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,17 +7,22 @@
 class Boa3:
     """
     The main class.
     Contains the methods that the final user have access to.
     """
 
     @staticmethod
-    def compile(path: str, root_folder: str = None, log_level: str = None,
-                env: str = None, fail_fast: bool = True,
-                optimize: bool = True) -> bytes:
+    def compile(
+            path: str,
+            root_folder: str = None,
+            log_level: str = None,
+            env: str = None,
+            fail_fast: bool = True,
+            optimize: bool = True
+    ) -> bytes:
         """
         Load a Python file to be compiled but don't write the result into a file
 
         :param path: the path of the Python file to compile
         :param root_folder: the root path of the project
         :param env: specific environment id to compile
         :param fail_fast: if should stop compilation on first error found.
@@ -29,18 +34,25 @@
         return Compiler().compile(path, root_folder, env,
                                   log_level=log_level,
                                   fail_fast=fail_fast,
                                   optimize=optimize
                                   )
 
     @staticmethod
-    def compile_and_save(path: str, output_path: str = None, root_folder: str = None,
-                         show_errors: bool = True, log_level: str = None,
-                         debug: bool = False, env: str = None, fail_fast: bool = True,
-                         optimize: bool = True):
+    def compile_and_save(
+            path: str,
+            output_path: str = None,
+            root_folder: str = None,
+            show_errors: bool = True,
+            log_level: str = None,
+            debug: bool = False,
+            env: str = None,
+            fail_fast: bool = True,
+            optimize: bool = True
+    ):
         """
         Load a Python file to be compiled and save the result into the files.
         By default, the resultant .nef file is saved in the same folder of the
         source file.
 
         :param path: the path of the Python file to compile
         :param output_path: Optional path to save the generated files
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/compile_time/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/compile_time/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,22 +1,21 @@
 __all__ = [
     'CreateNewEvent',
     'public',
-    'metadata',
     'contract',
     'display_name',
     'NeoMetadata',
 ]
 
-from typing import List, Dict, Any, Union, Optional, Tuple
+from typing import Any
 
 from boa3.builtin.type import Event
 
 
-def CreateNewEvent(arguments: List[Tuple[str, type]] = [], event_name: str = '') -> Event:
+def CreateNewEvent(arguments: list[tuple[str, type]] = [], event_name: str = '') -> Event:
     """
     Creates a new Event.
 
     Check out `Neo's Documentation <https://developers.neo.org/docs/n3/develop/write/basics#events>`__ to learn more
     about Events.
 
     >>> new_event: Event = CreateNewEvent(
@@ -24,15 +23,15 @@
     ...        ('name', str),
     ...        ('amount', int)
     ...     ],
     ...     'New Event'
     ... )
 
     :param arguments: the list of the events args' names and types
-    :type arguments: List[Tuple[str, type]]
+    :type arguments: list[tuple[str, type]]
     :param event_name: custom name of the event. It's filled with the variable name if not specified
     :type event_name: str
     :return: the new event
     :rtype: Event
     """
     pass
 
@@ -82,31 +81,15 @@
     :type safe: bool
     """
     def decorator_wrapper(*args, **kwargs):
         pass
     return decorator_wrapper
 
 
-def metadata(*args):
-    """
-    This decorator identifies the function that returns the metadata object of the smart contract.
-    This can be used to only one function. Using this decorator in multiple functions will raise a compiler error.
-
-    Deprecated in 1.1.1. Will be removed in 1.2.0
-
-    >>> @metadata   # this indicates that this function will have information about the smart contract
-    ... def neo_metadata() -> NeoMetadata:      # needs to return a NeoMetadata
-    ...     meta = NeoMetadata()
-    ...     meta.name = 'NewContractName'
-    ...     return meta
-    """
-    pass
-
-
-def contract(script_hash: Union[str, bytes]):
+def contract(script_hash: str | bytes):
     """
     This decorator identifies a class that should be interpreted as an interface to an existing contract.
 
     If you want to use the script hash in your code, you can use the `hash` class attribute that automatically maps the
     script hash parameter onto it. You don't need to declare it in your class, but your IDE might send a warning about
     the attribute if you don't.
 
@@ -179,39 +162,39 @@
     ...     meta.add_trusted_source("0x1234567890123456789012345678901234567890")
     ...     meta.date = "2023/05/30"    # this property will end up inside the extra property
     ...     return meta
 
     :ivar name: the smart contract name. Will be the name of the file by default;
     :vartype type name: str
     :ivar supported_standards: Neo standards supported by this smart contract. Empty by default;
-    :vartype supported_standards: List[str]
+    :vartype supported_standards: list[str]
     :ivar permissions: a list of contracts and methods that this smart contract permits to invoke and call. All
      contracts and methods permitted by default;
-    :vartype permissions: List[str]
+    :vartype permissions: list[str]
     :ivar trusts: a list of contracts that this smart contract trust. Empty by default;
-    :vartype trusts: List[str]
+    :vartype trusts: list[str]
     :ivar author: the smart contract author. None by default;
     :vartype author: str or None
     :ivar email: the smart contract author email. None by default;
     :vartype email: str or None
     :ivar description: the smart contract description. None by default;
     :vartype description: str or None
     """
     from boa3.internal.constants import IMPORT_WILDCARD
 
     def __init__(self):
         self.name: str = ''
-        self.source: Optional[str] = None
-        self.supported_standards: List[str] = []
-        self._trusts: List[str] = []
-        self._permissions: List[dict] = []
-        self._groups: List[dict] = []
+        self.source: str | None = None
+        self.supported_standards: list[str] = []
+        self._trusts: list[str] = []
+        self._permissions: list[dict] = []
+        self._groups: list[dict] = []
 
     @property
-    def extras(self) -> Dict[str, Any]:
+    def extras(self) -> dict[str, Any]:
         """
         Gets the metadata extra information.
 
         :return: a dictionary that maps each extra value with its name. Empty by default
         """
         # list the variables names that are part of the manifest
         specific_field_names = ['name',
@@ -227,26 +210,26 @@
             if var_value is not None and not var_name.startswith('_'):
                 extra_field = var_name.title().replace('_', '')
                 extra[extra_field] = var_value
 
         return extra
 
     @property
-    def trusts(self) -> List[str]:
+    def trusts(self) -> list[str]:
         from boa3.internal.constants import IMPORT_WILDCARD
         if self._trusts == [IMPORT_WILDCARD]:
             return IMPORT_WILDCARD
         return self._trusts.copy()
 
     @property
-    def permissions(self) -> List[dict]:
+    def permissions(self) -> list[dict]:
         return self._permissions.copy()
 
     @property
-    def groups(self) -> List[dict]:
+    def groups(self) -> list[dict]:
         return self._groups.copy()
 
     def add_trusted_source(self, hash_or_address: str):
         """
         Adds a valid contract hash, valid group public key, or the '*' wildcard to trusts.
 
         >>> self.add_trusted_source("0x1234567890123456789012345678901234abcdef")
@@ -302,61 +285,72 @@
             'pubkey': pub_key.lower(),
             'signature': signature,
         }
 
         if new_group not in self._permissions:
             self._groups.append(new_group)
 
-    def add_permission(self, *, contract: str = IMPORT_WILDCARD, methods: Union[List[str], str] = IMPORT_WILDCARD):
+    def add_permission(self, *, contract: str = IMPORT_WILDCARD,
+                       methods: list[str] | str | tuple[str, ...] = IMPORT_WILDCARD):
         """
         Adds a valid contract and a valid methods to the permissions in the manifest.
 
         >>> self.add_permission(methods=['onNEP17Payment'])
 
         >>> self.add_permission(contract='0x3846a4aa420d9831044396dd3a56011514cd10e3', methods=['get_object'])
 
         >>> self.add_permission(contract='0333b24ee50a488caa5deec7e021ff515f57b7993b93b45d7df901e23ee3004916')
 
         :param contract: a contract hash, group public key or '*'
         :type contract: str
         :param methods: a list of methods or '*'
-        :type methods: Union[List[str], str]
+        :type methods: list[str] or str
         """
 
         if isinstance(contract, bytes):
             try:
                 from boa3.internal.neo3.core.types import UInt160
                 contract = str(UInt160(contract))
             except BaseException:
                 pass
 
         if not isinstance(contract, str):
             return
 
-        if not isinstance(methods, (str, list)):
+        if not isinstance(methods, (str, list, tuple)):
             return
 
         from boa3.internal.constants import IMPORT_WILDCARD
         # verifies if contract is a valid value
         if (not self._verify_is_valid_contract_hash(contract) and
                 not self._verify_is_valid_public_key(contract) and
                 contract != IMPORT_WILDCARD):
             return
 
         # verifies if methods is a valid value
-        elif ((isinstance(methods, str) and methods != IMPORT_WILDCARD) or
-              (isinstance(methods, list) and any(not isinstance(method, str) for method in methods))):
+        elif isinstance(methods, (tuple, list)) and (any(not isinstance(method, str) for method in methods) or len(methods) == 0):
             return
 
         from boa3.internal import constants
         wildcard_permission = {
             'contract': constants.IMPORT_WILDCARD,
             'methods': constants.IMPORT_WILDCARD,
         }
 
+        # verifies if method contains wildcard
+        if isinstance(methods, (tuple, list)):
+            # if any of the elements in the tuple is the wildcard
+            if constants.IMPORT_WILDCARD in methods:
+                methods = constants.IMPORT_WILDCARD
+            else:
+                methods = list(methods)
+        # if it's a single str and not wildcard, add to a list
+        elif isinstance(methods, str) and methods != constants.IMPORT_WILDCARD:
+            methods = [methods]
+
         if wildcard_permission not in self._permissions:
             new_permission = {
                 'contract': contract.lower(),
                 'methods': methods,
             }
 
             if contract == constants.IMPORT_WILDCARD and methods == constants.IMPORT_WILDCARD:
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/contract/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/contract/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,26 +4,26 @@
     'Nep17Contract',
     'NeoAccountState',
     'abort',
     'to_hex_str',
     'to_script_hash',
 ]
 
-from typing import Any, Optional, Union
+from typing import Any
 
 from boa3.builtin.compile_time import CreateNewEvent
 from boa3.builtin.contract.Nep17Contract import Nep17Contract
 from boa3.builtin.type import ECPoint, UInt160, Event
 
 Nep11TransferEvent: Event = CreateNewEvent(
     [
-        ('from', Union[UInt160, None]),
-        ('to', Union[UInt160, None]),
+        ('from', UInt160 | None),
+        ('to', UInt160 | None),
         ('amount', int),
-        ('tokenId', Union[str, bytes])
+        ('tokenId', str | bytes)
     ],
     'Transfer'
 )
 """
 The NEP-11 Transfer event that should be triggered whenever a non-fungible token is transferred, minted or burned. It 
 needs the addresses of the sender, receiver, amount transferred and the id of the token.
 
@@ -45,16 +45,16 @@
 
 :meta hide-value:
 """
 
 
 Nep17TransferEvent: Event = CreateNewEvent(
     [
-        ('from', Union[UInt160, None]),
-        ('to', Union[UInt160, None]),
+        ('from', UInt160 | None),
+        ('to', UInt160 | None),
         ('amount', int)
     ],
     'Transfer'
 )
 """
 The NEP-17 Transfer event that should be triggered whenever a fungible token is transferred, minted or burned. It needs
 the addresses of the sender, receiver and the amount transferred.
@@ -74,15 +74,15 @@
     }
 }
 
 :meta hide-value:
 """
 
 
-def abort(msg: Optional[str] = None):
+def abort(msg: str | None = None):
     """
     Aborts the execution of a smart contract. Using this will cancel the changes made on the blockchain by the
     transaction.
 
     >>> abort()     # abort doesn't return anything by itself, but the execution will stop and the VMState will be FAULT
     VMState.FAULT
 
@@ -106,14 +106,15 @@
     """
 
     def __init__(self):
         from boa3.internal import constants
         self.balance: int = 0
         self.height: int = 0
         self.vote_to: ECPoint = ECPoint(bytes(constants.SIZE_OF_ECPOINT))
+        self.last_gas_per_vote: int = 0
 
 
 def to_script_hash(data_bytes: Any) -> bytes:
     """
     Converts a data to a script hash.
 
     >>> to_script_hash(ECPoint(bytes(range(33))))
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/blockchain/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/blockchain/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,25 +10,23 @@
     'get_transaction_height',
     'get_transaction_signers',
     'get_transaction_vm_state',
     'current_hash',
     'current_index',
 ]
 
-from typing import List, Optional, Union
-
 from boa3.builtin.interop.blockchain.block import Block
 from boa3.builtin.interop.blockchain.signer import Signer
 from boa3.builtin.interop.blockchain.transaction import Transaction
 from boa3.builtin.interop.blockchain.vmstate import VMState
 from boa3.builtin.interop.contract import Contract
 from boa3.builtin.type import UInt160, UInt256
 
 
-def get_contract(hash: UInt160) -> Optional[Contract]:
+def get_contract(hash: UInt160) -> Contract | None:
     """
     Gets a contract with a given hash. If the script hash is not associated with a smart contract, then it will return
     None.
 
     >>> get_contract(UInt160(b'\\xcfv\\xe2\\x8b\\xd0\\x06,JG\\x8e\\xe3Ua\\x01\\x13\\x19\\xf3\\xcf\\xa4\\xd2'))    # GAS script hash
     {
         'id': -6,
@@ -55,15 +53,15 @@
     :rtype: Contract
 
     :raise Exception: raised if hash length isn't 20 bytes.
     """
     pass
 
 
-def get_block(index_or_hash: Union[int, UInt256]) -> Optional[Block]:
+def get_block(index_or_hash: int | UInt256) -> Block | None:
     """
     Gets the block with the given index or hash. Will return None if the index or hash is not associated with a Block.
 
     >>> get_block(0)        # first block
     {
         'hash': b"S{\\xed'\\x85&\\xf5\\x93U=\\xc1\\xbf'\\x95\\xc4/\\x80X\\xdb\\xd5\\xa1-\\x97q\\x85\\xe3I\\xe5\\x99cd\\x04",
         'version': 0,
@@ -101,15 +99,15 @@
     :type index_or_hash: int or UInt256
     :return: the desired block, if exists. None otherwise
     :rtype: Block or None
     """
     pass
 
 
-def get_transaction(hash_: UInt256) -> Optional[Transaction]:
+def get_transaction(hash_: UInt256) -> Transaction | None:
     """
     Gets a transaction with the given hash. Will return None if the hash is not associated with a Transaction.
 
     >>> get_transaction(UInt256(b'\\xff\\x7f\\x18\\x99\\x8c\\x1d\\x10X{bA\\xc2\\xe3\\xdf\\xc8\\xb0\\x9f>\\xd0\\xd2G\\xe3\\xba\\xd8\\x96\\xb9\\x0e\\xc1iS\\xcdr'))
     {
         'hash': b'\\xff\\x7f\\x18\\x99\\x8c\\x1d\\x10X{bA\\xc2\\xe3\\xdf\\xc8\\xb0\\x9f>\\xd0\\xd2G\\xe3\\xba\\xd8\\x96\\xb9\\x0e\\xc1iS\\xcdr',
         'version': 0,
@@ -127,15 +125,15 @@
     :param hash_: hash identifier of the transaction
     :type hash_: UInt256
     :return: the Transaction, if exists. None otherwise
     """
     pass
 
 
-def get_transaction_from_block(block_hash_or_height: Union[UInt256, int], tx_index: int) -> Optional[Transaction]:
+def get_transaction_from_block(block_hash_or_height: UInt256 | int, tx_index: int) -> Transaction | None:
     """
     Gets a transaction from a block. Will return None if the block hash or height is not associated with a Transaction.
 
     >>> get_transaction_from_block(1, 0)
     {
         'hash': b'\\xff\\x7f\\x18\\x99\\x8c\\x1d\\x10X{bA\\xc2\\xe3\\xdf\\xc8\\xb0\\x9f>\\xd0\\xd2G\\xe3\\xba\\xd8\\x96\\xb9\\x0e\\xc1iS\\xcdr',
         'version': 0,
@@ -190,15 +188,15 @@
     :param hash_: hash identifier of the transaction
     :type hash_: UInt256
     :return: height of the transaction
     """
     pass
 
 
-def get_transaction_signers(hash_: UInt256) -> List[Signer]:
+def get_transaction_signers(hash_: UInt256) -> list[Signer]:
     """
     Gets a list with the signers of a transaction.
 
     >>> get_transaction_signers(UInt256(b'\\x29\\x41\\x06\\xdb\\x4c\\xf3\\x84\\xa7\\x20\\x4d\\xba\\x0a\\x04\\x03\\x72\\xb3\\x27\\x76\\xf2\\x6e\\xd3\\x87\\x49\\x88\\xd0\\x3e\\xff\\x5d\\xa9\\x93\\x8c\\xa3'))
     [
         {
             "account": b'\\xa6\\xea\\xb0\\xae\\xaf\\xb4\\x96\\xa1\\x1b\\xb0|\\x88\\x17\\xcar\\xa5J\\x00\\x12\\x04',
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/blockchain/block.py` & `neo3_boa-1.2.0/boa3/builtin/interop/blockchain/block.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,11 +1,7 @@
-__all__ = [
-    'Block'
-]
-
 from boa3.builtin.type import UInt160, UInt256
 
 
 class Block:
     """
     Represents a block.
 
@@ -22,26 +18,23 @@
     :vartype merkle_root: UInt256
     :ivar timestamp: UTC timestamp of the block in milliseconds
     :vartype timestamp: int
     :ivar nonce: a random number used once in the cryptography
     :vartype nonce: int
     :ivar index: the index of the block
     :vartype index: int
-    :ivar primary_index: the primary index of the consensus node that generated this block
-    :vartype primary_index: int
     :ivar next_consensus: the script hash of the consensus nodes that generates the next block
     :vartype next_consensus: UInt160
     :ivar transaction_count: the number of transactions on this block
     :vartype transaction_count: int
     """
 
     def __init__(self):
         self.hash: UInt256 = UInt256()
         self.version: int = 0
         self.previous_hash: UInt256 = UInt256()
         self.merkle_root: UInt256 = UInt256()
         self.timestamp: int = 0
         self.nonce: int = 0
         self.index: int = 0
-        self.primary_index: int = 0
         self.next_consensus: UInt160 = UInt160()
         self.transaction_count: int = 0
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/blockchain/signer.py` & `neo3_boa-1.2.0/boa3/builtin/interop/blockchain/signer.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,16 +3,14 @@
     "WitnessRule",
     "WitnessCondition",
     "WitnessConditionType",
     "WitnessRuleAction",
     "WitnessScope",
 ]
 
-from typing import List
-
 from boa3.builtin.type import UInt160
 from boa3.internal.neo3.network.payloads.verification import WitnessConditionType, WitnessRuleAction, WitnessScope
 
 
 class Signer:
     """
     Represents a signer.
@@ -21,27 +19,27 @@
     about Signers.
 
     :ivar account:
     :vartype account: UInt160
     :ivar scopes:
     :vartype scopes: WitnessScope
     :ivar allowed_contracts:
-    :vartype allowed_contracts: List[UInt160]
+    :vartype allowed_contracts: list[UInt160]
     :ivar allowed_groups:
-    :vartype allowed_groups: List[UInt160]
+    :vartype allowed_groups: list[UInt160]
     :ivar rules:
-    :vartype rules: List[WitnessRule]
+    :vartype rules: list[WitnessRule]
     """
 
     def __init__(self):
         self.account: UInt160 = UInt160()
         self.scopes: WitnessScope = WitnessScope.NONE
-        self.allowed_contracts: List[UInt160] = []
-        self.allowed_groups: List[UInt160] = []
-        self.rules: List[WitnessRule] = []
+        self.allowed_contracts: list[UInt160] = []
+        self.allowed_groups: list[UInt160] = []
+        self.rules: list[WitnessRule] = []
 
 
 class WitnessRule:
     """
     Represents a witness rule.
 
     Check out `Neo's Documentation <https://developers.neo.org/docs/n3/foundation/Transactions#witnessrule>`__ to learn
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/blockchain/transaction.py` & `neo3_boa-1.2.0/boa3/builtin/interop/blockchain/transaction.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/contract/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/contract/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,15 +11,16 @@
     'create_standard_account',
     'create_multisig_account',
     'NEO',
     'GAS',
 ]
 
 
-from typing import Any, List, Sequence
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.builtin.interop.contract.callflagstype import CallFlags
 from boa3.builtin.interop.contract.contract import Contract
 from boa3.builtin.interop.contract.contractmanifest import ContractManifest
 from boa3.builtin.type import ECPoint, UInt160
 
 
@@ -152,25 +153,25 @@
 
     :return: the corresponding script hash of the public key
     :rtype: UInt160
     """
     pass
 
 
-def create_multisig_account(m: int, pub_keys: List[ECPoint]) -> UInt160:
+def create_multisig_account(m: int, pub_keys: list[ECPoint]) -> UInt160:
     """
     Calculates corresponding multisig account script hash for the given public keys.
 
     >>> create_multisig_account(1, [ECPoint(b'\\x03\\x5a\\x92\\x8f\\x20\\x16\\x39\\x20\\x4e\\x06\\xb4\\x36\\x8b\\x1a\\x93\\x36\\x54\\x62\\xa8\\xeb\\xbf\\xf0\\xb8\\x81\\x81\\x51\\xb7\\x4f\\xaa\\xb3\\xa2\\xb6\\x1a')])
     b'"5,\\xd2\\x9e\\xe7\\xb4\\x02\\x08b\\xdbd\\x1e\\xedx\\x82\\x8fU(m'
 
     :param m: the minimum number of correct signatures need to be provided in order for the verification to pass.
     :type m: int
     :param pub_keys: the public keys of the account
-    :type pub_keys: List[ECPoint]
+    :type pub_keys: list[ECPoint]
 
     :return: the hash of the corresponding account
     :rtype: UInt160
     """
     pass
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/contract/contract.py` & `neo3_boa-1.2.0/boa3/builtin/interop/contract/contract.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/contract/contractmanifest.py` & `neo3_boa-1.2.0/boa3/builtin/interop/contract/contractmanifest.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,16 +6,14 @@
     'ContractAbi',
     'ContractMethodDescriptor',
     'ContractEventDescriptor',
     'ContractParameterDefinition',
     'ContractParameterType',
 ]
 
-from typing import List, Optional
-
 from boa3.builtin.type import ECPoint, UInt160
 from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType
 
 
 class ContractManifest:
     """
     Represents the manifest of a smart contract.
@@ -27,38 +25,38 @@
 
     For more details, check out `NEP-15 <https://github.com/neo-project/proposals/blob/master/nep-15.mediawiki>`__ or
     `Neo's Documentation <https://developers.neo.org/docs/n3/develop/write/manifest#manifest>`__.
 
     :ivar name: The name of the contract.
     :vartype name: str
     :ivar groups: The groups of the contract.
-    :vartype groups: List[ContractGroup]
+    :vartype groups: list[ContractGroup]
     :ivar supported_standards: Indicates which standards the contract supports. It can be a list of NEPs.
-    :vartype supported_standards: List[str]
+    :vartype supported_standards: list[str]
     :ivar abi: The ABI of the contract.
     :vartype abi: ContractAbi
     :ivar permissions: The permissions of the contract.
-    :vartype permissions: List[ContractPermission]
+    :vartype permissions: list[ContractPermission]
     :ivar trusts:
         The trusted contracts and groups of the contract.
 
         If a contract is trusted, the user interface will not give any warnings when called by the contract.
 
-    :vartype trusts: List[ContractPermissionDescriptor] or None
+    :vartype trusts: list[ContractPermissionDescriptor] or None
     :ivar extras: Custom user data as a json string.
     :vartype extras: str
     """
 
     def __init__(self):
         self.name: str = ''
-        self.groups: List[ContractGroup] = []
-        self.supported_standards: List[str] = []
+        self.groups: list[ContractGroup] = []
+        self.supported_standards: list[str] = []
         self.abi: ContractAbi = None
-        self.permissions: List[ContractPermission] = []
-        self.trusts: Optional[List[ContractPermissionDescriptor]] = None
+        self.permissions: list[ContractPermission] = []
+        self.trusts: list[ContractPermissionDescriptor] | None = None
         self.extras: str = ''
 
 
 class ContractPermission:
     """
     Represents a permission of a contract. It describes which contracts may be invoked and which methods are called.
 
@@ -77,35 +75,35 @@
     :vartype contract: ContractPermissionDescriptor or None
     :ivar methods:
         Indicates which methods to be called.
 
         It can also be assigned with a wildcard \\*. If it is a wildcard \\*, then it means that any method can be
         called.
 
-    :vartype methods: List[str] or None
+    :vartype methods: list[str] or None
     """
 
     def __init__(self):
-        self.contract: Optional[ContractPermissionDescriptor] = None
-        self.methods: Optional[List[str]] = None
+        self.contract: ContractPermissionDescriptor | None = None
+        self.methods: list[str] | None = None
 
 
 class ContractPermissionDescriptor:
     """
     Indicates which contracts are authorized to be called.
 
     :ivar hash: The hash of the contract.
     :vartype hash: UInt160 or None
     :ivar group: The group of the contracts.
     :vartype group: ECPoint or None
     """
 
     def __init__(self):
-        self.hash: Optional[UInt160] = None
-        self.group: Optional[ECPoint] = None
+        self.hash: UInt160 | None = None
+        self.group: ECPoint | None = None
 
 
 class ContractGroup:
     """
     Represents a set of mutually trusted contracts.
 
     A contract will trust and allow any contract in the same group to invoke it, and the user interface will not give
@@ -129,32 +127,32 @@
     """
     Represents the ABI of a smart contract.
 
     For more details, check out `NEP-14 <https://github.com/neo-project/proposals/blob/master/nep-14.mediawiki>`__ or
     `Neo's Documentation <https://developers.neo.org/docs/n3/develop/write/manifest#manifest>`__.
 
     :ivar methods: Gets the methods in the ABI.
-    :vartype methods: List[ContractMethodDescriptor]
+    :vartype methods: list[ContractMethodDescriptor]
     :ivar events: Gets the events in the ABI.
-    :vartype events: List[ContractEventDescriptor]
+    :vartype events: list[ContractEventDescriptor]
     """
 
     def __init__(self):
-        self.methods: List[ContractMethodDescriptor] = []
-        self.events: List[ContractEventDescriptor] = []
+        self.methods: list[ContractMethodDescriptor] = []
+        self.events: list[ContractEventDescriptor] = []
 
 
 class ContractMethodDescriptor:
     """
     Represents a method in a smart contract ABI.
 
     :ivar name: The name of the method.
     :vartype name: str
     :ivar parameters: The parameters of the method.
-    :vartype parameters: List[ContractParameterDefinition]
+    :vartype parameters: list[ContractParameterDefinition]
     :ivar return_type: Indicates the return type of the method.
     :vartype return_type: ContractParameterType
     :ivar offset: The position of the method in the contract script.
     :vartype offset: int
     :ivar safe:
         Indicates whether the method is a safe method.
 
@@ -162,33 +160,33 @@
         contracts.
 
     :vartype safe: bool
     """
 
     def __init__(self):
         self.name: str = ''
-        self.parameters: List[ContractParameterDefinition] = []
+        self.parameters: list[ContractParameterDefinition] = []
         self.return_type: ContractParameterType = ContractParameterType.Any
         self.offset: int = 0
         self.safe: bool = False
 
 
 class ContractEventDescriptor:
     """
     Represents an event in a smart contract ABI.
 
     :ivar name: The name of the event.
     :vartype name: str
     :ivar parameters: The parameters of the event.
-    :vartype parameters: List[ContractParameterDefinition]
+    :vartype parameters: list[ContractParameterDefinition]
     """
 
     def __init__(self):
         self.name: str = ''
-        self.parameters: List[ContractParameterDefinition] = []
+        self.parameters: list[ContractParameterDefinition] = []
 
 
 class ContractParameterDefinition:
     """
     Represents a parameter of an event or method in ABI.
 
     :ivar name: The name of the parameter.
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/crypto/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/crypto/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,15 @@
     'bls12_381_equal',
     'bls12_381_mul',
     'bls12_381_pairing',
     'bls12_381_serialize',
 ]
 
 
-from typing import Any, List
+from typing import Any
 
 from boa3.builtin.interop.crypto.ibls12381 import IBls12381
 from boa3.builtin.interop.crypto.namedcurve import NamedCurve
 from boa3.builtin.type import ECPoint
 
 
 def sha256(key: Any) -> bytes:
@@ -111,27 +111,27 @@
     :type signature: bytes
     :return: whether the signature is valid or not
     :rtype: bool
     """
     pass
 
 
-def check_multisig(pubkeys: List[ECPoint], signatures: List[bytes]) -> bool:
+def check_multisig(pubkeys: list[ECPoint], signatures: list[bytes]) -> bool:
     """
     Checks the signatures for the current script container.
 
     >>> check_multisig([ECPoint(b"\\x03\\xcd\\xb0\\x67\\xd9\\x30\\xfd\\x5a\\xda\\xa6\\xc6\\x85\\x45\\x01\\x60\\x44\\xaa\\xdd\\xec\\x64\\xba\\x39\\xe5\\x48\\x25\\x0e\\xae\\xa5\\x51\\x17\\x2e\\x53\\x5c"),
     ...                 ECPoint(b"\\x03l\\x841\\xccx\\xb31w\\xa6\\x0bK\\xcc\\x02\\xba\\xf6\\r\\x05\\xfe\\xe5\\x03\\x8es9\\xd3\\xa6\\x88\\xe3\\x94\\xc2\\xcb\\xd8C")],
     ...                [b'wrongsignature1', b'wrongsignature2'])
     False
 
     :param pubkeys: a list of public keys
-    :type pubkeys: List[ECPoint]
+    :type pubkeys: list[ECPoint]
     :param signatures: a list of signatures
-    :type signatures: List[bytes]
+    :type signatures: list[bytes]
     :return: a boolean value that represents whether the signatures were validated
     :rtype: bool
     """
     pass
 
 
 def verify_with_ecdsa(message: bytes, pubkey: ECPoint, signature: bytes, curve: NamedCurve) -> bool:
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/iterator/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/iterator/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/json/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/json/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/policy/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/policy/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/role/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/role/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/runtime/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/runtime/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,23 +18,25 @@
     'platform',
     'invocation_counter',
     'entry_script_hash',
     'script_container',
 ]
 
 
-from typing import Any, List, Union, Sequence
+from collections.abc import Sequence
+from typing import Any
 
+from boa3.builtin.interop.blockchain import Transaction
 from boa3.builtin.interop.contract.callflagstype import CallFlags
 from boa3.builtin.interop.runtime.notification import Notification
 from boa3.builtin.interop.runtime.triggertype import TriggerType
 from boa3.builtin.type import ECPoint, UInt160
 
 
-def check_witness(hash_or_pubkey: Union[UInt160, ECPoint]) -> bool:
+def check_witness(hash_or_pubkey: UInt160 | ECPoint) -> bool:
     """
     Verifies that the transactions or block of the calling contract has validated the required script hash.
 
     >>> check_witness(calling_script_hash)
     True
 
     >>> check_witness(UInt160(bytes(20)))
@@ -90,15 +92,15 @@
 
     :return: a value that represents the contract trigger type
     :rtype: TriggerType
     """
     pass
 
 
-def get_notifications(script_hash: UInt160 = UInt160()) -> List[Notification]:
+def get_notifications(script_hash: UInt160 = UInt160()) -> list[Notification]:
     """
     This method gets current invocation notifications from specific 'script_hash'.
 
     >>> notify(1); notify(2); notify(3)
     ... get_notifications(UInt160(b'\\xcfv\\xe2\\x8b\\xd0\\x06,JG\\x8e\\xe3Ua\\x01\\x13\\x19\\xf3\\xcf\\xa4\\xd2'))
     [
         [
@@ -118,15 +120,15 @@
         ]
     ]
 
     :param script_hash: must have 20 bytes, but if it's all zero 0000...0000 it refers to all existing notifications
         (like a * wildcard)
     :type script_hash: UInt160
     :return: It will return an array of all matched notifications
-    :rtype: List[Notification]
+    :rtype: list[Notification]
     """
     pass
 
 
 def get_network() -> int:
     """
     Gets the magic number of the current network.
@@ -264,15 +266,15 @@
 
 >>> entry_script_hash
 b'\\tK\\xb31\\xa8\\x13\\x80`\\xad\\xf6\\xda\\xdf\\xc6R\\x9b\\xfdB\\xbf\\x83\\x8f'
 
 :meta hide-value:
 """
 
-script_container: Any = None
+script_container: Transaction = Transaction()
 """
 Gets the current script container.
 
 >>> script_container
 [
     b'\\xf1y\\xc2\\xd6\\x1c\\xb6\\x98\\xa4\\xdc\\xf3\\xd67s\\xd7E\\xf0<;\\x98+\\xa2T\\x03P,T\\xe8\\xc6{ \\x101', 
     0,
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/runtime/notification.py` & `neo3_boa-1.2.0/boa3/builtin/interop/runtime/notification.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/stdlib/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/interop/stdlib/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     'atoi',
     'itoa',
     'memory_search',
     'memory_compare',
 ]
 
 
-from typing import Any, Union
+from typing import Any
 
 
 def base58_encode(key: bytes) -> str:
     """
     Encodes a bytes value using base58.
 
     >>> base58_encode(b'unit test')
@@ -211,15 +211,15 @@
     :type base: int
     :return: the converted string
     :rtype: int
     """
     pass
 
 
-def memory_search(mem: Union[bytes, str], value: Union[bytes, str], start: int = 0, backward: bool = False) -> int:
+def memory_search(mem: bytes | str, value: bytes | str, start: int = 0, backward: bool = False) -> int:
     """
     Searches for a given value in a given memory.
 
     >>> memory_search('abcde', 'a', 0)
     0
 
     >>> memory_search('abcde', 'e', 0)
@@ -236,15 +236,15 @@
 
     :return: the index of the value in the memory. Returns -1 if it's not found
     :rtype: int
     """
     pass
 
 
-def memory_compare(mem1: Union[bytes, str], mem2: Union[bytes, str]) -> int:
+def memory_compare(mem1: bytes | str, mem2: bytes | str) -> int:
     """
     Compares a memory with another one.
 
     >>> memory_compare('abc', 'abc')
     0
 
     >>> memory_compare('ABC', 'abc')
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/storage/storagecontext.py` & `neo3_boa-1.2.0/boa3/builtin/interop/storage/storagecontext.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/interop/storage/storagemap.py` & `neo3_boa-1.2.0/boa3/builtin/interop/storage/storagemap.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,11 +1,9 @@
 __all__ = ['StorageMap']
 
-from typing import Union
-
 
 class StorageMap:
     """
     The key-value storage for the specific prefix in the given storage context.
 
     Check out `Neo's Documentation <https://developers.neo.org/docs/n3/reference/scapi/framework/services/StorageMap>`__
     to learn more about StorageMap.
@@ -24,15 +22,15 @@
         :param key: value identifier in the store
         :type key: bytes
         :return: the value corresponding to given key for current storage context
         :rtype: bytes
         """
         pass
 
-    def put(self, key: bytes, value: Union[int, bytes, str]):
+    def put(self, key: bytes, value: int | bytes | str):
         """
         Inserts a given value in the key-value format into the map.
 
         :param key: the identifier in the store for the new value
         :type key: bytes
         :param value: value to be stored
         :type value: int or str or bytes
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/math.py` & `neo3_boa-1.2.0/boa3/builtin/math.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/contractmanagement.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/contractmanagement.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 __all__ = [
     'ContractManagement',
     'Contract',
 ]
 
 
-from typing import Any, Optional
+from typing import Any
 
 from boa3.builtin.interop.contract import Contract
 from boa3.builtin.type import UInt160
 
 
 class ContractManagement:
     """
@@ -29,15 +29,15 @@
         1000000000
 
         :return: the minimum fee of contract deployment
         """
         pass
 
     @classmethod
-    def get_contract(cls, script_hash: UInt160) -> Optional[Contract]:
+    def get_contract(cls, script_hash: UInt160) -> Contract | None:
         """
         Gets a contract with a given hash. If the script hash is not associated with a smart contract, then it will
         return None.
 
         >>> ContractManagement.get_contract(UInt160(b'\\xcfv\\xe2\\x8b\\xd0\\x06,JG\\x8e\\xe3Ua\\x01\\x13\\x19\\xf3\\xcf\\xa4\\xd2'))    # GAS script hash
         {
             'id': -6,
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/cryptolib.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/cryptolib.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/gas.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/gas.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/ledger.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/ledger.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,14 +1,11 @@
 __all__ = [
     'Ledger',
 ]
 
-
-from typing import List, Optional, Union
-
 from boa3.builtin.interop.blockchain import Block, Signer, Transaction, VMState
 from boa3.builtin.type import UInt256, UInt160
 
 
 class Ledger:
     """
     A class used to represent the Ledger native contract.
@@ -16,15 +13,15 @@
     Check out `Neo's Documentation <https://developers.neo.org/docs/n3/reference/scapi/framework/native/Ledger>`__
     to learn more about the Ledger class.
     """
 
     hash: UInt160
 
     @classmethod
-    def get_block(cls, index_or_hash: Union[int, UInt256]) -> Optional[Block]:
+    def get_block(cls, index_or_hash: int | UInt256) -> Block | None:
         """
         Gets the block with the given index or hash.
 
         >>> Ledger.get_block(0)        # first block
         {
             'hash': b"S{\\xed'\\x85&\\xf5\\x93U=\\xc1\\xbf'\\x95\\xc4/\\x80X\\xdb\\xd5\\xa1-\\x97q\\x85\\xe3I\\xe5\\x99cd\\x04",
             'version': 0,
@@ -81,15 +78,15 @@
 
         :return: the index of the current block
         :rtype: int
         """
         pass
 
     @classmethod
-    def get_transaction(cls, hash_: UInt256) -> Optional[Transaction]:
+    def get_transaction(cls, hash_: UInt256) -> Transaction | None:
         """
         Gets a transaction with the given hash.
 
         >>> Ledger.get_transaction(UInt256(b'\\xff\\x7f\\x18\\x99\\x8c\\x1d\\x10X{bA\\xc2\\xe3\\xdf\\xc8\\xb0\\x9f>\\xd0\\xd2G\\xe3\\xba\\xd8\\x96\\xb9\\x0e\\xc1iS\\xcdr'))
         {
             'hash': b'\\xff\\x7f\\x18\\x99\\x8c\\x1d\\x10X{bA\\xc2\\xe3\\xdf\\xc8\\xb0\\x9f>\\xd0\\xd2G\\xe3\\xba\\xd8\\x96\\xb9\\x0e\\xc1iS\\xcdr',
             'version': 0,
@@ -107,15 +104,15 @@
         :param hash_: hash identifier of the transaction
         :type hash_: UInt256
         :return: the Transaction, if exists. None otherwise
         """
         pass
 
     @classmethod
-    def get_transaction_from_block(cls, block_hash_or_height: Union[UInt256, int], tx_index: int) -> Optional[Transaction]:
+    def get_transaction_from_block(cls, block_hash_or_height: UInt256 | int, tx_index: int) -> Transaction | None:
         """
         Gets a transaction from a block.
 
         >>> Ledger.get_transaction_from_block(1, 0)
         {
             'hash': b'\\xff\\x7f\\x18\\x99\\x8c\\x1d\\x10X{bA\\xc2\\xe3\\xdf\\xc8\\xb0\\x9f>\\xd0\\xd2G\\xe3\\xba\\xd8\\x96\\xb9\\x0e\\xc1iS\\xcdr',
             'version': 0,
@@ -170,15 +167,15 @@
         :param hash_: hash identifier of the transaction
         :type hash_: UInt256
         :return: height of the transaction
         """
         pass
 
     @classmethod
-    def get_transaction_signers(cls, hash_: UInt256) -> List[Signer]:
+    def get_transaction_signers(cls, hash_: UInt256) -> list[Signer]:
         """
         Gets the VM state of a transaction.
 
         >>> Ledger.get_transaction_signers(UInt256(b'\\x29\\x41\\x06\\xdb\\x4c\\xf3\\x84\\xa7\\x20\\x4d\\xba\\x0a\\x04\\x03\\x72\\xb3\\x27\\x76\\xf2\\x6e\\xd3\\x87\\x49\\x88\\xd0\\x3e\\xff\\x5d\\xa9\\x93\\x8c\\xa3'))
         [
             {
                 "account": b'\\xa6\\xea\\xb0\\xae\\xaf\\xb4\\x96\\xa1\\x1b\\xb0|\\x88\\x17\\xcar\\xa5J\\x00\\x12\\x04',
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/neo.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/neo.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 __all__ = [
     'NEO',
 ]
 
 
-from typing import Any, List, Tuple
+from typing import Any
 
 from boa3.builtin.contract import NeoAccountState
 from boa3.builtin.interop.iterator import Iterator
 from boa3.builtin.type import ECPoint, UInt160
 
 
 class NEO:
@@ -215,23 +215,23 @@
 
         :param account: the account that is removing the vote
         :type account: UInt160
         """
         pass
 
     @classmethod
-    def get_candidates(cls) -> List[Tuple[ECPoint, int]]:
+    def get_candidates(cls) -> list[tuple[ECPoint, int]]:
         """
         Gets the list of all registered candidates.
 
         >>> NEO.get_candidates()
         []
 
         :return: all registered candidates
-        :rtype: List[Tuple[ECPoint, int]]
+        :rtype: list[tuple[ECPoint, int]]
         """
         pass
 
     @classmethod
     def get_candidate_vote(cls, pubkey: ECPoint) -> int:
         """
         Gets votes from specific candidate.
@@ -244,36 +244,36 @@
 
         :return: Votes or -1 if it was not found.
         :rtype: int
         """
         pass
 
     @classmethod
-    def get_committee(cls) -> List[ECPoint]:
+    def get_committee(cls) -> list[ECPoint]:
         """
         Gets all committee members list.
 
         >>> NEO.get_committee()
         [ b'\\x02|\\x84\\xb0V\\xc2j{$XG\\x1em\\xcfgR\\xed\\xd9k\\x96\\x88}x34\\xe3Q\\xdd\\xfe\\x13\\xc4\\xbc\\xa2' ]
 
         :return: all committee members
-        :rtype: List[ECPoint]
+        :rtype: list[ECPoint]
         """
         pass
 
     @classmethod
-    def get_next_block_validators(cls) -> List[ECPoint]:
+    def get_next_block_validators(cls) -> list[ECPoint]:
         """
         Gets validators list of the next block.
 
         >>> NEO.get_next_block_validators()
         [ b'\\x02|\\x84\\xb0V\\xc2j{$XG\\x1em\\xcfgR\\xed\\xd9k\\x96\\x88}x34\\xe3Q\\xdd\\xfe\\x13\\xc4\\xbc\\xa2' ]
 
         :return: the public keys of the validators
-        :rtype: List[ECPoint]
+        :rtype: list[ECPoint]
         """
         pass
 
     @classmethod
     def get_account_state(cls, account: UInt160) -> NeoAccountState:
         """
         Gets the latest votes of the specified account.
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/oracle.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/oracle.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 __all__ = [
     'Oracle',
 ]
 
 
-from typing import Union, Any
+from typing import Any
 
 from boa3.builtin.type import UInt160
 
 
 class Oracle:
     """
     Neo Oracle Service is an out-of-chain data access service built into Neo N3. It allows users to request the external
@@ -15,15 +15,15 @@
     then pass the result in the callback function to continue executing the smart contract logic.
 
     Check out `Neo's Documentation <https://developers.neo.org/docs/n3/Advances/Oracles>`__ to learn more about Oracles.
     """
     hash: UInt160
 
     @classmethod
-    def request(cls, url: str, request_filter: Union[str, None], callback: str, user_data: Any, gas_for_response: int):
+    def request(cls, url: str, request_filter: str | None, callback: str, user_data: Any, gas_for_response: int):
         """
         Requests an information from outside the blockchain.
 
         This method just requests data from the oracle, it won't return the result.
 
         >>> Oracle.request('https://dora.coz.io/api/v1/neo3/testnet/asset/0xef4073a0f2b305a38ec4050e4d3d28bc40ea63f5',
         ...                '', 'callback_name', None, 10 * 10 ** 8)
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/policy.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/policy.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/rolemanagement.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/rolemanagement.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/builtin/nativecontract/stdlib.py` & `neo3_boa-1.2.0/boa3/builtin/nativecontract/stdlib.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 __all__ = [
     'StdLib',
 ]
 
 
-from typing import Any, Union
+from typing import Any
 
 from boa3.builtin.type import UInt160
 
 
 class StdLib:
     """
     A class used to represent StdLib native contract.
@@ -248,15 +248,15 @@
         :rtype: int
 
         :raise Exception: raised when base isn't 10 or 16.
         """
         pass
 
     @classmethod
-    def memory_compare(cls, mem1: Union[bytes, str], mem2: Union[bytes, str]) -> int:
+    def memory_compare(cls, mem1: bytes | str, mem2: bytes | str) -> int:
         """
         Compares a memory with another one.
 
         >>> StdLib.memory_compare('abc', 'abc')
         0
 
         >>> StdLib.memory_compare('ABC', 'abc')
@@ -272,15 +272,15 @@
 
         :return: -1 if mem1 precedes mem2, 0 if mem1 and mem2 are equal, 1 if mem1 follows mem2
         :rtype: int
         """
         pass
 
     @classmethod
-    def memory_search(cls, mem: Union[bytes, str], value: Union[bytes, str], start: int = 0, backward: bool = False) -> int:
+    def memory_search(cls, mem: bytes | str, value: bytes | str, start: int = 0, backward: bool = False) -> int:
         """
         Searches for a given value in a given memory.
 
         >>> StdLib.memory_search('abcde', 'a', 0)
         0
 
         >>> StdLib.memory_search('abcde', 'e', 0)
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/type/__init__.py` & `neo3_boa-1.2.0/boa3/builtin/type/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,16 +9,14 @@
     'BlockHash',
     'PublicKey',
     'ScriptHash',
     'ScriptHashLittleEndian',
     'TransactionId',
 ]
 
-from typing import Union
-
 
 class Event:
     """
     Describes an action that happened in the blockchain.
     Neo3-Boa compiler won't recognize the `__init__` of this class. To create a new Event, use the method `CreateNewEvent`:
 
     Check out `Neo's Documentation <https://developers.neo.org/docs/n3/develop/write/basics#events>`__ to learn more
@@ -38,40 +36,43 @@
         pass
 
 
 class UInt160(bytes):
     """
     Represents a 160-bit unsigned integer.
     """
+    zero: UInt160
 
-    def __init__(self, arg: Union[bytes, int] = 0):
+    def __init__(self, arg: bytes | int = 0):
         super().__init__()
         pass
 
 
 class UInt256(bytes):
     """
     Represents a 256-bit unsigned integer.
     """
+    zero: UInt256
 
-    def __init__(self, arg: Union[bytes, int] = 0):
+    def __init__(self, arg: bytes | int = 0):
         super().__init__()
         pass
 
 
 class ECPoint(bytes):
     """
     Represents a coordinate pair for elliptic curve cryptography (ECC) structures.
     """
+    zero: ECPoint
 
     def __init__(self, arg: bytes):
         super().__init__()
         pass
 
-    def to_script_hash(self) -> bytes:
+    def to_script_hash(self) -> UInt160:
         """
         Converts a data to a script hash.
 
         :return: the script hash of the data
         :rtype: bytes
         """
         pass
```

### Comparing `neo3-boa-1.1.1/boa3/builtin/type/helper.py` & `neo3_boa-1.2.0/boa3/builtin/type/helper.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,16 @@
 __all__ = [
     'to_bool',
     'to_bytes',
     'to_int',
     'to_str',
 ]
 
-from typing import Union
 
-
-def to_bytes(value: Union[str, int]) -> bytes:
+def to_bytes(value: str | int) -> bytes:
     """
     Converts a str or integer value to an array of bytes
 
     >>> to_bytes(65)
     b'A'
 
     >>> to_bytes('A')
```

### Comparing `neo3-boa-1.1.1/boa3/cli.py` & `neo3_boa-1.2.0/boa3/cli.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/cpm.py` & `neo3_boa-1.2.0/boa3/cpm.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/analyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/analyser.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-from __future__ import annotations
-
 import ast
-from typing import Dict, List, Optional
+from typing import Self
 
 from boa3.builtin.compile_time import NeoMetadata
 from boa3.internal import constants
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.analyser.astoptimizer import AstOptimizer
 from boa3.internal.analyser.constructanalyser import ConstructAnalyser
 from boa3.internal.analyser.moduleanalyser import ModuleAnalyser
@@ -23,27 +21,27 @@
     This class is responsible for the semantic analysis of the code
 
     :ivar symbol_table: a dictionary used to store the identifiers
     """
 
     def __init__(self, ast_tree: ast.AST, path: str = None, project_root: str = None,
                  env: str = None, log: bool = False, fail_fast: bool = False):
-        self.symbol_table: Dict[str, ISymbol] = {}
+        self.symbol_table: dict[str, ISymbol] = {}
 
         self.ast_tree: ast.AST = ast_tree
         self.metadata: NeoMetadata = NeoMetadata()
         self.is_analysed: bool = False
         self._log: bool = log
         self._fail_fast: bool = fail_fast
         self._env: str = env if env is not None else constants.DEFAULT_CONTRACT_ENVIRONMENT
 
         self.__include_builtins_symbols()
         self._errors = []
         self._warnings = []
-        self._imported_files: Dict[str, Analyser] = {}
+        self._imported_files: dict[str, Analyser] = {}
         self._included_imported_files: bool = False
 
         import os
         self.path: str = path
         self.filename: str = path if path is None else os.path.realpath(path)
 
         if project_root is not None:
@@ -53,19 +51,26 @@
             if os.path.isfile(project_root):
                 project_root = os.path.dirname(os.path.abspath(project_root))
 
         self.root: str = (os.path.realpath(project_root)
                           if project_root is not None and os.path.isdir(project_root)
                           else path)
 
-    @staticmethod
-    def analyse(path: str, log: bool = False, fail_fast: bool = False,
-                imported_files: Optional[Dict[str, Analyser]] = None,
-                import_stack: Optional[List[str]] = None,
-                root: str = None, env: str = None, compiler_entry: bool = False) -> Analyser:
+    @classmethod
+    def analyse(
+            cls,
+            path: str,
+            log: bool = False,
+            fail_fast: bool = False,
+            imported_files: dict[str, Self] | None = None,
+            import_stack: list[str] | None = None,
+            root: str = None,
+            env: str = None,
+            compiler_entry: bool = False
+    ) -> Self:
         """
         Analyses the syntax of the Python code
 
         :param path: the path of the Python file
         :param log: if compiler errors should be logged.
         :param fail_fast: if should stop compilation on first error found.
         :param import_stack: a list that represents the current import stack if it's from an import.
@@ -81,15 +86,15 @@
         with open(path, 'rb') as source:
             ast_tree = ast.parse(source.read())
 
         analyser = Analyser(ast_tree, path, root if isinstance(root, str) else path, env, log, fail_fast)
         CompiledMetadata.set_current_metadata(analyser.metadata)
 
         if compiler_entry:
-            from boa3.internal.model.imports.builtin import CompilerBuiltin
+            from boa3.internal.model.imports.compilerbuiltin import CompilerBuiltin
             CompilerBuiltin.update_with_analyser(analyser)
 
         # fill symbol table
         if not analyser.__analyse_modules(imported_files, import_stack):
             return analyser
         analyser.__pre_execute()
 
@@ -102,26 +107,26 @@
 
         analyser.__pos_execute()
         analyser.is_analysed = True
 
         return analyser
 
     @property
-    def errors(self) -> List[CompilerError]:
+    def errors(self) -> list[CompilerError]:
         return self._errors.copy()
 
     @property
-    def warnings(self) -> List[CompilerWarning]:
+    def warnings(self) -> list[CompilerWarning]:
         return self._warnings.copy()
 
     @property
     def env(self) -> str:
         return self._env
 
-    def copy(self) -> Analyser:
+    def copy(self) -> Self:
         copied = Analyser(ast_tree=self.ast_tree, path=self.path, project_root=self.root,
                           env=self._env, log=self._log, fail_fast=self._fail_fast)
 
         copied.metadata = self.metadata
         copied.is_analysed = self.is_analysed
         copied.symbol_table = self.symbol_table.copy()
         copied.filename = self.filename
@@ -143,16 +148,16 @@
         :return: a boolean value that represents if the analysis was successful
         """
         type_analyser = TypeAnalyser(self, self.symbol_table, log=self._log, fail_fast=self._fail_fast)
         self._update_logs(type_analyser)
         return not type_analyser.has_errors
 
     def __analyse_modules(self,
-                          imported_files: Optional[Dict[str, Analyser]] = None,
-                          import_stack: Optional[List[str]] = None) -> bool:
+                          imported_files: dict[str, Self] | None = None,
+                          import_stack: list[str] | None = None) -> bool:
         """
         Validates the symbols and constructs the symbol table of the ast tree
 
         :return: a boolean value that represents if the analysis was successful
         """
         current_metadata = self.metadata
         module_analyser = ModuleAnalyser(self, self.symbol_table,
@@ -197,15 +202,15 @@
     def __pos_execute(self):
         """
         Tries to optimize the ast after validations
         """
         optimizer = AstOptimizer(self, log=self._log, fail_fast=self._fail_fast)
         self._update_logs(optimizer)
 
-    def update_symbol_table(self, symbol_table: Dict[str, ISymbol]):
+    def update_symbol_table(self, symbol_table: dict[str, ISymbol]):
         for symbol_id, symbol in symbol_table.items():
             if (hasattr(symbol, 'origin')
                     and hasattr(symbol.origin, 'origin')
                     and isinstance(symbol.origin.origin, ast.AST)
                     and len(symbol_id.split(constants.VARIABLE_NAME_SEPARATOR)) <= 1):
 
                 if symbol_id in self.symbol_table:
@@ -243,9 +248,9 @@
                                                  log=False, fail_fast=self._fail_fast,
                                                  get_entry=True)
                 import_symbol = Import(file_path, analyser.ast_tree, import_analyser, {})
                 self.symbol_table[file_path] = import_symbol
 
         self._included_imported_files = True
 
-    def get_imports(self) -> List[Analyser]:
+    def get_imports(self) -> list[Self]:
         return list(self._imported_files.values())
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/astanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/astanalyser.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import ast
 import logging
 import os
 from abc import ABC
+from collections.abc import Sequence
 from inspect import isclass
-from typing import Any, Dict, List, Optional, Sequence, Union
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.exception.CompilerError import CompilerError, InternalError, UnresolvedReference
 from boa3.internal.exception.CompilerWarning import CompilerWarning
 from boa3.internal.model.attribute import Attribute
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
@@ -25,28 +26,28 @@
 
     :ivar errors: a list that contains all the errors raised by the compiler. Empty by default.
     :ivar warnings: a list that contains all the warnings found by the compiler. Empty by default.
     """
 
     def __init__(self, ast_tree: ast.AST, filename: str = None, root_folder: str = None,
                  log: bool = False, fail_fast: bool = True):
-        self.errors: List[CompilerError] = []
-        self.warnings: List[CompilerWarning] = []
+        self.errors: list[CompilerError] = []
+        self.warnings: list[CompilerWarning] = []
 
-        self.filename: Optional[str] = filename
+        self.filename: str | None = filename
         if not isinstance(root_folder, str) or not os.path.isdir(root_folder):
             root_folder = (os.path.dirname(os.path.abspath(filename))
                            if isinstance(filename, str) and os.path.isfile(filename)
                            else os.path.abspath(os.path.curdir))
         self.root_folder: str = root_folder
         self._log: bool = log
         self._fail_fast: bool = fail_fast
 
         self._tree: ast.AST = ast_tree
-        self.symbols: Dict[str, ISymbol] = {}
+        self.symbols: dict[str, ISymbol] = {}
 
     @property
     def has_errors(self) -> bool:
         return len(self.errors) > 0
 
     def _log_error(self, error: CompilerError):
         if self._fail_fast and len(self.errors) > 0:
@@ -146,15 +147,15 @@
             return final_type.meta_type
         else:
             return final_type
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
                    check_raw_id: bool = False,
-                   origin_node: ast.AST = None) -> Optional[ISymbol]:
+                   origin_node: ast.AST = None) -> ISymbol | None:
         """
         Tries to get the symbol by its id name
 
         :param symbol_id: the id name of the symbol
         :return: the symbol if found. None otherwise.
         :rtype: ISymbol or None
         """
@@ -166,15 +167,15 @@
             found_symbol = self._search_by_raw_id(symbol_id, list(self.symbols.values()))
             if found_symbol is not None:
                 # the symbol exists in the global scope, but with an alias different from the original name
                 return found_symbol
 
         if is_internal:
             from boa3.internal.model import imports
-            found_symbol = imports.builtin.get_internal_symbol(symbol_id)
+            found_symbol = imports.compilerbuiltin.get_internal_symbol(symbol_id)
             if isinstance(found_symbol, ISymbol):
                 return found_symbol
 
         # the symbol may be a built in. If not, returns None
         from boa3.internal.model.builtin.builtin import Builtin
         found_symbol = Builtin.get_symbol(symbol_id)
 
@@ -188,15 +189,15 @@
                     col=origin_node.col_offset,
                     symbol_id=symbol_id
                 )
             )
 
         return found_symbol
 
-    def _search_by_raw_id(self, symbol_id: str, symbols: Sequence[ISymbol]) -> Optional[ISymbol]:
+    def _search_by_raw_id(self, symbol_id: str, symbols: Sequence[ISymbol]) -> ISymbol | None:
         for symbol in symbols:
             if isinstance(symbol, IdentifiedSymbol) and symbol.identifier == symbol_id:
                 return symbol
 
         return None
 
     def is_exception(self, symbol_id: str) -> bool:
@@ -214,15 +215,15 @@
             return False
 
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         from boa3.internal.model.builtin.interop.interopinterfacetype import InteropInterfaceType
 
         return not isinstance(symbol, PythonClass) or isinstance(symbol, InteropInterfaceType)
 
-    def parse_to_node(self, expression: str, origin: ast.AST = None) -> Union[ast.AST, Sequence[ast.AST]]:
+    def parse_to_node(self, expression: str, origin: ast.AST = None) -> ast.AST | Sequence[ast.AST]:
         """
         Parses an expression to an ast.
 
         :param expression: string expression to be parsed
         :param origin: an existing ast. If not None, the parsed node will have the same location of origin.
         :return: the parsed node
         :rtype: ast.AST or Sequence[ast.AST]
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/astoptimizer.py` & `neo3_boa-1.2.0/boa3/internal/analyser/astoptimizer.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import ast
-from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.analyser.model.optimizer import ScopeValue, Undefined
 from boa3.internal.analyser.model.optimizer.Operation import Operation
 from boa3.internal.exception import CompilerWarning
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
@@ -28,16 +29,16 @@
     :ivar modules: a list with the analysed modules. Empty by default.
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
     def __init__(self, analyser, log: bool = False, fail_fast: bool = True):
         super().__init__(analyser.ast_tree, filename=analyser.filename, root_folder=analyser.root,
                          log=log, fail_fast=fail_fast)
-        self.modules: Dict[str, Module] = {}
-        self.symbols: Dict[str, ISymbol] = analyser.symbol_table
+        self.modules: dict[str, Module] = {}
+        self.symbols: dict[str, ISymbol] = analyser.symbol_table
 
         self._is_optimizing: bool = False
         self.has_changes: bool = False
         self.current_scope: ScopeValue = ScopeValue()
 
         self._current_class: UserClass = None
 
@@ -60,15 +61,15 @@
         :return: the evaluated expression if the node is valid. Otherwise, returns Undefined.
         """
         try:
             return ast.literal_eval(node)
         except BaseException:
             return Undefined
 
-    def parse_to_node(self, expression: str, origin: ast.AST = None, is_origin_str: bool = False) -> Union[ast.AST, Sequence[ast.AST]]:
+    def parse_to_node(self, expression: str, origin: ast.AST = None, is_origin_str: bool = False) -> ast.AST | Sequence[ast.AST]:
         """
         Parses an expression to an ast.
 
         :param expression: string expression to be parsed
         :param origin: an existing ast. If not None, the parsed node will have the same location of origin.
         :return: the parsed node
         :rtype: ast.AST or Sequence[ast.AST]
@@ -81,15 +82,15 @@
             new_node.op = Operator.get_operation(new_node.op)
 
         return new_node
 
     def reset_state(self):
         self.current_scope.reset()
 
-    def get_symbol_id(self, node: ast.AST) -> Optional[str]:
+    def get_symbol_id(self, node: ast.AST) -> str | None:
         parts = []
         cur_node = node
         while isinstance(cur_node, ast.Attribute):
             parts.insert(0, cur_node.attr)
             cur_node = cur_node.value
 
         if isinstance(cur_node, ast.Name):
@@ -149,15 +150,15 @@
         value.left = node.target
         value.op = node.op
         value.right = node.value
 
         self.set_variables_value([node.target], value)
         return node
 
-    def set_variables_value(self, targets: List[ast.AST], value: ast.AST):
+    def set_variables_value(self, targets: list[ast.AST], value: ast.AST):
         new_value = self.literal_eval(value)
         for target in targets:
             if isinstance(target, ast.Name) and isinstance(target.ctx, ast.Store):
                 self.current_scope.assign(target.id)
 
                 if new_value is not Undefined:
                     self.current_scope[target.id] = new_value
@@ -199,15 +200,15 @@
         second_operation = type(second_op)
 
         if operation != second_operation:
             return False
 
         return first_op.is_symmetric
 
-    def reorder_operations(self, outer_bin_op: ast.BinOp, inner_bin_op: ast.BinOp) -> Tuple[Any, Any]:
+    def reorder_operations(self, outer_bin_op: ast.BinOp, inner_bin_op: ast.BinOp) -> tuple[Any, Any]:
         inner_first_value = self.literal_eval(inner_bin_op.left)
         inner_second_value = self.literal_eval(inner_bin_op.right)
 
         if (not (isinstance(outer_bin_op.op, BinaryOperation) and outer_bin_op.op.is_symmetric)
                 or not (isinstance(outer_bin_op.op, BinaryOperation) and outer_bin_op.op.is_symmetric)):
             return inner_first_value, inner_second_value
 
@@ -247,15 +248,15 @@
                         inner_bin_op.right, outer_bin_op.left = outer_bin_op.left, inner_bin_op.right
 
         super().generic_visit(outer_bin_op)
 
         return self.literal_eval(outer_bin_op), self.literal_eval(outer_bin_op)
 
     def _evaluate_binary_operation(self, left: Any, right: Any,
-                                   op: Union[ast.operator, BinaryOperation]) -> Optional[Any]:
+                                   op: ast.operator | BinaryOperation) -> Any | None:
         operator = Operation.get_operation(op)
         try:
             if operator is Operation.Add:
                 return left + right
             if operator is Operation.Sub:
                 return left - right
             if operator is Operation.Mult:
@@ -287,15 +288,15 @@
                     self.update_line_and_col(un_op.operand, un_op)
                     return un_op.operand
                 return self.parse_to_node(str(value), un_op, isinstance(value, str))
             return un_op
         except ValueError:
             return un_op
 
-    def _evaluate_unary_operation(self, operand: Any, op: Union[ast.operator, UnaryOperation]) -> Optional[Any]:
+    def _evaluate_unary_operation(self, operand: Any, op: ast.operator | UnaryOperation) -> Any | None:
         operator = Operation.get_operation(op)
         try:
             if operator is Operation.Add:
                 return +operand
             elif operator is Operation.Sub:
                 return -operand
             return None
@@ -383,15 +384,15 @@
         self.current_scope = while_scope.previous_scope()
 
         return node
 
     def visit_Try(self, node: ast.Try) -> ast.AST:
         outer_scope = self.current_scope
         try_scope: ScopeValue = self.current_scope.new_scope()
-        except_scopes: List[ScopeValue] = []
+        except_scopes: list[ScopeValue] = []
 
         self.current_scope = try_scope
         for stmt in node.body:
             self.visit(stmt)
 
         if len(node.handlers) > 0:
             for handler in node.handlers:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/builtinfunctioncallanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/builtinfunctioncallanalyser.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import ast
-from typing import Any, Callable, Dict, List, Optional, Type
+from collections.abc import Callable
+from typing import Any
 
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.exception import CompilerError
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.builtin.method.isinstancemethod import IsInstanceMethod
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
@@ -14,34 +15,34 @@
                  log: bool, fail_fast: bool = True):
         self._method: IBuiltinMethod = builtin_method
         self.method_id: str = method_id
         super().__init__(call, root_folder=origin.root_folder, log=log, fail_fast=fail_fast)
 
         self._origin: IAstAnalyser = origin
 
-        # all methods validators must be (IBuiltinMethod, List[IType]) -> None
-        self._methods_validators: Dict[Type[IBuiltinMethod],
-                                       Callable[[IBuiltinMethod, List[IType]], None]] = {
+        # all methods validators must be (IBuiltinMethod, list[IType]) -> None
+        self._methods_validators: dict[type[IBuiltinMethod],
+                                       Callable[[IBuiltinMethod, list[IType]], None]] = {
             IsInstanceMethod: self._validate_IsInstanceMethod
         }
 
     @property
     def method(self) -> IBuiltinMethod:
         return self._method
 
     @property
     def call(self) -> ast.Call:
         return self._tree
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
-                   check_raw_id: bool = False) -> Optional[ISymbol]:
+                   check_raw_id: bool = False) -> ISymbol | None:
         return self._origin.get_symbol(symbol_id, is_internal)
 
-    def get_symbol_from_node(self, node: ast.AST) -> Optional[ISymbol]:
+    def get_symbol_from_node(self, node: ast.AST) -> ISymbol | None:
         if isinstance(node, ast.Name):
             return self.get_symbol(node.id)
 
         if isinstance(node, ast.Attribute):
             value = self.get_symbol_from_node(node.value)
             if hasattr(value, 'symbols') and node.attr in value.symbols:
                 return value.symbols[node.attr]
@@ -62,15 +63,15 @@
                 # if the identifiers are diffrente, this method was validated already
                 validator = self._methods_validators[type(self.method)]
                 args = [self.get_type(param) for param in self.call.args]
                 validator(self.method, args)
             return True
         return False
 
-    def _validate_IsInstanceMethod(self, method: IsInstanceMethod, args_types: List[IType]):
+    def _validate_IsInstanceMethod(self, method: IsInstanceMethod, args_types: list[IType]):
         """
         Validates the arguments for `isinstance` method
 
         :param method: instance of the builtin method
         :param args_types: types of the arguments
         """
         last_arg = self.call.args[-1]
@@ -78,15 +79,15 @@
                                                    for tpe in last_arg.elts):
             if len(last_arg.elts) == 1:
                 # if the types tuple has only one type, remove it from inside the tuple
                 last_arg = self.call.args[-1] = last_arg.elts[-1]
                 args_types[-1] = args_types[-1].value_type
             elif len(last_arg.elts) > 1:
                 # if there are more than one type, updates information in the instance of the method
-                types: List[IType] = [self.get_symbol_from_node(name) for name in last_arg.elts]
+                types: list[IType] = [self.get_symbol_from_node(name) for name in last_arg.elts]
                 method.set_instance_type(types)
                 self.call.args[-1] = last_arg.elts[-1]
                 return
 
         from boa3.internal.model.type.annotation.metatype import MetaType
         from boa3.internal.model.type.type import Type
         is_ast_valid = (isinstance(last_arg, ast.Name)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/constructanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/constructanalyser.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,23 @@
 import ast
-from typing import Dict
 
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.symbol import ISymbol
 
 
 class ConstructAnalyser(IAstAnalyser, ast.NodeTransformer):
     """
     This class is responsible for pre processing Python constructs
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
     """
 
-    def __init__(self, analyser, ast_tree: ast.AST, symbol_table: Dict[str, ISymbol],
+    def __init__(self, analyser, ast_tree: ast.AST, symbol_table: dict[str, ISymbol],
                  log: bool = False, fail_fast: bool = True):
         super().__init__(ast_tree, root_folder=analyser.root, log=log, fail_fast=fail_fast)
         self.symbols = symbol_table.copy()
         self.analyse_visit(self._tree)
 
     @property
     def tree(self) -> ast.AST:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/importanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/importanalyser.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,42 +1,44 @@
 import ast
 import importlib.util
 import os
 import sys
-from typing import Dict, List, Optional
 
 from boa3.internal import constants
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.model import imports
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.type import Type
 
 
 class ImportAnalyser(IAstAnalyser):
 
     def __init__(self, import_target: str, root_folder: str,
-                 importer_file: Optional[str] = None,
-                 import_stack: List[str] = None,
+                 importer_file: str | None = None,
+                 import_stack: list[str] = None,
                  already_imported_modules: dict = None,
                  log: bool = False,
                  fail_fast: bool = True,
                  get_entry: bool = False):
 
         self.can_be_imported: bool = False
         self.is_builtin_import: bool = False
         self.is_namespace_package: bool = False
         self.recursive_import: bool = False
         self._import_identifier: str = import_target
+
         self._get_from_entry: bool = get_entry and (os.path.isfile(import_target) or os.path.isdir(import_target))
 
+        from boa3.internal.model.imports.package import Package
+        self._package: Package | None = None
         from boa3.internal.analyser.analyser import Analyser
-        self._imported_files: Dict[str, Analyser] = (already_imported_modules
+        self._imported_files: dict[str, Analyser] = (already_imported_modules
                                                      if isinstance(already_imported_modules, dict)
                                                      else {})
-        self._import_stack: List[str] = import_stack if isinstance(import_stack, list) else []
+        self._import_stack: list[str] = import_stack if isinstance(import_stack, list) else []
         self.analyser: Analyser = None  # set if the import is successful
         self._submodule_search_locations = None
 
         if isinstance(root_folder, str):
             if os.path.isfile(root_folder):
                 root = os.path.dirname(root_folder)
             elif os.path.isdir(root_folder):
@@ -78,26 +80,30 @@
                 module_origin: str = module_  # + "\\" + names[0] + '.py'
                 break
 
             # if the origin is still not set, there's nothing to import
             if module_origin is None:
                 return
 
-        path: List[str] = module_origin.split(os.sep)
+        path: list[str] = module_origin.split(os.sep)
         self.filename = path[-1]
         self._submodule_search_locations = import_spec.submodule_search_locations
         self.path: str = module_origin.replace(os.sep, constants.PATH_SEPARATOR)
 
         self._find_package(module_origin, importer_file)
 
     @property
     def tree(self) -> ast.AST:
         return self._tree
 
-    def export_symbols(self, identifiers: List[str] = None) -> Dict[str, ISymbol]:
+    @property
+    def is_import_deprecated(self) -> bool:
+        return self._package.is_deprecated if self._package is not None else False
+
+    def export_symbols(self, identifiers: list[str] = None) -> dict[str, ISymbol]:
         """
         Gets a dictionary that maps each exported symbol with its identifier
 
         :param identifiers: list of identifiers of the imported symbols
         :return:
         """
         if identifiers is None:
@@ -119,33 +125,43 @@
         if self.can_be_imported and self.path in self._imported_files and self.path not in external_files:
             external_files[self.path] = self._imported_files[self.path]
 
         for path, analyser in self._imported_files.items():
             if path not in external_files and analyser.is_analysed:
                 external_files[path] = analyser
 
-    def _find_package(self, module_origin: str, origin_file: Optional[str] = None):
-        path: List[str] = module_origin.split(os.sep)
+    def _find_package(self, module_origin: str, origin_file: str | None = None):
+        path: list[str] = module_origin.split(os.sep)
 
-        package = imports.builtin.get_package(self._import_identifier)
+        package = imports.compilerbuiltin.get_package(self._import_identifier)
         if hasattr(package, 'symbols'):
             if hasattr(package, 'inner_packages'):
                 # when have symbol and packages with the same id, prioritize symbol
-                self.symbols: Dict[str, ISymbol] = package.inner_packages
+                self.symbols: dict[str, ISymbol] = package.inner_packages
                 self.symbols.update(package.symbols)
             else:
                 self.symbols = package.symbols
 
+            self._package = package
             self.can_be_imported = True
             self.is_builtin_import = True
             return
 
-        if (os.path.commonpath([self.path, constants.BOA_PACKAGE_PATH]) != constants.BOA_PACKAGE_PATH or
-                ('boa3' in path and constants.PATH_SEPARATOR.join(path[path.index('boa3'):]).startswith('boa3/builtin'))):
-            # doesn't analyse boa3.builtin packages that aren't included in the imports.builtin as an user module
+        def is_boa_package() -> bool:
+            common_path = os.path.commonpath([self.path, constants.BOA_PACKAGE_PATH])
+            if common_path == constants.BOA_PACKAGE_PATH:
+                return True
+            if 'boa3' not in path:
+                return False
+
+            boa_path = path[path.index('boa3'):]
+            return len(boa_path) > 1 and boa_path[1] in ('builtin', 'sc')
+
+        if not is_boa_package():
+            # doesn't analyse boa3.builtin packages that aren't included in the imports.compilerbuiltin as an user module
             import re
 
             inside_python_folder = any(re.search(r'python(\d\.?)*', folder.lower()) for folder in path)
             updated_tree = None
 
             if not (inside_python_folder and 'lib' in path):
                 # check circular imports to avoid recursions inside the compiler
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/model/functionarguments.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/inativecontractclass.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,43 +1,46 @@
-from typing import Dict, Optional, Tuple
+import abc
 
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
 
 
-class FunctionArguments:
+class INativeContractClass(ClassArrayType, abc.ABC):
+    def __init__(self, identifier: str, contract_hash_property: IBuiltinProperty):
+        super().__init__(identifier)
+
+        self._variables: dict[str, Variable] = {}
+        self._class_methods: dict[str, Method] = {}
+        self._constructor: Method = None
+        self._properties = {
+            'hash': contract_hash_property
+        }
 
-    def __init__(self):
-        self._args: Dict[str, Variable] = {}
-        self._vararg: Optional[Tuple[str, Variable]] = None
-        self._kwargs: Optional[Dict[str, Variable]] = None
+    @property
+    def instance_variables(self) -> dict[str, Variable]:
+        return self._variables.copy()
 
     @property
-    def args(self) -> Dict[str, Variable]:
-        return self._args.copy()
+    def class_variables(self) -> dict[str, Variable]:
+        return {}
 
-    def add_arg(self, arg_id: str, arg: Variable) -> bool:
-        if not isinstance(arg, Variable):
-            return False
-        self._args[arg_id] = arg
-        return True
+    @property
+    def properties(self) -> dict[str, Property]:
+        return self._properties
 
     @property
-    def vararg(self) -> Optional[Tuple[str, Variable]]:
-        return self._vararg
+    def static_methods(self) -> dict[str, Method]:
+        return {}
 
-    def set_vararg(self, arg_id: str, arg: Variable) -> bool:
-        if not isinstance(arg, Variable):
-            return False
-        self._vararg = (arg_id, arg)
-        return True
+    @property
+    def class_methods(self) -> dict[str, Method]:
+        return self._class_methods
 
     @property
-    def kwargs(self) -> Dict[str, Variable]:
-        return self._kwargs
+    def instance_methods(self) -> dict[str, Method]:
+        return {}
 
-    def add_kwarg(self, arg_id: str, arg: Variable) -> bool:
-        if not isinstance(arg, Variable):
-            return False
-        if self._kwargs is None:
-            self._kwargs: Dict[str, Variable] = {}
-        self._kwargs[arg_id] = arg
-        return True
+    def constructor_method(self) -> Method | None:
+        return self._constructor
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/model/optimizer/Operation.py` & `neo3_boa-1.2.0/boa3/internal/analyser/model/optimizer/Operation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,10 @@
-from __future__ import annotations
-
 import ast
 from enum import Enum, auto
-from typing import Optional, Union
+from typing import Self
 
 from boa3.internal.model.operation.operation import IOperation
 from boa3.internal.model.operation.operator import Operator
 
 
 class Operation(Enum):
     Add = auto()
@@ -17,15 +15,15 @@
     Mod = auto()
 
     @property
     def is_symmetric(self) -> bool:
         return self._symmetric
 
     @classmethod
-    def get_operation(cls, op: Union[ast.operator, IOperation]) -> Optional[Operation]:
+    def get_operation(cls, op: ast.operator | IOperation) -> Self | None:
         op = op.operator if isinstance(op, IOperation) else op
         if op is Operator.Plus or isinstance(op, (ast.Add, ast.UAdd)):
             return cls.Add
         elif op is Operator.Minus or isinstance(op, (ast.Sub, ast.USub)):
             return cls.Sub
         elif op is Operator.Mult or isinstance(op, ast.Mult):
             return cls.Mult
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/model/optimizer/__init__.py` & `neo3_boa-1.2.0/boa3/internal/analyser/model/optimizer/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,36 +1,34 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional, Set
+from typing import Any, Self
 
 
 class ScopeValue:
     def __init__(self):
-        self._values: Dict[str, Any] = {}
-        self._assigned_variables: Set[str] = set()
-        self._parent_scope: Optional[ScopeValue] = None
+        self._values: dict[str, Any] = {}
+        self._assigned_variables: set[str] = set()
+        self._parent_scope: ScopeValue | None = None
 
-    def new_scope(self) -> ScopeValue:
+    def new_scope(self) -> Self:
         scope = ScopeValue()
         scope._values = self._values.copy()
         scope._assigned_variables = self._assigned_variables.copy()
         scope._parent_scope = self
         return scope
 
-    def previous_scope(self) -> Optional[ScopeValue]:
+    def previous_scope(self) -> Self | None:
         return self._parent_scope
 
     def update_values(self, *scopes, is_loop_scope: bool = False):
         other_scopes = [scope for scope in scopes if isinstance(scope, ScopeValue) and scope._parent_scope == self]
         if len(other_scopes) == 0:
             return
 
         first_scope = other_scopes[0]
-        common_keys: Set[str] = set(first_scope._values)
-        common_assigns: Set[str] = first_scope._assigned_variables
+        common_keys: set[str] = set(first_scope._values)
+        common_assigns: set[str] = first_scope._assigned_variables
 
         for scope in other_scopes[1:]:
             common_keys = common_keys.intersection(set(scope._values))
             common_assigns = common_assigns.intersection(scope._assigned_variables)
 
         new_values = {}
         different_values = []
@@ -88,9 +86,13 @@
     def __init__(self):
         pass
 
     @property
     def identifier(self) -> str:
         return 'undefined'
 
+    @property
+    def is_deprecated(self) -> bool:
+        return False
+
 
 Undefined = UndefinedType()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/model/symbolscope.py` & `neo3_boa-1.2.0/boa3/internal/analyser/model/symbolscope.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,23 +1,21 @@
-from __future__ import annotations
-
-from typing import Dict
+from typing import Self
 
 from boa3.internal.model.symbol import ISymbol
 
 
 class SymbolScope:
-    def __init__(self, symbols: Dict[str, ISymbol] = None):
+    def __init__(self, symbols: dict[str, ISymbol] = None):
         self._symbols = symbols.copy() if symbols is not None else {}
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         return self._symbols.copy()
 
-    def copy(self) -> SymbolScope:
+    def copy(self) -> Self:
         return SymbolScope(self._symbols)
 
     def include_symbol(self, symbol_id: str, symbol: ISymbol, reassign_original: bool = True):
         """
         Includes a symbols into the scope
 
         :param symbol_id: symbol identifier
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/moduleanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/moduleanalyser.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import ast
 import logging
 import os
-from typing import Any, Dict, Iterable, List, Optional, Tuple, Union
+from collections.abc import Iterable
+from typing import Any
 
 from boa3.builtin.compile_time import NeoMetadata
 from boa3.internal import constants
 from boa3.internal.analyser import asthelper
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.analyser.importanalyser import ImportAnalyser
 from boa3.internal.analyser.model.ManifestSymbol import ManifestSymbol
@@ -49,110 +50,110 @@
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
 
     :ivar modules: a dictionary that maps each module with its name. Empty by default.
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
-    def __init__(self, analyser, symbol_table: Dict[str, ISymbol],
+    def __init__(self, analyser, symbol_table: dict[str, ISymbol],
                  filename: str = None, root_folder: str = None,
-                 analysed_files: Optional[dict] = None,
-                 import_stack: Optional[List[str]] = None,
+                 analysed_files: dict | None = None,
+                 import_stack: list[str] | None = None,
                  log: bool = False,
                  fail_fast: bool = True):
         super().__init__(analyser.ast_tree, filename, root_folder, log, fail_fast)
-        self.modules: Dict[str, Module] = {}
-        self.symbols: Dict[str, ISymbol] = symbol_table
+        self.modules: dict[str, Module] = {}
+        self.symbols: dict[str, ISymbol] = symbol_table
 
         from boa3.internal.analyser.analyser import Analyser
         if isinstance(analysed_files, dict):
             for file_path, file_analyser in analysed_files.copy().items():
                 fixed_path = file_path.replace(os.sep, constants.PATH_SEPARATOR)
                 if file_path != fixed_path:
                     analysed_files.pop(file_path)
                     analysed_files[fixed_path] = file_analyser
         else:
             analysed_files = {}
 
         analysed_files[filename.replace(os.sep, constants.PATH_SEPARATOR)] = analyser
-        self._analysed_files: Dict[str, Analyser] = analysed_files
+        self._analysed_files: dict[str, Analyser] = analysed_files
 
         if isinstance(import_stack, list):
             import_stack = [file_path.replace(os.sep, constants.PATH_SEPARATOR)
                             if isinstance(file_path, str) else file_path
                             for file_path in import_stack]
         else:
             import_stack = []
-        self._import_stack: List[str] = import_stack
+        self._import_stack: list[str] = import_stack
 
-        self._builtin_functions_to_visit: Dict[str, IBuiltinMethod] = {}
+        self._builtin_functions_to_visit: dict[str, IBuiltinMethod] = {}
         self._current_module: Module = None
         self._current_class: UserClass = None
         self._current_method: Method = None
         self._current_event: Event = None
 
-        self._deploy_method: Optional[Method] = None
+        self._deploy_method: Method | None = None
 
-        self._annotated_variables: List[str] = []
-        self._global_assigned_variables: List[str] = []
-        self._scope_stack: List[SymbolScope] = []
+        self._annotated_variables: list[str] = []
+        self._global_assigned_variables: list[str] = []
+        self._scope_stack: list[SymbolScope] = []
 
         self._metadata: NeoMetadata = None
         self._metadata_node: ast.AST = ast.parse('')
-        self._manifest_symbols: Dict[Tuple[ManifestSymbol, str, int], Callable] = {}
-        self.imported_nodes: List[ast.AST] = []
+        self._manifest_symbols: dict[tuple[ManifestSymbol, str, int], Callable] = {}
+        self.imported_nodes: list[ast.AST] = []
 
         if self.filename:
             self._tree.filename = self.filename
         self.analyse_visit(self._tree)
 
         analyser.metadata = self._metadata if self._metadata is not None else NeoMetadata()
 
     @property
-    def _current_scope(self) -> Union[Method, Module, UserClass, None]:
+    def _current_scope(self) -> Method | Module | UserClass | None:
         """
         Returns the scope that is currently being analysed
 
         :return: the current scope. Return None if it is the global scope
         :rtype: Method or Module or None
         """
         if self._current_method is not None:
             return self._current_method
         if self._current_class is not None:
             return self._current_class
         return self._current_module
 
     @property
-    def _current_symbol_scope(self) -> Optional[SymbolScope]:
+    def _current_symbol_scope(self) -> SymbolScope | None:
         if len(self._scope_stack) > 0:
             return self._scope_stack[-1]
         else:
             return None
 
     @property
-    def global_symbols(self) -> Dict[str, ISymbol]:
+    def global_symbols(self) -> dict[str, ISymbol]:
         """
         Returns the symbols in global scope
 
         :return: the symbol table of the global scope
         """
-        global_symbols: Dict[str, ISymbol] = {}
+        global_symbols: dict[str, ISymbol] = {}
 
         global_symbols.update(self.symbols)
         for mod in self.modules.values():
             global_symbols.update(mod.symbols)
 
         return global_symbols
 
     @property
-    def analysed_files(self) -> Dict[str, Any]:
+    def analysed_files(self) -> dict[str, Any]:
         return self._analysed_files.copy()
 
     def __include_variable(self,
-                           var_id: str, var_type_id: Union[str, IType],
+                           var_id: str, var_type_id: str | IType,
                            source_node: ast.AST,
                            var_enumerate_type: IType = Type.none,
                            assignment: bool = True,
                            literal_value: Any = asthelper.INVALID_NODE_RESULT):
         """
         Includes the variable in the symbol table if the id was not used
 
@@ -204,15 +205,15 @@
                     var_type = Type.any
 
                 if isinstance(var_type, IType) or var_type is None:
                     # if type is None, the variable type depends on the type of a expression
                     if isinstance(source_node, ast.Global):
                         var = outer_symbol
                     else:
-                        if isinstance(var_type, SequenceType):
+                        if isinstance(var_type, SequenceType) and not Type.tuple.is_type_of(var_type):
                             var_type = var_type.build_collection(var_enumerate_type)
                         var = Variable(var_type, origin_node=source_node)
 
                     if first_assign and isinstance(Type.get_type(literal_value), PrimitiveType):
                         var.set_initial_assign(literal_value)
 
                     self._current_symbol_scope.include_symbol(var_id, var)
@@ -266,15 +267,15 @@
     def __set_source_origin(self, source_node: ast.AST, scope_is_correct: bool = True):
         if scope_is_correct or self._current_scope == self._deploy_method:
             source_node.origin = self._tree
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
                    check_raw_id: bool = False,
-                   origin_node: ast.AST = None) -> Optional[ISymbol]:
+                   origin_node: ast.AST = None) -> ISymbol | None:
         for scope in reversed(self._scope_stack):
             if symbol_id in scope.symbols:
                 return scope.symbols[symbol_id]
 
             if check_raw_id:
                 found_symbol = self._search_by_raw_id(symbol_id, list(scope.symbols.values()))
                 if found_symbol is not None:
@@ -294,30 +295,30 @@
 
             found_symbol = self._search_by_raw_id(symbol_id, list(self._current_module.symbols.values()))
             if found_symbol is not None:
                 return found_symbol
 
         return super().get_symbol(symbol_id, is_internal, check_raw_id, origin_node)
 
-    def get_annotation(self, value: Any, use_metatype: bool = False, accept_none: bool = False) -> Optional[IType]:
+    def get_annotation(self, value: Any, use_metatype: bool = False, accept_none: bool = False) -> IType | None:
         if not isinstance(value, ast.AST):
             return None
 
         annotation_type = self.get_type(value, use_metatype)
         if not isinstance(annotation_type, PythonClass):
             return annotation_type
         if hasattr(value, 'value') and value.value is None and annotation_type is Type.none:
             return annotation_type
 
         if isinstance(value, (ast.Constant, ast.NameConstant, ast.List, ast.Tuple, ast.Dict, ast.Set)):
             # annotated types should only accept types
             return None
         return annotation_type
 
-    def _check_annotation_type(self, node: ast.AST, origin_node: Optional[ast.AST] = None):
+    def _check_annotation_type(self, node: ast.AST, origin_node: ast.AST | None = None):
         if node is None:
             return
 
         if origin_node is None:
             origin_node = node
 
         if self.get_annotation(node) is None:
@@ -356,15 +357,15 @@
         :param function:
         """
         if self._metadata is not None:
             # metadata function has been defined already
             self._log_warning(
                 CompilerWarning.RedeclaredSymbol(
                     line=function.lineno, col=function.col_offset,
-                    symbol_id=Builtin.Metadata.identifier
+                    symbol_id="metadata"
                 )
             )
         # this function must have a return and no arguments
         elif len(function.args.args) != 0:
             self._log_error(
                 CompilerError.UnexpectedArgument(
                     line=function.lineno, col=function.col_offset
@@ -377,16 +378,16 @@
                     symbol_id=function.name
                 )
             )
         else:
             function.returns = None
             function.decorator_list = []
 
-            imports: List[ast.AST] = []
-            other_instructions: List[ast.AST] = []
+            imports: list[ast.AST] = []
+            other_instructions: list[ast.AST] = []
             for node in self._tree.body:
                 if node == function:
                     # metadata function must be right after all the imports, so it executes correctly
                     continue
 
                 if isinstance(node, (ast.ImportFrom, ast.Import)):
                     imports.append(node)
@@ -450,15 +451,15 @@
                         line=node.lineno, col=node.col_offset,
                         symbol_id=str(e)
                     )
                 )
                 return
 
             # validates the metadata attributes types
-            attributes: Dict[str, Any] = {attr: value
+            attributes: dict[str, Any] = {attr: value
                                           for attr, value in dict(obj.__dict__).items()
                                           if attr in Builtin.metadata_fields}
             if any(not isinstance(value, Builtin.metadata_fields[attr]) for attr, value in attributes.items()):
                 for expected, actual in [(Builtin.metadata_fields[attr], type(v_type))
                                          for attr, v_type in attributes.items()
                                          if not isinstance(v_type, Builtin.metadata_fields[attr])]:
                     if isinstance(expected, Iterable):
@@ -489,18 +490,18 @@
         Includes methods and variables from other modules into the current scope
 
         :param import_from:
         """
         self._log_import(import_from.module)
         analyser = self._analyse_module_to_import(import_from, import_from.module)
         if analyser is not None:
-            import_alias: Dict[str] = \
+            import_alias: dict[str] = \
                 {alias.name: alias.asname if alias.asname is not None else alias.name for alias in import_from.names}
 
-            new_symbols: Dict[str, ISymbol] = analyser.export_symbols(list(import_alias.keys()))
+            new_symbols: dict[str, ISymbol] = analyser.export_symbols(list(import_alias.keys()))
 
             # check if the wildcard is used and filter the symbols
             if constants.IMPORT_WILDCARD in import_alias:
                 import_alias.pop(constants.IMPORT_WILDCARD)
                 for imported_symbol_id in new_symbols:
                     # add the symbols imported with the wildcard without specific aliases in the dict
                     if imported_symbol_id not in import_alias:
@@ -519,39 +520,39 @@
 
     def visit_Import(self, import_node: ast.Import):
         """
         Includes methods and variables from other modules into the current scope
 
         :param import_node:
         """
-        import_alias: Dict[str] = \
+        import_alias: dict[str] = \
             {alias.name: alias.asname if alias.asname is not None else alias.name for alias in import_node.names}
 
         for target, alias in import_alias.items():
             self._log_import(target)
             analyser = self._analyse_module_to_import(import_node, target)
             if analyser is not None:
-                new_symbols: Dict[str, ISymbol] = analyser.export_symbols()
+                new_symbols: dict[str, ISymbol] = analyser.export_symbols()
                 for symbol in [symbol for symbol in analyser.symbols if symbol not in new_symbols]:
                     # if there's a symbol that couldn't be loaded, log a compiler error
                     self._log_unresolved_import(import_node, '{0}.{1}'.format(target, symbol))
 
                 imported_module = self._build_import(analyser.path, analyser.tree, analyser)
                 self._current_scope.include_symbol(alias, imported_module)
 
     def _build_import(self, origin: str, syntax_tree: ast.AST,
                       import_analyser: ImportAnalyser,
-                      imported_symbols: Dict[str, ISymbol] = None) -> Import:
+                      imported_symbols: dict[str, ISymbol] = None) -> Import:
 
         if import_analyser.is_builtin_import:
             return BuiltinImport(origin, syntax_tree, import_analyser, imported_symbols)
 
         return Import(origin, syntax_tree, import_analyser, imported_symbols)
 
-    def _analyse_module_to_import(self, origin_node: ast.AST, target: str) -> Optional[ImportAnalyser]:
+    def _analyse_module_to_import(self, origin_node: ast.AST, target: str) -> ImportAnalyser | None:
         already_imported = {imported.origin: imported.analyser
                             for imported in self._current_module.symbols.values()
                             if isinstance(imported, Import) and imported.analyser is not None
                             }
         already_imported.update(self._analysed_files)
 
         try:
@@ -581,14 +582,24 @@
                     self.errors.append(circular_import_error)
                 elif hasattr(analyser, 'is_namespace_package') and analyser.is_namespace_package:
                     return analyser
                 else:
                     self._log_unresolved_import(origin_node, target)
 
             else:
+                if analyser.is_import_deprecated:
+                    location_tip = analyser._package.new_location if analyser._package is not None else None
+                    self._log_warning(
+                        CompilerWarning.DeprecatedSymbol(
+                            origin_node.lineno,
+                            origin_node.col_offset,
+                            analyser._import_identifier,
+                            location_tip
+                        )
+                    )
                 analyser.update_external_analysed_files(self._analysed_files)
                 return analyser
 
         except CompilerError.CompilerError as error_on_import:
             if self._log:
                 self.errors.append(error_on_import)
                 raise error_on_import
@@ -628,15 +639,15 @@
                         symbol_id=var_id
                     )
                 )
 
         for stmt in function_stmts:
             result = self.visit(stmt)
             # don't evaluate the metadata function in the following analysers
-            if result is Builtin.Metadata:
+            if result is MetadataTypeSingleton:
                 module.body.remove(stmt)
 
         self.modules['main'] = mod
         module_scope = self._scope_stack.pop()
         for symbol_id, symbol in module_scope.symbols.items():
             if symbol_id in self._global_assigned_variables:
                 mod.include_symbol(symbol_id, symbol)
@@ -683,15 +694,15 @@
                 CompilerError.NotSupportedOperation(
                     class_node.lineno, class_node.col_offset,
                     symbol_id='class keyword'
                 )
             )
 
         # TODO: change when class decorators are implemented #2ewf04r
-        class_decorators: List[Method] = self._get_decorators(class_node)
+        class_decorators: list[Method] = self._get_decorators(class_node)
         if not all(isinstance(decorator, IBuiltinDecorator) and decorator.is_class_decorator
                    for decorator in class_decorators):
             # only builtin decorator are currently accepted
             self._log_error(
                 CompilerError.NotSupportedOperation(
                     class_node.lineno, class_node.col_offset,
                     symbol_id='class decorator'
@@ -729,34 +740,25 @@
         """
         Visitor of the function node
 
         Includes the method in the scope of its module
 
         :param function:
         """
-        fun_decorators: List[Method] = self._get_decorators(function)
-        if Builtin.Metadata in fun_decorators:
-            self._log_warning(
-                CompilerWarning.DeprecatedSymbol(
-                    function.lineno, function.col_offset,
-                    symbol_id=Builtin.Metadata.identifier
-                )
-            )
-            self._read_metadata_object(function)
-            return Builtin.Metadata
+        fun_decorators: list[Method] = self._get_decorators(function)
 
         if any(decorator is None for decorator in fun_decorators):
             self._log_error(
                 CompilerError.NotSupportedOperation(
                     function.lineno, function.col_offset,
                     symbol_id='decorator'
                 )
             )
 
-        valid_decorators: List[IDecorator] = []
+        valid_decorators: list[IDecorator] = []
         for decorator in fun_decorators:
             if isinstance(decorator, IDecorator):
                 if not decorator.is_function_decorator:
                     self._log_error(
                         CompilerError.NotSupportedOperation(
                             function.lineno, function.col_offset,
                             symbol_id=f'"{decorator.identifier}" decorator with function'
@@ -842,15 +844,15 @@
                 )
             )
 
         if isinstance(fun_rtype_symbol, str):
             symbol = self.get_symbol(fun_rtype_symbol, origin_node=function.returns)
             if symbol is MetadataTypeSingleton:
                 self._read_metadata_object(function)
-                return Builtin.Metadata
+                return symbol
 
             fun_rtype_symbol = self.get_type(symbol)
 
         fun_return: IType = self.get_type(fun_rtype_symbol)
 
         method = Method(args=fun_args.args, defaults=function.args.defaults, return_type=fun_return,
                         vararg=fun_args.vararg,
@@ -905,15 +907,15 @@
             if isinstance(var, Variable) and var_id not in self._annotated_variables:
                 method.include_variable(var_id, Variable(UndefinedType, var.origin))
             else:
                 method.include_symbol(var_id, var)
 
         self._annotated_variables.clear()
 
-    def _get_decorators(self, node: ast.AST) -> List[Method]:
+    def _get_decorators(self, node: ast.AST) -> list[Method]:
         """
         Gets a list of the symbols used to decorate the given node
 
         :param node: python ast node
         :return: a list with all decorators in the node. Empty if no decorator is found.
         """
         decorators = []
@@ -962,28 +964,28 @@
 
         :param arguments:
         :return: a dictionary that maps each argument to its identifier
         """
         fun_args = FunctionArguments()
 
         for arg in arguments.args:
-            var_id, var = self.visit_arg(arg)  # Tuple[str, Variable]
+            var_id, var = self.visit_arg(arg)  # tuple[str, Variable]
             fun_args.add_arg(var_id, var)
 
         if arguments.vararg is not None:
-            var_id, var = self.visit_arg(arguments.vararg)  # Tuple[str, Variable]
+            var_id, var = self.visit_arg(arguments.vararg)  # tuple[str, Variable]
             fun_args.set_vararg(var_id, var)
 
         if arguments.kwarg is not None:
-            var_id, var = self.visit_arg(arguments.kwarg)  # Tuple[str, Variable]
+            var_id, var = self.visit_arg(arguments.kwarg)  # tuple[str, Variable]
             fun_args.add_kwarg(var_id, var)
 
         return fun_args
 
-    def visit_arg(self, arg: ast.arg) -> Tuple[str, Variable]:
+    def visit_arg(self, arg: ast.arg) -> tuple[str, Variable]:
         """
         Visitor of a function argument node
 
         :param arg:
         :return: a tuple with the identifier and the argument
         """
         var_id = arg.arg
@@ -1013,15 +1015,15 @@
                 self._log_error(
                     CompilerError.UnresolvedReference(ret.value.lineno, ret.value.col_offset, symbol_id)
                 )
 
         if ret.value is not None:
             self.__set_source_origin(ret.value)
 
-    def visit_type(self, target: ast.AST) -> Optional[IType]:
+    def visit_type(self, target: ast.AST) -> IType | None:
         """
         Gets the type by its identifier
 
         :param target: ast node to be evaluated
         :return: the type of the value inside the node. None by default
         """
         target_type = self.visit(target)  # Type:str or IType
@@ -1119,15 +1121,24 @@
         var_id: str = self.visit(ann_assign.target)
         var_type: IType = self.visit_type(ann_assign.annotation)
         if var_type is Builtin.Event:
             self.visit(ann_assign.value)
 
         self._check_annotation_type(ann_assign.annotation, ann_assign)
 
-        # TODO: check if the annotated type and the value type are the same #86a1ctmwy
+        if isinstance(ann_assign.value, ast.Constant):
+            annotation_type = self.get_type(ann_assign.value)
+            if not var_type.is_type_of(annotation_type):
+                self._log_error(
+                    CompilerError.MismatchedTypes(line=ann_assign.value.lineno,
+                                                  col=ann_assign.value.col_offset,
+                                                  expected_type_id=var_type.identifier,
+                                                  actual_type_id=annotation_type.identifier)
+                )
+
         return self.assign_value(var_id, var_type,
                                  source_node=ann_assign,
                                  assignment=ann_assign.value is not None,
                                  literal_value=asthelper.literal_eval_node(ann_assign.value)
                                  )
 
     def visit_AugAssign(self, aug_assign: ast.AugAssign):
@@ -1187,84 +1198,101 @@
                     # nor it is a symbol of the global scope
                     or value not in self.symbols
             ):
                 self._log_error(
                     CompilerError.UnresolvedReference(expr.value.lineno, expr.value.col_offset, value)
                 )
 
-    def visit_Subscript(self, subscript: ast.Subscript) -> Union[str, IType]:
+    def visit_Subscript(self, subscript: ast.Subscript) -> str | IType:
         """
         Verifies if it is the types in the subscription are valid
 
         :param subscript: the python ast subscription node
         :return: if the subscript is not a symbol, returns its type. Otherwise returns the symbol id.
         :rtype: IType or str
         """
         is_internal = hasattr(subscript, 'is_internal_call') and subscript.is_internal_call
         value = self.visit(subscript.value)
         symbol = self.get_symbol(value, is_internal=is_internal, origin_node=subscript.value) if isinstance(value, str) else value
 
         if isinstance(subscript.ctx, ast.Load):
             if (isinstance(symbol, (Collection, MetaType))
                     and isinstance(subscript.value, (ast.Name, ast.NameConstant, ast.Attribute))):
-                # for evaluating names like List[str], Dict[int, bool], etc
-                value = subscript.slice.value if isinstance(subscript.slice, ast.Index) else subscript.slice
-                values_type: Iterable[IType] = self.get_values_type(value)
+                # for evaluating names like list[str], dict[int, bool], etc
+                values_type: Iterable[IType] = self.get_values_type(subscript.slice)
                 if isinstance(symbol, Collection):
                     return symbol.build_collection(*values_type)
                 else:
                     return symbol.build(*values_type)
 
             symbol_type = self.get_type(symbol)
             if isinstance(subscript.slice, ast.Slice):
                 return symbol_type
 
             if isinstance(symbol, UnionType) or isinstance(symbol_type, UnionType):
                 if not isinstance(symbol_type, UnionType):
                     symbol_type = symbol
-                index = subscript.slice.value if isinstance(subscript.slice, ast.Index) else subscript.slice
-                if isinstance(index, ast.Tuple):
-                    union_types = [self.get_type(value) for value in index.elts]
+                if isinstance(subscript.slice, ast.Tuple):
+                    union_types = [self.get_type(value) for value in subscript.slice.elts]
                 else:
-                    union_types = self.get_type(index)
+                    union_types = self.get_type(subscript.slice)
                 return symbol_type.build(union_types)
 
             if isinstance(symbol_type, Collection):
                 return symbol_type.item_type
 
         return value
 
-    def get_values_type(self, value: ast.AST) -> Iterable[Optional[IType]]:
+    def get_values_type(self, value: ast.AST) -> Iterable[IType | None]:
         """
         Verifies if it is a multiple assignments statement
 
         :param value: the python ast subscription node
         """
-        value_type: Optional[IType] = None
+        value_type: IType | None = None
 
-        if isinstance(value, (ast.Subscript, ast.Attribute, ast.Tuple)):
+        if isinstance(value, (ast.Subscript, ast.Attribute, ast.Tuple, ast.BinOp)):
             # index is another subscription
             value_type = self.visit(value)
         elif isinstance(value, ast.Name):
             # index is an identifier
             value_type = self.get_symbol(value.id)
 
-        types: Iterable[Optional[IType]] = value_type if isinstance(value_type, Iterable) else [value_type]
+        types: Iterable[IType | None] = value_type if isinstance(value_type, Iterable) else [value_type]
         for tpe in types:
             if not isinstance(tpe, IType):
                 # type hint not using identifiers or using identifiers that are not types
                 index = self.visit(value)
                 if isinstance(index, str):
                     self._log_error(
                         CompilerError.UnresolvedReference(value.lineno, value.col_offset, index)
                     )
 
         return types
 
-    def visit_Call(self, call: ast.Call) -> Optional[IType]:
+    def visit_BinOp(self, bin_op: ast.BinOp) -> IType | None:
+        left = self.visit(bin_op.left)
+        if isinstance(left, str):
+            left = self.get_symbol(left)
+        elif isinstance(bin_op.left, ast.Constant) and left is None:
+            left = self.get_type(left)
+
+        right = self.visit(bin_op.right)
+        if isinstance(right, str):
+            right = self.get_symbol(right)
+        elif isinstance(bin_op.right, ast.Constant) and right is None:
+            right = self.get_type(right)
+
+        # only validate type1 | type2, other binary operations are evaluated on TypeAnalyser
+        if isinstance(bin_op.op, ast.BitOr) and isinstance(left, IType) and isinstance(right, IType):
+            return left.union_type(right)
+
+        return self.generic_visit(bin_op)
+
+    def visit_Call(self, call: ast.Call) -> IType | None:
         """
         Visitor of a function call node
 
         :param call: the python ast function call node
         :return: the result type of the called function. None if the function is not found
         """
         func_id = self.visit(call.func)
@@ -1316,33 +1344,32 @@
             self._log_error(
                 CompilerError.UnfilledArgument(line=create_call.lineno,
                                                col=create_call.col_offset,
                                                param=list(Builtin.NewEvent.args)[0])
             )
         elif len(event_args) > 0:
             args_type = self.get_type(event_args[0])
+            expected_type = Builtin.NewEvent.arguments_type
             if not Type.list.is_type_of(args_type):
                 self._log_error(
                     CompilerError.MismatchedTypes(line=event_args[0].lineno,
                                                   col=event_args[0].col_offset,
-                                                  expected_type_id=Type.list.identifier,
+                                                  expected_type_id=expected_type.identifier,
                                                   actual_type_id=args_type.identifier)
                 )
             else:
+                expected_type = expected_type.value_type
                 for value in event_args[0].elts:
-                    if not isinstance(value, ast.Tuple):
-                        CompilerError.MismatchedTypes(line=value.lineno,
-                                                      col=value.col_offset,
-                                                      expected_type_id=Type.tuple.identifier,
-                                                      actual_type_id=self.get_type(value).identifier)
-                    elif len(value.elts) < 2:
+                    if not isinstance(value, ast.Tuple) or len(value.elts) < 2:
+                        actual_type = self.get_type(value)
                         self._log_error(
-                            CompilerError.UnfilledArgument(line=value.lineno,
-                                                           col=value.col_offset,
-                                                           param=list(Builtin.NewEvent.args)[0])
+                            CompilerError.MismatchedTypes(line=value.lineno,
+                                                          col=value.col_offset,
+                                                          expected_type_id=expected_type.identifier,
+                                                          actual_type_id=actual_type.identifier)
                         )
                     else:
                         event_arg_name, event_arg_type = value.elts
                         are_types_valid = True
                         if not isinstance(event_arg_name, ast.Str):
                             are_types_valid = False
                         else:
@@ -1362,15 +1389,15 @@
                                                                   actual_type_id=arg_type.identifier)
                                 )
 
                         if not are_types_valid:
                             self._log_error(
                                 CompilerError.MismatchedTypes(line=value.lineno,
                                                               col=value.col_offset,
-                                                              expected_type_id=Type.tuple.identifier,
+                                                              expected_type_id=expected_type.identifier,
                                                               actual_type_id=self.get_type(value).identifier)
                             )
                         else:
                             arg_name = event_arg_name.s
                             arg_type = (self.get_symbol(event_arg_type.id)
                                         if isinstance(event_arg_type, ast.Name)
                                         else self.visit(event_arg_type))
@@ -1388,37 +1415,52 @@
                 else:
                     name = event_args[1].s
 
         event = Event(name, args)
         event._origin_node = create_call
         return event
 
-    def visit_Attribute(self, attribute: ast.Attribute) -> Union[ISymbol, str]:
+    def visit_Attribute(self, attribute: ast.Attribute) -> ISymbol | str:
         """
         Gets the attribute inside the ast node
 
         :param attribute: the python ast attribute node
         :return: returns the type of the value, the attribute symbol and its id if the attribute exists.
                  Otherwise, returns None
         """
         value_id = attribute.value.id if isinstance(attribute.value, ast.Name) else None
         value: ISymbol = self.get_symbol(value_id) if value_id is not None else self.visit(attribute.value)
 
         if isinstance(value, Variable):
             value = value.type
+
+        attribute_symbol = None
         if hasattr(value, 'symbols') and attribute.attr in value.symbols:
-            return value.symbols[attribute.attr]
+            attribute_symbol = value.symbols[attribute.attr]
         elif isinstance(value, Package) and attribute.attr in value.inner_packages:
-            return value.inner_packages[attribute.attr]
+            attribute_symbol = value.inner_packages[attribute.attr]
         elif Builtin.get_symbol(attribute.attr) is not None:
-            return Builtin.get_symbol(attribute.attr)
+            attribute_symbol = Builtin.get_symbol(attribute.attr)
         elif isinstance(value, UndefinedType):
-            return value
+            attribute_symbol = value
+
+        attribute_id = '{0}.{1}'.format(value_id, attribute.attr)
+        if attribute_symbol is not None:
+            if attribute_symbol.is_deprecated:
+                self._log_warning(
+                    CompilerWarning.DeprecatedSymbol(
+                        attribute.lineno,
+                        attribute.col_offset,
+                        attribute_id,
+                        attribute_symbol.new_location if hasattr(attribute_symbol, 'new_location') else None
+                    )
+                )
+            return attribute_symbol
         else:
-            return '{0}.{1}'.format(value_id, attribute.attr)
+            return attribute_id
 
     def visit_For(self, for_node: ast.For):
         """
         Visitor of for statement node
 
         :param for_node: the python ast for node
         """
@@ -1540,42 +1582,42 @@
         Visitor of literal string node
 
         :param btes:
         :return: the value of the string
         """
         return btes.s
 
-    def visit_Tuple(self, tup_node: ast.Tuple) -> Optional[Tuple[Any, ...]]:
+    def visit_Tuple(self, tup_node: ast.Tuple) -> tuple | None:
         """
         Visitor of literal tuple node
 
         :param tup_node: the python ast string node
         :return: the value of the tuple
         """
         result = [self.get_type(value) for value in tup_node.elts]
         if Type.none in result and isinstance(tup_node.ctx, ast.Load):
             # if can't define the type of any value, let it to be defined in the type checking
             # only in load ctx because on store ctx means a tuple of variables to be assigned
             return None
         return tuple(result)
 
-    def visit_List(self, list_node: ast.List) -> Optional[List[Any]]:
+    def visit_List(self, list_node: ast.List) -> list[Any] | None:
         """
         Visitor of literal list node
 
         :param list_node: the python ast list node
         :return: the value of the list
         """
         result = [self.get_type(value) for value in list_node.elts]
         if Type.none in result:
             # if can't define the type of any value, let it to be defined in the type checking
             return None
         return result
 
-    def visit_Dict(self, dict_node: ast.Dict) -> Optional[Dict[Any, Any]]:
+    def visit_Dict(self, dict_node: ast.Dict) -> dict[Any, Any] | None:
         """
         Visitor of literal dict node
 
         :param dict_node: the python ast dict node
         :return: the value of the dict
         """
         dictionary = {}
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/supportedstandard/standardanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/supportedstandard/standardanalyser.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import re
-from typing import Dict, List
 
 from boa3.internal.analyser import supportedstandard
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.exception import CompilerError
 from boa3.internal.model.event import Event
 from boa3.internal.model.method import Method
 from boa3.internal.model.symbol import ISymbol
@@ -12,31 +11,31 @@
 class StandardAnalyser(IAstAnalyser):
     """
     This class is responsible for the checking if the given contract standards are implemented
 
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
-    def __init__(self, analyser, symbol_table: Dict[str, ISymbol],
+    def __init__(self, analyser, symbol_table: dict[str, ISymbol],
                  log: bool = False, fail_fast: bool = True):
         from boa3.builtin.compile_time import NeoMetadata
 
         super().__init__(analyser.ast_tree, analyser.filename, analyser.root, log=log, fail_fast=fail_fast)
 
-        self.symbols: Dict[str, ISymbol] = symbol_table
+        self.symbols: dict[str, ISymbol] = symbol_table
 
         if isinstance(analyser.metadata, NeoMetadata):
             # filter only strings
             analyser.metadata.supported_standards = [standard for standard in analyser.metadata.supported_standards
                                                      if isinstance(standard, str)]
             standards = analyser.metadata.supported_standards
         else:
             standards = []
 
-        self.standards: List[str] = standards
+        self.standards: list[str] = standards
         self._analyser = analyser
         self._filter_standards_names()
         self._validate_standards()
         self._check_other_implemented_standards()
 
     def _filter_standards_names(self):
         """
@@ -52,15 +51,15 @@
                 standard = rebab_case
 
             filtered_standards.add(standard)
 
         self.standards.clear()
         self.standards.extend(filtered_standards)
 
-    def get_methods_by_display_name(self, method_id: str) -> List[Method]:
+    def get_methods_by_display_name(self, method_id: str) -> list[Method]:
         methods = []
         for symbol_id, symbol in self.symbols.items():
             if isinstance(symbol, Method) and symbol.is_public:
                 display_name = symbol.external_name if symbol.external_name is not None else symbol_id
                 if display_name == method_id:
                     methods.append(symbol)
         return methods
```

### Comparing `neo3-boa-1.1.1/boa3/internal/analyser/typeanalyser.py` & `neo3_boa-1.2.0/boa3/internal/analyser/typeanalyser.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 import ast
-from typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union
+from collections.abc import Iterable
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.analyser.builtinfunctioncallanalyser import BuiltinFunctionCallAnalyser
 from boa3.internal.analyser.model.optimizer import Undefined, UndefinedType
 from boa3.internal.analyser.model.symbolscope import SymbolScope
 from boa3.internal.exception import CompilerError, CompilerWarning
 from boa3.internal.model.attribute import Attribute
 from boa3.internal.model.builtin.builtin import Builtin
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.imports.importsymbol import Import
 from boa3.internal.model.imports.package import Package
 from boa3.internal.model.method import Method
 from boa3.internal.model.module import Module
@@ -43,25 +45,26 @@
     These methods are used to walk through the Python abstract syntax tree.
 
     :ivar type_errors: a list with the found type errors. Empty by default.
     :ivar modules: a list with the analysed modules. Empty by default.
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
-    def __init__(self, analyser, symbol_table: Dict[str, ISymbol], log: bool = False, fail_fast: bool = True):
+    def __init__(self, analyser, symbol_table: dict[str, ISymbol], log: bool = False, fail_fast: bool = True):
         super().__init__(analyser.ast_tree, analyser.filename, analyser.root, log=log, fail_fast=fail_fast)
-        self.type_errors: List[Exception] = []
-        self.modules: Dict[str, Module] = {}
-        self.symbols: Dict[str, ISymbol] = symbol_table
+        self.type_errors: list[Exception] = []
+        self.modules: dict[str, Module] = {}
+        self.symbols: dict[str, ISymbol] = symbol_table
 
+        self._is_annotation: bool = False
         self._current_class: UserClass = None
         self._current_method: Method = None
-        self._scope_stack: List[SymbolScope] = []
+        self._scope_stack: list[SymbolScope] = []
 
-        self._super_calls: List[IBuiltinMethod] = []
+        self._super_calls: list[IBuiltinMethod] = []
         self.analyse_visit(self._tree)
 
     def visit(self, node: ast.AST, get_literal_value: bool = False):
         if get_literal_value:
             node.get_literal_value = True
 
         result = super().visit(node)
@@ -80,33 +83,33 @@
         :rtype: str or None
         """
         if self._current_method in self.symbols.values():
             index = list(self.symbols.values()).index(self._current_method)
             return list(self.symbols.keys())[index]
 
     @property
-    def _current_scope(self) -> Optional[SymbolScope]:
+    def _current_scope(self) -> SymbolScope | None:
         return self._scope_stack[-1] if len(self._scope_stack) > 0 else None
 
     @property
-    def _modules_symbols(self) -> Dict[str, ISymbol]:
+    def _modules_symbols(self) -> dict[str, ISymbol]:
         """
         Gets all the symbols in the modules scopes.
 
         :return: Returns a dictionary that maps the modules symbols.
         """
         symbols = {}
         for module in self.modules.values():
             symbols.update(module.symbols)
         return symbols
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
                    check_raw_id: bool = False,
-                   origin_node: ast.AST = None) -> Optional[ISymbol]:
+                   origin_node: ast.AST = None) -> ISymbol | None:
         if symbol_id is None:
             return None
         if isinstance(symbol_id, ISymbol) and not isinstance(symbol_id, (IType, IExpression)):
             return symbol_id
         if not isinstance(symbol_id, str):
             return Variable(self.get_type(symbol_id))
 
@@ -140,15 +143,15 @@
         if check_raw_id:
             found_symbol = self._search_by_raw_id(symbol_id, list(cur_symbols.values()))
             if found_symbol is not None:
                 return found_symbol
 
         return super().get_symbol(symbol_id, is_internal, check_raw_id, origin_node)
 
-    def new_local_scope(self, symbols: Dict[str, ISymbol] = None):
+    def new_local_scope(self, symbols: dict[str, ISymbol] = None):
         if symbols is None:
             symbols = self._current_scope.symbols if self._current_scope is not None else {}
 
         self._scope_stack.append(SymbolScope(symbols))
 
     def pop_local_scope(self) -> SymbolScope:
         return self._scope_stack.pop()
@@ -251,16 +254,18 @@
         :param arg: the python ast arg node
         """
         if arg.annotation is None:
             self._log_error(
                 CompilerError.TypeHintMissing(arg.lineno, arg.col_offset, symbol_id=arg.arg)
             )
 
+        self._is_annotation = True
         # continue to walk through the tree
         self.generic_visit(arg)
+        self._is_annotation = False
 
     def visit_Return(self, ret: ast.Return):
         """
         Verifies if the return of the function is the same type as the return type annotation
 
         :param ret: the python ast return node
         """
@@ -482,15 +487,15 @@
                         origin_type_id=value_type.identifier,
                         cast_type_id=target_type.identifier
                     )
                 )
 
         return True
 
-    def _has_only_default_values(self, value: Any, target_type: Optional[IType] = None) -> bool:
+    def _has_only_default_values(self, value: Any, target_type: IType | None = None) -> bool:
         if not isinstance(target_type, IType):
             target_type = self.get_type(value)
 
         has_only_default_values = value == target_type.default_value
         if not has_only_default_values and isinstance(target_type, Collection) and hasattr(value, '__len__'):
             has_only_default_values = True
             if isinstance(value, dict):
@@ -578,15 +583,15 @@
         elif isinstance(subscript.ctx, ast.Store) and not symbol_type.can_reassign_values:
             self._log_error(
                 CompilerError.UnresolvedOperation(
                     subscript.lineno, subscript.col_offset,
                     type_id=symbol_type.identifier,
                     operation_id=Operator.Subscript)
             )
-        return symbol_type.item_type
+        return symbol_type.get_item_type(index)
 
     def validate_slice(self, subscript: ast.Subscript, slice_node: ast.Slice) -> IType:
         """
         Verifies if the subscribed value is a sequence and if the slice is valid to this sequence
 
         :param subscript: the python ast subscript node
         :param slice_node: the subscript slice
@@ -610,15 +615,15 @@
         upper = upper if upper is not Type.none else symbol_type.valid_key
         step = step if step is not Type.none else symbol_type.valid_key
 
         if (not symbol_type.is_valid_key(lower)
                 or not symbol_type.is_valid_key(upper)
                 or (step is not Type.none and not symbol_type.is_valid_key(step))
             ):
-            actual: Tuple[IType, ...] = (lower, upper) if step is Type.none else (lower, upper, step)
+            actual: tuple[IType, ...] = (lower, upper) if step is Type.none else (lower, upper, step)
             self._log_error(
                 CompilerError.MismatchedTypes(
                     subscript.lineno, subscript.col_offset,
                     expected_type_id=[symbol_type.valid_key.identifier for value in actual],
                     actual_type_id=[value.identifier for value in actual]
                 )
             )
@@ -741,15 +746,15 @@
             new_type = Type.union.build([new_value_type_if_branch, new_value_type_else_branch])
             last_scope.include_symbol(changed_symbol, Variable(new_type))
 
         # updates with the variables assigned in a branch that doesn't exist in the outer scope
         self._include_symbols_to_scope(last_scope, is_instance_if, intersected_ids)
         self._include_symbols_to_scope(last_scope, is_instance_else, intersected_ids)
 
-    def _include_symbols_to_scope(self, scope: SymbolScope, other_scope: Dict[str, ISymbol], items_filter: Set[str]):
+    def _include_symbols_to_scope(self, scope: SymbolScope, other_scope: dict[str, ISymbol], items_filter: set[str]):
         for new_symbol_id in {key for key in other_scope if key not in items_filter}:
             new_symbol = other_scope[new_symbol_id]
             new_value_type = self.get_type(new_symbol)
             outer_symbol = self.get_symbol(new_symbol_id)
             outer_value_type = outer_symbol.type if isinstance(outer_symbol, IExpression) else Type.none
 
             if (isinstance(outer_symbol, Variable) and isinstance(new_symbol, Variable)
@@ -780,27 +785,27 @@
 
         self.new_local_scope(is_instance_else)
         else_type: IType = self.get_type(else_value)
         self.pop_local_scope()
 
         return Type.get_generic_type(if_type, else_type)
 
-    def validate_if(self, if_node: ast.AST) -> Tuple[Dict[str, ISymbol], Dict[str, ISymbol]]:
+    def validate_if(self, if_node: ast.AST) -> tuple[dict[str, ISymbol], dict[str, ISymbol]]:
         """
         Verifies if the type of if test is valid
 
         :param if_node: the python ast if statement node
         :type if_node: ast.If or ast.IfExp
         """
         test = self.visit(if_node.test)
         test_type: IType = self.get_type(test)
 
         return self._get_is_instance_function_calls(if_node.test)
 
-    def _get_is_instance_function_calls(self, node: ast.AST) -> Tuple[Dict[str, ISymbol], Dict[str, ISymbol]]:
+    def _get_is_instance_function_calls(self, node: ast.AST) -> tuple[dict[str, ISymbol], dict[str, ISymbol]]:
         from boa3.internal.model.builtin.method.isinstancemethod import IsInstanceMethod
         is_instance_objs = [x for x, symbol in self.symbols.items()
                             if isinstance(symbol, IsInstanceMethod)]
         is_instance_objs.append(isinstance.__name__)
 
         is_instance_symbols = {}
         is_not_instance_symbols = {}
@@ -875,30 +880,35 @@
         for key, value in is_not_instance_symbols.copy().items():
             if value == self.get_type(self.get_symbol(key)):
                 is_not_instance_symbols.pop(key)
             else:
                 is_not_instance_symbols[key] = Variable(value)
         return is_instance_symbols, is_not_instance_symbols
 
-    def visit_BinOp(self, bin_op: ast.BinOp) -> Optional[IType]:
+    def visit_BinOp(self, bin_op: ast.BinOp) -> IType | None:
         """
         Verifies if the types of the operands are valid to the operation
 
         If the operation is valid, changes de Python operator by the Boa operator in the syntax tree
 
         :param bin_op: the python ast binary operation node
         :return: the type of the result of the operation if the operation is valid. Otherwise, returns None
         :rtype: IType or None
         """
-        operation = self.validate_binary_operation(bin_op, bin_op.left, bin_op.right)
-        if operation is not None:
-            bin_op.op = operation
-            return operation.result
+        if self._is_annotation and isinstance(bin_op.op, ast.BitOr):
+            left_type = self.get_type(bin_op.left)
+            right_type = self.get_type(bin_op.right)
+            return left_type.union_type(right_type)
+        else:
+            operation = self.validate_binary_operation(bin_op, bin_op.left, bin_op.right)
+            if operation is not None:
+                bin_op.op = operation
+                return operation.result
 
-    def validate_binary_operation(self, node: ast.AST, left_op: ast.AST, right_op: ast.AST) -> Optional[IOperation]:
+    def validate_binary_operation(self, node: ast.AST, left_op: ast.AST, right_op: ast.AST) -> IOperation | None:
         """
         Validates a ast node that represents a binary operation
 
         :param node: ast node that represents a binary operation
         :param left_op: ast node that represents the left operand of the operation
         :param right_op: ast node that represents the right operand of the operation
         :return: the corresponding :class:`BinaryOperation` if is valid. None otherwise.
@@ -965,15 +975,15 @@
                 left = l_type if left is not None else r_type
                 right = None
 
             expected_op: BinaryOperation = BinaryOp.get_operation_by_operator(operator, left, right)
             expected_types = (expected_op.left_type.identifier, expected_op.right_type.identifier)
             raise CompilerError.MismatchedTypes(0, 0, expected_types, actual_types)
 
-    def visit_UnaryOp(self, un_op: ast.UnaryOp) -> Optional[IType]:
+    def visit_UnaryOp(self, un_op: ast.UnaryOp) -> IType | None:
         """
         Verifies if the type of the operand is valid to the operation
 
         If the operation is valid, changes de Python operator by the Boa operator in the syntax tree
 
         :param un_op: the python ast unary operation node
         :return: the type of the result of the operation if the operation is valid. Otherwise, returns None
@@ -1051,15 +1061,15 @@
                     CompilerError.MismatchedTypes(
                         assert_.msg.lineno, assert_.msg.col_offset,
                         expected_type_id=Type.str.identifier,
                         actual_type_id=str(msg_type)
                     )
                 )
 
-    def visit_Compare(self, compare: ast.Compare) -> Optional[IType]:
+    def visit_Compare(self, compare: ast.Compare) -> IType | None:
         """
         Verifies if the types of the operands are valid to the compare operations
 
         If the operations are valid, changes de Python operator by the Boa operator in the syntax tree
 
         :param compare: the python ast compare operation node
         :return: the type of the result of the operation if the operation is valid. Otherwise, returns None
@@ -1110,15 +1120,15 @@
             return return_type
         except CompilerError.MismatchedTypes as raised_error:
             raised_error.line = line
             raised_error.col = col
             # raises the exception with the line/col info
             self._log_error(raised_error)
 
-    def visit_BoolOp(self, bool_op: ast.BoolOp) -> Optional[IType]:
+    def visit_BoolOp(self, bool_op: ast.BoolOp) -> IType | None:
         """
         Verifies if the types of the operands are valid to the boolean operations
 
         If the operations are valid, changes de Python operator by the Boa operator in the syntax tree
 
         :param bool_op: the python ast boolean operation node
         :return: the type of the result of the operation if the operation is valid. Otherwise, returns None
@@ -1158,15 +1168,15 @@
             return return_type
         except CompilerError.MismatchedTypes as raised_error:
             raised_error.line = lineno
             raised_error.col = col_offset
             # raises the exception with the line/col info
             self._log_error(raised_error)
 
-    def get_operator(self, node: Union[ast.operator, Operator, IOperation]) -> Optional[Operator]:
+    def get_operator(self, node: ast.operator | Operator | IOperation) -> Operator | None:
         """
         Gets the :class:`Operator` equivalent to given Python ast operator
 
         :param node: object with the operator data
         :type node: ast.operator or Operator or IOperation
         :return: the Boa operator equivalent to the node. None if it doesn't exit.
         :rtype: Operator or None
@@ -1182,25 +1192,36 @@
     def visit_Call(self, call: ast.Call):
         """
         Verifies if the number of arguments is correct
 
         :param call: the python ast function call node
         :return: the result type of the called function
         """
+        is_internal_call = hasattr(call, 'is_internal_call') and call.is_internal_call
+
         if isinstance(call.func, ast.Name):
             callable_id: str = call.func.id
             is_internal = hasattr(call, 'is_internal_call') and call.is_internal_call
             callable_target = self.get_symbol(callable_id, is_internal)
-        elif isinstance(call.func, ast.Lambda):
-            self._log_error(
-                CompilerError.NotSupportedOperation(call.func.lineno, call.func.col_offset, 'lambda function')
-            )
         else:
+            if isinstance(call.func, ast.Lambda):
+                self._log_error(
+                    CompilerError.NotSupportedOperation(call.func.lineno, call.func.col_offset, 'lambda function')
+                )
             callable_id, callable_target = self.get_callable_and_update_args(call)  # type: str, ISymbol
 
+        if callable_target is not None and callable_target.is_deprecated and not is_internal_call:
+            self._log_warning(
+                CompilerWarning.DeprecatedSymbol(
+                    call.lineno,
+                    call.col_offset,
+                    callable_id,
+                    callable_target.new_location if isinstance(callable_target, IBuiltinCallable) else None
+                )
+            )
         callable_target = self.validate_builtin_callable(callable_id, callable_target, call.args)
 
         if not isinstance(callable_target, Callable):
             # if the outer call is a builtin, enable call even without the import
             builtin_symbol = Builtin.get_symbol(callable_id)
             if builtin_symbol is not None:
                 callable_target = builtin_symbol
@@ -1248,15 +1269,15 @@
                         if cast_types is None:
                             origin_type_id = 'unknown'
                             cast_type_id = callable_target.type.identifier
                         else:
                             origin_type_id = cast_types[0].identifier
                             cast_type_id = cast_types[1].identifier
 
-                        if not hasattr(call, 'is_internal_call') or not call.is_internal_call:
+                        if not is_internal_call:
                             self._log_warning(
                                 CompilerWarning.TypeCasting(call.lineno, call.col_offset,
                                                             origin_type_id=origin_type_id,
                                                             cast_type_id=cast_type_id)
                             )
 
                 self.validate_passed_arguments(call, args, callable_id, callable_target)
@@ -1264,15 +1285,15 @@
             if private_identifier is not None and callable_target.identifier != private_identifier:
                 # updates the callable_id for validation of internal builtin that accepts generic variables
                 callable_id = private_identifier
             self.update_callable_after_validation(call, callable_id, callable_target)
 
         return self.get_type(callable_target)
 
-    def get_callable_and_update_args(self, call: ast.Call) -> Tuple[str, ISymbol]:
+    def get_callable_and_update_args(self, call: ast.Call) -> tuple[str, ISymbol]:
         attr: Attribute = self.visit(call.func)
         if not isinstance(attr, Attribute):
             attr_id = str(attr)
             attr_id_split = attr_id.split(constants.ATTRIBUTE_NAME_SEPARATOR)
             attr_call_id = attr_id
             if len(attr_id_split) > 0:
                 attr_call_id = constants.ATTRIBUTE_NAME_SEPARATOR.join(attr_id_split[:-1])
@@ -1366,15 +1387,15 @@
             self._log_error(
                 CompilerError.UnresolvedReference(call.func.lineno, call.func.col_offset, callable_complete_id)
             )
 
         return len(self.errors) == error_count
 
     def validate_builtin_callable(self, callable_id: str, callable_target: ISymbol,
-                                  call_args: List[ast.AST] = None) -> ISymbol:
+                                  call_args: list[ast.AST] = None) -> ISymbol:
         if call_args is None:
             call_args = []
 
         if not isinstance(callable_target, Callable):
             # verify if it is a builtin method with its name shadowed
             call_target = Builtin.get_symbol(callable_id)
             if not isinstance(call_target, Callable):
@@ -1487,15 +1508,15 @@
 
         if callable_required_args <= len_call_args < len(callable_target.args):
             included_args = len_call_args - callable_required_args
             for default in callable_target.defaults[included_args:]:
                 call.args.append(self.clone(default))
         return True
 
-    def validate_passed_arguments(self, call: ast.Call, args_types: List[IType], callable_id: str, callable: Callable):
+    def validate_passed_arguments(self, call: ast.Call, args_types: list[IType], callable_id: str, callable: Callable):
         if isinstance(callable, IBuiltinMethod):
             builtin_analyser = BuiltinFunctionCallAnalyser(self, call, callable_id, callable, self._log)
             if builtin_analyser.validate():
                 self.errors.extend(builtin_analyser.errors)
                 self.warnings.extend(builtin_analyser.warnings)
                 return
 
@@ -1518,15 +1539,15 @@
         # validate keyword arguments
         for param in call.keywords:
             arg_value = callable.args[param.arg]
             param = param.value
             param_type = self._validate_argument_type(param, arg_value.type)
             param_types.append(param_type)
 
-    def _validate_argument_type(self, param: ast.AST, arg_type: IType, use_metatype: bool = False) -> Optional[IType]:
+    def _validate_argument_type(self, param: ast.AST, arg_type: IType, use_metatype: bool = False) -> IType | None:
         param_type = self.get_type(param, use_metatype=use_metatype)
         if arg_type.is_type_of(param_type):
             return param_type
         else:
             self._log_error(
                 CompilerError.MismatchedTypes(
                     param.lineno, param.col_offset,
@@ -1584,15 +1605,15 @@
             self.visit(stmt)
 
         for stmt in try_node.finalbody:
             self.visit(stmt)
 
     def validate_except_handlers(self, try_node: ast.Try):
         if len(try_node.handlers) > 1:
-            exception_handlers: List[ast.ExceptHandler] = try_node.handlers.copy()
+            exception_handlers: list[ast.ExceptHandler] = try_node.handlers.copy()
             general_exc_handler: ast.ExceptHandler = next(
                 (handler
                  for handler in exception_handlers
                  if (handler.type is None or  # no specified exception or is BaseException
                      (isinstance(handler.type, ast.Name) and handler.type.id == BaseException.__name__)
                      )
                  ), exception_handlers[0]
@@ -1667,24 +1688,24 @@
                 if value is None and isinstance(origin, ast.Name):
                     value = self.get_symbol(origin.id)
                 if value is not None:
                     return value
 
         return result
 
-    def visit_Attribute(self, attribute: ast.Attribute) -> Union[str, Attribute]:
+    def visit_Attribute(self, attribute: ast.Attribute) -> str | Attribute:
         """
         Gets the attribute inside the ast node
 
         :param attribute: the python ast attribute node
         :return: returns the type of the value, the attribute symbol and its id if the attribute exists.
                  Otherwise, returns None
         """
         is_internal = hasattr(attribute, 'is_internal_call') and attribute.is_internal_call
-        value: Optional[Union[str, ISymbol]] = self.get_symbol(attribute.value.id, is_internal) \
+        value: str | ISymbol | None = self.get_symbol(attribute.value.id, is_internal) \
             if isinstance(attribute.value, ast.Name) else self.visit(attribute.value)
 
         if value is None and isinstance(attribute.value, ast.Name):
             return '{0}.{1}'.format(attribute.value.id, attribute.attr)
 
         symbol = None
         if isinstance(value, str) and not isinstance(attribute.value, ast.Str):
@@ -1703,15 +1724,15 @@
         if isinstance(symbol, IExpression):
             symbol = symbol.type
         if hasattr(symbol, 'symbols') and attribute.attr in symbol.symbols:
             attr_symbol = symbol.symbols[attribute.attr]
         elif isinstance(symbol, Package) and attribute.attr in symbol.inner_packages:
             attr_symbol = symbol.inner_packages[attribute.attr]
         else:
-            attr_symbol: Optional[ISymbol] = self.get_symbol(attribute.attr)
+            attr_symbol: ISymbol | None = self.get_symbol(attribute.attr)
 
         origin = value
         module_symbols = origin.symbols if isinstance(origin, Package) else symbol.methods if isinstance(symbol, Import) else None
         if isinstance(origin, Attribute):
             while isinstance(origin, Attribute):
                 origin = origin.value
         else:
@@ -1841,43 +1862,43 @@
             if item is None or isinstance(item, ast.AST):
                 item = self.get_type(node)
         else:
             item = self.get_type(node)
 
         return item
 
-    def visit_Tuple(self, tup_node: ast.Tuple) -> Tuple[Any, ...]:
+    def visit_Tuple(self, tup_node: ast.Tuple) -> tuple[Any, ...]:
         """
         Visitor of literal tuple node
 
         :param tup_node: the python ast tuple node
         :return: the value of the tuple
         """
         get_literal_values = hasattr(tup_node, 'get_literal_value') and tup_node.get_literal_value
         result = []
         for value in tup_node.elts:
             result.append(self._visit_literal(value, get_literal_values))
 
         return tuple(result)
 
-    def visit_List(self, list_node: ast.List) -> List[Any]:
+    def visit_List(self, list_node: ast.List) -> list[Any]:
         """
         Visitor of literal list node
 
         :param list_node: the python ast list node
         :return: the value of the list
         """
         get_literal_values = hasattr(list_node, 'get_literal_value') and list_node.get_literal_value
         result = []
         for value in list_node.elts:
             result.append(self._visit_literal(value, get_literal_values))
 
         return result
 
-    def visit_Dict(self, dict_node: ast.Dict) -> Dict[Any, Any]:
+    def visit_Dict(self, dict_node: ast.Dict) -> dict[Any, Any]:
         """
         Visitor of literal dict node
 
         :param dict_node: the python ast dict node
         :return: a list with each key and value type
         """
         get_literal_values = hasattr(dict_node, 'get_literal_value') and dict_node.get_literal_value
@@ -1889,15 +1910,15 @@
 
             if key in dictionary and dictionary[key] != value:
                 dictionary[key] = Type.get_generic_type(dictionary[key], value)
             else:
                 dictionary[key] = value
         return dictionary
 
-    def visit_Set(self, node: ast.Set) -> Set[Any]:
+    def visit_Set(self, node: ast.Set) -> set[Any]:
         """
         Visitor of literal set node. Currently, is not supported
         """
 
         self._log_error(
             CompilerError.InvalidType(node.lineno, node.col_offset, 'Set')
         )
@@ -1927,29 +1948,29 @@
         if not Type.sequence.is_type_of(value_type):
             self._log_error(
                 CompilerError.MismatchedTypes(line=node.lineno, col=node.col_offset,
                                               expected_type_id=Type.sequence.identifier,
                                               actual_type_id=value_type.identifier)
             )
 
-        return Type.tuple.build_collection(value_type.value_type)
+        return Type.tuple.build_any_length(value_type.value_type)
 
     def visit_Index(self, index: ast.Index) -> Any:
         """
         Visitor of an index node
 
         :param index:
         :return: the object with the index value information
         """
         index = self.visit(index.value)
-        if isinstance(index, (Iterable, Tuple)):
+        if isinstance(index, (Iterable, tuple)):
             return tuple(index)
         return index
 
-    def visit_Slice(self, slice_node: ast.Slice) -> Tuple[Any, Any, Any]:
+    def visit_Slice(self, slice_node: ast.Slice) -> tuple[Any, Any, Any]:
         """
         Visitor of an slice node
 
         :param slice_node:
         :return: the object with the index value information
         """
         return slice_node.lower, slice_node.upper, slice_node.step
```

### Comparing `neo3-boa-1.1.1/boa3/internal/cli_commands/compile_command.py` & `neo3_boa-1.2.0/boa3/internal/cli_commands/compile_command.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 import logging
 import os
 import sys
 from argparse import _SubParsersAction
-from typing import Optional
 
 from boa3.boa3 import Boa3
 from boa3.internal.cli_commands.icommand import ICommand
 from boa3.internal.exception.NotLoadedException import NotLoadedException
 
 
 class CompileCommand(ICommand):
@@ -45,15 +44,15 @@
 
     @staticmethod
     def execute_command(args: dict):
         sc_path: str = args['input']
         project_path: str = args['project_path']
         debug: bool = args['debug']
         env: str = args['env']
-        output_path: Optional[str] = args['output_path']
+        output_path: str | None = args['output_path']
         fail_fast: bool = not args['no_failfast']
         log_level = args['log_level']
 
         if not sc_path.endswith(".py") or not os.path.isfile(sc_path):
             logging.error("Input file is not .py")
             sys.exit(1)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/__init__.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import List, Tuple
-
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.type.Integer import Integer
 
 
-def get_bytes(instructions: List[Tuple[Opcode, bytes]]) -> bytes:
+def get_bytes(instructions: list[tuple[Opcode, bytes]]) -> bytes:
     return b''.join([opcode + arg for opcode, arg in instructions])
 
 
-def get_bytes_count(instructions: List[Tuple[Opcode, bytes]]) -> int:
+def get_bytes_count(instructions: list[tuple[Opcode, bytes]]) -> int:
     return sum([len(opcode) + len(arg) for opcode, arg in instructions])
 
 
 def get_storage_key_for_variable(symbol: ISymbol) -> bytes:
     if isinstance(symbol, IExpression):
         symbol_obj = symbol.origin
     else:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/codegenerator.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/codegenerator.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 __all__ = [
     'CodeGenerator'
 ]
 
 
-from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.analyser.analyser import Analyser
 from boa3.internal.analyser.model.symbolscope import SymbolScope
 from boa3.internal.compiler import codegenerator
 from boa3.internal.compiler.codegenerator import optimizerhelper
 from boa3.internal.compiler.codegenerator.codeoptimizer import CodeOptimizer
@@ -150,15 +151,15 @@
         if optimization_level > OptimizationLevel.NONE:
             compilation_result = generator.get_optimized_output(optimization_level)
         else:
             compilation_result = generator.output
         return compilation_result
 
     @staticmethod
-    def _find_all_imports(analyser: Analyser) -> Dict[str, Import]:
+    def _find_all_imports(analyser: Analyser) -> dict[str, Import]:
         imports = {}
         for key, symbol in analyser.symbol_table.copy().items():
             if isinstance(symbol, Import):
                 importing = symbol
             elif isinstance(symbol, Package) and isinstance(symbol.origin, Import):
                 importing = symbol.origin
                 analyser.symbol_table[symbol.origin.origin] = symbol.origin
@@ -167,49 +168,49 @@
 
             if importing is not None and importing.origin not in imports:
                 imports[importing.origin] = importing
 
         return imports
 
     def __init__(self,
-                 symbol_table: Dict[str, ISymbol],
+                 symbol_table: dict[str, ISymbol],
                  optimization_level: OptimizationLevel = OptimizationLevel.DEFAULT
                  ):
 
-        self.symbol_table: Dict[str, ISymbol] = symbol_table.copy()
+        self.symbol_table: dict[str, ISymbol] = symbol_table.copy()
         self._optimization_level = (optimization_level
                                     if isinstance(optimization_level, OptimizationLevel)
                                     else OptimizationLevel.DEFAULT)
-        self.additional_symbols: Optional[Dict[str, ISymbol]] = None
+        self.additional_symbols: dict[str, ISymbol] | None = None
 
         self._current_method: Method = None
         self._current_class: Method = None
 
-        self._missing_target: Dict[int, List[VMCode]] = {}  # maps targets with address not included yet
+        self._missing_target: dict[int, list[VMCode]] = {}  # maps targets with address not included yet
         self._can_append_target: bool = True
 
-        self._scope_stack: List[SymbolScope] = []
+        self._scope_stack: list[SymbolScope] = []
         self._global_scope = SymbolScope()
 
-        self._current_loop: List[int] = []  # a stack with the converting loops' start addresses
-        self._current_for: List[int] = []
-        self._jumps_to_loop_condition: Dict[int, List[int]] = {}
+        self._current_loop: list[int] = []  # a stack with the converting loops' start addresses
+        self._current_for: list[int] = []
+        self._jumps_to_loop_condition: dict[int, list[int]] = {}
 
-        self._jumps_to_loop_break: Dict[int, List[int]] = {}
+        self._jumps_to_loop_break: dict[int, list[int]] = {}
         # the indexes of boolean insertion values indicating if the jmp is from a break
-        self._inserted_loop_breaks: Dict[int, List[int]] = {}
+        self._inserted_loop_breaks: dict[int, list[int]] = {}
 
-        self._opcodes_to_remove: List[int] = []
+        self._opcodes_to_remove: list[int] = []
         self._stack_states: StackMemento = StackMemento()  # simulates neo execution stack
 
         self.can_init_static_fields: bool = False
         self.initialized_static_fields: bool = False
 
-        self._static_vars: Optional[list] = None
-        self._global_vars: Optional[list] = None
+        self._static_vars: list | None = None
+        self._global_vars: list | None = None
 
     @property
     def bytecode(self) -> bytes:
         """
         Gets the bytecode of the translated code
 
         :return: the generated bytecode
@@ -238,15 +239,15 @@
 
         optimizer = CodeOptimizer(symbol_table=self.symbol_table)
         optimizer.optimize(optimization_level)
 
         return VMCodeMapping.instance().result()
 
     @property
-    def last_code(self) -> Optional[VMCode]:
+    def last_code(self) -> VMCode | None:
         """
         Gets the last code in the bytecode
 
         :return: the last code. If the bytecode is empty, returns None
         :rtype: VMCode or None
         """
         if len(VMCodeMapping.instance().codes) > 0:
@@ -264,19 +265,22 @@
         Gets the size of the stack
 
         :return: the size of the stack of converted values
         """
         return len(self._stack)
 
     def _stack_append(self, value_type: IType):
-        self._stack_states.append(value_type, self.last_code)
+        self._stack_states.append(self.last_code, value_type)
 
     def _stack_pop(self, index: int = -1) -> IType:
         return self._stack_states.pop(self.last_code, index)
 
+    def _stack_reverse(self, start: int = 0, end: int = None, *, rotate: bool = False) -> IType:
+        return self._stack_states.reverse(self.last_code, start, end, rotate=rotate)
+
     @property
     def last_code_start_address(self) -> int:
         """
         Gets the first address from last code in the bytecode
 
         :return: the last code's first address
         """
@@ -292,40 +296,40 @@
         Gets the current bytecode size
 
         :return: the current bytecode size
         """
         return VMCodeMapping.instance().bytecode_size
 
     @property
-    def _args(self) -> List[str]:
+    def _args(self) -> list[str]:
         """
         Gets a list with the arguments names of the current method
 
         :return: A list with the arguments names
         """
         return [] if self._current_method is None else list(self._current_method.args.keys())
 
     @property
-    def _locals(self) -> List[str]:
+    def _locals(self) -> list[str]:
         """
         Gets a list with the variables names in the scope of the current method
 
         :return: A list with the variables names
         """
         return [] if self._current_method is None else list(self._current_method.locals.keys())
 
     @property
-    def _globals(self) -> List[str]:
+    def _globals(self) -> list[str]:
         return self._module_variables(True)
 
     @property
-    def _statics(self) -> List[str]:
+    def _statics(self) -> list[str]:
         return self._module_variables(False)
 
-    def _module_variables(self, modified_variable: bool) -> List[str]:
+    def _module_variables(self, modified_variable: bool) -> list[str]:
         """
         Gets a list with the variables name in the global scope
 
         :return: A list with the variables names
         """
         if modified_variable:
             vars_map = self._global_vars
@@ -447,15 +451,15 @@
         Checks whether the last insertion is null
 
         :return: whether the last value is null
         """
         return (self.last_code.opcode is Opcode.PUSHNULL or
                 (len(self._stack) > 0 and self._stack[-1] is Type.none))
 
-    def get_symbol(self, identifier: str, scope: Optional[ISymbol] = None, is_internal: bool = False) -> Tuple[str, ISymbol]:
+    def get_symbol(self, identifier: str, scope: ISymbol | None = None, is_internal: bool = False) -> tuple[str, ISymbol]:
         """
         Gets a symbol in the symbol table by its id
 
         :param identifier: id of the symbol
         :return: the symbol if exists. Symbol None otherwise
         """
         cur_symbol_table = self.symbol_table.copy()
@@ -572,15 +576,15 @@
         method.init_address = VMCodeMapping.instance().bytecode_size
         if num_args > 0 or num_vars > 0:
             init_data = bytearray([num_vars, num_args])
             self.__insert1(OpcodeInfo.INITSLOT, init_data)
             method.init_bytecode = self.last_code
         self._current_method = method
 
-    def convert_end_method(self, method_id: Optional[str] = None):
+    def convert_end_method(self, method_id: str | None = None):
         """
         Converts the end of the method
         """
         if (self._current_method.init_bytecode is None
                 and self._current_method.init_address in VMCodeMapping.instance().code_map):
             self._current_method.init_bytecode = VMCodeMapping.instance().code_map[self._current_method.init_address]
 
@@ -821,15 +825,15 @@
         :return: the address of the try first opcode
         """
         # it will be updated when the while ends
         self.__insert_code(TryCode())
 
         return self.last_code_start_address
 
-    def convert_try_except(self, exception_id: Optional[str]) -> int:
+    def convert_try_except(self, exception_id: str | None) -> int:
         """
         Converts the end of the try statement
 
         :param exception_id: the name identifier of the exception
         :type exception_id: str or None
 
         :return: the last address from try body
@@ -840,16 +844,16 @@
         self._stack_append(Type.exception)  # when reaching the except body, an exception was raised
         if exception_id is None:
             self.remove_stack_top_item()
 
         return last_try_code
 
     def convert_end_try(self, start_address: int,
-                        end_address: Optional[int] = None,
-                        else_address: Optional[int] = None) -> int:
+                        end_address: int | None = None,
+                        else_address: int | None = None) -> int:
         """
         Converts the end of the try statement
 
         :param start_address: the address of the try first opcode
         :param end_address: the address of the try last opcode. If it is None, there's no except body.
         :param else_address: the address of the try else. If it is None, there's no else body.
         :return: the last address of the except body
@@ -1552,16 +1556,16 @@
         elif top_stack_item is StackItemType.Map:
             self.convert_builtin_method_call(Builtin.DictKeys)
         else:
             return
 
         self.convert_cast(Type.tuple)
 
-    def convert_load_symbol(self, symbol_id: str, params_addresses: List[int] = None, is_internal: bool = False,
-                            class_type: Optional[UserClass] = None):
+    def convert_load_symbol(self, symbol_id: str, params_addresses: list[int] = None, is_internal: bool = False,
+                            class_type: UserClass | None = None):
         """
         Converts the load of a symbol
 
         :param symbol_id: the symbol identifier
         :param params_addresses: a list with each function arguments' first addresses
         """
         another_symbol_id, symbol = self.get_symbol(symbol_id, is_internal=is_internal)
@@ -1600,15 +1604,15 @@
             var = variable_list[var_id]
             index = list(variable_list).index(var_id)
             self.convert_literal(index)
             self.convert_get_item(index_inserted_internally=True)
             self._stack_pop()  # pop class type
             self._stack_append(var.type)  # push variable type
 
-    def convert_load_variable(self, var_id: str, var: Variable, class_type: Optional[UserClass] = None):
+    def convert_load_variable(self, var_id: str, var: Variable, class_type: UserClass | None = None):
         """
         Converts the assignment of a variable
 
         :param var_id: the value to be converted
         :param var: the actual variable to be loaded
         """
         index, local, is_arg = self._get_variable_info(var_id)
@@ -1711,15 +1715,15 @@
         builtin_method = Interop.StorageGet if is_get else Interop.StoragePut
         self.convert_builtin_method_call(builtin_method)
 
         if is_get:
             # once the value is retrieved, it must be deserialized
             self.convert_builtin_method_call(Interop.Deserialize, addresses)
 
-    def _get_variable_info(self, var_id: str) -> Tuple[int, bool, bool]:
+    def _get_variable_info(self, var_id: str) -> tuple[int, bool, bool]:
         """
         Gets the necessary information about the variable to get the correct opcode
 
         :param var_id: the name id of the
         :return: returns the index of the variable in its scope and two boolean variables for representing the
         variable scope:
             `local` is True if it is a local variable and
@@ -1744,15 +1748,15 @@
         if scope is not None:
             index: int = scope.index(var_id) if var_id in scope else -1
         else:
             index = -1
 
         return index, local, is_arg
 
-    def convert_builtin_method_call(self, function: IBuiltinMethod, args_address: List[int] = None, is_internal: bool = False):
+    def convert_builtin_method_call(self, function: IBuiltinMethod, args_address: list[int] = None, is_internal: bool = False):
         """
         Converts a builtin method function call
 
         :param function: the function to be converted
         :param args_address: a list with each function arguments' first addresses
         :param is_internal: whether it was called when generating other implemented symbols
         """
@@ -1897,15 +1901,15 @@
             self.convert_literal(event.name)
         else:
             self.swap_reverse_stack_items(2)
 
         from boa3.internal.model.builtin.interop.interop import Interop
         self._convert_builtin_call(Interop.Notify, is_internal=True)
 
-    def convert_class_symbol(self, class_type: ClassType, symbol_id: str, load: bool = True) -> Optional[int]:
+    def convert_class_symbol(self, class_type: ClassType, symbol_id: str, load: bool = True) -> int | None:
         """
         Converts an class symbol
 
         :param class_type:
         :param symbol_id:
         :param load:
         """
@@ -1933,15 +1937,15 @@
 
             if is_safe_to_convert:
                 self.convert_builtin_method_call(method)
         else:
             self.convert_method_call(method, 0)
         return symbol_id
 
-    def convert_user_class(self, class_type: UserClass, symbol_id: str) -> Optional[int]:
+    def convert_user_class(self, class_type: UserClass, symbol_id: str) -> int | None:
         """
         Converts an class symbol
 
         :param class_type:
         :param symbol_id:
         """
         start_address = self.bytecode_size
@@ -2068,15 +2072,15 @@
         if len(self._stack) == 0:
             self.convert_literal(Builtin.Exception.default_message)
 
         self._stack_pop()
         self.__insert1(OpcodeInfo.THROW)
 
     def insert_opcode(self, opcode: Opcode, data: bytes = None,
-                      add_to_stack: List[IType] = None, pop_from_stack: bool = False):
+                      add_to_stack: list[IType] = None, pop_from_stack: bool = False):
         """
         Inserts one opcode into the bytecode. Used to generate built-in symbols.
 
         :param opcode: info of the opcode  that will be inserted
         :param data: data of the opcode, if needed
         :param add_to_stack: expected data to be included on stack, if needed
         :param pop_from_stack: if needs to update stack given opcode stack items
@@ -2088,15 +2092,15 @@
                 for _ in range(op_info.stack_items):
                     self._stack_pop()
 
         if isinstance(add_to_stack, list):
             for stack_item in add_to_stack:
                 self._stack_append(stack_item)
 
-    def insert_type_check(self, type_to_check: Optional[StackItemType]):
+    def insert_type_check(self, type_to_check: StackItemType | None):
         if isinstance(type_to_check, StackItemType):
             self.__insert1(OpcodeInfo.ISTYPE, type_to_check)
         else:
             self.__insert1(OpcodeInfo.ISNULL)
         self._stack_pop()
         self._stack_append(Type.bool)
 
@@ -2237,15 +2241,15 @@
                 for code in vmcodes.copy():
                     code.set_target(VMCodeMapping.instance().get_code(target))
                     vmcodes.remove(code)
 
             if len(vmcodes) == 0:
                 self._missing_target.pop(target)
 
-    def _insert_jump(self, op_info: OpcodeInformation, jump_to: Union[int, VMCode] = 0, insert_jump: bool = False):
+    def _insert_jump(self, op_info: OpcodeInformation, jump_to: int | VMCode = 0, insert_jump: bool = False):
         """
         Inserts a jump opcode into the bytecode
 
         :param op_info: info of the opcode  that will be inserted
         :param jump_to: data of the opcode
         :param insert_jump: whether it should be included a jump to the end before the else branch
         """
@@ -2381,15 +2385,15 @@
                 self.convert_literal(pos - 1)
                 self._stack_pop()
             op_info = OpcodeInfo.get_info(opcode)
             self.__insert1(op_info)
             if pos > 0 and len(self._stack) > 0:
                 self._stack_pop(-pos)
 
-    def _remove_inserted_opcodes_since(self, last_address: int, last_stack_size: Optional[int] = None):
+    def _remove_inserted_opcodes_since(self, last_address: int, last_stack_size: int | None = None):
         self._stack_states.restore_state(last_address)
         if VMCodeMapping.instance().bytecode_size > last_address:
             # remove opcodes inserted during the evaluation of the symbol
             VMCodeMapping.instance().remove_opcodes(last_address, VMCodeMapping.instance().bytecode_size)
 
         if isinstance(last_stack_size, int) and last_stack_size < self.stack_size:
             # remove any additional values pushed to the stack during the evalution of the symbol
@@ -2403,15 +2407,15 @@
             if opcode is Opcode.REVERSEN and no_items > 0:
                 self.convert_literal(no_items)
             op_info = OpcodeInfo.get_info(opcode)
             self.__insert1(op_info)
             if opcode is Opcode.REVERSEN and no_items > 0:
                 self._stack_pop()
             if no_items > 0:
-                self._stack.reverse(-no_items, rotate=rotate)
+                self._stack_reverse(-no_items, rotate=rotate)
 
     def convert_init_user_class(self, class_type: ClassType):
         if isinstance(class_type, UserClass):
             # create an none-filled array with the size of the instance variables
             no_instance_variables = len(class_type.instance_variables)
             self.convert_new_empty_array(no_instance_variables, class_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/codegeneratorvisitor.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/codegeneratorvisitor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,10 @@
 import ast
 import os.path
 from inspect import isclass
-from typing import Dict, List, Optional
 
 from boa3.internal import constants
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.compiler.codegenerator.codegenerator import CodeGenerator
 from boa3.internal.compiler.codegenerator.generatordata import GeneratorData
 from boa3.internal.compiler.codegenerator.variablegenerationdata import VariableGenerationData
 from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
@@ -37,43 +36,43 @@
     :ivar generator:
     """
 
     def __init__(self, generator: CodeGenerator, filename: str = None, root: str = None):
         super().__init__(ast.parse(""), filename=filename, root_folder=root, log=True, fail_fast=True)
 
         self.generator = generator
-        self.current_method: Optional[Method] = None
-        self.current_class: Optional[UserClass] = None
+        self.current_method: Method | None = None
+        self.current_class: UserClass | None = None
         self.symbols = generator.symbol_table
 
-        self.global_stmts: List[ast.AST] = []
+        self.global_stmts: list[ast.AST] = []
         self._is_generating_initialize = False
         self._root_module: ast.AST = self._tree
 
     @property
-    def _symbols(self) -> Dict[str, ISymbol]:
+    def _symbols(self) -> dict[str, ISymbol]:
         symbol_table = self.symbols.copy()
 
         if isinstance(self.current_class, UserClass):
             symbol_table.update(self.current_class.symbols)
 
         return symbol_table
 
     def include_instruction(self, node: ast.AST, address: int):
         if self.current_method is not None and address in VMCodeMapping.instance().code_map:
             bytecode = VMCodeMapping.instance().code_map[address]
             from boa3.internal.model.debuginstruction import DebugInstruction
             self.current_method.include_instruction(DebugInstruction.build(node, bytecode))
 
-    def build_data(self, origin_node: Optional[ast.AST],
-                   symbol_id: Optional[str] = None,
-                   symbol: Optional[ISymbol] = None,
-                   result_type: Optional[IType] = None,
-                   index: Optional[int] = None,
-                   origin_object_type: Optional[ISymbol] = None,
+    def build_data(self, origin_node: ast.AST | None,
+                   symbol_id: str | None = None,
+                   symbol: ISymbol | None = None,
+                   result_type: IType | None = None,
+                   index: int | None = None,
+                   origin_object_type: ISymbol | None = None,
                    already_generated: bool = False) -> GeneratorData:
 
         if isinstance(symbol, IType) and result_type is None:
             result_type = symbol
             symbol = None
 
         if symbol is None and symbol_id is not None:
@@ -167,15 +166,15 @@
             return False
         if self.current_method and (variable_id in self.current_method.args
                                     or variable_id in self.current_method.locals):
             return False
 
         return variable_id in self.symbols
 
-    def _remove_inserted_opcodes_since(self, last_address: int, last_stack_size: Optional[int] = None):
+    def _remove_inserted_opcodes_since(self, last_address: int, last_stack_size: int | None = None):
         self.generator._remove_inserted_opcodes_since(last_address, last_stack_size)
 
     def _get_unique_name(self, name_id: str, node: ast.AST) -> str:
         return '{0}{2}{1}'.format(node.__hash__(), name_id, constants.VARIABLE_NAME_SEPARATOR)
 
     def set_filename(self, filename: str):
         if isinstance(filename, str) and os.path.isfile(filename):
@@ -438,15 +437,15 @@
 
     def visit_Assign(self, assign: ast.Assign) -> GeneratorData:
         """
         Visitor of an assignment node
 
         :param assign: the python ast variable assignment node
         """
-        vars_ids: List[VariableGenerationData] = []
+        vars_ids: list[VariableGenerationData] = []
         for target in assign.targets:
             var_value_address = self.generator.bytecode_size
             target_data: GeneratorData = self.visit(target)
 
             var_id = target_data.symbol_id
             var_index = target_data.index
 
@@ -515,27 +514,27 @@
         :param subscript: the python ast subscript node
         """
         index = None
         symbol_id = None
         if isinstance(subscript.ctx, ast.Load):
             # get item
             value_data = self.visit_to_generate(subscript.value)
-            slice = subscript.slice.value if isinstance(subscript.slice, ast.Index) else subscript.slice
+            slice = subscript.slice
             self.visit_to_generate(slice)
 
             index_is_constant_number = isinstance(slice, ast.Num) and isinstance(slice.n, int)
             self.generator.convert_get_item(index_is_positive=(index_is_constant_number and slice.n >= 0),
                                             test_is_negative_index=not (index_is_constant_number and slice.n < 0))
 
             value_type = value_data.type
         else:
             # set item
             var_data = self.visit(subscript.value)
 
-            index = subscript.slice.value if isinstance(subscript.slice, ast.Index) else subscript.slice
+            index = subscript.slice
             symbol_id = var_data.symbol_id
             value_type = var_data.type
 
         result_type = value_type.item_type if isinstance(value_type, SequenceType) else value_type
         return self.build_data(subscript, result_type=result_type,
                                symbol_id=symbol_id, index=index)
 
@@ -868,15 +867,15 @@
         if not isinstance(symbol, Method):
             is_internal = hasattr(call, 'is_internal_call') and call.is_internal_call
             _, symbol = self.generator.get_symbol(function_id, is_internal=is_internal)
 
         if self.is_implemented_class_type(symbol):
             self.generator.convert_init_user_class(symbol)
             symbol = symbol.constructor_method()
-        args_addresses: List[int] = []
+        args_addresses: list[int] = []
 
         has_cls_or_self_argument = isinstance(symbol, Method) and symbol.has_cls_or_self
         if not has_cls_or_self_argument:
             self._remove_inserted_opcodes_since(last_address, last_stack)
 
         if isinstance(symbol, Method):
             # self or cls is already generated
@@ -956,15 +955,15 @@
     def visit_Try(self, try_node: ast.Try) -> GeneratorData:
         """
         Visitor of the try node
 
         :param try_node: the python ast try node
         """
         try_address: int = self.generator.convert_begin_try()
-        try_end: Optional[int] = None
+        try_end: int | None = None
         for stmt in try_node.body:
             self.visit_to_map(stmt, generate=True)
 
         if len(try_node.handlers) == 1:
             handler = try_node.handlers[0]
             try_end = self.generator.convert_try_except(handler.name)
             for stmt in handler.body:
@@ -1299,15 +1298,15 @@
 
         if isinstance(self.current_method, Method):
             self.generator.insert_nop()
             generated = True
 
         return self.build_data(pass_node, result_type=result_type, already_generated=generated)
 
-    def _create_array(self, values: List[ast.AST], array_type: IType):
+    def _create_array(self, values: list[ast.AST], array_type: IType):
         """
         Creates a new array from a literal sequence
 
         :param values: list of values of the new array items
         """
         length = len(values)
         if length > 0:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/codeoptimizer.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/codeoptimizer.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/executionscript.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/executionscript.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,12 @@
-from __future__ import annotations
-
 __all__ = [
     'ExecutionScript'
 ]
 
+from typing import Self
 
 from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
 from boa3.internal.neo.vm.VMCode import VMCode
 from boa3.internal.neo3.contracts.nef import MethodToken
 
 
 class ExecutionScript:
@@ -17,15 +16,15 @@
 
         self._last_address = self._addresses[-1] if len(self._addresses) else -1
         self._last_instruction_size = self._instructions[-1].size if len(self._instructions) else 0
 
         self._tokens = tokens
 
     @classmethod
-    def from_code_map(cls, instance: VMCodeMapping) -> ExecutionScript:
+    def from_code_map(cls, instance: VMCodeMapping) -> Self:
         obj = ExecutionScript(instance.code_map, instance._method_tokens.to_list())
         return obj
 
     def get_instruction(self, address) -> VMCode:
         if address not in self._addresses:
             raise IndexError
         index = self._addresses.index(address)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/istack.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/istack.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,42 +1,40 @@
-from __future__ import annotations
-
 import abc
-from typing import TypeVar, Union, Type
+from typing import TypeVar, Self
 
 T = TypeVar("T")
 
 
 class IStack(abc.ABC):
-    def __init__(self, stack_type: Type[T]):
+    def __init__(self, stack_type: type[T]):
         self._stack_type = stack_type
         self._stack: list[T] = []
 
     @abc.abstractmethod
     def _default_constructor_args(self) -> tuple:
         return (self._stack_type,)
 
     def append(self, value: T):
         return self._stack.append(value)
 
     def clear(self):
         return self._stack.clear()
 
-    def copy(self) -> IStack:
+    def copy(self) -> Self:
         new_stack = self.__class__(*self._default_constructor_args())
         new_stack._stack = self._stack.copy()
         return new_stack
 
     def pop(self, index: int) -> T:
         return self._stack.pop(index)
 
     def __len__(self) -> int:
         return len(self._stack)
 
-    def __getitem__(self, index_or_slice: Union[int, slice]):
+    def __getitem__(self, index_or_slice: int | slice):
         return self._stack[index_or_slice]
 
     def reverse(self, start: int = 0, end: int = None, *, rotate: bool = False):
         if end is None:
             end = len(self._stack)
 
         if rotate:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/neoengine.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/neoengine.py`

 * *Files 1% similar despite different names*

```diff
@@ -74,10 +74,10 @@
             self._state_stack.clear()
 
         return executed_instructions_addresses
 
     def _execute_instruction(self, current_opcode: VMCode):
         match current_opcode.opcode:
             case Opcode.INITSLOT | Opcode.INITSSLOT:
-                print()
+                return
             case Opcode.RET:
                 self._state_stack.pop()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/engine/stackmemento.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/engine/stackmemento.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,34 +1,38 @@
-from __future__ import annotations
-
 __all__ = [
     'StackMemento',
     'NeoStack'
 ]
 
-
-from typing import Dict, List, Tuple
-
 from boa3.internal.compiler.codegenerator.engine.istack import IStack
 from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.VMCode import VMCode
 
 
+class NeoStack(IStack):
+    def __init__(self):
+        from boa3.internal.model.type.itype import IType
+        super().__init__(stack_type=IType)
+
+    def _default_constructor_args(self) -> tuple:
+        return tuple()
+
+
 class StackMemento:
     """
     This class is responsible for managing the simulation of the blockchain stack during the code generation
     """
 
     def __init__(self):
-        self._stacks: List[Tuple[VMCode, NeoStack]] = []
+        self._stacks: list[tuple[VMCode, NeoStack]] = []
         self._current_stack: NeoStack = NeoStack()
 
     @property
-    def stack_map(self) -> Dict[int, NeoStack]:
+    def stack_map(self) -> dict[int, NeoStack]:
         vm_code_mapping = VMCodeMapping.instance()
         return {vm_code_mapping.get_start_address(vmcode): stack for vmcode, stack in self._stacks}
 
     def get_state(self, code_address: int) -> NeoStack:
         stacks = self.stack_map
         index = None
         for address, stack in sorted(stacks.items()):
@@ -56,15 +60,15 @@
             vm_code = VMCodeMapping.instance().get_code(address)
             if (vm_code, stack) in self._stacks:
                 self._stacks.remove((vm_code, stack))
 
         if latest_stack is not None:
             self._current_stack = latest_stack
 
-    def append(self, value: IType, code: VMCode):
+    def append(self, code: VMCode, value: IType):
         states = self.stack_map
         index = VMCodeMapping.instance().get_start_address(code)
         if index in states:
             states[index].append(value)
 
         else:
             if self._current_stack is not None:
@@ -89,15 +93,22 @@
 
             self._stacks.append((code, stack))
             self._current_stack = stack
 
         if len(stack) > 0:
             return stack.pop(index)
 
+    def reverse(self, code: VMCode, start: int = 0, end: int = None, *, rotate: bool = False):
+        states = self.stack_map
+        stack_index = VMCodeMapping.instance().get_start_address(code)
+        if stack_index in states:
+            stack = states[stack_index]
+        else:
+            if self._current_stack is not None:
+                stack = self._current_stack.copy()
+            else:
+                stack = NeoStack()
 
-class NeoStack(IStack):
-    def __init__(self):
-        from boa3.internal.model.type.itype import IType
-        super().__init__(stack_type=IType)
+            self._stacks.append((code, stack))
+            self._current_stack = stack
 
-    def _default_constructor_args(self) -> tuple:
-        return tuple()
+        return stack.reverse(start, end, rotate=rotate)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/initstatementsvisitor.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/initstatementsvisitor.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Dict, List, Tuple
 
 from boa3.internal import constants
 from boa3.internal.analyser.astanalyser import IAstAnalyser
 from boa3.internal.model.symbol import ISymbol
 
 
 class InitStatementsVisitor(IAstAnalyser):
@@ -12,25 +11,25 @@
     from the '_initialize' internal method.
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
 
     """
 
-    def __init__(self, symbols: Dict[str, ISymbol], fail_fast: bool = True):
+    def __init__(self, symbols: dict[str, ISymbol], fail_fast: bool = True):
         super().__init__(ast.parse(""), log=True, fail_fast=fail_fast)
         self.symbols = symbols.copy()
 
-        self._deploy_instructions: List[ast.AST] = []
-        self._init_instructions: List[ast.AST] = []
+        self._deploy_instructions: list[ast.AST] = []
+        self._init_instructions: list[ast.AST] = []
 
     @classmethod
     def separate_global_statements(cls,
-                                   symbol_table: Dict[str, ISymbol],
-                                   statements: List[ast.AST]) -> Tuple[List[ast.AST], List[ast.AST]]:
+                                   symbol_table: dict[str, ISymbol],
+                                   statements: list[ast.AST]) -> tuple[list[ast.AST], list[ast.AST]]:
 
         visitor = InitStatementsVisitor(symbol_table)
 
         root_ast = ast.parse("")
         root_ast.body = statements
         visitor.visit(root_ast)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/methodtokencollection.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/methodtokencollection.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,22 +1,20 @@
-from typing import List, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.type import Type
 from boa3.internal.neo3.contracts import CallFlags
 from boa3.internal.neo3.contracts.nef import MethodToken
 from boa3.internal.neo3.core import types
 
 
 class MethodTokenCollection:
     def __init__(self):
-        self._method_tokens: List[MethodToken] = []
-        self._called_builtins: List[IBuiltinMethod] = []
+        self._method_tokens: list[MethodToken] = []
+        self._called_builtins: list[IBuiltinMethod] = []
 
-    def append(self, contract_method: IBuiltinMethod, call_flag: CallFlags = CallFlags.ALL) -> Optional[int]:
+    def append(self, contract_method: IBuiltinMethod, call_flag: CallFlags = CallFlags.ALL) -> int | None:
         method_token_id = self._try_get_index(contract_method, call_flag)
         if method_token_id is None and hasattr(contract_method, 'contract_script_hash'):
             method_token = MethodToken(hash=types.UInt160(contract_method.contract_script_hash),
                                        method=contract_method.external_name,
                                        parameters_count=(contract_method.internal_call_args
                                                          if hasattr(contract_method, 'internal_call_args')
                                                          else len(contract_method.args)),
@@ -41,15 +39,15 @@
         # reset the opcodes to ensure the correct output when calling consecutive compilations
         for method in self._called_builtins:
             method.reset()
 
         self._called_builtins.clear()
         return self._method_tokens.clear()
 
-    def _try_get_index(self, contract_method: IBuiltinMethod, call_flag: CallFlags = CallFlags.ALL) -> Optional[int]:
+    def _try_get_index(self, contract_method: IBuiltinMethod, call_flag: CallFlags = CallFlags.ALL) -> int | None:
         if not hasattr(contract_method, 'contract_script_hash'):
             return None
 
         parameters_count = (contract_method.internal_call_args
                             if hasattr(contract_method, 'internal_call_args')
                             else len(contract_method.args))
 
@@ -57,15 +55,15 @@
                                    if (token.hash.to_array() == contract_method.contract_script_hash
                                        and token.method == contract_method.external_name
                                        and token.parameters_count == parameters_count
                                        and token.has_return_value == (contract_method.return_type is not Type.none)
                                        and token.call_flags == call_flag)), None)
         return method_token_index
 
-    def to_list(self) -> List[MethodToken]:
+    def to_list(self) -> list[MethodToken]:
         return self._method_tokens.copy()
 
     def __getitem__(self, item):
         if isinstance(item, int) and len(self._method_tokens) > item:
             return self._method_tokens[item]
         else:
             return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/optimizerhelper.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/optimizerhelper.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/vmcodemap.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/vmcodemap.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,35 +1,33 @@
-from typing import List, Dict, Optional
-
 from boa3.internal.neo.vm.VMCode import VMCode
 
 
 class VMCodeMap:
     def __init__(self):
-        self._vm_code_list: List[VMCode] = []
-        self._vm_code_addresses: List[int] = []
+        self._vm_code_list: list[VMCode] = []
+        self._vm_code_addresses: list[int] = []
 
         # optimization so it's not needed to iterate over everything in search of targets
-        self._vm_code_with_target: List[VMCode] = []
+        self._vm_code_with_target: list[VMCode] = []
 
     def __len__(self) -> int:
         return self._vm_code_list.__len__()
 
     def clear(self):
         self._vm_code_addresses.clear()
         self._vm_code_list.clear()
 
-    def get_code_map(self) -> Dict[int, VMCode]:
+    def get_code_map(self) -> dict[int, VMCode]:
         size = len(self)
         return {self._vm_code_addresses[index]: self._vm_code_list[index] for index in range(size)}
 
-    def get_code_list(self) -> List[VMCode]:
+    def get_code_list(self) -> list[VMCode]:
         return self._vm_code_list
 
-    def get_code_with_target_list(self) -> List[VMCode]:
+    def get_code_with_target_list(self) -> list[VMCode]:
         return self._vm_code_with_target
 
     def get_bytecode_size(self) -> int:
         if len(self) < 1:
             return 0
 
         return self._vm_code_addresses[-1] + self._vm_code_list[-1].size
@@ -38,15 +36,15 @@
         if vm_code not in self._vm_code_list:
             self._vm_code_addresses.append(self.get_bytecode_size())
             self._vm_code_list.append(vm_code)
 
             if has_target:
                 self._vm_code_with_target.append(vm_code)
 
-    def get_code(self, address: int) -> Optional[VMCode]:
+    def get_code(self, address: int) -> VMCode | None:
         try:
             index = self._vm_code_addresses.index(address)
         except ValueError:
             # the address is not int the list
             if address >= self.get_bytecode_size():
                 # the address is not in the bytecode
                 return None
@@ -75,39 +73,39 @@
             if index == len(self._vm_code_list):
                 return self.get_bytecode_size()
             else:
                 return self._vm_code_addresses[index] - 1
         except ValueError:
             return 0
 
-    def get_addresses(self, start_address: int, end_address: int) -> List[int]:
+    def get_addresses(self, start_address: int, end_address: int) -> list[int]:
         if start_address > end_address:
             start_address, end_address = end_address, start_address
 
         addresses = []
         for address in range(start_address, end_address + 1):
             if address in self._vm_code_addresses:
                 addresses.append(address)
         return addresses
 
-    def get_addresses_from_codes(self, codes: List[VMCode]) -> List[int]:
+    def get_addresses_from_codes(self, codes: list[VMCode]) -> list[int]:
         if len(codes) < 1:
             return []
 
         addresses = []
         for vm_code in codes:
             try:
                 index = self._vm_code_list.index(vm_code)
                 addresses.append(self._vm_code_addresses[index])
             except ValueError:
                 continue
 
         return addresses
 
-    def get_opcodes(self, addresses: List[int]) -> List[VMCode]:
+    def get_opcodes(self, addresses: list[int]) -> list[VMCode]:
         codes = []
 
         for address in sorted(addresses):
             try:
                 index = self._vm_code_addresses.index(address)
                 codes.append(self._vm_code_list[index])
             except ValueError:
@@ -138,15 +136,15 @@
                     if index < len(self._vm_code_addresses):
                         self._vm_code_addresses[index] = next_address
                     else:
                         self._vm_code_addresses.append(next_address)
 
                 next_address += self._vm_code_list[index].size
 
-    def move_to_end(self, first_code_address: int, last_code_address: int) -> Optional[int]:
+    def move_to_end(self, first_code_address: int, last_code_address: int) -> int | None:
         if last_code_address < first_code_address:
             return
 
         if (len(self._vm_code_addresses) > 0 and
                 last_code_address == self._vm_code_addresses[-1]):
             # there's nothing to change if it's moving the all the codes
             return
@@ -168,15 +166,15 @@
             self._vm_code_list[first_index:] = (self._vm_code_list[last_index:] +
                                                 self._vm_code_list[first_index:last_index])
             self.update_addresses(first_code_address)
 
         index = self.get_bytecode_size()
         return index
 
-    def remove_opcodes_by_addresses(self, addresses: List[int]):
+    def remove_opcodes_by_addresses(self, addresses: list[int]):
         was_changed = False
         # reversed so we only need to update addresses once after all are removed
         for code_address in sorted(addresses, reverse=True):
             try:
                 index = self._vm_code_addresses.index(code_address)
                 code = self._vm_code_list.pop(index)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/codegenerator/vmcodemapping.py` & `neo3_boa-1.2.0/boa3/internal/compiler/codegenerator/vmcodemapping.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Dict, List, Optional, Union
+from typing import Self
 
 from boa3.internal.compiler.codegenerator.methodtokencollection import MethodTokenCollection
 from boa3.internal.compiler.codegenerator.vmcodemap import VMCodeMap
 from boa3.internal.compiler.compileroutput import CompilerOutput
 from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.neo.vm.VMCode import VMCode
 from boa3.internal.neo.vm.opcode import OpcodeHelper
@@ -12,15 +10,15 @@
 from boa3.internal.neo3.contracts.contracttypes import CallFlags
 
 
 class VMCodeMapping:
     """
     This class is responsible for managing the Neo VM instruction during the bytecode generation.
     """
-    _instance: VMCodeMapping = None
+    _instance: Self = None
 
     @classmethod
     def instance(cls):
         """
         :return: the singleton instance
         """
         if cls._instance is None:
@@ -36,15 +34,15 @@
         """
         Resets the map to the first state
         """
         if cls._instance is not None:
             cls._instance._code_map.clear()
             cls._instance._method_tokens.clear()
 
-    def add_method_token(self, method: IBuiltinMethod, call_flag: CallFlags) -> Optional[int]:
+    def add_method_token(self, method: IBuiltinMethod, call_flag: CallFlags) -> int | None:
         """
         Creates a new method token if the method call another contract and return its id.
         Otherwise, returns None
         """
         if hasattr(method, 'contract_script_hash'):
             return self._method_tokens.append(method, call_flag)
         return None
@@ -55,32 +53,32 @@
         Otherwise, returns None
 
         :rtype: boa3.internal.neo3.contracts.nef.MethodToken or None
         """
         return self._method_tokens[method_token_id]
 
     @property
-    def codes(self) -> List[VMCode]:
+    def codes(self) -> list[VMCode]:
         """
         Gets a list with the included vm codes
 
         :return: a list of vm codes ordered by its address in the bytecode
         """
         return self._code_map.get_code_list()
 
     @property
-    def code_map(self) -> Dict[int, VMCode]:
+    def code_map(self) -> dict[int, VMCode]:
         """
         Gets a dictionary that maps each vm code with its address.
 
         :return: a dictionary that maps each instruction with its address. The keys are ordered by the address.
         """
         return self._code_map.get_code_map()
 
-    def targeted_address(self) -> Dict[int, List[int]]:
+    def targeted_address(self) -> dict[int, list[int]]:
         """
         Gets a dictionary that maps each address to the opcodes that targets it
 
         :return: a dictionary that maps the targeted instructions to its source.
         """
         target_maps = {}
         for code in self._code_map.get_code_with_target_list():
@@ -119,25 +117,25 @@
     @property
     def bytecode_size(self) -> int:
         return self._code_map.get_bytecode_size()
 
     def insert_code(self, vm_code: VMCode):
         return self._code_map.insert_code(vm_code, has_target=OpcodeHelper.has_target(vm_code.opcode))
 
-    def get_code(self, address: int) -> Optional[VMCode]:
+    def get_code(self, address: int) -> VMCode | None:
         """
         Gets the VM Opcode at the given position
 
         :param address: the position of the opcode
         :return: the opcode if it exists. None otherwise
         :rtype: VMCode or None
         """
         return self._code_map.get_code(address)
 
-    def get_addresses(self, start_address: int, end_address: int) -> List[int]:
+    def get_addresses(self, start_address: int, end_address: int) -> list[int]:
         return self._code_map.get_addresses(start_address, end_address)
 
     def get_start_address(self, vm_code: VMCode) -> int:
         """
         Gets the vm code's first byte address
 
         :param vm_code: the instruction to get the address
@@ -150,15 +148,15 @@
         Gets the vm code's last byte address
 
         :param vm_code: the instruction to get the address
         :return: the vm code's last address if it's in the map. Otherwise, return's zero.
         """
         return self._code_map.get_end_address(vm_code)
 
-    def get_opcodes(self, addresses: List[int]) -> List[VMCode]:
+    def get_opcodes(self, addresses: list[int]) -> list[VMCode]:
         return self._code_map.get_opcodes(addresses)
 
     def update_vm_code(self, vm_code: VMCode, opcode: OpcodeInformation, data: bytes = bytes()):
         """
         Updates the information from an inserted code
 
         :param vm_code: code to be updated
@@ -217,15 +215,15 @@
 
                     self.update_vm_code(code, info)
                     if info.opcode == OpcodeHelper.get_larger_opcode(info.opcode):
                         # if it's the largest equivalent, it won't be updated anymore
                         instr_with_small_codes.remove(code)
             current_size = self.bytecode_size
 
-    def _validate_targets(self, code_or_address: Union[int, VMCode]):
+    def _validate_targets(self, code_or_address: int | VMCode):
         if isinstance(code_or_address, int):
             address = code_or_address
             code = self.get_code(address)
         else:
             code = code_or_address
             address = self.get_start_address(code)
 
@@ -256,15 +254,15 @@
         if not isinstance(last_code_address, int):
             last_code_address = self.bytecode_size
         addresses_to_remove = self._code_map.get_addresses(first_code_address, last_code_address)
         for address in addresses_to_remove:
             self._validate_targets(address)
         return self._code_map.remove_opcodes_by_addresses(addresses_to_remove)
 
-    def remove_opcodes_by_code(self, codes: List[VMCode]):
+    def remove_opcodes_by_code(self, codes: list[VMCode]):
         addresses_to_remove = self._code_map.get_addresses_from_codes(codes)
         for address in addresses_to_remove:
             self._validate_targets(address)
         return self._code_map.remove_opcodes_by_addresses(addresses_to_remove)
 
     def _remove_empty_targets(self):
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/compiledmetadata.py` & `neo3_boa-1.2.0/boa3/internal/compiler/compiledmetadata.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from __future__ import annotations
-
-from typing import Union
+from typing import Self
 
 from boa3.builtin.compile_time import NeoMetadata
 from boa3.internal import constants
 from boa3.internal.neo3.core.types import UInt160
 
 
 class CompiledMetadata:
     _instance = None
 
     @classmethod
-    def instance(cls) -> CompiledMetadata:
+    def instance(cls) -> Self:
         if cls._instance is None:
             cls._instance = cls()
         return cls._instance
 
     def __init__(self):
         self._metadata = NeoMetadata()
 
@@ -23,15 +21,15 @@
     def reset(cls):
         cls.instance()._metadata = NeoMetadata()
 
     @classmethod
     def set_current_metadata(cls, metadata: NeoMetadata):
         cls.instance()._metadata = metadata
 
-    def add_contract_permission(self, contract: Union[UInt160, bytes, str], method: str = None):
+    def add_contract_permission(self, contract: UInt160 | bytes | str, method: str = None):
         if isinstance(contract, bytes):
             contract = UInt160(contract)
         elif not isinstance(contract, UInt160):
             contract = UInt160.from_string(contract)
         contract_hex_script = str(contract)
         method_string = method if isinstance(method, str) and len(method) > 0 else constants.IMPORT_WILDCARD
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/compiler.py` & `neo3_boa-1.2.0/boa3/internal/compiler/compiler.py`

 * *Files 1% similar despite different names*

```diff
@@ -64,15 +64,15 @@
         logger.info(f'neo3-boa v{constants.BOA_VERSION}\tPython {constants.SYS_VERSION}')
         logger.info(f'Started compiling\t{filename}')
         self._change_log_level(log_level)
 
         self._entry_smart_contract = os.path.splitext(filename)[0]
 
         from boa3.internal.compiler.compiledmetadata import CompiledMetadata
-        from boa3.internal.model.imports.builtin import CompilerBuiltin
+        from boa3.internal.model.imports.compilerbuiltin import CompilerBuiltin
         CompilerBuiltin.reset()
         CompiledMetadata.reset()
 
         self._analyse(fullpath, root_folder, env, log, fail_fast)
         return self._compile(optimization_level)
 
     def compile_and_save(self, path: str, output_path: str, root_folder: str = None,
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/filegenerator/filegenerator.py` & `neo3_boa-1.2.0/boa3/internal/compiler/filegenerator/filegenerator.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import json
 import logging
 import os.path
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.analyser.analyser import Analyser
 from boa3.internal.compiler.compileroutput import CompilerOutput
 from boa3.internal.compiler.filegenerator.importdata import ImportData
 from boa3.internal.model.event import Event
 from boa3.internal.model.imports.importsymbol import BuiltinImport, Import
@@ -24,50 +24,50 @@
     """
     This class is responsible for generating the files.
     """
 
     def __init__(self, compiler_result: CompilerOutput, analyser: Analyser, entry_file: str):
         import os
         self._metadata = analyser.metadata
-        self._symbols: Dict[str, ISymbol] = analyser.symbol_table.copy()
+        self._symbols: dict[str, ISymbol] = analyser.symbol_table.copy()
 
         self._entry_file = entry_file
         self._entry_file_full_path = analyser.path.replace(os.sep, constants.PATH_SEPARATOR)
 
-        self._files: List[str] = [self._entry_file_full_path]
+        self._files: list[str] = [self._entry_file_full_path]
         self._nef: NefFile = NefFile(compiler_result.bytecode,
                                      source=self._metadata.source,
                                      method_tokens=compiler_result.method_tokens)
 
-        self.__all_imports: List[Import] = None
-        self._all_methods: Dict[str, Method] = None
-        self._all_static_vars: Dict[str, Variable] = None
+        self.__all_imports: list[Import] = None
+        self._all_methods: dict[str, Method] = None
+        self._all_static_vars: dict[str, Variable] = None
 
         self._inner_methods = None
         self._inner_events = None
 
     @property
-    def _public_methods(self) -> Dict[str, Method]:
+    def _public_methods(self) -> dict[str, Method]:
         """
         Gets a sublist of the symbols containing all public methods
 
         :return: a dictionary that maps each public method with its identifier
         """
         return {name: method for name, method in self._methods.items() if method.is_public}
 
     @property
-    def _static_variables(self) -> Dict[str, Variable]:
+    def _static_variables(self) -> dict[str, Variable]:
         """
         Gets a sublist of the symbols containing all global variables
 
         :return: a dictionary that maps each global variable with its identifier
         """
         if self._all_static_vars is None:
-            variables: Dict[Tuple[str, str], Variable] = {}
-            imported_symbols: Dict[str, Import] = {}
+            variables: dict[tuple[str, str], Variable] = {}
+            imported_symbols: dict[str, Import] = {}
 
             for name, symbol in self._symbols.items():
                 if isinstance(symbol, Variable) and not symbol.is_reassigned:
                     variables[(self._entry_file, name)] = symbol
                 elif isinstance(symbol, Import):
                     imported_symbols[symbol.origin] = symbol
 
@@ -99,15 +99,15 @@
             else:
                 self._all_static_vars = {var_id: var
                                          for (unique_id, var_id), var in variables.items()}
 
         return self._all_static_vars
 
     @property
-    def _methods(self) -> Dict[str, Method]:
+    def _methods(self) -> dict[str, Method]:
         """
         Gets a sublist of the symbols containing all user methods
 
         :return: a dictionary that maps each method with its identifier
         """
         if self._inner_methods is None:
             from boa3.internal.model.builtin.method import IBuiltinMethod
@@ -122,20 +122,20 @@
                         if class_method.defined_by_entry:
                             all_entry_file_methods[f'{symbol.identifier}.{class_method_name}'] = class_method
 
             self._inner_methods = all_entry_file_methods
         return self._inner_methods
 
     @property
-    def _methods_with_imports(self) -> Dict[Tuple[str, str], Method]:
+    def _methods_with_imports(self) -> dict[tuple[str, str], Method]:
         if self._all_methods is None:
             from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinCallable
 
-            methods: Dict[Tuple[str, str], Method] = {}
-            imported_symbols: Dict[str, Import] = {symbol.origin: symbol for symbol in self._all_imports}
+            methods: dict[tuple[str, str], Method] = {}
+            imported_symbols: dict[str, Import] = {symbol.origin: symbol for symbol in self._all_imports}
 
             for name, symbol in self._symbols.items():
                 if isinstance(symbol, Method) and not isinstance(symbol, IBuiltinCallable):
                     if symbol.defined_by_entry:
                         methods[(self._entry_file, name)] = symbol
                 elif isinstance(symbol, UserClass):
                     for class_method_name, class_method in symbol.methods.items():
@@ -175,15 +175,15 @@
 
                             methods[(module_id, f'{symbol.identifier}.{class_method_name}')] = class_method
 
             self._all_methods = methods
         return self._all_methods
 
     @property
-    def _events(self) -> Dict[str, Event]:
+    def _events(self) -> dict[str, Event]:
         """
         Gets a sublist of the symbols containing all user events
 
         :return: a dictionary that maps each event with its identifier
         """
         if self._inner_events is None:
             events = set()
@@ -198,15 +198,15 @@
                         if isinstance(package_symbol, Event):
                             events.add(package_symbol)
 
             self._inner_events = {event.name: event for event in events}
         return self._inner_events
 
     @property
-    def _all_imports(self) -> List[Import]:
+    def _all_imports(self) -> list[Import]:
         if self.__all_imports is None:
             all_imports = [imported for imported in self._symbols.values()
                            if (isinstance(imported, (Import, Package))
                                and not isinstance(imported, BuiltinImport))]
             only_imports = []
             imported_files = []
 
@@ -290,19 +290,19 @@
 
     def generate_manifest_file(self) -> bytes:
         """
         Generates the .manifest metadata file
 
         :return: the resulting manifest as a byte array
         """
-        data: Dict[str, Any] = self._get_manifest_info()
+        data: dict[str, Any] = self._get_manifest_info()
         json_data: str = json.dumps(data, indent=4)
         return bytes(json_data, constants.ENCODING)
 
-    def _get_manifest_info(self) -> Dict[str, Any]:
+    def _get_manifest_info(self) -> dict[str, Any]:
         """
         Gets the manifest information in a dictionary format
 
         :return: a dictionary with the manifest information
         """
         return {
             "name": self._get_name(),
@@ -319,54 +319,54 @@
         """
         Gets the name of the contract, if name wasn't specified it will be the file name.
 
         :return: the contract name
         """
         return self._metadata.name if self._metadata.name else self._entry_file
 
-    def _get_permissions(self) -> List[Dict[str, Any]]:
+    def _get_permissions(self) -> list[dict[str, Any]]:
         """
         Gets the permission information in a dictionary format, if _metadata._permissions is empty, then consider it
         with the import wildcard inside it.
 
         :return: a dictionary with the permission information
         """
         return self._metadata.permissions
 
-    def _get_groups(self) -> List[Dict[str, Any]]:
+    def _get_groups(self) -> list[dict[str, Any]]:
         """
         Gets the group information in a dictionary format.
 
         :return: a dictionary with the groups information
         """
         return self._metadata.groups
 
-    def _get_abi_info(self) -> Dict[str, Any]:
+    def _get_abi_info(self) -> dict[str, Any]:
         """
         Gets the abi information in a dictionary format
 
         :return: a dictionary with the abi information
         """
         return {
             "methods": self._get_abi_methods(),
             "events": self._get_abi_events()
         }
 
-    def _get_abi_methods(self) -> List[Dict[str, Any]]:
+    def _get_abi_methods(self) -> list[dict[str, Any]]:
         """
         Gets the abi methods in a dictionary format
 
         :return: a dictionary with the abi methods
         """
         return [
             self._construct_abi_method(method_id, method)
             for method_id, method in self._public_methods.items()
         ]
 
-    def _construct_abi_method(self, method_id: str, method: Method) -> Dict[str, Any]:
+    def _construct_abi_method(self, method_id: str, method: Method) -> dict[str, Any]:
         from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
 
         abi_method_name = method.external_name if isinstance(method.external_name, str) else method_id
         logging.getLogger(constants.BOA_LOGGING_NAME).info(f"'{abi_method_name}' method included in the manifest")
 
         method_abi = {
             "name": abi_method_name,
@@ -381,15 +381,15 @@
         return_type_extension = self._construct_abi_type_hint(method.type, is_return_type=True)
         for return_type_name, return_type in return_type_extension.items():
             method_abi[return_type_name] = return_type
 
         return method_abi
 
     @staticmethod
-    def _construct_abi_type_hint(var_type: IType, var_id: Optional[str] = None, is_return_type: bool = False) -> Optional[Dict[str, Any]]:
+    def _construct_abi_type_hint(var_type: IType, var_id: str | None = None, is_return_type: bool = False) -> dict[str, Any] | None:
         """
         A recursive function that adds more details to some types on the manifest:
         - Arrays and Maps now have new keys to indicate the type of the items ('generic', 'generickey' and 'genericitem');
         - A String could have a 'hint' that it is an Address;
         - A Hash160 could have a 'hint' that it is a Scripthash or ScripthashLittleEndian;
         - A Hash256 could have a 'hint' that it is a BlockHash or TransactionId;
         - A StorageContext could have a 'hint' that it is a StorageContext or InteropInterface;
@@ -424,15 +424,15 @@
 
         # Calls itself to discover the types inside the Union/Optional
         elif isinstance(var_type, UnionType):
 
             from boa3.internal.model.type.annotation.optionaltype import OptionalType
             if isinstance(var_type, OptionalType):
 
-                # if Optional is being used only with one type, e.g., Optional[Str], then don't consider it an Union
+                # if Optional is being used only with one type, e.g., Str | None, then don't consider it an Union
                 if len(var_type.optional_types) == 1:
                     extended_type = FileGenerator._construct_abi_type_hint(var_type.optional_types[0],
                                                                            is_return_type=is_return_type)
 
                 else:
                     extended_type[return_prefix + "union"] = [
                         FileGenerator._construct_abi_type_hint(union_type) for union_type in
@@ -456,15 +456,15 @@
             extended_type[return_prefix + "genericitem"] = FileGenerator._construct_abi_type_hint(var_type.item_type)
 
         if var_id is not None:
             extended_type[return_prefix + "name"] = var_id
 
         return extended_type
 
-    def _get_abi_events(self) -> List[Dict[str, Any]]:
+    def _get_abi_events(self) -> list[dict[str, Any]]:
         """
         Gets the abi events in a dictionary format
 
         :return: a dictionary with the abi events
         """
         return [
             {
@@ -474,15 +474,15 @@
                         "name": arg_id,
                         "type": arg.type.abi_type
                     } for arg_id, arg in event.args_to_generate.items()
                 ],
             } for name, event in self._events.items() if event.is_called
         ]
 
-    def _get_extras(self) -> Optional[Dict[str, Any]]:
+    def _get_extras(self) -> dict[str, Any] | None:
         """
         Gets the abi information in a dictionary format
 
         :return: a dictionary with the abi information
         """
         extras = {}
         for key, value in self._metadata.extras.items():
@@ -500,34 +500,34 @@
 
     def generate_nefdbgnfo_file(self) -> bytes:
         """
         Generates a debug map for NEO debugger
 
         :return: the resulting map as a byte array
         """
-        data: Dict[str, Any] = self._get_debug_info()
+        data: dict[str, Any] = self._get_debug_info()
         json_data: str = json.dumps(data, indent=4)
         return bytes(json_data, constants.ENCODING)
 
-    def _get_debug_info(self) -> Dict[str, Any]:
+    def _get_debug_info(self) -> dict[str, Any]:
         """
         Gets the debug information in a dictionary format
 
         :return: a dictionary with the debug information
         """
         return {
             "hash": self._nef_hash,
             "entrypoint": self._entry_file_full_path,
             "documents": self._files,
             "static-variables": self._get_debug_static_variables(),
             "methods": self._get_debug_methods(),
             "events": self._get_debug_events()
         }
 
-    def _get_debug_methods(self) -> List[Dict[str, Any]]:
+    def _get_debug_methods(self) -> list[dict[str, Any]]:
         """
         Gets the methods' debug information in a dictionary format
 
         :return: a dictionary with the methods' debug information
         """
         method_ids = []
         debug_methods = []
@@ -537,15 +537,15 @@
             dbg_id = dbg_method['id']
             if method.is_compiled and dbg_id not in method_ids:
                 method_ids.append(dbg_id)
                 debug_methods.append(dbg_method)
 
         return debug_methods
 
-    def _get_method_debug_info(self, module_id: str, method_id: str, method: Method) -> Dict[str, Any]:
+    def _get_method_debug_info(self, module_id: str, method_id: str, method: Method) -> dict[str, Any]:
         from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
         from boa3.internal.neo.vm.type.AbiType import AbiType
         from boa3.internal.model.type.itype import IType
 
         sequence_points = []
         for instruction in method.debug_map():
             vm_code_map = VMCodeMapping.instance()
@@ -574,15 +574,15 @@
             "sequence-points": sequence_points
         }
 
     def _get_method_origin_index(self, method: Method) -> int:
         if method.file_origin in self._files:
             return self._files.index(method.file_origin)
 
-        imported_files: List[Import] = [imported for imported in self._symbols.values()
+        imported_files: list[Import] = [imported for imported in self._symbols.values()
                                         if (isinstance(imported, Import)
                                             and not isinstance(imported, BuiltinImport)
                                             and imported.origin is not None)]
         imported = None
         for file in imported_files:
             if method in file.all_symbols.values():
                 imported = file
@@ -591,15 +591,15 @@
         if imported is None:
             return 0
         else:
             if imported.origin not in self._files:
                 self._files.append(imported.origin)
             return self._files.index(imported.origin)
 
-    def _get_debug_events(self) -> List[Dict[str, Any]]:
+    def _get_debug_events(self) -> list[dict[str, Any]]:
         """
         Gets the events' debug information in a dictionary format
 
         :return: a dictionary with the event's debug information
         """
         event_ids = []
         debug_events = []
@@ -615,15 +615,15 @@
             }
             if dbg_id not in event_ids:
                 event_ids.append(dbg_id)
                 debug_events.append(dbg_event)
 
         return debug_events
 
-    def _get_debug_static_variables(self) -> List[str]:
+    def _get_debug_static_variables(self) -> list[str]:
         """
         Gets the static variables' debug information in a dictionary format
 
         :return: a dictionary with the event's debug information
         """
         from boa3.internal.model.type.itype import IType
         from boa3.internal.neo.vm.type.AbiType import AbiType
@@ -645,15 +645,15 @@
             )
 
         return static_variables
 
     # endregion
 
     def _get_static_var_unique_name(self, variable_id) -> str:
-        imported_symbols: Dict[str, Import] = {symbol.origin: symbol for symbol in self._all_imports}
+        imported_symbols: dict[str, Import] = {symbol.origin: symbol for symbol in self._all_imports}
 
         for name, symbol in self._symbols.items():
             if isinstance(symbol, Import) and symbol.origin not in imported_symbols:
                 imported_symbols[symbol.origin] = symbol
 
         imported_to_map, imports_unique_ids = self._get_imports_unique_ids(imported_symbols,
                                                                            False,
@@ -676,23 +676,23 @@
         for index, imported in enumerate(imported_symbols.values()):
             if isinstance(imported, Import) and variable_original_id in imported.all_symbols:
                 if len(split_name) <= 1 or str(imported.ast.__hash__()) == split_name[0]:
                     return '{0}.{1}'.format(imports_unique_ids[index], variable_original_id)
 
         return '{0}.{1}'.format(imports_unique_ids[-1], variable_original_id)
 
-    def _get_static_var_slot_index(self, variable_id) -> Optional[int]:
+    def _get_static_var_slot_index(self, variable_id) -> int | None:
         module_globals = list(self._static_variables.keys())
         if variable_id in module_globals:
             return module_globals.index(variable_id)
         return None
 
-    def _get_imports_unique_ids(self, imported_symbols: Dict[str, Import],
+    def _get_imports_unique_ids(self, imported_symbols: dict[str, Import],
                                 importing_methods: bool,
-                                inner_imported_symbols: List[ISymbol] = None) -> Tuple[Dict[str, ImportData], List[str]]:
+                                inner_imported_symbols: list[ISymbol] = None) -> tuple[dict[str, ImportData], list[str]]:
         if not isinstance(imported_symbols, dict):
             return {}, []
         if not isinstance(inner_imported_symbols, list):
             inner_imported_symbols = []
 
         # must map all imports, including inner imports
         index = 0
@@ -700,15 +700,15 @@
             module_origin, imported = list(imported_symbols.items())[index]
             for name, inner_imported in imported.all_symbols.items():
                 if isinstance(inner_imported, Import) and inner_imported.origin not in inner_imported_symbols:
                     imported_symbols[inner_imported.origin] = inner_imported
             index += 1
 
         # map the modules that have user modules not imported by the entry file
-        imported_to_map: Dict[str, ImportData] = self._get_imports_to_map(imported_symbols, importing_methods)
+        imported_to_map: dict[str, ImportData] = self._get_imports_to_map(imported_symbols, importing_methods)
 
         # change the full path names to unique small names
         imports_paths = list(imported_to_map)
         imports_paths.append(self._entry_file_full_path.replace('.py', '').replace('/__init__', ''))
 
         imports_unique_ids = []
         imports_duplicated_ids = []
@@ -738,19 +738,19 @@
 
                 imports_unique_ids[index_of_duplicated] = dup_new_id
 
             imports_unique_ids.append(short_name)
 
         return imported_to_map, imports_unique_ids
 
-    def _get_imports_to_map(self, imported_symbols: Dict[str, Import],
-                            importing_methods: bool) -> Dict[str, ImportData]:
+    def _get_imports_to_map(self, imported_symbols: dict[str, Import],
+                            importing_methods: bool) -> dict[str, ImportData]:
 
-        imported_to_map: Dict[str, ImportData] = {}
-        inner_packages: List[Tuple[str, Package]] = []
+        imported_to_map: dict[str, ImportData] = {}
+        inner_packages: list[tuple[str, Package]] = []
 
         for name, imported in imported_symbols.items():
             need_to_map = False
             filtered_name = name.replace('.py', '').replace('/__init__', '')
 
             if not isinstance(imported, BuiltinImport):
                 for _, symbol in imported.all_symbols.items():
```

### Comparing `neo3-boa-1.1.1/boa3/internal/compiler/filegenerator/importdata.py` & `neo3_boa-1.2.0/boa3/internal/compiler/filegenerator/importdata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Dict
-
 from boa3.internal.model.symbol import ISymbol
 
 
 class ImportData:
     def __init__(self, import_symbol: ISymbol, origin_id: str, origin_file: str = None):
         self._imported_symbol = import_symbol
         self._origin_id = origin_id
@@ -20,15 +18,15 @@
         return None
 
     @property
     def origin_file(self) -> str:
         return self._origin_file
 
     @property
-    def all_symbols(self) -> Dict[str, ISymbol]:
+    def all_symbols(self) -> dict[str, ISymbol]:
         if hasattr(self._imported_symbol, 'all_symbols'):
             return self._imported_symbol.all_symbols
 
         if hasattr(self._imported_symbol, 'symbols'):
             return self._imported_symbol.symbols
 
         return {}
```

### Comparing `neo3-boa-1.1.1/boa3/internal/constants.py` & `neo3_boa-1.2.0/boa3/internal/constants.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 IMPORT_WILDCARD = '*'
 
 SYS_VERSION_INFO = sys.version_info
 SYS_VERSION = platform.python_version()
 BOA_VERSION = _actual_boa_version  # for logging only
 BOA_LOGGING_NAME = 'neo3-boa-log'
 COMPILER_VERSION = BOA_VERSION
-BOA_PACKAGE_PATH = os.path.abspath(f'{__file__}/..')
+BOA_PACKAGE_PATH = os.path.abspath(f'{__file__}/../..')
 DEFAULT_CONTRACT_ENVIRONMENT = 'mainnet'
 
 locale.setlocale(locale.LC_ALL, '')
 SYS_LOCALE = locale.localeconv()
 SYS_LOCALE_DECIMAL_POINT = SYS_LOCALE['decimal_point'] if 'decimal_point' in SYS_LOCALE else '.'
 
 ONE_BYTE_MAX_VALUE = 255
```

### Comparing `neo3-boa-1.1.1/boa3/internal/exception/CompilerError.py` & `neo3_boa-1.2.0/boa3/internal/exception/CompilerError.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from abc import ABC
-from typing import Iterable, Optional, Union
+from collections.abc import Iterable
 
 from boa3.internal import constants
 from boa3.internal.model.builtin.internal.internalmethod import IInternalMethod
 from boa3.internal.model.event import Event
 from boa3.internal.model.method import Method
 
 
@@ -11,25 +11,25 @@
     """
     An interface for compilation errors
     """
 
     def __init__(self, line: int, col: int):
         self.line: int = line
         self.col: int = col
-        self.filepath: Optional[str] = None
+        self.filepath: str | None = None
 
     @property
     def message(self) -> str:
         message = '' if self._error_message is None else ' - ' + self._error_message
         if isinstance(self.filepath, str):
             message += f'\t <{self.filepath}>'
         return '{0}:{1}{2}'.format(self.line, self.col, message)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return None
 
     def __str__(self) -> str:
         return self.message
 
     def __eq__(self, other) -> bool:
         if not isinstance(other, type(self)):
@@ -45,73 +45,73 @@
     def __init__(self, line: int, col: int, target_import: str, target_origin: str):
         import os
         self.target_import = target_import
         self.target_origin = target_origin.replace(os.sep, constants.PATH_SEPARATOR)
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Circular import with '%s' ('%s')" % (self.target_import, self.target_origin)
 
 
 class DuplicatedIdentifier(CompilerError):
     """
     An error raised when more than one symbol uses the same identifier in the same scope and cannot be overwritten.
     """
 
     def __init__(self, line: int, col: int, duplicated_id: str = None):
         self._duplicated_id = duplicated_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return f"Duplicate identifier: '{self._duplicated_id}'"
 
 
 class DuplicatedManifestIdentifier(CompilerError):
     """
     An error raised when more than one symbol uses the same identifier in the manifest.
     """
 
     def __init__(self, line: int, col: int, duplicated_id: str = None, duplicated_arg_count: int = None):
         self._duplicated_id = duplicated_id
         self._arg_count = duplicated_arg_count
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return f"Duplicate manifest identifier: '{self._duplicated_id}' with {self._arg_count} argument(s)"
 
 
 class IncorrectNumberOfOperands(CompilerError):
     """
     An error raised when an operation is used with the wrong number of operands
     """
 
     def __init__(self, line: int, col: int, expected_count: int, actual_count: int):
         self.expected = expected_count
         self.actual = actual_count
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Incorrect number of operands: expected '%s', got '%s' instead" % (self.expected, self.actual)
 
 
 class InvalidUsage(CompilerError):
     """
     An error raised when a built-in function or decorator is incorrectly defined
     """
 
     def __init__(self, line: int, col: int, custom_error_message: str = None):
         self.custom_error_message = custom_error_message
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         message = "Invalid usage"
         if self.custom_error_message is not None:
             message += f": {self.custom_error_message}"
         return message
 
 
 class InvalidType(CompilerError):
@@ -120,15 +120,15 @@
     """
 
     def __init__(self, line: int, col: int, symbol_id: str = None):
         self.symbol_id = symbol_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         message = "Invalid type"
         if self.symbol_id is not None:
             message += ": '%s'" % self.symbol_id
         return message
 
 
 class InternalError(CompilerError):
@@ -137,15 +137,15 @@
     """
 
     def __init__(self, line: int, col: int, raised_exception: BaseException = None):
         self.raised_exception: BaseException = raised_exception
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         message = "Internal compiler error"
         if self.raised_exception is not None:
             message += ". {0}: {1}".format(type(self.raised_exception).__name__, str(self.raised_exception))
         return message
 
 
 class InternalIncorrectSignature(CompilerError):
@@ -154,15 +154,15 @@
     """
 
     def __init__(self, line: int, col: int, expected_method: IInternalMethod):
         self.expected_method: IInternalMethod = expected_method
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "The implementation of '{0}' is different " \
                "from the expected '{1}'.".format(self.expected_method.raw_identifier,
                                                  self.expected_method)
 
 
 class MetadataImplementationMissing(CompilerError):
     """
@@ -171,15 +171,15 @@
 
     def __init__(self, line: int, col: int, symbol_id: str, metadata_attr_id: str):
         self.symbol_id: str = symbol_id
         self.metadata_attr_id: str = metadata_attr_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "'{0}' requires '{1}' implementation".format(self.metadata_attr_id, self.symbol_id)
 
 
 class MetadataIncorrectImplementation(CompilerError):
     """
     An error raised when a metadata required function is incorrectly implemented
     """
@@ -190,15 +190,15 @@
 
         self.symbol_id: str = symbol_id
         self.expected_symbol: ISymbol = expected_symbol
         self.actual_symbol: ISymbol = actual_symbol
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return ("'{0}' is not correctly implemented. Expecting '{1}', got '{2}' instead"
                 .format(self.symbol_id, self.expected_symbol, self.actual_symbol))
 
 
 class MetadataInformationMissing(CompilerError):
     """
     An error raised when the metadata info doesn't match with the functions requirements
@@ -206,82 +206,82 @@
 
     def __init__(self, line: int, col: int, symbol_id: str, metadata_attr_id: str):
         self.symbol_id: str = symbol_id
         self.metadata_attr_id: str = metadata_attr_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "'{0}' requires '{1}' attribute, which is missing in the metadata".format(self.symbol_id,
                                                                                          self.metadata_attr_id)
 
 
 class MismatchedTypes(CompilerError):
     """
     An error raised when the evaluated and expected types are not the same
     """
 
-    def __init__(self, line: int, col: int, expected_type_id: Union[str, Iterable[str]],
-                 actual_type_id: Union[str, Iterable[str]]):
+    def __init__(self, line: int, col: int, expected_type_id: str | Iterable[str],
+                 actual_type_id: str | Iterable[str]):
         if isinstance(expected_type_id, str):
             expected_type_id = [expected_type_id]
         if isinstance(actual_type_id, str):
             actual_type_id = [actual_type_id]
 
         self.expected_types = expected_type_id
         self.actual_types = actual_type_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         expected_types = join_args(self.expected_types)
         actual_types = join_args(self.actual_types)
         return "Expected type '%s', got '%s' instead" % (expected_types, actual_types)
 
 
 class MissingInitCall(CompilerError):
     """
     An error raised when a custom class is created with inheritance and it's missing the base __init__ call
     """
 
     def __init__(self, line: int, col: int):
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Call to __init__ of super class is missed"
 
 
 class MissingReturnStatement(CompilerError):
     """
     An error raised when a function with a return value is missing a return statement
     """
 
     def __init__(self, line: int, col: int, symbol_id: str):
         self.symbol_id = symbol_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "'%s': Missing return statement" % self.symbol_id
 
 
 class MissingStandardDefinition(CompilerError):
     """
     An error raised when a contract standard is defined in the metadata and are required symbols missing
     """
 
-    def __init__(self, standard_id: str, symbol_id: str, symbol: Union[Method, Event]):
+    def __init__(self, standard_id: str, symbol_id: str, symbol: Method | Event):
         self.standard = standard_id
         self.symbol_id = symbol_id
         self.symbol = symbol
         super().__init__(0, 0)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         safe_symbol_prefix = 'safe ' if self.symbol.is_safe else ''
         return f"'{self.standard}': Missing '{self.symbol_id}' {self.symbol.shadowing_name} definition " \
                f"'{safe_symbol_prefix}{self.symbol}'"
 
     @property
     def message(self) -> str:
         return self._error_message
@@ -293,56 +293,56 @@
     """
 
     def __init__(self, line: int, col: int, symbol_id: str):
         self.symbol_id = symbol_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "The following operation is not supported: '%s'" % self.symbol_id
 
 
 class UnexpectedArgument(CompilerError):
     """
     An error thrown when more arguments are used in a function than the number of arguments in the function's signature
     """
 
     def __init__(self, line: int, col: int):
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Unexpected argument"
 
 
 class UnfilledArgument(CompilerError):
     """
     An error thrown when less arguments are used in a function than the number of arguments in the function's signature
     """
 
     def __init__(self, line: int, col: int, param: str):
         self.param = param
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Parameter '%s' unfilled" % self.param
 
 
 class UnresolvedReference(CompilerError):
     """
     An error raised when an undefined symbol is used
     """
 
     def __init__(self, line: int, col: int, symbol_id: str):
         self.symbol_id = symbol_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Unresolved reference '%s'" % self.symbol_id
 
     def __eq__(self, other) -> bool:
         if not isinstance(other, type(self)):
             return False
         return self._error_message == other._error_message
 
@@ -354,55 +354,55 @@
 
     def __init__(self, line: int, col: int, type_id: str, operation_id: str):
         self.type_id = type_id
         self.operation_id = operation_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Unresolved reference: '{0}' does not have a definition of '{1}' operator".format(self.type_id,
                                                                                                  self.operation_id)
 
 
 class TooManyReturns(CompilerError):
     """
     An error raised when a function returns a tuple
     """
 
     def __init__(self, line: int, col: int):
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "Too many returns"
 
 
 class TypeHintMissing(CompilerError):
     """
     An error raised when type hint cannot be found
     """
 
     def __init__(self, line: int, col: int, symbol_id: str = None):
         self.symbol_id = symbol_id
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         if self.symbol_id is not None:
             return "Type hint is missing for the symbol '%s'" % self.symbol_id
 
 
 class SelfArgumentError(CompilerError):
     """
     An error raised when the self argument is wrong
     """
 
     def __init__(self, line: int, col: int):
         super().__init__(line, col)
 
     @property
-    def _error_message(self) -> Optional[str]:
+    def _error_message(self) -> str | None:
         return "The self argument was not found or the annotation is incorrect"
 
 
 def join_args(iterable: Iterable[str]) -> str:
     return str.join("', '", iterable)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/exception/CompilerWarning.py` & `neo3_boa-1.2.0/boa3/internal/exception/CompilerWarning.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from abc import ABC
-from typing import Iterable, Optional, Union
+from collections.abc import Iterable
 
 
 class CompilerWarning(ABC, BaseException):
     def __init__(self, line: int, col: int):
         self.line: int = line
         self.col: int = col
-        self.filepath: Optional[str] = None
+        self.filepath: str | None = None
 
     @property
     def message(self) -> str:
         message = '' if self._warning_message is None else ' - ' + self._warning_message
         if isinstance(self.filepath, str):
             message += f'\t <{self.filepath}>'
         return '{0}:{1}{2}'.format(self.line, self.col, message)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         return None
 
     def __str__(self) -> str:
         return self.message
 
     def __eq__(self, other) -> bool:
         if not isinstance(other, type(self)):
@@ -29,35 +29,39 @@
 
 
 class DeprecatedSymbol(CompilerWarning):
     """
     A warning raised when a deprecated symbol is used.
     """
 
-    def __init__(self, line: int, col: int, symbol_id: str):
+    def __init__(self, line: int, col: int, symbol_id: str, alternative_id: str = None):
         self.symbol_id: str = symbol_id
+        self.alternative_symbol: str | None = alternative_id
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         if self.symbol_id is not None:
-            return f'Using deprecated feature: {self.symbol_id}'
+            msg = f"Using deprecated symbol: '{self.symbol_id}'."
+            if self.alternative_symbol is not None:
+                msg += f" Use '{self.alternative_symbol}' instead."
+            return msg
 
 
 class InvalidArgument(CompilerWarning):
     """
     An warning raised when an attempt of method evaluation fails during optimization because an argument is invalid.
     """
 
     def __init__(self, line: int, col: int, custom_error_message: str = None):
         self.custom_error_message = custom_error_message
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         message = "One or more arguments are invalid values"
         if self.custom_error_message is not None:
             message += f": {self.custom_error_message}"
         return message
 
 
 class NameShadowing(CompilerWarning):
@@ -68,52 +72,52 @@
 
     def __init__(self, line: int, col: int, outer_symbol: ISymbol, symbol_id: str):
         self.symbol_id: str = symbol_id
         self.existing_symbol = outer_symbol
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         if self.symbol_id is not None:
             return "Shadowing {0} name '{1}'".format(self.existing_symbol.shadowing_name, self.symbol_id)
 
 
 class RedeclaredSymbol(CompilerWarning):
     """
     A warning raised when a name from the same scope is used to identify multiple symbols
     """
 
     def __init__(self, line: int, col: int, symbol_id: str):
         self.symbol_id: str = symbol_id
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         if self.symbol_id is not None:
             return "Redeclared '{0}' defined above".format(self.symbol_id)
 
 
 class TypeCasting(CompilerWarning):
     """
     A warning raised when a type castings is used.
     """
 
-    def __init__(self, line: int, col: int, origin_type_id: Union[str, Iterable[str]],
-                 cast_type_id: Union[str, Iterable[str]]):
+    def __init__(self, line: int, col: int, origin_type_id: str | Iterable[str],
+                 cast_type_id: str | Iterable[str]):
         if isinstance(origin_type_id, str):
             origin_type_id = [origin_type_id]
         if isinstance(cast_type_id, str):
             cast_type_id = [cast_type_id]
 
         self.origin_types = origin_type_id
         self.cast_types = cast_type_id
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         origin_types = join_args(self.origin_types)
         cast_types = join_args(self.cast_types)
         return ("Casting {0} to {1}. Be aware that casting types may lead to runtime errors."
                 .format(origin_types, cast_types)
                 )
 
 
@@ -122,27 +126,27 @@
     A warning raised when a block of code is detected as unreachable
     """
 
     def __init__(self, line: int, col: int):
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         return "Unreachable code"
 
 
 class UsingSpecificException(CompilerWarning):
     """
     A warning raised when a specific exception is used.
     """
 
     def __init__(self, line: int, col: int, exception_id: str):
         self._exception_id: str = exception_id
         super().__init__(line, col)
 
     @property
-    def _warning_message(self) -> Optional[str]:
+    def _warning_message(self) -> str | None:
         return "{0} will be interpreted as BaseException when running in the blockchain".format(self._exception_id)
 
 
 def join_args(iterable: Iterable[str]) -> str:
     return str.join("', '", iterable)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/builtin.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/builtin.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 from enum import Enum
-from typing import Dict, List, Optional, Tuple, Union
 
 from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
 from boa3.internal.model.builtin.classmethod import *
 from boa3.internal.model.builtin.compile_time import *
 from boa3.internal.model.builtin.contract import *
 from boa3.internal.model.builtin.decorator import *
 from boa3.internal.model.builtin.internal import *
@@ -29,21 +28,21 @@
     Type = 'type'
     TypeHelper = 'helper'
     VM = 'vm'
 
 
 class Builtin:
     @classmethod
-    def get_symbol(cls, symbol_id: str) -> Optional[Callable]:
+    def get_symbol(cls, symbol_id: str) -> Callable | None:
         for method in cls._python_builtins:
             if isinstance(method, IBuiltinCallable) and method.identifier == symbol_id:
                 return method
 
     @classmethod
-    def get_by_self(cls, symbol_id: str, self_type: IType) -> Optional[Callable]:
+    def get_by_self(cls, symbol_id: str, self_type: IType) -> Callable | None:
         for name, method in vars(cls).items():
             if (isinstance(method, IBuiltinMethod)
                     and method.identifier == symbol_id
                     and method.validate_self(self_type)):
                 return method
 
     # builtin method
@@ -115,71 +114,66 @@
 
     # builtin decorator
     ClassMethodDecorator = ClassMethodDecorator()
     InstanceMethodDecorator = InstanceMethodDecorator()
     PropertyDecorator = PropertyDecorator()
     StaticMethodDecorator = StaticMethodDecorator()
 
-    _python_builtins: List[IdentifiedSymbol] = [Abs,
-                                                ByteArray,
-                                                ByteArrayEncoding,
-                                                BytesStringIndex,
-                                                BytesStringIsDigit,
-                                                BytesStringJoin,
-                                                BytesStringLower,
-                                                BytesStringStartswith,
-                                                BytesStringStrip,
-                                                BytesStringUpper,
-                                                BytesStringReplace,
-                                                ClassMethodDecorator,
-                                                ConvertToBool,
-                                                ConvertToBytes,
-                                                ConvertToInt,
-                                                ConvertToStr,
-                                                Copy,
-                                                CountSequenceGeneric,
-                                                CountSequencePrimitive,
-                                                CountStr,
-                                                DictKeys,
-                                                DictValues,
-                                                Exception,
-                                                Exit,
-                                                IsInstance,
-                                                Len,
-                                                ListSort,
-                                                Max,
-                                                Min,
-                                                Print,
-                                                PropertyDecorator,
-                                                Range,
-                                                Reversed,
-                                                ScriptHashMethod_,
-                                                SequenceAppend,
-                                                SequenceClear,
-                                                SequenceExtend,
-                                                SequenceIndex,
-                                                SequenceInsert,
-                                                SequencePop,
-                                                SequenceRemove,
-                                                SequenceReverse,
-                                                StaticMethodDecorator,
-                                                StrSplit,
-                                                Sum,
-                                                Super,
-                                                ]
-
-    @classmethod
-    def interop_symbols(cls, package: str = None) -> Dict[str, IdentifiedSymbol]:
-        return {symbol.raw_identifier if hasattr(symbol, 'raw_identifier') else symbol.identifier: symbol
-                for symbol in Interop.interop_symbols(package)}
+    _python_builtins: list[IdentifiedSymbol] = [
+        Abs,
+        ByteArray,
+        ByteArrayEncoding,
+        BytesStringIndex,
+        BytesStringIsDigit,
+        BytesStringJoin,
+        BytesStringLower,
+        BytesStringStartswith,
+        BytesStringStrip,
+        BytesStringUpper,
+        BytesStringReplace,
+        ClassMethodDecorator,
+        ConvertToBool,
+        ConvertToBytes,
+        ConvertToInt,
+        ConvertToStr,
+        Copy,
+        CountSequenceGeneric,
+        CountSequencePrimitive,
+        CountStr,
+        DictKeys,
+        DictValues,
+        Exception,
+        Exit,
+        IsInstance,
+        Len,
+        ListSort,
+        Max,
+        Min,
+        Print,
+        PropertyDecorator,
+        Range,
+        Reversed,
+        ScriptHashMethod_,
+        SequenceAppend,
+        SequenceClear,
+        SequenceExtend,
+        SequenceIndex,
+        SequenceInsert,
+        SequencePop,
+        SequenceRemove,
+        SequenceReverse,
+        StaticMethodDecorator,
+        StrSplit,
+        Sum,
+        Super,
+    ]
 
     # boa builtin decorator
     ContractInterface = ContractDecorator()
     ContractMethodDisplayName = DisplayNameDecorator()
-    Metadata = MetadataDecorator()
     Public = PublicDecorator()
 
     # boa builtin type
     Event = EventType
     UInt160 = UInt160Type.build()
     UInt256 = UInt256Type.build()
     ECPoint = ECPointType.build()
@@ -214,43 +208,43 @@
                                   BuiltinMathFloor])
 
     _symbols = [Env]
     _modules = [MathModule]
 
     # endregion
 
-    boa_builtins: List[IdentifiedSymbol] = []
+    boa_builtins: list[IdentifiedSymbol] = []
     boa_builtins.extend(_modules)
     boa_builtins.extend(_symbols)
 
-    metadata_fields: Dict[str, Union[type, Tuple[type]]] = {
+    metadata_fields: dict[str, type | tuple[type, ...]] = {
         'name': str,
         'source': (str, type(None)),
         'supported_standards': list,
         'trusts': list,
         'author': (str, type(None)),
         'email': (str, type(None)),
         'description': (str, type(None)),
         'extras': dict
     }
 
     @classmethod
-    def boa_symbols(cls) -> Dict[str, IdentifiedSymbol]:
+    def boa_symbols(cls) -> dict[str, IdentifiedSymbol]:
         return {symbol.identifier: symbol for symbol in cls.boa_builtins}
 
     @classmethod
-    def package_symbols(cls, package: str = None) -> Dict[str, IdentifiedSymbol]:
+    def package_symbols(cls, package: str = None) -> dict[str, IdentifiedSymbol]:
         if package in BoaPackage.__members__.values():
             return {symbol.identifier: symbol for symbol in cls._boa_symbols[package]}
 
         return cls.boa_symbols()
 
     @classmethod
-    def builtin_events(cls) -> List[EventSymbol]:
-        lst: List[EventSymbol] = [event for event in cls.boa_builtins if isinstance(event, EventSymbol)]
+    def builtin_events(cls) -> list[EventSymbol]:
+        lst: list[EventSymbol] = [event for event in cls.boa_builtins if isinstance(event, EventSymbol)]
 
         for symbols in cls._boa_symbols.values():
             lst.extend([event for event in symbols if isinstance(event, EventSymbol)])
 
         return lst
 
     _builtin_type_package_symbols = [ECPoint,
@@ -268,30 +262,29 @@
                                                       ConvertToBytes,
                                                       ConvertToInt,
                                                       ConvertToStr,
                                                       ]
                                              )
                                      ]
 
-    _boa_symbols: Dict[BoaPackage, List[IdentifiedSymbol]] = {
+    _boa_symbols: dict[BoaPackage, list[IdentifiedSymbol]] = {
         BoaPackage.Contract: [Abort,
                               NeoAccountState,
                               Nep11Transfer,
                               Nep17Transfer,
                               Nep17Contract,
                               ScriptHashMethod_,
                               ToHexStr,
                               ],
         BoaPackage.Interop: Interop.package_symbols,
         BoaPackage.Type: _builtin_type_package_symbols,
         BoaPackage.VM: [Opcode
                         ],
         BoaPackage.CompileTime: [ContractInterface,
                                  ContractMethodDisplayName,
-                                 Metadata,
                                  NeoMetadataType,
                                  Public,
                                  NewEvent
                                  ]
     }
 
     _internal_methods = [InnerDeployMethod.instance()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/builtincallable.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/builtincallable.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,30 +1,50 @@
 import ast
 from abc import ABC
-from typing import Dict, List, Optional, Tuple
 
 from boa3.internal.model.builtin.builtinsymbol import IBuiltinSymbol
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IBuiltinCallable(Callable, IBuiltinSymbol, ABC):
-    def __init__(self, identifier: str, args: Dict[str, Variable] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(args, vararg, kwargs, defaults, return_type)
+    def __init__(self,
+                 identifier: str,
+                 args: dict[str, Variable] = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None,
+                 defaults: list[ast.AST] = None,
+                 return_type: IType = None,
+                 deprecated: bool = False,
+                 new_location: str = None
+                 ):
+        super().__init__(args, vararg, kwargs, defaults, return_type, deprecated=deprecated)
         self._identifier = identifier
         self._generated_opcode = None
+        self._new_location = new_location
         self.defined_by_entry = False  # every builtin symbol must have this variable set as False
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def new_location(self) -> str | None:
+        return self._new_location
+
+    def set_new_location(self, new_location: str, identifier: str = None):
+        """
+        Set the location that is going to be shown in the deprecation warning in case if this symbol is deprecated.
+        """
+        from boa3.internal import constants
+        if identifier is None or len(identifier.strip()) == 0:
+            identifier = self._identifier
+
+        self._new_location = constants.ATTRIBUTE_NAME_SEPARATOR.join((new_location, identifier))
+
+    @property
+    def opcode(self) -> list[tuple[Opcode, bytes]]:
         """
         Gets the opcode for the method.
 
         :return: the opcode and its data if exists. None otherwise.
         """
         # don't need to recalculate for every time this property is called
         if self._generated_opcode is None:
@@ -49,13 +69,13 @@
 
     def reset(self):
         # reset the opcodes to ensure the correct output when calling consecutive compilations
         self._generated_opcode = None
         self.reset_calls()
 
     @property
-    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> list[tuple[Opcode, bytes]]:
         return []
 
     @property
     def identifier(self) -> str:
         return self._identifier
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/builtinproperty.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/builtinproperty.py`

 * *Files 26% similar despite different names*

```diff
@@ -2,16 +2,21 @@
 
 from boa3.internal.model.builtin.builtinsymbol import IBuiltinSymbol
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 
 
 class IBuiltinProperty(Property, IBuiltinSymbol, ABC):
-    def __init__(self, identifier: str, getter: Method, setter: Method = None):
-        super().__init__(getter, setter)
+    def __init__(self,
+                 identifier: str,
+                 getter: Method,
+                 setter: Method = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(getter, setter, deprecated=deprecated)
         self._identifier = identifier
 
     def update_with_analyser(self, analyser):
         super().update_with_analyser(analyser)
 
         if hasattr(self._getter, 'update_with_analyser'):
             self._getter.update_with_analyser(analyser)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/appendmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/appendmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Any, Dict, Optional, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -14,15 +15,15 @@
             self_arg = Variable(Type.mutableSequence)
             item_arg = Variable(Type.any)
         else:
             self_arg = Variable(sequence_type)
             item_arg = Variable(sequence_type.value_type)
 
         identifier = 'append'
-        args: Dict[str, Variable] = {'self': self_arg, 'item': item_arg}
+        args: dict[str, Variable] = {'self': self_arg, 'item': item_arg}
         super().__init__(identifier, args)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     @property
@@ -69,15 +70,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, Sized) and len(value) > 0:
             value = value[0]
         if value == self.args['self'].type:
             return self
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/clearmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/clearmethod.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -10,15 +10,15 @@
 class ClearMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
             from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         identifier = 'clear'
-        args: Dict[str, Variable] = {'self': Variable(sequence_type)}
+        args: dict[str, Variable] = {'self': Variable(sequence_type)}
         super().__init__(identifier, args)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     @property
@@ -56,15 +56,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MutableSequenceType):
             return ClearMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/copydictmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/copydictmethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.classmethod.copymethod import CopyMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class CopyDictMethod(CopyMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         super().__init__(arg_value if Type.dict.is_type_of(arg_value) else Type.dict)
 
     def generate_internal_opcodes(self, code_generator):
         code_generator.insert_opcode(Opcode.UNPACK)
         code_generator.insert_opcode(Opcode.PACKMAP)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/copymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/copymethod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class CopyMethod(IBuiltinMethod):
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         identifier = 'copy'
 
         self._allowed_types = [Type.dict, Type.list]
         default_type = Type.list
         if not self._is_valid_type(arg_value):
             arg_value = default_type
 
-        args: Dict[str, Variable] = {'self': Variable(arg_value)}
+        args: dict[str, Variable] = {'self': Variable(arg_value)}
         super().__init__(identifier, args, return_type=arg_value)
 
-    def _is_valid_type(self, arg_type: Optional[IType]) -> bool:
+    def _is_valid_type(self, arg_type: IType | None) -> bool:
         return (isinstance(arg_type, IType) and
                 any(allowed_type.is_type_of(arg_type) for allowed_type in self._allowed_types))
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -49,15 +49,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, list) and len(value) == 1:
             value = value[0]
         if value == self.args['self']:
             return self
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countmethod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import ast
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class CountMethod(IBuiltinMethod):
 
-    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+    def __init__(self, args: dict[str, Variable] = None, defaults: list[ast.AST] = None):
         from boa3.internal.model.type.type import Type
         identifier = 'count'
         super().__init__(identifier, args, defaults=defaults, return_type=Type.int)
 
     @property
     def identifier(self) -> str:
         from boa3.internal.model.type.type import Type
@@ -45,15 +45,15 @@
         return self.args['value']
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
         from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countsequencegenericmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countsequencegenericmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import List, Optional, Tuple
-
 from boa3.internal.model.builtin.classmethod.countsequencemethod import CountSequenceMethod
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 
 
 class CountSequenceGenericMethod(CountSequenceMethod):
 
-    def __init__(self, sequence_type: Optional[SequenceType] = None, arg_value: Optional[IType] = None):
+    def __init__(self, sequence_type: SequenceType | None = None, arg_value: IType | None = None):
         super().__init__(sequence_type, arg_value)
 
-    def _generic_verification(self, code_generator) -> Tuple[List[int], List[int]]:
+    def _generic_verification(self, code_generator) -> tuple[list[int], list[int]]:
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
         from boa3.internal.model.type.type import Type
         from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
         jmps_to_inc, jmps_to_condition = super()._generic_verification(code_generator)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countsequencemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countsequencemethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,24 @@
-from typing import Dict, List, Optional, Tuple
-
 from boa3.internal.model.builtin.classmethod.countmethod import CountMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class CountSequenceMethod(CountMethod):
 
-    def __init__(self, sequence_type: Optional[SequenceType] = None, arg_value: Optional[IType] = None):
+    def __init__(self, sequence_type: SequenceType | None = None, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         if not isinstance(sequence_type, SequenceType):
             sequence_type = Type.sequence
         if not isinstance(arg_value, IType):
             arg_value = Type.any
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(sequence_type),
             'value': Variable(arg_value)
         }
 
         super().__init__(args)
 
     def validate_parameters(self, *params: IExpression) -> bool:
@@ -98,14 +96,14 @@
 
         # clean stack
         code_generator.remove_stack_top_item()
         code_generator.swap_reverse_stack_items(3)
         code_generator.remove_stack_top_item()
         code_generator.remove_stack_top_item()
 
-    def _generic_verification(self, code_generator) -> Tuple[List[int], List[int]]:
+    def _generic_verification(self, code_generator) -> tuple[list[int], list[int]]:
         """
         Generate the Neo VM opcodes for the method.
 
         :type code_generator: boa3.internal.compiler.codegenerator.codegenerator.CodeGenerator
         """
         return [], []
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countsequenceprimitivemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countsequenceprimitivemethod.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,13 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.classmethod.countsequencemethod import CountSequenceMethod
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 
 
 class CountSequencePrimitiveMethod(CountSequenceMethod):
 
-    def __init__(self, sequence_type: Optional[SequenceType] = None, arg_value: Optional[IType] = None):
+    def __init__(self, sequence_type: SequenceType | None = None, arg_value: IType | None = None):
         if not isinstance(sequence_type, SequenceType):
             from boa3.internal.model.type.type import Type
             sequence_type = Type.sequence.build_collection([Type.str, Type.int, Type.bytes])
 
         super().__init__(sequence_type, arg_value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/countstrmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/countstrmethod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.classmethod.countmethod import CountMethod
 from boa3.internal.model.variable import Variable
 
 
 class CountStrMethod(CountMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(Type.str),
             'value': Variable(Type.str),
             'start': Variable(Type.int),
             'end': Variable(Type.union.build([Type.int, Type.none])),
         }
 
         start_default = set_internal_call(ast.parse("{0}".format(Type.int.default_value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/extendmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/extendmethod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
@@ -14,15 +14,15 @@
         if not isinstance(sequence_type, MutableSequenceType):
             sequence_type = Type.mutableSequence
 
         self_arg = Variable(sequence_type)
         item_arg = Variable(Type.sequence.build_collection(sequence_type.value_type))
 
         identifier = 'extend'
-        args: Dict[str, Variable] = {'self': self_arg, 'item': item_arg}
+        args: dict[str, Variable] = {'self': self_arg, 'item': item_arg}
         super().__init__(identifier, args)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     @property
@@ -99,15 +99,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MutableSequenceType):
             return ExtendMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/indexbytesstringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/indexbytesstringmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 import ast
-from typing import Dict, Optional
 
 from boa3.internal.model.builtin.classmethod.indexmethod import IndexMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.model.type.primitive.strtype import StrType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IndexBytesStringMethod(IndexMethod):
 
-    def __init__(self, self_type: Optional[StrType] = None):
+    def __init__(self, self_type: StrType | None = None):
         from boa3.internal.model.type.type import Type
         if not isinstance(self_type, (StrType, BytesType)):
             self_type = Type.str
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(self_type),
             'x': Variable(self_type),
             'start': Variable(Type.int),
             'end': Variable(Type.optional.build(Type.int)),
         }
 
         start_default = ast.parse("{0}".format(0)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/indexmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/indexmethod.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import ast
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class IndexMethod(IBuiltinMethod):
 
-    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+    def __init__(self, args: dict[str, Variable] = None, defaults: list[ast.AST] = None):
         from boa3.internal.model.type.type import Type
         identifier = 'index'
         super().__init__(identifier, args, defaults=defaults, return_type=Type.int)
 
     @property
     def identifier(self) -> str:
         from boa3.internal.model.type.type import Type
@@ -44,15 +44,15 @@
         return self.args['value']
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
         from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/indexsequencemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/indexsequencemethod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,28 +1,27 @@
 import ast
-from typing import Dict, Optional
 
 from boa3.internal.model.builtin.classmethod.indexmethod import IndexMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IndexSequenceMethod(IndexMethod):
 
-    def __init__(self, sequence_type: Optional[SequenceType] = None, arg_value: Optional[IType] = None):
+    def __init__(self, sequence_type: SequenceType | None = None, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         if not isinstance(sequence_type, SequenceType):
             sequence_type = Type.sequence
         if not isinstance(arg_value, IType):
             arg_value = Type.any
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(sequence_type),
             'x': Variable(arg_value),
             'start': Variable(Type.int),
             'end': Variable(Type.int),
         }
 
         start_default = ast.parse("{0}".format(0)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/insertmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/insertmethod.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.variable import Variable
 
 
@@ -13,15 +13,15 @@
             sequence_type = Type.mutableSequence
 
         self_arg = Variable(sequence_type)
         index_arg = Variable(sequence_type.valid_key)
         item_arg = Variable(sequence_type.value_type)
 
         identifier = 'insert'
-        args: Dict[str, Variable] = {'self': self_arg,
+        args: dict[str, Variable] = {'self': self_arg,
                                      '__index': index_arg,
                                      '__object': item_arg}
         super().__init__(identifier, args)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
@@ -37,15 +37,15 @@
         index_type: IType = params[1].type
         value_type: IType = params[2].type
 
         if not isinstance(sequence_type, MutableSequenceType):
             return False
         return sequence_type.key_type.is_type_of(index_type) and sequence_type.value_type.is_type_of(value_type)
 
-    def validate_negative_arguments(self) -> List[int]:
+    def validate_negative_arguments(self) -> list[int]:
         return [list(self.args).index('__index')]
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
         from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -105,15 +105,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MutableSequenceType):
             return InsertMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/isdigitmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/isdigitmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
@@ -10,15 +10,15 @@
     def __init__(self, self_type: IByteStringType = None):
         from boa3.internal.model.type.type import Type
 
         if not isinstance(self_type, IByteStringType):
             self_type = Type.bytes
 
         identifier = 'isdigit'
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
 
         super().__init__(identifier, args, return_type=Type.bool)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -94,14 +94,14 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, IByteStringType):
             return IsDigitMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/joinmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/joinmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,29 +1,30 @@
-from typing import Any, Dict, Iterable, Optional, Union
+from collections.abc import Iterable
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.collection.mapping.mutable.dicttype import DictType
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class JoinMethod(IBuiltinMethod):
-    def __init__(self, self_type: IByteStringType = None, iterable_type: Union[SequenceType, DictType] = None):
+    def __init__(self, self_type: IByteStringType = None, iterable_type: SequenceType | DictType = None):
         from boa3.internal.model.type.type import Type
 
         if not isinstance(self_type, IByteStringType):
             self_type = Type.bytes
 
         if not isinstance(iterable_type, (SequenceType, DictType)):
             iterable_type = Type.sequence.build_collection([self_type])
 
         identifier = 'join'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(self_type),
             'iterable': Variable(iterable_type),
         }
 
         super().__init__(identifier, args, return_type=self_type)
 
     @property
@@ -115,15 +116,15 @@
         code_generator.remove_stack_item(2)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, Iterable):
             value = [value]
         if isinstance(value, list) and len(value) <= 2:
             self_type = self._arg_self.type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/lowermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/lowermethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class LowerMethod(IBuiltinMethod):
     def __init__(self, self_type: IByteStringType = None):
         if not isinstance(self_type, IByteStringType):
             from boa3.internal.model.type.type import Type
             self_type = Type.bytes
 
         identifier = 'lower'
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
 
         super().__init__(identifier, args, return_type=self_type)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -108,14 +108,14 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, IByteStringType):
             return LowerMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/mapkeysmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/mapkeysmethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -14,15 +14,15 @@
             self_arg = Variable(Type.mapping)
             return_type = Type.sequence
         else:
             self_arg = Variable(mapping_type)
             return_type = Type.sequence.build_collection(mapping_type.key_type)
 
         identifier = 'keys'
-        args: Dict[str, Variable] = {'self': self_arg}
+        args: dict[str, Variable] = {'self': self_arg}
         super().__init__(identifier, args, return_type=return_type)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
@@ -37,15 +37,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MappingType):
             return MapKeysMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/mapvaluesmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/mapvaluesmethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -14,15 +14,15 @@
             self_arg = Variable(Type.mapping)
             return_type = Type.sequence
         else:
             self_arg = Variable(mapping_type)
             return_type = Type.sequence.build_collection(mapping_type.value_type)
 
         identifier = 'values'
-        args: Dict[str, Variable] = {'self': self_arg}
+        args: dict[str, Variable] = {'self': self_arg}
         super().__init__(identifier, args, return_type=return_type)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
@@ -37,15 +37,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MappingType):
             return MapValuesMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popdictdefaultmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popdictdefaultmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.classmethod.popmethod import PopMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class PopDictDefaultMethod(PopMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
 
         if not Type.dict.is_type_of(arg_value):
             arg_value = Type.dict
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(arg_value),
             'key': Variable(arg_value.valid_key),
             'default': Variable(Type.any)
         }
 
         super().__init__(args, return_type=arg_value.value_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popdictmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popdictmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.classmethod.popmethod import PopMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class PopDictMethod(PopMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
 
         if not Type.dict.is_type_of(arg_value):
             arg_value = Type.dict
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(arg_value),
             'key': Variable(arg_value.valid_key)
         }
 
         super().__init__(args, return_type=arg_value.value_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popmethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 import ast
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.mapping.mutable.dicttype import DictType
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class PopMethod(IBuiltinMethod):
-    def __init__(self, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
+    def __init__(self, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None):
         identifier = 'pop'
 
         super().__init__(identifier, args, defaults=defaults, return_type=return_type)
 
     @property
     def identifier(self) -> str:
         from boa3.internal.model.type.type import Type
@@ -72,15 +72,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
         from boa3.internal.model.builtin.classmethod.popdictmethod import PopDictMethod
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/popsequencemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/bytearraytype.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,29 +1,37 @@
-import ast
-from typing import Dict, Optional
+from typing import Any
 
-from boa3.internal.model.builtin.classmethod.popmethod import PopMethod
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.type.itype import IType
-from boa3.internal.model.variable import Variable
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
-class PopSequenceMethod(PopMethod):
+class ByteArrayType(BytesType, MutableSequenceType):
+    """
+    A class used to represent Python list type
+    """
 
-    def __init__(self, arg_value: Optional[IType] = None):
-        from boa3.internal.model.type.type import Type
+    def __init__(self):
+        super().__init__()
+        self._identifier = 'bytearray'
+
+    @property
+    def stack_item(self) -> StackItemType:
+        return StackItemType.Buffer
 
-        if not Type.mutableSequence.is_type_of(arg_value):
-            arg_value = Type.mutableSequence
+    @property
+    def default_value(self) -> Any:
+        return bytearray()
+
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        from boa3.internal.model.type.type import Type
+        return Type.bytearray
 
-        args: Dict[str, Variable] = {
-            'self': Variable(arg_value),
-            'index': Variable(arg_value.valid_key)
-        }
-
-        index_default = ast.parse("-1").body[0].value.operand
-        index_default.n = -1
-
-        super().__init__(args, defaults=[index_default], return_type=arg_value.value_type)
-
-    def generate_opcodes(self, code_generator):
-        code_generator.fix_negative_index()
-        self.generate_internal_opcodes(code_generator)
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return type(value) in [bytearray, ByteArrayType]
+
+    @property
+    def can_reassign_values(self) -> bool:
+        return True
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/removemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/removemethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.variable import Variable
 
 
@@ -12,15 +12,15 @@
             from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         self_arg = Variable(sequence_type)
         item_arg = Variable(sequence_type.value_type)
 
         identifier = 'remove'
-        args: Dict[str, Variable] = {'self': self_arg,
+        args: dict[str, Variable] = {'self': self_arg,
                                      '__value': item_arg}
         super().__init__(identifier, args)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -82,15 +82,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MutableSequenceType):
             return RemoveMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/replacemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/replacemethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
@@ -11,15 +11,15 @@
     def __init__(self, self_type: IByteStringType = None):
         from boa3.internal.model.type.type import Type
 
         if not isinstance(self_type, IByteStringType):
             self_type = Type.bytes
 
         identifier = 'replace'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(self_type),
             'old': Variable(self_type),
             'new': Variable(self_type),
             'count': Variable(Type.int),
         }
 
         count_default = ast.parse("-1").body[0].value.operand
@@ -166,14 +166,14 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, IByteStringType):
             return ReplaceMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/reversemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/reversemethod.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -10,15 +10,15 @@
 class ReverseMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
             from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         identifier = 'reverse'
-        args: Dict[str, Variable] = {'self': Variable(sequence_type)}
+        args: dict[str, Variable] = {'self': Variable(sequence_type)}
         super().__init__(identifier, args)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
@@ -33,15 +33,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, MutableSequenceType):
             return ReverseMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/sortmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/sortmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.model.operation.binaryop import BinaryOp
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class SortMethod(IBuiltinMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
 
         if not Type.list.is_type_of(arg_value):
             arg_value = Type.list
 
         identifier = 'sort'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(arg_value),
             'reverse': Variable(Type.bool)
         }
         # TODO: change this when keyword-only arguments are implemented #2ewewtz
         kwargs = {
             'reverse': Variable(Type.bool)
         }
@@ -164,15 +164,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
         from boa3.internal.model.type.type import Type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/startswithmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/startswithmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
@@ -11,15 +11,15 @@
     def __init__(self, self_type: IByteStringType = None):
         from boa3.internal.model.type.type import Type
 
         if not isinstance(self_type, IByteStringType):
             self_type = Type.bytes
 
         identifier = 'startswith'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(self_type),
             'value': Variable(self_type),
             'start': Variable(Type.int),
             'end': Variable(Type.optional.build(Type.int)),
         }
 
         start_default = ast.parse("{0}".format(0)
@@ -107,14 +107,14 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, IByteStringType):
             return StartsWithMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/stripmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/stripmethod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
@@ -11,15 +11,15 @@
     def __init__(self, self_type: IByteStringType = None):
         from boa3.internal.model.type.type import Type
 
         if not isinstance(self_type, IByteStringType):
             self_type = Type.bytes
 
         identifier = 'strip'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(self_type),
             'chars': Variable(self_type),
         }
 
         from string import whitespace
 
         # whitespace is ' \t\n\r\v\f', but it needs to be r' \t\n\r\v\f'
@@ -206,15 +206,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, IByteStringType):
             return StripMethod(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/classmethod/uppermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/uppermethod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
@@ -10,15 +10,15 @@
     def __init__(self, self_type: IByteStringType = None):
 
         if not isinstance(self_type, IByteStringType):
             from boa3.internal.model.type.type import Type
             self_type = Type.bytes
 
         identifier = 'upper'
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
 
         super().__init__(identifier, args, return_type=self_type)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -109,14 +109,14 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, IByteStringType):
             return UpperMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/abortmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/abortmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Dict, Optional, Any, Sequence
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
@@ -12,23 +13,23 @@
         import ast
         from boa3.internal.model.type.itype import IType
         from boa3.internal.model.type.type import Type
 
         identifier = 'abort'
 
         if isinstance(message_type, IType):
-            args: Dict[str, Variable] = {
+            args: dict[str, Variable] = {
                 'msg': Variable(Type.optional.build(message_type))
             }
             defaults = [
                 ast.parse(f'{Type.none.default_value}').body[0].value
             ]
 
         else:
-            args: Dict[str, Variable] = {}
+            args: dict[str, Variable] = {}
             defaults = []
 
         super().__init__(identifier, args, defaults, return_type=Type.none)
 
     @property
     def identifier(self) -> str:
         if 'msg' not in self.args:
@@ -54,15 +55,15 @@
             obj = AbortStrMethod()
         else:
             from boa3.internal.model.builtin.builtin import Builtin
             obj = Builtin.Abort
         return obj
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class AbortStrMethod(AbortMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
         message_type = Type.str
@@ -72,15 +73,15 @@
         from boa3.internal.model.type.type import Type
         return self.args['msg'].type if 'msg' in self.args else Type.optional.build(Type.str)
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.type.type import Type
 
         msg = code_generator._stack[-1] if len(code_generator._stack) else self.msg_arg_type()
-        # if msg is optional[str] both variables are going to be set as True
+        # if msg is str | None both variables are going to be set as True
         is_not_str = not Type.str.is_type_of(msg)
         is_not_none = not Type.none.is_type_of(msg)
 
         if is_not_str and is_not_none:
             # need to check the type at runtime
             code_generator.duplicate_stack_top_item()
             code_generator.insert_type_check(Type.str.stack_item)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/neoaccountstatetype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/notificationtype.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,102 +1,97 @@
-from __future__ import annotations
-
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 from boa3.internal.model.variable import Variable
-from boa3.internal.neo.vm.opcode import OpcodeHelper
-from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NeoAccountStateType(ClassArrayType):
+class NotificationType(ClassArrayType):
     """
-    A class used to represent Neo NeoAccountState class
+    A class used to represent Neo Notification class
     """
 
     def __init__(self):
-        super().__init__('NeoAccountState')
-        from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        super().__init__('Notification')
 
-        self._variables: Dict[str, Variable] = {
-            'balance': Variable(Type.int),
-            'height': Variable(Type.int),
-            'vote_to': Variable(ECPointType.build()),
+        from boa3.internal.model.type.type import Type
+        self._variables: dict[str, Variable] = {
+            'script_hash': Variable(UInt160Type.build()),
+            'event_name': Variable(Type.str),
+            'state': Variable(Type.tuple)
         }
-        self._constructor: Optional[Method] = None
+        self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
-        return {}
+    def instance_variables(self) -> dict[str, Variable]:
+        return self._variables.copy()
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
-        return self._variables.copy()
+    def class_variables(self) -> dict[str, Variable]:
+        return {}
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
-            self._constructor: Method = NeoAccountStateMethod(self)
+            self._constructor: Method = NotificationMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> NeoAccountStateType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
-            return _NeoAccountState
+            return _Notification
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, NeoAccountStateType)
+        return isinstance(value, NotificationType)
 
 
-_NeoAccountState = NeoAccountStateType()
+_Notification = NotificationType()
 
 
-class NeoAccountStateMethod(IBuiltinMethod):
+class NotificationMethod(IBuiltinMethod):
 
-    def __init__(self, return_type: NeoAccountStateType):
-        identifier = '-NeoAccountState__init__'
-        args: Dict[str, Variable] = {}
+    def __init__(self, return_type: NotificationType):
+        identifier = '-Notification__init__'
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
-    @property
-    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
-        return [
-            OpcodeHelper.get_pushdata_and_data(ECPointType.build().default_value),  # vote_to
-            (Opcode.PUSH0, b''),  # height
-            (Opcode.PUSH0, b''),  # balance
-            (Opcode.PUSH3, b''),
-            (Opcode.PACK, b'')
-        ]
+    def generate_internal_opcodes(self, code_generator):
+        from boa3.internal.neo3.core.types import UInt160
+
+        uint160_default = UInt160.zero().to_array()
+
+        code_generator.convert_literal(())  # state
+        code_generator.convert_literal('')  # event_name
+        code_generator.convert_literal(uint160_default)  # script_hash
+        code_generator.convert_new_array(length=3, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep11transferevent.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17transferevent.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,17 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
 from boa3.internal.model.variable import Variable
 
 
-class Nep11TransferEvent(IBuiltinEvent):
+class Nep17TransferEvent(IBuiltinEvent):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-
-        identifier = 'Nep11TransferEvent'
-        type_token_id = Type.union.build([Type.str, Type.bytes])
-
-        args: Dict[str, Variable] = {
+        identifier = 'Nep17TransferEvent'
+        args: dict[str, Variable] = {
             'from_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
             'to_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
-            'amount': Variable(Type.int),
-            'tokenId': Variable(type_token_id),
+            'amount': Variable(Type.int)
         }
         super().__init__(identifier, args)
         self.name = 'Transfer'
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacebalanceofmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacebalanceofmethod.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.contract.nep17_interface_methods.nep17interfacemethod import Nep17InterfaceMethod
 from boa3.internal.model.builtin.interop.contract import ContractType
 from boa3.internal.model.variable import Variable
 
 
 class Nep17InterfaceBalanceOfMethod(Nep17InterfaceMethod):
 
     def __init__(self, self_type: ContractType):
         from boa3.internal.model.type.type import Type
 
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(self_type),
             'account': Variable(UInt160Type.build())
         }
         super().__init__(args, 'balance_of', native_identifier='balanceOf', return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacedecimalsmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacedecimalsmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.contract.nep17_interface_methods.nep17interfacemethod import Nep17InterfaceMethod
 from boa3.internal.model.builtin.interop.contract import ContractType
 from boa3.internal.model.variable import Variable
 
 
 class Nep17InterfaceDecimalsMethod(Nep17InterfaceMethod):
 
     def __init__(self, self_type: ContractType):
         from boa3.internal.model.type.type import Type
 
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
         super().__init__(args, 'decimals', return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacemethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,32 +1,31 @@
 import ast
-from typing import Dict, Optional, List
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class Nep17InterfaceMethod(IBuiltinMethod):
 
-    def __init__(self, args: Dict[str, Variable], identifier: str,
-                 return_type: IType, defaults: List[ast.AST] = None,
+    def __init__(self, args: dict[str, Variable], identifier: str,
+                 return_type: IType, defaults: list[ast.AST] = None,
                  native_identifier: str = None):
         super().__init__(identifier, args, return_type=return_type, defaults=defaults)
         if native_identifier is None:
             self.native_identifier = identifier
         else:
             self.native_identifier = native_identifier
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.interop import Interop
         from boa3.internal.model.type.type import Type
         from boa3.builtin.interop.contract import CallFlags
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacesymbolmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetotalsupplymethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.contract.nep17_interface_methods.nep17interfacemethod import Nep17InterfaceMethod
 from boa3.internal.model.builtin.interop.contract import ContractType
 from boa3.internal.model.variable import Variable
 
 
-class Nep17InterfaceSymbolMethod(Nep17InterfaceMethod):
+class Nep17InterfaceTotalSupplyMethod(Nep17InterfaceMethod):
 
     def __init__(self, self_type: ContractType):
         from boa3.internal.model.type.type import Type
 
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
-        super().__init__(args, 'symbol', return_type=Type.str)
+        args: dict[str, Variable] = {'self': Variable(self_type)}
+        super().__init__(args, 'total_supply', native_identifier='totalSupply', return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetotalsupplymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacesymbolmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.contract.nep17_interface_methods.nep17interfacemethod import Nep17InterfaceMethod
 from boa3.internal.model.builtin.interop.contract import ContractType
 from boa3.internal.model.variable import Variable
 
 
-class Nep17InterfaceTotalSupplyMethod(Nep17InterfaceMethod):
+class Nep17InterfaceSymbolMethod(Nep17InterfaceMethod):
 
     def __init__(self, self_type: ContractType):
         from boa3.internal.model.type.type import Type
 
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
-        super().__init__(args, 'total_supply', native_identifier='totalSupply', return_type=Type.int)
+        args: dict[str, Variable] = {'self': Variable(self_type)}
+        super().__init__(args, 'symbol', return_type=Type.str)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetransfermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/transfermethod.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 import ast
-from typing import Dict
 
-from boa3.internal.model.builtin.contract.nep17_interface_methods.nep17interfacemethod import Nep17InterfaceMethod
-from boa3.internal.model.builtin.interop.contract import ContractType
+from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
 from boa3.internal.model.variable import Variable
 
 
-class Nep17InterfaceTransferMethod(Nep17InterfaceMethod):
+class TransferMethod(Nep17Method):
 
-    def __init__(self, self_type: ContractType):
+    def __init__(self, contract_script_hash: bytes):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
-        args: Dict[str, Variable] = {
-            'self': Variable(self_type),
+        identifier = 'transfer'
+        native_identifier = 'transfer'
+        args: dict[str, Variable] = {
             'from_address': Variable(UInt160Type.build()),
             'to_address': Variable(UInt160Type.build()),
             'amount': Variable(Type.int),
             'data': Variable(Type.any),
         }
 
         data_default = ast.parse("{0}".format(Type.any.default_value)
                                  ).body[0].value
 
-        super().__init__(args, 'transfer', return_type=Type.bool, defaults=[data_default])
+        super().__init__(identifier, native_identifier, args, defaults=[data_default],
+                         return_type=Type.bool, script_hash=contract_script_hash)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17contract.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17contract.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Dict, List
-
 from boa3.internal.model.builtin.interop.contract import ContractType
 from boa3.internal.model.method import Method
 
 
 class Nep17ContractClass(ContractType):
     def __init__(self):
         super().__init__()
@@ -14,25 +12,25 @@
             Nep17InterfaceBalanceOfMethod,
             Nep17InterfaceDecimalsMethod,
             Nep17InterfaceSymbolMethod,
             Nep17InterfaceTotalSupplyMethod,
             Nep17InterfaceTransferMethod,
         )
 
-        nep17_methods: List = [
+        nep17_methods: list = [
             Nep17InterfaceBalanceOfMethod,
             Nep17InterfaceDecimalsMethod,
             Nep17InterfaceSymbolMethod,
             Nep17InterfaceTotalSupplyMethod,
             Nep17InterfaceTransferMethod,
         ]
 
-        instance_methods: Dict[str, Method] = {}
+        instance_methods: dict[str, Method] = {}
         for nep17_method in nep17_methods:
             nep17_method_obj = nep17_method(self)
             instance_methods[nep17_method_obj.identifier] = nep17_method_obj
 
-        self._instance_methods: Dict[str, Method] = instance_methods
+        self._instance_methods: dict[str, Method] = instance_methods
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return self._instance_methods.copy()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/contract/nep17transferevent.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/vote.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class Nep17TransferEvent(IBuiltinEvent):
+class VoteMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = 'Nep17TransferEvent'
-        args: Dict[str, Variable] = {
-            'from_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
-            'to_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
-            'amount': Variable(Type.int)
+
+        identifier = 'vote'
+        native_identifier = 'vote'
+        args: dict[str, Variable] = {
+            'account': Variable(UInt160Type.build()),
+            'vote_to': Variable(ECPointType.build())
         }
-        super().__init__(identifier, args)
-        self.name = 'Transfer'
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,16 @@
 __all__ = ['ClassMethodDecorator',
            'ContractDecorator',
            'DisplayNameDecorator',
            'InstanceMethodDecorator',
-           'MetadataDecorator',
            'PropertyDecorator',
            'PublicDecorator',
            'StaticMethodDecorator'
            ]
 
 from boa3.internal.model.builtin.decorator.classmethoddecorator import ClassMethodDecorator
 from boa3.internal.model.builtin.decorator.contractdecorator import ContractDecorator
 from boa3.internal.model.builtin.decorator.displaynamedecorator import DisplayNameDecorator
 from boa3.internal.model.builtin.decorator.instancemethoddecorator import InstanceMethodDecorator
-from boa3.internal.model.builtin.decorator.metadatadecorator import MetadataDecorator
 from boa3.internal.model.builtin.decorator.propertydecorator import PropertyDecorator
 from boa3.internal.model.builtin.decorator.publicdecorator import PublicDecorator
 from boa3.internal.model.builtin.decorator.staticmethoddecorator import StaticMethodDecorator
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/builtindecorator.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/exitmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,21 +1,23 @@
-import ast
-from abc import ABC
-from typing import Any, Dict, List
-
-from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
-from boa3.internal.model.decorator import IDecorator
-from boa3.internal.model.expression import IExpression
-from boa3.internal.model.type.itype import IType
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class IBuiltinDecorator(IBuiltinCallable, IDecorator, ABC):
-    def __init__(self, identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(identifier, args, defaults, return_type)
+class ExitMethod(IBuiltinMethod):
 
-    def validate_parameters(self, *params: IExpression) -> bool:
-        return len(params) == len(self.args)
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        identifier = 'exit'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, args, return_type=Type.none)
 
-    def validate_values(self, *params: Any) -> List[Any]:
-        return []
+    def generate_internal_opcodes(self, code_generator):
+        code_generator.insert_opcode(Opcode.ABORT)
+
+    @property
+    def _args_on_stack(self) -> int:
+        return 0
+
+    @property
+    def _body(self) -> str | None:
+        return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/classmethoddecorator.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/classmethoddecorator.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 import ast
-from typing import Optional
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinDecorator
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.annotation import metatype
 from boa3.internal.model.type.classes.userclass import UserClass
 
 
 class ClassMethodDecorator(IBuiltinDecorator):
     def __init__(self):
         identifier = 'classmethod'
         super().__init__(identifier)
 
-    def update_args(self, args: ast.arguments, origin: Optional[ISymbol] = None):
+    def update_args(self, args: ast.arguments, origin: ISymbol | None = None):
         if isinstance(origin, UserClass) and len(args.args) > 0 and args.args[0].annotation is None:
             # the user doesn't need to explicitly write the type of the first argument if it's a classmethod
-            # the first argument is a Type[Class]
+            # the first argument is a type[Class]
             cls_type = metatype.metaType.build(origin)
             cls_type_annotation = (cls_type.meta_identifier
                                    if isinstance(cls_type, metatype.MetaType)
                                    else cls_type.identifier)
 
             cls_ast_annotation = ast.parse(cls_type_annotation).body[0].value
             cls_ast_annotation = set_internal_call(cls_ast_annotation)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/contractdecorator.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/contractdecorator.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 import ast
-from typing import Any, Dict, List, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinDecorator
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo3.core.types import UInt160
 
 
 class ContractDecorator(IBuiltinDecorator):
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
         identifier = 'contract'
-        args: Dict[str, Variable] = {'script_hash': Variable(Type.union.build([Type.bytes,
+        args: dict[str, Variable] = {'script_hash': Variable(Type.union.build([Type.bytes,
                                                                                Type.str
                                                                                ]))}
         super().__init__(identifier, args)
         self.contract_hash = UInt160()
 
     def build(self, *args) -> IBuiltinDecorator:
         if isinstance(args, Sized) and len(args) > 0 and isinstance(args[0], ast.AST):
@@ -28,15 +29,15 @@
                 hash_arg = values[0] if len(values) > 0 else None
                 if isinstance(hash_arg, UInt160):
                     decorator.contract_hash = hash_arg
             return decorator
 
         return self
 
-    def validate_values(self, *params: Any) -> List[Any]:
+    def validate_values(self, *params: Any) -> list[Any]:
         values = []
         if len(params) != 2:
             return values
 
         origin, visitor = params
         values.append(self.contract_hash)
         from boa3.internal.analyser.astanalyser import IAstAnalyser
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/displaynamedecorator.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/displaynamedecorator.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 import ast
-from typing import Any, Dict, List, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinDecorator
 from boa3.internal.model.variable import Variable
 
 
 class DisplayNameDecorator(IBuiltinDecorator):
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
         identifier = 'display_name'
-        args: Dict[str, Variable] = {'name': Variable(Type.str)}
+        args: dict[str, Variable] = {'name': Variable(Type.str)}
         super().__init__(identifier, args)
         self.external_name = None
 
     def build(self, *args) -> IBuiltinDecorator:
         if isinstance(args, Sized) and len(args) > 0 and isinstance(args[0], ast.AST):
             decorator = DisplayNameDecorator()
             decorator._origin_node = args[0]
@@ -25,15 +26,15 @@
                 hash_arg = values[0] if len(values) > 0 else None
                 if isinstance(hash_arg, str):
                     decorator.external_name = hash_arg
             return decorator
 
         return self
 
-    def validate_values(self, *params: Any) -> List[Any]:
+    def validate_values(self, *params: Any) -> list[Any]:
         values = []
         if len(params) != 2:
             return values
 
         origin, visitor = params
         values.append(self.external_name)
         from boa3.internal.analyser.astanalyser import IAstAnalyser
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/propertydecorator.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/propertydecorator.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Optional
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinDecorator
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.annotation import metatype
 from boa3.internal.model.type.classes.userclass import UserClass
 
@@ -15,18 +14,18 @@
 
         """
         @property
         def property_name(self):
             return something
         """
 
-    def update_args(self, args: ast.arguments, origin: Optional[ISymbol] = None):
+    def update_args(self, args: ast.arguments, origin: ISymbol | None = None):
         if isinstance(origin, UserClass) and len(args.args) == 1 and args.args[0].annotation is None:
             # the user doesn't need to explicitly write the type of the first argument if it's a classmethod
-            # the first argument is a Type[Class]
+            # the first argument is a type[Class]
             cls_type = metatype.metaType.build(origin)
             cls_type_annotation = (cls_type.meta_identifier
                                    if isinstance(cls_type, metatype.MetaType)
                                    else cls_type.identifier)
 
             cls_ast_annotation = ast.parse(cls_type_annotation).body[0].value
             cls_ast_annotation = set_internal_call(cls_ast_annotation)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/decorator/publicdecorator.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/publicdecorator.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,29 +1,30 @@
 import ast
-from typing import Any, Dict, List, Optional, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinDecorator
 from boa3.internal.model.type.type import Type
 from boa3.internal.model.variable import Variable
 
 
 class PublicDecorator(IBuiltinDecorator):
     def __init__(self):
         identifier = 'public'
-        args: Dict[str, Variable] = {'name': Variable(Type.str),
+        args: dict[str, Variable] = {'name': Variable(Type.str),
                                      'safe': Variable(Type.bool),
                                      }
 
         name_default = ast.parse("'{0}'".format(Type.str.default_value)).body[0].value
         safe_default = ast.parse("{0}".format(Type.bool.default_value)).body[0].value
 
         defaults = [name_default, safe_default]
         super().__init__(identifier, args, defaults)
 
-        self.name: Optional[str] = None
+        self.name: str | None = None
         self.safe = False
 
     def build(self, *args) -> IBuiltinDecorator:
         if isinstance(args, Sized) and len(args) > 0 and isinstance(args[0], ast.AST):
             decorator = PublicDecorator()
             origin = args[0]
             decorator._origin_node = origin
@@ -37,15 +38,15 @@
                 if isinstance(safe_arg, bool):
                     decorator.safe = safe_arg
 
             return decorator
 
         return self
 
-    def validate_values(self, *params: Any) -> List[Any]:
+    def validate_values(self, *params: Any) -> list[Any]:
         values = []
         if len(params) != 2:
             return values
 
         origin, visitor = params
         from boa3.internal.analyser.astanalyser import IAstAnalyser
         if not isinstance(origin, ast.Call) or not isinstance(visitor, IAstAnalyser):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/internal/getenvmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/internal/getenvmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Optional, Any
+from typing import Any
 
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.method import IBuiltinMethod
 
 
 class GetEnvMethod(IBuiltinMethod):
     def __init__(self, env: str = None):
@@ -17,15 +17,15 @@
     def _args_on_stack(self) -> int:
         return super()._args_on_stack
 
     def generate_opcodes(self, code_generator):
         code_generator.convert_literal(self._env)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def update_with_analyser(self, analyser):
         from boa3.internal.analyser.analyser import Analyser
         if isinstance(analyser, Analyser):
             self.reset()
             self._env = analyser.env
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/internal/innerdeploymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/internal/innerdeploymethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,52 +1,50 @@
-from __future__ import annotations
-
 import ast
-from typing import Dict, Optional
+from typing import Self
 
 from boa3.internal import constants
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.internal.internalmethod import IInternalMethod
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.method import Method
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.variable import Variable
 
 
 class InnerDeployMethod(IInternalMethod):
 
     @classmethod
-    def instance(cls) -> InnerDeployMethod:
+    def instance(cls) -> Self:
         return _INNER_DEPLOY_METHOD
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = constants.DEPLOY_METHOD_ID
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'data': Variable(Type.any),
             'update': Variable(Type.bool)
         }
         super().__init__(identifier, args, return_type=Type.none)
 
         self.is_public = True
         self._origin_node = set_internal_call(ast.parse(self._body).body[0])
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         method_args = [f"{var_id}: {var_type.type.raw_identifier}"
                        for var_id, var_type in self.args.items()
                        ]
 
         return f"def {self.identifier}({', '.join(method_args)}): return"
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
-    def copy(self) -> InnerDeployMethod:
+    def copy(self) -> Self:
         return InnerDeployMethod()
 
     @classmethod
     def is_valid_deploy_method(cls, symbol: ISymbol) -> bool:
         if isinstance(symbol, InnerDeployMethod):
             return True
         if isinstance(symbol, IBuiltinMethod):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/internal/internalmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/internal/internalmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,28 +1,31 @@
-from __future__ import annotations
-
 import abc
 import ast
-from typing import Dict, List, Optional, Tuple
+from typing import Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class IInternalMethod(IBuiltinMethod, abc.ABC):
 
-    def __init__(self, identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
-                 vararg: Optional[Tuple[str, Variable]] = None):
-        super().__init__(identifier, args, defaults, return_type, vararg)
+    def __init__(self,
+                 identifier: str,
+                 args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None,
+                 return_type: IType = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(identifier, args, defaults, return_type, vararg, deprecated=deprecated)
 
     @classmethod
     @abc.abstractmethod
-    def instance(cls) -> IInternalMethod:
+    def instance(cls) -> Self:
         pass
 
     @classmethod
     @abc.abstractmethod
     def is_valid_deploy_method(cls, symbol: ISymbol) -> bool:
         return False
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/blocktype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/blocktype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -19,60 +17,59 @@
         super().__init__('Block')
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 
         uint256 = UInt256Type.build()
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'hash': Variable(uint256),
             'version': Variable(Type.int),
             'previous_hash': Variable(uint256),
             'merkle_root': Variable(uint256),
             'timestamp': Variable(Type.int),
             'nonce': Variable(Type.int),
             'index': Variable(Type.int),
-            'primary_index': Variable(Type.int),
             'next_consensus': Variable(UInt160Type.build()),
             'transaction_count': Variable(Type.int)
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = BlockMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> BlockType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Block
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, BlockType)
 
@@ -80,38 +77,37 @@
 _Block = BlockType()
 
 
 class BlockMethod(IBuiltinMethod):
 
     def __init__(self, return_type: BlockType):
         identifier = '-Block__init__'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.neo3.core.types import UInt160, UInt256
 
         uint160_default = UInt160.zero().to_array()
         uint256_default = UInt256.zero().to_array()
 
         code_generator.convert_literal(0)  # transaction_count
         code_generator.convert_literal(uint160_default)  # next_consensus
-        code_generator.convert_literal(0)  # primary_index
         code_generator.convert_literal(0)  # index
         code_generator.convert_literal(0)  # nonce
         code_generator.convert_literal(0)  # timestamp
         code_generator.convert_literal(uint256_default)  # merkle_root
         code_generator.convert_literal(uint256_default)  # previous_hash
         code_generator.convert_literal(0)  # version
         code_generator.convert_literal(uint256_default)  # hash
-        code_generator.convert_new_array(length=10, array_type=self.type)
+        code_generator.convert_new_array(length=9, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/currenthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/currenthashmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
 class CurrentHashMethod(LedgerMethod):
     def __init__(self):
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
         identifier = '-get_current_hash'
         syscall = 'currentHash'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=UInt256Type.build())
 
 
 class CurrentHashProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'current_hash'
         getter = CurrentHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/currentindexmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/currentindexmethod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetCurrentIndexMethod(LedgerMethod):
     def __init__(self):
         identifier = 'get_current_index'
         syscall = 'currentIndex'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         from boa3.internal.model.type.type import Type
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
 
 class CurrentIndexProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'current_index'
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/getblockmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/getblockmethod.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.blockchain.blocktype import BlockType
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetBlockMethod(LedgerMethod):
 
     def __init__(self, block_type: BlockType):
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
         from boa3.internal.model.type.type import Type
 
         identifier = 'get_block'
         syscall = 'getBlock'
-        args: Dict[str, Variable] = {'index': Variable(Type.union.build([Type.int,
+        args: dict[str, Variable] = {'index': Variable(Type.union.build([Type.int,
                                                                          UInt256Type.build()]))}
         super().__init__(identifier, syscall, args, return_type=Type.optional.build(block_type))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/getcontractmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/getcontractmethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,17 +1,15 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.contract.contracttype import ContractType
 from boa3.internal.model.builtin.interop.nativecontract.ContractManagement.contractmanagementmethod import \
     ContractManagementMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetContractMethod(ContractManagementMethod):
 
     def __init__(self, contract_type: ContractType):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.type import Type
         identifier = 'get_contract'
         syscall = 'getContract'
-        args: Dict[str, Variable] = {'hash': Variable(UInt160Type.build())}
+        args: dict[str, Variable] = {'hash': Variable(UInt160Type.build())}
         super().__init__(identifier, syscall, args, return_type=Type.optional.build(contract_type))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionfromblockmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/verifywithecdsa.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,19 +1,20 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.blockchain.transactiontype import TransactionType
-from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
+from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetTransactionFromBlockMethod(LedgerMethod):
+class VerifyWithECDsaMethod(CryptoLibMethod):
 
-    def __init__(self, transaction_type: TransactionType):
-        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
+    def __init__(self):
         from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.builtin.interop.crypto.namedcurvetype import NamedCurveType
 
-        identifier = 'get_transaction_from_block'
-        syscall = 'getTransactionFromBlock'
-        args: Dict[str, Variable] = {'block_hash_or_height': Variable(Type.union.build([UInt256Type.build(),
-                                                                                        Type.int])),
-                                     'tx_index': Variable(Type.int)}
-        super().__init__(identifier, syscall, args, return_type=Type.optional.build(transaction_type))
+        identifier = 'verify_with_ecdsa'
+        native_identifier = 'verifyWithECDsa'
+        args: dict[str, Variable] = {
+            'data': Variable(Type.bytes),
+            'pubkey': Variable(ECPointType.build()),
+            'signature': Variable(Type.bytes),
+            'curve': Variable(NamedCurveType.build())
+        }
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionheightmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionheightmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetTransactionHeightMethod(LedgerMethod):
 
     def __init__(self):
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
         from boa3.internal.model.type.type import Type
 
         identifier = 'get_transaction_height'
         syscall = 'getTransactionHeight'
-        args: Dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
+        args: dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
         super().__init__(identifier, syscall, args, return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,15 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.blockchain.transactiontype import TransactionType
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetTransactionMethod(LedgerMethod):
 
     def __init__(self, transaction_type: TransactionType):
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
         from boa3.internal.model.type.type import Type
 
         identifier = 'get_transaction'
         syscall = 'getTransaction'
-        args: Dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
+        args: dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
         super().__init__(identifier, syscall, args, return_type=Type.optional.build(transaction_type))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionsignersmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionfromblockmethod.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.blockchain.signertype import SignerType
+from boa3.internal.model.builtin.interop.blockchain.transactiontype import TransactionType
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetTransactionSignersMethod(LedgerMethod):
+class GetTransactionFromBlockMethod(LedgerMethod):
 
-    def __init__(self, signer_type: SignerType):
+    def __init__(self, transaction_type: TransactionType):
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
         from boa3.internal.model.type.type import Type
 
-        identifier = 'get_transaction_signers'
-        syscall = 'getTransactionSigners'
-        args: Dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
-        super().__init__(identifier, syscall, args, return_type=Type.list.build([signer_type]))
+        identifier = 'get_transaction_from_block'
+        syscall = 'getTransactionFromBlock'
+        args: dict[str, Variable] = {'block_hash_or_height': Variable(Type.union.build([UInt256Type.build(),
+                                                                                        Type.int])),
+                                     'tx_index': Variable(Type.int)}
+        super().__init__(identifier, syscall, args, return_type=Type.optional.build(transaction_type))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/gettransactionvmstatemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionvmstatemethod.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.blockchain.vmstatetype import VMStateType
 from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetTransactionVMStateMethod(LedgerMethod):
 
     def __init__(self, vm_state_type: VMStateType):
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 
         identifier = 'get_transaction_vm_state'
         syscall = 'getTransactionVMState'
-        args: Dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
+        args: dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
         super().__init__(identifier, syscall, args, return_type=vm_state_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/signertype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/signertype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -21,55 +19,55 @@
         from boa3.internal.model.builtin.interop.blockchain.witnessruletype import WitnessRuleType
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
         uint160 = UInt160Type.build()
         list_uint160 = Type.list.build([uint160])
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'account': Variable(uint160),
             'scopes': Variable(WitnessScopeType.build()),
             'allowed_contracts': Variable(list_uint160),
             'allowed_groups': Variable(list_uint160),
             'rules': Variable(Type.list.build([WitnessRuleType.build()]))
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = SignerMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> SignerType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Signer
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, SignerType)
 
@@ -77,15 +75,15 @@
 _Signer = SignerType()
 
 
 class SignerMethod(IBuiltinMethod):
 
     def __init__(self, return_type: SignerType):
         identifier = '-Signer__init__'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.neo3.core.types import UInt160
@@ -100,9 +98,9 @@
         code_generator.convert_new_array(length=5, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/transactiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/transactiontype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -17,58 +15,58 @@
 
     def __init__(self):
         super().__init__('Transaction')
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'hash': Variable(UInt256Type.build()),
             'version': Variable(Type.int),
             'nonce': Variable(Type.int),
             'sender': Variable(UInt160Type.build()),
             'system_fee': Variable(Type.int),
             'network_fee': Variable(Type.int),
             'valid_until_block': Variable(Type.int),
             'script': Variable(Type.bytes),
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = TransactionMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> TransactionType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Transaction
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, TransactionType)
 
@@ -76,15 +74,15 @@
 _Transaction = TransactionType()
 
 
 class TransactionMethod(IBuiltinMethod):
 
     def __init__(self, return_type: TransactionType):
         identifier = '-Transaction__init__'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.neo3.core.types import UInt160, UInt256
@@ -103,9 +101,9 @@
         code_generator.convert_new_array(length=8, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/vmstatetype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/vmstatetype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.primitive.inttype import IntType
 from boa3.internal.neo3.vm import VMState
 
 
 class VMStateType(IntType):
@@ -17,24 +15,24 @@
         self._identifier = 'VMState'
 
     @property
     def default_value(self) -> Any:
         return VMState.NONE
 
     @classmethod
-    def build(cls, value: Any = None) -> VMStateType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _VMState
 
     @classmethod
     def _is_type_of(cls, value: Any = None):
         return isinstance(value, (VMState, VMStateType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessconditionenumtype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessconditionenumtype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.primitive.inttype import IntType
 from boa3.internal.neo3.network.payloads.verification import WitnessConditionType as WitnessCondition
 
 
 class WitnessConditionType(IntType):
@@ -17,24 +15,24 @@
         self._identifier = 'WitnessConditionType'
 
     @property
     def default_value(self) -> Any:
         return WitnessCondition.BOOLEAN
 
     @classmethod
-    def build(cls, value: Any = None) -> WitnessConditionType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _WitnessConditionType
 
     @classmethod
     def _is_type_of(cls, value: Any = None):
         return isinstance(value, (WitnessCondition, WitnessConditionType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessconditiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessconditiontype.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -15,51 +13,51 @@
     A class used to represent Neo WitnessCondition class
     """
 
     def __init__(self):
         super().__init__('WitnessCondition')
         from boa3.internal.model.builtin.interop.blockchain.witnessconditionenumtype import WitnessConditionType as WitnessConditionEnum
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'type': Variable(WitnessConditionEnum.build())
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = WitnessConditionMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> WitnessConditionType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _WitnessCondition
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, WitnessConditionType)
 
@@ -67,15 +65,15 @@
 _WitnessCondition = WitnessConditionType()
 
 
 class WitnessConditionMethod(IBuiltinMethod):
 
     def __init__(self, return_type: WitnessConditionType):
         identifier = '-WitnessCondition__init__'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.blockchain.witnessconditionenumtype import WitnessConditionType as WitnessConditionEnum
@@ -84,9 +82,9 @@
         code_generator.convert_new_array(length=1, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessruleactiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessruleactiontype.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.primitive.inttype import IntType
 from boa3.internal.neo3.network.payloads.verification import WitnessRuleAction
 
 
 class WitnessRuleActionType(IntType):
@@ -17,24 +15,24 @@
         self._identifier = 'WitnessRuleAction'
 
     @property
     def default_value(self) -> Any:
         return WitnessRuleAction.DENY
 
     @classmethod
-    def build(cls, value: Any = None) -> WitnessRuleActionType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _WitnessRuleAction
 
     @classmethod
     def _is_type_of(cls, value: Any = None):
         return isinstance(value, (WitnessRuleAction, WitnessRuleActionType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessruletype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessruletype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -16,52 +14,52 @@
     """
 
     def __init__(self):
         super().__init__('WitnessRule')
         from boa3.internal.model.builtin.interop.blockchain.witnessruleactiontype import WitnessRuleActionType
         from boa3.internal.model.builtin.interop.blockchain.witnessconditiontype import WitnessConditionType
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'action': Variable(WitnessRuleActionType.build()),
             'condition': Variable(WitnessConditionType.build())
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = WitnessRuleMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> WitnessRuleType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _WitnessRule
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, WitnessRuleType)
 
@@ -69,15 +67,15 @@
 _WitnessRule = WitnessRuleType()
 
 
 class WitnessRuleMethod(IBuiltinMethod):
 
     def __init__(self, return_type: WitnessRuleType):
         identifier = '-WitnessRule__init__'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.blockchain.witnessconditiontype import WitnessConditionType
@@ -88,9 +86,9 @@
         code_generator.convert_new_array(length=2, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/blockchain/witnessscopeenumtype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/witnessscopeenumtype.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.primitive.inttype import IntType
 from boa3.internal.neo3.network.payloads.verification import WitnessScope
 
 
 class WitnessScopeType(IntType):
@@ -17,24 +15,24 @@
         self._identifier = 'WitnessScope'
 
     @property
     def default_value(self) -> Any:
         return WitnessScope.NONE
 
     @classmethod
-    def build(cls, value: Any = None) -> WitnessScopeType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _WitnessScope
 
     @classmethod
     def _is_type_of(cls, value: Any = None):
         return isinstance(value, (WitnessScope, WitnessScopeType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/callflagstype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/callflagstype.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class CallFlagsType(IntType):
@@ -26,15 +26,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.contract import CallFlags
         return isinstance(value, (CallFlags, CallFlagsType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.contract import CallFlags
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/callmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/callmethod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Dict, List
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class CallMethod(InteropMethod):
@@ -12,30 +11,30 @@
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.builtin.interop.contract.callflagstype import CallFlagsType
         from boa3.internal.model.type.type import Type
         identifier = 'call_contract'
         syscall = 'System.Contract.Call'
 
         call_flags = CallFlagsType.build()
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'script_hash': Variable(UInt160Type.build()),
             'method': Variable(Type.str),
             'args': Variable(Type.sequence),  # TODO: change when *args is implemented #2kq1hzg
             'call_flags': Variable(call_flags)
         }
         args_default = ast.parse("{0}".format(Type.sequence.default_value)
                                  ).body[0].value
         call_flags_default = set_internal_call(ast.parse("{0}.{1}".format(call_flags.identifier,
                                                                           call_flags.default_value.name)
                                                          ).body[0].value)
 
         super().__init__(identifier, syscall, args, defaults=[args_default, call_flags_default], return_type=Type.any)
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         """
         Gets the indexes order that need to be used during code generation.
         If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
 
         :return: Index order for code generation
         """
         indexes = super().generation_order
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractabitype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractabitype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classstructtype import ClassStructType
 from boa3.internal.model.variable import Variable
 
 
@@ -17,49 +15,49 @@
         super().__init__('ContractAbi')
         from boa3.internal.model.builtin.interop.contract.contractmanifest.contractmethoddescriptortype import \
             ContractMethodDescriptorType
         from boa3.internal.model.builtin.interop.contract.contractmanifest.contracteventdescriptortype import \
             ContractEventDescriptorType
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'methods': Variable(Type.list.build_collection(ContractMethodDescriptorType.build())),
             'events': Variable(Type.list.build_collection(ContractEventDescriptorType.build()))
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractAbiType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractAbi
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractAbiType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classstructtype import ClassStructType
 from boa3.internal.model.variable import Variable
 
 
@@ -15,49 +13,49 @@
 
     def __init__(self):
         super().__init__('ContractEventDescriptor')
         from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
             ContractParameterDefinitionType
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'name': Variable(Type.str),
             'parameters': Variable(Type.list.build_collection(ContractParameterDefinitionType.build()))
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractEventDescriptorType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractEventDescriptor
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractEventDescriptorType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractgrouptype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractgrouptype.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classstructtype import ClassStructType
 from boa3.internal.model.variable import Variable
 
 
@@ -14,49 +12,49 @@
     """
 
     def __init__(self):
         super().__init__('ContractGroup')
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'pubkey': Variable(ECPointType.build()),
             'signature': Variable(Type.bytes)
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractGroupType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractGroup
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractGroupType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classstructtype import ClassStructType
 from boa3.internal.model.variable import Variable
 
 
@@ -13,55 +11,55 @@
     A class used to represent Neo ContractManifest class
     """
 
     def __init__(self):
         super().__init__('ContractManifest')
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'name': Variable(Type.str),
             'groups': Variable(Type.list),
             '-features': Variable(Type.dict),
             'supported_standards': Variable(Type.list.build_collection([Type.str])),
             'abi': Variable(Type.any),
             'permissions': Variable(Type.list),
             'trusts': Variable(Type.optional.build(Type.list)),
             'extras': Variable(Type.str)
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractManifestType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractManifest
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractManifestType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/createeventmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,69 +1,65 @@
-from __future__ import annotations
+from typing import Any
 
-from typing import Any, Dict, Optional
-
-from boa3.internal.model.method import Method
-from boa3.internal.model.property import Property
-from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
+from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class ContractMethodDescriptorType(ClassStructType):
-    """
-    A class used to represent Neo ContractMethodDescriptor class
-    """
-
+class CreateEventMethod(IBuiltinMethod):
     def __init__(self):
-        super().__init__('ContractMethodDescriptor')
-        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
-            ContractParameterDefinitionType
-        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
+        import ast
         from boa3.internal.model.type.type import Type
-
-        self._variables: Dict[str, Variable] = {
-            'name': Variable(Type.str),
-            'parameters': Variable(Type.list.build_collection(ContractParameterDefinitionType.build())),
-            'return_type': Variable(ContractParameterType.build()),
-            'offset': Variable(Type.int),
-            'safe': Variable(Type.bool)
+        from boa3.internal.model.type.typeutils import TypeUtils
+        identifier = 'CreateNewEvent'
+        args = {
+            'arguments': Variable(Type.list.build(
+                Type.tuple.build_collection((Type.str, TypeUtils.type))
+            )),
+            'event_name': Variable(Type.str)
         }
-        self._constructor: Method = None
+        event_name_default = ast.parse("'{0}'".format(Type.str.default_value)
+                                       ).body[0].value
+        super().__init__(identifier, args, defaults=[event_name_default], return_type=EventType)
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
-        return {}
+    def arguments_type(self) -> ListType:
+        return self.args['arguments'].type
 
-    @property
-    def instance_variables(self) -> Dict[str, Variable]:
-        return self._variables.copy()
+    def validate_parameters(self, *params: IExpression) -> bool:
+        return len(params) == len(self.args)
 
     @property
-    def properties(self) -> Dict[str, Property]:
-        return {}
+    def _args_on_stack(self) -> int:
+        return 0
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
-        return {}
+    def _body(self) -> str | None:
+        return None
 
-    @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
 
-    @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
+class __EventType(IType):
+    """
+    A class used to represent an Neo event
+    """
 
-    def constructor_method(self) -> Optional[Method]:
-        return self._constructor
+    def __init__(self):
+        identifier = 'Event'
+        super().__init__(identifier)
+
+    @property
+    def abi_type(self) -> AbiType:
+        return AbiType.Void
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractMethodDescriptorType:
-        if value is None or cls._is_type_of(value):
-            return _ContractMethodDescriptor
+    def build(cls, value: Any) -> IType:
+        return EventType
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, ContractMethodDescriptorType)
+        return value is EventType
 
 
-_ContractMethodDescriptor = ContractMethodDescriptorType()
+EventType = __EventType()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classstructtype import ClassStructType
 from boa3.internal.model.variable import Variable
 
 
@@ -14,49 +12,49 @@
     """
 
     def __init__(self):
         super().__init__('ContractParameterDefinition')
         from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'name': Variable(Type.str),
             'type': Variable(ContractParameterType.build())
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractParameterDefinitionType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractParameterDefinition
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractParameterDefinitionType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparametertype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparametertype.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class ContractParameterType(IntType):
@@ -26,15 +26,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
         return isinstance(value, (ContractParameter, ContractParameterType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classstructtype import ClassStructType
 from boa3.internal.model.variable import Variable
 
 
@@ -15,49 +13,49 @@
 
     def __init__(self):
         super().__init__('ContractPermissionDescriptor')
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'hash': Variable(Type.optional.build(UInt160Type.build())),
             'group': Variable(Type.optional.build(ECPointType.build()))
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractPermissionDescriptorType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractPermissionDescriptor
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractPermissionDescriptorType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
 
 
@@ -13,49 +11,49 @@
     A class used to represent Neo ContractPermission class
     """
 
     def __init__(self):
         super().__init__('ContractPermission')
         from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'contract': Variable(Type.str),
             'methods': Variable(Type.optional.build(Type.list.build_collection([Type.str])))
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractPermissionType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractPermission
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractPermissionType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/contracttype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/contracttype.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -17,55 +15,55 @@
 
     def __init__(self):
         super().__init__('Contract')
         from boa3.internal.model.builtin.interop.contract.contractmanifest import ContractManifestType
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
-        self._variables: Dict[str, Variable] = {
+        self._variables: dict[str, Variable] = {
             'id': Variable(Type.int),
             'update_counter': Variable(Type.int),
             'hash': Variable(UInt160Type.build()),
             'nef': Variable(Type.bytes),
             'manifest': Variable(ContractManifestType.build())
         }
         self._constructor: Method = None
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = ContractMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Contract
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractType)
 
@@ -73,15 +71,15 @@
 _Contract = ContractType()
 
 
 class ContractMethod(IBuiltinMethod):
 
     def __init__(self, return_type: ContractType):
         identifier = '-Contract__init__'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.contract.contractmanifest import ContractManifestType
@@ -97,9 +95,9 @@
         code_generator.convert_new_array(length=5, array_type=self.type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/createmultisigaccountmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/registercandidatemethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,16 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class CreateMultisigAccountMethod(InteropMethod):
+class RegisterCandidateMethod(NeoContractMethod):
 
     def __init__(self):
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
         from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        identifier = 'create_multisig_account'
-        syscall = 'System.Contract.CreateMultisigAccount'
-        args: Dict[str, Variable] = {
-            'm': Variable(Type.int),
-            'pub_keys': Variable(Type.list.build_collection([ECPointType.build()]))
+        identifier = 'register_candidate'
+        native_identifier = 'registerCandidate'
+        args: dict[str, Variable] = {
+            'pubkey': Variable(ECPointType.build())
         }
-        super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/createstandardaccountmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/createstandardaccountmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class CreateStandardAccountMethod(InteropMethod):
 
     def __init__(self):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
         identifier = 'create_standard_account'
         syscall = 'System.Contract.CreateStandardAccount'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'pub_key': Variable(ECPointType.build())
         }
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getcallflagsmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getblocktimemethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,14 +1,19 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.contract.callflagstype import CallFlagsType
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetCallFlagsMethod(InteropMethod):
+class GetBlockTimeMethod(InteropMethod):
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        identifier = '-get_time'
+        syscall = 'System.Runtime.GetTime'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, syscall, args, return_type=Type.int)
+
 
-    def __init__(self, call_flags_type: CallFlagsType):
-        identifier = 'get_call_flags'
-        syscall = 'System.Contract.GetCallFlags'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=call_flags_type)
+class BlockTimeProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'time'
+        getter = GetBlockTimeMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getgasscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Neo/getneoscripthashmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,29 +1,27 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.nativecontract.Nep17.getnep17scripthashmethod import GetNep17ScriptHashMethod
 
 
-class GetGasScriptHashMethod(GetNep17ScriptHashMethod):
+class GetNeoScriptHashMethod(GetNep17ScriptHashMethod):
     def __init__(self):
-        from boa3.internal.constants import GAS_SCRIPT
-        identifier = '-get_gas'
-        super().__init__(GAS_SCRIPT, identifier)
+        from boa3.internal.constants import NEO_SCRIPT
+        identifier = '-get_neo_contract'
+        super().__init__(NEO_SCRIPT, identifier)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
-class GasProperty(IBuiltinProperty):
+class NeoContractProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'GAS'
-        getter = GetGasScriptHashMethod()
+        identifier = 'NeoContract'
+        getter = GetNeoScriptHashMethod()
         super().__init__(identifier, getter)
 
 
-GasToken = GasProperty()
+NeoContract = NeoContractProperty()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getminimumdeploymentfeemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/updatemethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,14 +1,20 @@
-from typing import Dict
+import ast
 
 from boa3.internal.model.builtin.interop.nativecontract import ContractManagementMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetMinimumDeploymentFeeMethod(ContractManagementMethod):
+class UpdateMethod(ContractManagementMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'get_minimum_deployment_fee'
-        syscall = 'getMinimumDeploymentFee'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+        identifier = 'update_contract'
+        syscall = 'update'
+        args: dict[str, Variable] = {
+            'nef_file': Variable(Type.bytes),
+            'manifest': Variable(Type.bytes),
+            'data': Variable(Type.any)
+        }
+        data_default = ast.parse("{0}".format(Type.any.default_value)
+                                 ).body[0].value
+        super().__init__(identifier, syscall, args, defaults=[data_default], return_type=Type.none)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/getneoscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/getneoscripthashmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.nativecontract.Nep17.getnep17scripthashmethod import GetNep17ScriptHashMethod
 
 
 class GetNeoScriptHashMethod(GetNep17ScriptHashMethod):
     def __init__(self):
         from boa3.internal.constants import NEO_SCRIPT
@@ -11,15 +9,15 @@
         super().__init__(NEO_SCRIPT, identifier)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class NeoProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'NEO'
         getter = GetNeoScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contract/updatemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381mulmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,20 @@
-import ast
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import ContractManagementMethod
+from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class UpdateMethod(ContractManagementMethod):
+class Bls12381MulMethod(CryptoLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'update_contract'
-        syscall = 'update'
-        args: Dict[str, Variable] = {
-            'nef_file': Variable(Type.bytes),
-            'manifest': Variable(Type.bytes),
-            'data': Variable(Type.any)
+        from boa3.internal.model.builtin.interop.crypto import Bls12381Type
+
+        bls12_381_type = Bls12381Type.build()
+
+        identifier = 'bls12_381_mul'
+        native_identifier = 'bls12381Mul'
+        args: dict[str, Variable] = {
+            'x': Variable(bls12_381_type),
+            'mul': Variable(Type.bytes),
+            'neg': Variable(Type.bool),
         }
-        data_default = ast.parse("{0}".format(Type.any.default_value)
-                                 ).body[0].value
-        super().__init__(identifier, syscall, args, defaults=[data_default], return_type=Type.none)
+        super().__init__(identifier, native_identifier, args, return_type=bls12_381_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/contractgethashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contractgethashmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,23 +1,20 @@
-from __future__ import annotations
-
 import ast
 from abc import ABC
-from typing import Dict, List, Optional, Tuple
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class ContractGetHashMethod(IBuiltinMethod, ABC):
-    def __init__(self, script_hash: bytes, identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None):
+    def __init__(self, script_hash: bytes, identifier: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None):
         self._script_hash = script_hash
         super().__init__(identifier, args, defaults, return_type, vararg, kwargs)
 
     @property
     def script_hash(self) -> bytes:
         return self._script_hash
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381addmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381addmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
 class Bls12381AddMethod(CryptoLibMethod):
 
     def __init__(self):
         from boa3.internal.model.builtin.interop.crypto import Bls12381Type
         bls12_381_type = Bls12381Type.build()
 
         identifier = 'bls12_381_add'
         native_identifier = 'bls12381Add'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'x': Variable(bls12_381_type),
             'y': Variable(bls12_381_type),
         }
         super().__init__(identifier, native_identifier, args, return_type=bls12_381_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381deserializemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381serializemethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class Bls12381DeserializeMethod(CryptoLibMethod):
+class Bls12381SerializeMethod(CryptoLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.crypto import Bls12381Type
 
-        identifier = 'bls12_381_deserialize'
-        native_identifier = 'bls12381Deserialize'
-        args: Dict[str, Variable] = {
-            'data': Variable(Type.bytes),
+        identifier = 'bls12_381_serialize'
+        native_identifier = 'bls12381Serialize'
+        args: dict[str, Variable] = {
+            'g': Variable(Bls12381Type.build()),
         }
-        super().__init__(identifier, native_identifier, args, return_type=Bls12381Type.build())
+        super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381equalmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381deserializemethod.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,21 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class Bls12381EqualMethod(CryptoLibMethod):
+class Bls12381DeserializeMethod(CryptoLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.crypto import Bls12381Type
 
-        bls12_381_type = Bls12381Type.build()
-
-        identifier = 'bls12_381_equal'
-        native_identifier = 'bls12381Equal'
-        args: Dict[str, Variable] = {
-            'x': Variable(bls12_381_type),
-            'y': Variable(bls12_381_type),
+        identifier = 'bls12_381_deserialize'
+        native_identifier = 'bls12381Deserialize'
+        args: dict[str, Variable] = {
+            'data': Variable(Type.bytes),
         }
-        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
+        super().__init__(identifier, native_identifier, args, return_type=Bls12381Type.build())
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381mulmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381equalmethod.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,22 +1,19 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class Bls12381MulMethod(CryptoLibMethod):
+class Bls12381EqualMethod(CryptoLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.crypto import Bls12381Type
 
         bls12_381_type = Bls12381Type.build()
 
-        identifier = 'bls12_381_mul'
-        native_identifier = 'bls12381Mul'
-        args: Dict[str, Variable] = {
+        identifier = 'bls12_381_equal'
+        native_identifier = 'bls12381Equal'
+        args: dict[str, Variable] = {
             'x': Variable(bls12_381_type),
-            'mul': Variable(Type.bytes),
-            'neg': Variable(Type.bool),
+            'y': Variable(bls12_381_type),
         }
-        super().__init__(identifier, native_identifier, args, return_type=bls12_381_type)
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381pairingmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381pairingmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
 class Bls12381PairingMethod(CryptoLibMethod):
 
     def __init__(self):
         from boa3.internal.model.builtin.interop.crypto import Bls12381Type
 
         bls12_381_type = Bls12381Type.build()
 
         identifier = 'bls12_381_pairing'
         native_identifier = 'bls12381Pairing'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'g1': Variable(bls12_381_type),
             'g2': Variable(bls12_381_type),
         }
         super().__init__(identifier, native_identifier, args, return_type=bls12_381_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381serializemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/memorycomparemethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,18 +1,19 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
+from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class Bls12381SerializeMethod(CryptoLibMethod):
+class MemoryCompareMethod(StdLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        from boa3.internal.model.builtin.interop.crypto import Bls12381Type
 
-        identifier = 'bls12_381_serialize'
-        native_identifier = 'bls12381Serialize'
-        args: Dict[str, Variable] = {
-            'g': Variable(Bls12381Type.build()),
+        identifier = 'memory_compare'
+        syscall = 'memoryCompare'
+        byte_string_type = Type.union.build([Type.bytes, Type.str])
+
+        args: dict[str, Variable] = {
+            'mem1': Variable(byte_string_type),
+            'mem2': Variable(byte_string_type)
         }
-        super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
+
+        super().__init__(identifier, syscall, args, return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/bls12381type.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/bls12381type.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/checkmultisigmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/checkmultisigmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class CheckMultisigMethod(InteropMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
         identifier = 'check_multisig'
         syscall = 'System.Crypto.CheckMultisig'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'pubkeys': Variable(Type.list.build_collection([ECPointType.build()])),
             'signatures': Variable(Type.list.build_collection([Type.bytes]))
         }
         super().__init__(identifier, syscall, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/checksigmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/checksigmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class CheckSigMethod(InteropMethod):
 
     _RAW_BYTES = b''
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
         identifier = 'check_sig'
         syscall = 'System.Crypto.CheckSig'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'pubkeys': Variable(ECPointType.build()),
             'signatures': Variable(Type.bytes)
         }
         super().__init__(identifier, syscall, args, return_type=Type.bool)
 
     @classmethod
     def get_raw_bytes(cls) -> bytes:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/hash160method.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/hash256method.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,24 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class Hash160Method(CryptoLibMethod):
-
+class Hash256Method(CryptoLibMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'hash160'
-        native_identifier = ''  # hash160 is not neo native
-        args: Dict[str, Variable] = {'key': Variable(Type.any)}
+        identifier = 'hash256'
+        native_identifier = ''  # hash256 is not neo native
+        args: dict[str, Variable] = {'key': Variable(Type.any)}
         super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
 
     @property
     def pack_arguments(self) -> bool:
         if self._pack_arguments is None:
             from boa3.internal.model.builtin.interop.interop import Interop
             self._pack_arguments = Interop.Sha256.pack_arguments  # this is the first method called
         return self._pack_arguments
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.interop import Interop
 
         code_generator.convert_builtin_method_call(Interop.Sha256, is_internal=True)
-        code_generator.convert_builtin_method_call(Interop.Ripemd160, is_internal=True)
+        code_generator.convert_builtin_method_call(Interop.Sha256, is_internal=True)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/hash256method.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/hash160method.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,26 +1,25 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class Hash256Method(CryptoLibMethod):
+class Hash160Method(CryptoLibMethod):
+
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'hash256'
-        native_identifier = ''  # hash256 is not neo native
-        args: Dict[str, Variable] = {'key': Variable(Type.any)}
+        identifier = 'hash160'
+        native_identifier = ''  # hash160 is not neo native
+        args: dict[str, Variable] = {'key': Variable(Type.any)}
         super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
 
     @property
     def pack_arguments(self) -> bool:
         if self._pack_arguments is None:
             from boa3.internal.model.builtin.interop.interop import Interop
             self._pack_arguments = Interop.Sha256.pack_arguments  # this is the first method called
         return self._pack_arguments
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.interop import Interop
 
         code_generator.convert_builtin_method_call(Interop.Sha256, is_internal=True)
-        code_generator.convert_builtin_method_call(Interop.Sha256, is_internal=True)
+        code_generator.convert_builtin_method_call(Interop.Ripemd160, is_internal=True)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/murmur32method.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/murmur32method.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,17 +1,15 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
 from boa3.internal.model.variable import Variable
 
 
 class Murmur32Method(CryptoLibMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
         identifier = 'murmur32'
         native_identifier = 'murmur32'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'data': Variable(Type.bytes),
             'seed': Variable(Type.int),
         }
         super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/namedcurvetype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/crypto/namedcurvetype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class NamedCurveType(IntType):
@@ -21,15 +21,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.crypto import NamedCurve
         return isinstance(value, (NamedCurve, NamedCurveType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.crypto import NamedCurve
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/crypto/verifywithecdsa.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/memorysearchmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,22 +1,31 @@
-from typing import Dict
+import ast
 
-from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class VerifyWithECDsaMethod(CryptoLibMethod):
+class MemorySearchMethod(StdLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.internal.model.builtin.interop.crypto.namedcurvetype import NamedCurveType
 
-        identifier = 'verify_with_ecdsa'
-        native_identifier = 'verifyWithECDsa'
-        args: Dict[str, Variable] = {
-            'data': Variable(Type.bytes),
-            'pubkey': Variable(ECPointType.build()),
-            'signature': Variable(Type.bytes),
-            'curve': Variable(NamedCurveType.build())
+        identifier = 'memory_search'
+        native_identifier = 'memorySearch'
+        byte_string_type = Type.union.build([Type.bytes, Type.str])
+
+        args: dict[str, Variable] = {
+            'mem': Variable(byte_string_type),
+            'value': Variable(byte_string_type),
+            'start': Variable(Type.int),
+            'backward': Variable(Type.bool),
         }
-        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
+
+        start_default = set_internal_call(ast.parse("{0}".format(Type.int.default_value)
+                                                    ).body[0].value)
+        backward_default = set_internal_call(ast.parse("{0}".format(Type.bool.default_value)
+                                                       ).body[0].value)
+
+        super().__init__(identifier, native_identifier, args,
+                         defaults=[start_default, backward_default],
+                         return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interop.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interop.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 from enum import Enum
-from typing import Dict, List, Optional
 
 from boa3.internal.model.builtin.interop.blockchain import *
 from boa3.internal.model.builtin.interop.contract import *
 from boa3.internal.model.builtin.interop.contract.contractmanifest import *
 from boa3.internal.model.builtin.interop.crypto import *
 from boa3.internal.model.builtin.interop.iterator import *
 from boa3.internal.model.builtin.interop.json import *
@@ -35,33 +34,33 @@
     Runtime = 'runtime'
     Stdlib = 'stdlib'
     Storage = 'storage'
 
 
 class Interop:
     @classmethod
-    def get_symbol(cls, symbol_id: str) -> Optional[IdentifiedSymbol]:
+    def get_symbol(cls, symbol_id: str) -> IdentifiedSymbol | None:
         for pkg_symbols in cls._interop_symbols.values():
             for method in pkg_symbols:
                 if method.identifier == symbol_id:
                     return method
 
     @classmethod
-    def interop_symbols(cls, package: str = None) -> List[IdentifiedSymbol]:
+    def interop_symbols(cls, package: str = None) -> list[IdentifiedSymbol]:
         if package in InteropPackage.__members__.values():
             return cls._interop_symbols[package]
 
-        lst: List[IdentifiedSymbol] = []
+        lst: list[IdentifiedSymbol] = []
         for symbols in cls._interop_symbols.values():
             lst.extend(symbols)
         return lst
 
     @classmethod
-    def interop_events(cls) -> List[Event]:
-        lst: List[Event] = []
+    def interop_events(cls) -> list[Event]:
+        lst: list[Event] = []
         for symbols in cls._interop_symbols.values():
             lst.extend([event for event in symbols if isinstance(event, Event)])
 
         return lst
 
     # region Interops
 
@@ -189,16 +188,28 @@
     Serialize = SerializeMethod()
 
     # Storage Interops
     StorageDelete = StorageDeleteMethod()
     StorageFind = StorageFindMethod(FindOptionsType)
     StorageGetContext = StorageGetContextMethod(StorageContextType)
     StorageGetReadOnlyContext = StorageGetReadOnlyContextMethod(StorageContextType)
-    StorageGet = StorageGetMethod()
-    StoragePut = StoragePutMethod()
+    StorageGet = StorageGetBytesMethod()
+    StorageGetInt = StorageGetIntMethod()
+    StorageGetBool = StorageGetBoolMethod()
+    StorageGetStr = StorageGetStrMethod()
+    StorageGetUInt160 = StorageGetUInt160Method()
+    StorageGetUInt256 = StorageGetUInt256Method()
+    StorageGetECPoint = StorageGetECPointMethod()
+    StoragePut = StoragePutBytesMethod()
+    StoragePutInt = StoragePutIntMethod()
+    StoragePutBool = StoragePutBoolMethod()
+    StoragePutStr = StoragePutStrMethod()
+    StoragePutUInt160 = StoragePutUInt160Method()
+    StoragePutUInt256 = StoragePutUInt256Method()
+    StoragePutECPoint = StoragePutECPointMethod()
 
     # endregion
 
     # region Packages
 
     BlockModule = Package(identifier=BlockType.identifier.lower(),
                           types=[BlockType]
@@ -424,38 +435,50 @@
                              types=[FindOptionsType,
                                     StorageContextType,
                                     StorageMapType
                                     ],
                              methods=[StorageDelete,
                                       StorageFind,
                                       StorageGet,
+                                      StorageGetInt,
+                                      StorageGetBool,
+                                      StorageGetStr,
+                                      StorageGetUInt160,
+                                      StorageGetUInt256,
+                                      StorageGetECPoint,
                                       StorageGetContext,
                                       StorageGetReadOnlyContext,
-                                      StoragePut
+                                      StoragePut,
+                                      StoragePutInt,
+                                      StoragePutBool,
+                                      StoragePutStr,
+                                      StoragePutUInt160,
+                                      StoragePutUInt256,
+                                      StoragePutECPoint,
                                       ],
                              packages=[FindOptionsModule,
                                        StorageContextModule,
                                        StorageMapModule
                                        ]
                              )
 
     # endregion
 
-    package_symbols: List[IdentifiedSymbol] = [
+    package_symbols: list[IdentifiedSymbol] = [
         OracleType,
         BlockchainPackage,
         ContractPackage,
         CryptoPackage,
         IteratorPackage,
         JsonPackage,
         OraclePackage,
         PolicyPackage,
         RolePackage,
         RuntimePackage,
         StdlibPackage,
         StoragePackage
     ]
 
-    _interop_symbols: Dict[InteropPackage, List[IdentifiedSymbol]] = {
+    _interop_symbols: dict[InteropPackage, list[IdentifiedSymbol]] = {
         package.identifier: list(package.symbols.values()) for package in package_symbols if
         isinstance(package, Package)
     }
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interopevent.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interopevent.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,25 @@
 import ast
 from abc import ABC
-from typing import Dict, List
 
 from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
 from boa3.internal.model.variable import Variable
 
 
 class InteropEvent(IBuiltinEvent, ABC):
 
-    def __init__(self, identifier: str, sys_call: str,
-                 args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+    def __init__(self,
+                 identifier: str,
+                 sys_call: str,
+                 args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None,
+                 deprecated: bool = False
+                 ):
         self._sys_call: str = sys_call
-        super().__init__(identifier, args, defaults)
+        super().__init__(identifier, args, defaults, deprecated=deprecated)
 
     @property
     def interop_method_hash(self) -> bytes:
         return self._method_hash(self._sys_call)
 
     def _method_hash(self, method_name: str) -> bytes:
         from boa3.internal.constants import SIZE_OF_INT32
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interopinterfacetype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interopinterfacetype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/interopmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/interopmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,29 +1,34 @@
 import ast
 from abc import ABC
-from typing import Dict, List, Optional
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class InteropMethod(IBuiltinMethod, ABC):
 
-    def __init__(self, identifier: str, sys_call: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
+    def __init__(self,
+                 identifier: str,
+                 sys_call: str,
+                 args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None,
+                 return_type: IType = None,
+                 deprecated: bool = False
+                 ):
         self._sys_call: str = sys_call
-        super().__init__(identifier, args, defaults, return_type)
+        super().__init__(identifier, args, defaults, return_type, deprecated=deprecated)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if any(not isinstance(param, IExpression) for param in params):
             return False
 
-        args: List[IType] = [arg.type for arg in self.args.values()]
+        args: list[IType] = [arg.type for arg in self.args.values()]
         if len(params) != len(args):
             return False
         return all(args[index].is_type_of(params[index]) for index in range(len(args)))
 
     @property
     def interop_method_hash(self) -> bytes:
         return self._method_hash(self._sys_call)
@@ -43,9 +48,9 @@
         return Opcode.SYSCALL + self.interop_method_hash
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/getiteratorvalue.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/getiteratorvalue.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
 from boa3.internal.model.variable import Variable
 
 
 class GetIteratorValue(InteropMethod):
     def __init__(self, iterator: IteratorType):
         syscall = 'System.Iterator.Value'
         identifier = '-get_iterator_value'
-        args: Dict[str, Variable] = {'self': Variable(iterator)}
+        args: dict[str, Variable] = {'self': Variable(iterator)}
 
         result_type = iterator.item_type
         from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
         if isinstance(iterator._origin_collection, MappingType):
             from boa3.internal.model.type.type import Type
             result_type = Type.tuple.build((iterator.key_type, iterator.item_type))
         super().__init__(identifier, syscall, args, return_type=result_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/iteratorinitmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/iteratorinitmethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,34 +1,35 @@
-from typing import Any, Dict, Optional, Sequence
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.variable import Variable
 
 
 class IteratorMethod(InteropMethod):
 
     def __init__(self, return_type: IteratorType):
         identifier = '-Iterator__init__'
         syscall = 'System.Iterator.Create'
         from boa3.internal.model.type.type import Type
-        args: Dict[str, Variable] = {'entry': Variable(Type.collection)}
+        args: dict[str, Variable] = {'entry': Variable(Type.collection)}
         super().__init__(identifier, syscall, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def _entry_arg(self) -> Variable:
         return self.args['entry']
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, Sequence) and len(value) == 1:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/iteratornextmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/iteratornextmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
 from boa3.internal.model.variable import Variable
 
 
 class IteratorNextMethod(InteropMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
         syscall = 'System.Iterator.Next'
         identifier = '-iterator_next'
-        args: Dict[str, Variable] = {'self': Variable(IteratorType.build())}
+        args: dict[str, Variable] = {'self': Variable(IteratorType.build())}
         super().__init__(identifier, syscall, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/iterator/iteratortype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/iterator/iteratortype.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, List, Optional, Tuple
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.interopinterfacetype import InteropInterfaceType
 from boa3.internal.model.method import Method
 from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
@@ -30,30 +28,30 @@
         self.key_type = self._origin_collection.valid_key
         self.item_type = self._origin_collection.item_type
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}, {2}]'.format(self._identifier, self.valid_key.identifier, self.item_type.identifier)
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @property
     def value_type(self) -> IType:
         return self._origin_collection.item_type
 
     @property
     def valid_key(self) -> IType:
         return self._origin_collection.valid_key
 
     def is_valid_key(self, key_type: IType) -> bool:
         return self._origin_collection.is_valid_key(key_type)
 
     @classmethod
-    def build(cls, value: Any = None) -> IteratorType:
+    def build(cls, value: Any = None) -> Self:
         if isinstance(value, ICollectionType):
             return IteratorType(value)
         else:
             return _Iterator
 
     @classmethod
     def _is_type_of(cls, value: Any):
@@ -65,15 +63,15 @@
         from boa3.internal.model.builtin.interop.iterator.iteratornextmethod import IteratorNextMethod
         from boa3.internal.model.builtin.interop.iterator.getiteratorvalue import IteratorValueProperty
 
         self._instance_methods['next'] = IteratorNextMethod()
 
         self._properties['value'] = IteratorValueProperty(self)
 
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+    def is_instance_opcodes(self) -> list[tuple[Opcode, bytes]]:
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         return super(PythonClass, self).is_instance_opcodes()
 
     def generate_is_instance_type_check(self, code_generator):
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         return super(PythonClass, self).generate_is_instance_type_check(code_generator)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 import ast
-from typing import Dict, List
 
 from boa3.internal.model.builtin.interop.nativecontract.ContractManagement.getcontractmanagementscripthashmethod import \
     ContractManagement
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class ContractManagementMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, syscall: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
         super().__init__(ContractManagement.getter, identifier, syscall,
                          args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetContractManagementScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
         from boa3.internal.constants import MANAGEMENT_SCRIPT
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_management_contract'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(MANAGEMENT_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class ContractManagementProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'ManagementContract'
         getter = GetContractManagementScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 import ast
-from typing import Dict, List
 
 from boa3.internal.model.builtin.interop.nativecontract.CryptoLib.getcryptolibscripthashmethod import CryptoLibContract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class CryptoLibMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, syscall: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
         super().__init__(CryptoLibContract.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetCryptoLibScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
         from boa3.internal.constants import CRYPTO_SCRIPT
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_crypto_lib_contract'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(CRYPTO_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class CryptoLibContractProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'CryptoLib'
         getter = GetCryptoLibScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetLedgerScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
         from boa3.internal.constants import LEDGER_SCRIPT
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_ledger_contract'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(LEDGER_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class LedgerContractProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'LedgerContract'
         getter = GetLedgerScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Ledger/ledgermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Neo/neocontractmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 import ast
-from typing import Dict, List
 
-from boa3.internal.model.builtin.interop.nativecontract.Ledger.getledgerscripthashmethod import LedgerContract
+from boa3.internal.model.builtin.interop.nativecontract.Neo.getneoscripthashmethod import NeoContract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class LedgerMethod(NativeContractMethod):
+class NeoContractMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, native_identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, native_identifier: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
-        super().__init__(LedgerContract.getter, identifier, native_identifier,
+        super().__init__(NeoContract.getter, identifier, native_identifier,
                          args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Neo/getneoscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,29 +1,30 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.internal.model.builtin.interop.nativecontract.Nep17.getnep17scripthashmethod import GetNep17ScriptHashMethod
+from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetNeoScriptHashMethod(GetNep17ScriptHashMethod):
+class GetRoleManagementScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
-        from boa3.internal.constants import NEO_SCRIPT
-        identifier = '-get_neo_contract'
-        super().__init__(NEO_SCRIPT, identifier)
+        from boa3.internal.constants import ROLE_MANAGEMENT
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        identifier = '-get_role-management'
+        args: dict[str, Variable] = {}
+        super().__init__(ROLE_MANAGEMENT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
-class NeoContractProperty(IBuiltinProperty):
+class RoleManagementProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'NeoContract'
-        getter = GetNeoScriptHashMethod()
+        identifier = 'RoleManagement'
+        getter = GetRoleManagementScriptHashMethod()
         super().__init__(identifier, getter)
 
 
-NeoContract = NeoContractProperty()
+RoleManagement = RoleManagementProperty()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Neo/neocontractmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/oraclemethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 import ast
-from typing import Dict, List
 
-from boa3.internal.model.builtin.interop.nativecontract.Neo.getneoscripthashmethod import NeoContract
+from boa3.internal.model.builtin.interop.nativecontract.Oracle.getoraclescripthashmethod import OracleContract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class NeoContractMethod(NativeContractMethod):
+class OracleMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, native_identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, syscall: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
-        super().__init__(NeoContract.getter, identifier, native_identifier,
-                         args, defaults, return_type, internal_call_args)
+        super().__init__(OracleContract.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Nep17/getnep17scripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/getnep17scripthashmethod.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,25 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetNep17ScriptHashMethod(ContractGetHashMethod):
     def __init__(self, script_hash: bytes, identifier: str = None):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_nep17_contract' if not isinstance(identifier, str) else identifier
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(script_hash, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class Nep17ContractProperty(IBuiltinProperty):
     def __init__(self, script_hash: bytes):
         identifier = 'Nep17'
         getter = GetNep17ScriptHashMethod(script_hash)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Nep17/nep17method.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/nep17method.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 import ast
-from typing import Dict, List
 
 from boa3.internal.model.builtin.interop.nativecontract.Nep17.getnep17scripthashmethod import GetNep17ScriptHashMethod, \
     Nep17Contract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class Nep17Method(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None, script_hash: bytes = None,
+    def __init__(self, identifier: str, syscall: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None, script_hash: bytes = None,
                  internal_call_args: int = None):
         contract = Nep17Contract if script_hash is None else GetNep17ScriptHashMethod(script_hash)
         super().__init__(contract, identifier, syscall, args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetOracleScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
         from boa3.internal.constants import ORACLE_SCRIPT
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_oracle_contract'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(ORACLE_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class OracleProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'Oracle'
         getter = GetOracleScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/Oracle/oraclemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import ast
-from typing import Dict, List
 
-from boa3.internal.model.builtin.interop.nativecontract.Oracle.getoraclescripthashmethod import OracleContract
+from boa3.internal.model.builtin.interop.nativecontract.RoleManagement.getrolemanagementscripthashmethod import \
+    RoleManagement
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class OracleMethod(NativeContractMethod):
+class RoleManagementMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, syscall: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
-        super().__init__(OracleContract.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
+        super().__init__(RoleManagement.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/contractinterfacehash.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,32 +1,25 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
+from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 from boa3.internal.model.variable import Variable
 
 
-class GetPolicyContractScriptHashMethod(ContractGetHashMethod):
-    def __init__(self):
-        from boa3.internal.constants import POLICY_SCRIPT
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_policy_contract'
-        args: Dict[str, Variable] = {}
-        super().__init__(POLICY_SCRIPT, identifier, args, return_type=UInt160Type.build())
+class ContractInterfaceGetScriptHashMethod(ContractGetHashMethod):
+    def __init__(self, identifier: str, contract_script: bytes):
+        identifier = f'-get_{identifier}'
+        args: dict[str, Variable] = {}
+        super().__init__(contract_script, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
-class PolicyContractProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'PolicyContract'
-        getter = GetPolicyContractScriptHashMethod()
+class ContractHashProperty(IBuiltinProperty):
+    def __init__(self, identifier: str, contract_script: bytes):
+        getter = ContractInterfaceGetScriptHashMethod(identifier, contract_script)
         super().__init__(identifier, getter)
-
-
-PolicyContract = PolicyContractProperty()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import ast
-from typing import Dict, List
 
-from boa3.internal.model.builtin.interop.nativecontract.PolicyContract.getpolicycontractscripthashmethod import PolicyContract
+from boa3.internal.model.builtin.interop.nativecontract.PolicyContract.getpolicycontractscripthashmethod import \
+    PolicyContract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class PolicyContractMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, native_identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, native_identifier: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
         super().__init__(PolicyContract.getter, identifier, native_identifier,
                          args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/getstdlibscripthashmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,32 +1,30 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetRoleManagementScriptHashMethod(ContractGetHashMethod):
+class GetStdLibScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
-        from boa3.internal.constants import ROLE_MANAGEMENT
+        from boa3.internal.constants import STD_LIB_SCRIPT
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_role-management'
-        args: Dict[str, Variable] = {}
-        super().__init__(ROLE_MANAGEMENT, identifier, args, return_type=UInt160Type.build())
+        identifier = '-get_std_lib_contract'
+        args: dict[str, Variable] = {}
+        super().__init__(STD_LIB_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
-class RoleManagementProperty(IBuiltinProperty):
+class StdLibProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'RoleManagement'
-        getter = GetRoleManagementScriptHashMethod()
+        identifier = 'StdLib'
+        getter = GetStdLibScriptHashMethod()
         super().__init__(identifier, getter)
 
 
-RoleManagement = RoleManagementProperty()
+StdLibContract = StdLibProperty()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 import ast
-from typing import Dict, List
 
-from boa3.internal.model.builtin.interop.nativecontract.RoleManagement.getrolemanagementscripthashmethod import \
-    RoleManagement
+from boa3.internal.model.builtin.interop.nativecontract.StdLib.getstdlibscripthashmethod import StdLibContract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class RoleManagementMethod(NativeContractMethod):
+class StdLibMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, syscall: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
-        super().__init__(RoleManagement.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
+        super().__init__(StdLibContract.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/ledgermethod.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import ast
-from typing import Dict, List
 
-from boa3.internal.model.builtin.interop.nativecontract.StdLib.getstdlibscripthashmethod import StdLibContract
+from boa3.internal.model.builtin.interop.nativecontract.Ledger.getledgerscripthashmethod import LedgerContract
 from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class StdLibMethod(NativeContractMethod):
+class LedgerMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
+    def __init__(self, identifier: str, native_identifier: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
-        super().__init__(StdLibContract.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
+        super().__init__(LedgerContract.getter, identifier, native_identifier,
+                         args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/nativecontract/nativecontractmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/nativecontract/nativecontractmethod.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 import ast
-from typing import Dict, List, Optional
 
 from boa3.internal.compiler.compiledmetadata import CompiledMetadata
 from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class NativeContractMethod(InteropMethod):
 
     def __init__(self, native_contract_script_hash_method: ContractGetHashMethod, identifier: str, syscall: str,
-                 args: Dict[str, Variable] = None, defaults: List[ast.AST] = None, return_type: IType = None,
+                 args: dict[str, Variable] = None, defaults: list[ast.AST] = None, return_type: IType = None,
                  internal_call_args: int = None):
         super().__init__(identifier, syscall, args, defaults, return_type)
         self.script_hash_method = native_contract_script_hash_method
         min_no_args = len(self.args_without_default)
         if not isinstance(internal_call_args, int):
             internal_call_args = len(self.args)
         elif len(self.args_without_default) > internal_call_args:
@@ -61,15 +60,15 @@
             code_generator.convert_literal(self.method_name)
             code_generator.convert_builtin_method_call(self.script_hash_method, is_internal=True)
             code_generator.convert_builtin_method_call(Interop.CallContract, is_internal=True)
 
             if self.return_type is Type.none:
                 code_generator.remove_stack_top_item()
 
-    def _get_method_token_id(self, call_flag=None) -> Optional[int]:
+    def _get_method_token_id(self, call_flag=None) -> int | None:
         if self._method_token_id is None:
             from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
 
             if call_flag is None:
                 call_flag = self._call_flags_default
             self._method_token_id = VMCodeMapping.instance().add_method_token(self, call_flag)
         return self._method_token_id
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/oraclegetpricemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/oraclegetpricemethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.interop.nativecontract import OracleMethod
 from boa3.internal.model.variable import Variable
 
 
 class OracleGetPriceMethod(OracleMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
         identifier = 'get_price'
         syscall = 'getPrice'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
 
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/oraclerequestmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/bytearrayencodingmethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,28 +1,27 @@
-from typing import Dict, Optional
-
-from boa3.internal.model.builtin.interop.nativecontract import OracleMethod
+from boa3.internal.model.builtin.method import ByteArrayMethod
 from boa3.internal.model.variable import Variable
 
 
-class OracleRequestMethod(OracleMethod):
+class ByteArrayEncodingMethod(ByteArrayMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
-        identifier = 'request'
-        syscall = 'request'
-        args: Dict[str, Variable] = {'url': Variable(Type.str),
-                                     'request_filter': Variable(Type.str),
-                                     'callback': Variable(Type.str),
-                                     'user_data': Variable(Type.any),
-                                     'gas_for_response': Variable(Type.int)}
+        args: dict[str, Variable] = {
+            'object': Variable(Type.str),
+            'encoding': Variable(Type.str)
+        }
+        super().__init__(args)
 
-        super().__init__(identifier, syscall, args, return_type=Type.none)
+    @property
+    def is_supported(self) -> bool:
+        # TODO: change when building bytearray from string encoding #86a1cu16e
+        return False
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
-        return None
+    def _body(self) -> str | None:
+        return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/oracle/oracleresponsecodetype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/oracleresponsecodetype.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class OracleResponseCodeType(IntType):
@@ -21,15 +21,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.oracle.oracleresponsecode import OracleResponseCode
         return isinstance(value, (OracleResponseCode, OracleResponseCodeType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type.
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.role.roletype import Role
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/policy/isblockedmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/policy/isblockedmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import PolicyContractMethod
 from boa3.internal.model.variable import Variable
 
 
 class IsBlockedMethod(PolicyContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
         identifier = 'is_blocked'
         native_identifier = 'isBlocked'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'account': Variable(UInt160Type.build())
         }
         super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/role/getdesignatedbyrolemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/role/getdesignatedbyrolemethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import RoleManagementMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetDesignatedByRoleMethod(RoleManagementMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.role.roletype import RoleType
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
         identifier = 'get_designated_by_role'
         native_identifier = 'getDesignatedByRole'
 
         role_type = RoleType.build()
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'role': Variable(role_type),
             'index': Variable(Type.int)
         }
         super().__init__(identifier, native_identifier, args, return_type=ECPointType.build())
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/role/roletype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/role/roletype.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class RoleType(IntType):
@@ -21,15 +21,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.role.roletype import Role
         return isinstance(value, (Role, RoleType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type.
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.role.roletype import Role
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/checkwitnessmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/checkwitnessmethod.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class CheckWitnessMethod(InteropMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
         identifier = 'check_witness'
         syscall = 'System.Runtime.CheckWitness'
-        args: Dict[str, Variable] = {'hash_or_pubkey': Variable(Type.union.build([ECPointType.build(),
+        args: dict[str, Variable] = {'hash_or_pubkey': Variable(Type.union.build([ECPointType.build(),
                                                                                   UInt160Type.build()
                                                                                   ]))}
         super().__init__(identifier, syscall, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getaddressversionmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getaddressversionmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetAddressVersionMethod(InteropMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = '-get_address_version'
         syscall = 'System.Runtime.GetAddressVersion'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
 
 class AddressVersionProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'address_version'
         getter = GetAddressVersionMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getblocktimemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/scriptcontainermethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetBlockTimeMethod(InteropMethod):
+class ScriptContainerMethod(InteropMethod):
     def __init__(self):
-        from boa3.internal.model.type.type import Type
-        identifier = '-get_time'
-        syscall = 'System.Runtime.GetTime'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+        identifier = '-get_script_container'
+        syscall = 'System.Runtime.GetScriptContainer'
+        args: dict[str, Variable] = {}
+        from boa3.internal.model.builtin.interop.blockchain import TransactionType
+        super().__init__(identifier, syscall, args, return_type=TransactionType.build())
 
 
-class BlockTimeProperty(IBuiltinProperty):
+class ScriptContainerProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'time'
-        getter = GetBlockTimeMethod()
+        identifier = 'script_container'
+        getter = ScriptContainerMethod()
         super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getcallingscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getcallingscripthashmethod.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetCallingScriptHashMethod(InteropMethod):
     def __init__(self):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_calling_script_hash'
         syscall = 'System.Runtime.GetCallingScriptHash'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
 
 
 class CallingScriptHashProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'calling_script_hash'
         getter = GetCallingScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getentryscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getentryscripthashmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetEntryScriptHashMethod(InteropMethod):
     def __init__(self):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_entry_script_hash'
         syscall = 'System.Runtime.GetEntryScriptHash'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
 
 
 class EntryScriptHashProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'entry_script_hash'
         getter = GetEntryScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getexecutingscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getexecutingscripthashmethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetExecutingScriptHashMethod(InteropMethod):
     def __init__(self):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_executing_script_hash'
         syscall = 'System.Runtime.GetExecutingScriptHash'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
 
 
 class ExecutingScriptHashProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'executing_script_hash'
         getter = GetExecutingScriptHashMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getgasleftmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/strsequencemethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,34 @@
-from typing import Dict
+from typing import Any
 
-from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.method import IBuiltinMethod
+from boa3.internal.model.builtin.method.strmethod import StrMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.type import Type
 from boa3.internal.model.variable import Variable
 
 
-class GetGasLeftMethod(InteropMethod):
-    def __init__(self):
-        from boa3.internal.model.type.type import Type
-        identifier = '-get_gas_left'
-        syscall = 'System.Runtime.GasLeft'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+class StrSequenceMethod(StrMethod):
 
+    def __init__(self, arg_value: IType | None = None):
+        if arg_value is None:
+            arg_value = Type.sequence
 
-class GasLeftProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'gas_left'
-        getter = GetGasLeftMethod()
-        super().__init__(identifier, getter)
+        args: dict[str, Variable] = {
+            'object': Variable(arg_value),
+        }
+
+        super().__init__(args)
+
+    def build(self, value: Any) -> IBuiltinMethod:
+        if 'object' in self.args and self.args['object'].type is not Type.any:
+            return self
+
+        if Type.sequence.is_type_of(value):
+            return StrSequenceMethod(value)
+
+        return super().build(value)
+
+    def generate_internal_opcodes(self, code_generator):
+        from boa3.internal.model.builtin.interop.interop import Interop
+
+        code_generator.convert_builtin_method_call(Interop.JsonSerialize, is_internal=True)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getinvocationcountermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getinvocationcountermethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetInvocationCounterMethod(InteropMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = '-get_invocation_counter'
         syscall = 'System.Runtime.GetInvocationCounter'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
 
 class InvocationCounterProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'invocation_counter'
         getter = GetInvocationCounterMethod()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getnotificationsmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getnotificationsmethod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.runtime.notificationtype import NotificationType
 from boa3.internal.model.variable import Variable
 
 
@@ -13,15 +12,15 @@
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.type import Type
 
         identifier = 'get_notifications'
         syscall = 'System.Runtime.GetNotifications'
         uint160 = UInt160Type.build()
 
-        args: Dict[str, Variable] = {'script_hash': Variable(Type.optional.build(uint160))}
+        args: dict[str, Variable] = {'script_hash': Variable(Type.optional.build(uint160))}
         args_default = set_internal_call(ast.parse("{0}".format(Type.none.default_value)
                                                    ).body[0].value)
 
         super().__init__(identifier, syscall, args, [args_default],
                          return_type=Type.list.build([notification_type]))
 
     def generate_internal_opcodes(self, code_generator):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/getplatformmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/unregistercandidatemethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,21 +1,16 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetPlatformMethod(InteropMethod):
+class UnregisterCandidateMethod(NeoContractMethod):
+
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = '-get_platform'
-        syscall = 'System.Runtime.Platform'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.str)
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-
-class PlatformProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'platform'
-        getter = GetPlatformMethod()
-        super().__init__(identifier, getter)
+        identifier = 'unregister_candidate'
+        native_identifier = 'unregisterCandidate'
+        args: dict[str, Variable] = {
+            'pubkey': Variable(ECPointType.build())
+        }
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/gettriggermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/intintmethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,14 +1,22 @@
-from typing import Dict
+import ast
 
-from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
-from boa3.internal.model.builtin.interop.runtime.triggertype import TriggerType
+from boa3.internal.model.builtin.method.intmethod import IntMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetTriggerMethod(InteropMethod):
+class IntIntMethod(IntMethod):
 
-    def __init__(self, trigger_type: TriggerType):
-        identifier = 'get_trigger'
-        syscall = 'System.Runtime.GetTrigger'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=trigger_type)
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        args: dict[str, Variable] = {
+            'value': Variable(Type.int),
+        }
+
+        value_default = ast.parse("{0}".format(Type.int.default_value)
+                                  ).body[0].value
+
+        super().__init__(args, [value_default])
+
+    def generate_internal_opcodes(self, code_generator):
+        # it is the identity function, so there is no need of including another opcode
+        super().generate_internal_opcodes(code_generator)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/loadscriptmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/loadscriptmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Dict, List
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class LoadScriptMethod(InteropMethod):
@@ -13,30 +12,30 @@
         from boa3.internal.model.type.type import Type
         from boa3.internal.neo3.contracts import CallFlags
 
         identifier = 'load_script'
         syscall = 'System.Runtime.LoadScript'
         call_flags: CallFlagsType = CallFlagsType.build()
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'script': Variable(Type.bytes),
             'args': Variable(Type.sequence),
             'call_flags': Variable(call_flags)
         }
 
         args_default = ast.parse("{0}".format(Type.sequence.default_value)
                                  ).body[0].value
         call_flags_default = set_internal_call(ast.parse("{0}.{1}".format(call_flags.identifier,
                                                                           CallFlags.NONE.name)
                                                          ).body[0].value)
 
         super().__init__(identifier, syscall, args, defaults=[args_default, call_flags_default], return_type=Type.any)
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         indexes = super().generation_order
         context_index = list(self.args).index('args')
 
         if indexes[-1] != context_index:
             # args must be the first generated argument
             indexes.remove(context_index)
             indexes.insert(0, context_index)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/notificationtype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/neoaccountstatetype.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,99 +1,102 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
-from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NotificationType(ClassArrayType):
+class NeoAccountStateType(ClassArrayType):
     """
-    A class used to represent Neo Notification class
+    A class used to represent Neo NeoAccountState class
     """
 
     def __init__(self):
-        super().__init__('Notification')
-
+        super().__init__('NeoAccountState')
         from boa3.internal.model.type.type import Type
-        self._variables: Dict[str, Variable] = {
-            'script_hash': Variable(UInt160Type.build()),
-            'event_name': Variable(Type.str),
-            'state': Variable(Type.tuple)
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+
+        self._variables: dict[str, Variable] = {
+            'balance': Variable(Type.int),
+            'height': Variable(Type.int),
+            'vote_to': Variable(ECPointType.build()),
+            'last_gas_per_vote': Variable(Type.int),
         }
-        self._constructor: Method = None
+        self._constructor: Method | None = None
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
-        return self._variables.copy()
+    def class_variables(self) -> dict[str, Variable]:
+        return {}
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
-        return {}
+    def instance_variables(self) -> dict[str, Variable]:
+        return self._variables.copy()
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         return {}
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
-            self._constructor: Method = NotificationMethod(self)
+            self._constructor: Method = NeoAccountStateMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> NotificationType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
-            return _Notification
+            return _NeoAccountState
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, NotificationType)
+        return isinstance(value, NeoAccountStateType)
 
 
-_Notification = NotificationType()
+_NeoAccountState = NeoAccountStateType()
 
 
-class NotificationMethod(IBuiltinMethod):
+class NeoAccountStateMethod(IBuiltinMethod):
 
-    def __init__(self, return_type: NotificationType):
-        identifier = '-Notification__init__'
-        args: Dict[str, Variable] = {}
+    def __init__(self, return_type: NeoAccountStateType):
+        identifier = '-NeoAccountState__init__'
+        args: dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
-    def generate_internal_opcodes(self, code_generator):
-        from boa3.internal.neo3.core.types import UInt160
-
-        uint160_default = UInt160.zero().to_array()
-
-        code_generator.convert_literal(())  # state
-        code_generator.convert_literal('')  # event_name
-        code_generator.convert_literal(uint160_default)  # script_hash
-        code_generator.convert_new_array(length=3, array_type=self.type)
+    @property
+    def _opcode(self) -> list[tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        return [
+            (Opcode.PUSH0, b''),  # last_gas_per_vote
+            OpcodeHelper.get_pushdata_and_data(ECPointType.build().default_value),  # vote_to
+            (Opcode.PUSH0, b''),  # height
+            (Opcode.PUSH0, b''),  # balance
+            (Opcode.PUSH3, b''),
+            (Opcode.PACK, b'')
+        ]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/notifymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/notifymethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopevent import InteropEvent
 from boa3.internal.model.variable import Variable
 
 
 class NotifyMethod(InteropEvent):
 
     def __init__(self):
         self._event_name_key = 'notification_name'
 
         from boa3.internal.model.type.type import Type
         identifier = 'notify'
         syscall = 'System.Runtime.Notify'
-        args: Dict[str, Variable] = {'state': Variable(Type.any),
+        args: dict[str, Variable] = {'state': Variable(Type.any),
                                      self._event_name_key: Variable(Type.str)
                                      }
         import ast
         event_name_default = ast.parse("'{0}'".format(identifier)
                                        ).body[0].value
         super().__init__(identifier, syscall, args, defaults=[event_name_default])
 
     @property
     def generate_name(self) -> bool:
         return False
 
     @property
-    def args_to_generate(self) -> Dict[str, Variable]:
+    def args_to_generate(self) -> dict[str, Variable]:
         return {key_name: value_type
                 for key_name, value_type in self.args.items()
                 if key_name != self._event_name_key}
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/scriptcontainermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/balanceofmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,14 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
 from boa3.internal.model.variable import Variable
 
 
-class ScriptContainerMethod(InteropMethod):
-    def __init__(self):
-        from boa3.internal.model.type.type import Type
-        identifier = '-get_script_container'
-        syscall = 'System.Runtime.GetScriptContainer'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.any)
+class BalanceOfMethod(Nep17Method):
 
+    def __init__(self, contract_script_hash: bytes):
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
-class ScriptContainerProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'script_container'
-        getter = ScriptContainerMethod()
-        super().__init__(identifier, getter)
+        identifier = 'balanceOf'
+        native_identifier = 'balanceOf'
+        args: dict[str, Variable] = {'account': Variable(UInt160Type.build())}
+        super().__init__(identifier, native_identifier, args, return_type=Type.int, script_hash=contract_script_hash)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/runtime/triggertype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/triggertype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class TriggerType(IntType):
@@ -27,15 +27,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.runtime import TriggerType as Trigger
         return isinstance(value, (Trigger, TriggerType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.runtime import TriggerType as Trigger
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/atoimethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatevotemethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,22 +1,17 @@
-import ast
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class AtoiMethod(StdLibMethod):
+class GetCandidateVoteMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'atoi'
-        syscall = 'atoi'
-        args: Dict[str, Variable] = {
-            'value': Variable(Type.str),
-            'base': Variable(Type.int)
-        }
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        args_default = ast.parse("{0}".format(10)
-                                 ).body[0].value
-
-        super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.int)
+        identifier = 'get_candidate_vote'
+        native_identifier = 'getCandidateVote'
+        args: dict[str, Variable] = {
+            'pubkey': Variable(ECPointType.build())
+        }
+        super().__init__(identifier, native_identifier, args,
+                         return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base58checkdecodemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatesmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,14 +1,18 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class Base58CheckDecodeMethod(StdLibMethod):
+class GetCandidatesMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'base58_check_decode'
-        native_identifier = 'base58CheckDecode'
-        args: Dict[str, Variable] = {'key': Variable(Type.str)}
-        super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+
+        identifier = 'get_candidates'
+        native_identifier = 'getCandidates'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, native_identifier, args,
+                         return_type=Type.list.build_collection([
+                             Type.tuple.build_collection([
+                                 ECPointType.build(),
+                                 Type.int])]))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/base58checkencodemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/unclaimedgasmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,14 +1,17 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class Base58CheckEncodeMethod(StdLibMethod):
+class UnclaimedGasMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'base58_check_encode'
-        native_identifier = 'base58CheckEncode'
-        args: Dict[str, Variable] = {'key': Variable(Type.bytes)}
-        super().__init__(identifier, native_identifier, args, return_type=Type.str)
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'unclaimed_gas'
+        native_identifier = 'unclaimedGas'
+        args: dict[str, Variable] = {
+            'account': Variable(UInt160Type.build()),
+            'end': Variable(Type.int)
+        }
+        super().__init__(identifier, native_identifier, args, return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/itoamethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/itoamethod.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
 from boa3.internal.model.variable import Variable
 
 
 class ItoaMethod(StdLibMethod):
 
     def __init__(self, internal_call_args: int = None):
         from boa3.internal.model.type.type import Type
         identifier = 'itoa'
         syscall = 'itoa'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(Type.int),
             'base': Variable(Type.int)
         }
         args_default = ast.parse("{0}".format(10)).body[0].value
 
         super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.str,
                          internal_call_args=internal_call_args)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/memorycomparemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getnextblockvalidators.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,14 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class MemoryCompareMethod(StdLibMethod):
+class GetNextBlockValidatorsMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        identifier = 'memory_compare'
-        syscall = 'memoryCompare'
-        byte_string_type = Type.union.build([Type.bytes, Type.str])
-
-        args: Dict[str, Variable] = {
-            'mem1': Variable(byte_string_type),
-            'mem2': Variable(byte_string_type)
-        }
-
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+        identifier = 'get_next_block_validators'
+        native_identifier = 'getNextBlockValidators'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, native_identifier, args, return_type=Type.list.build([ECPointType.build()]))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/stdlib/memorysearchmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/builtinevent.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,32 +1,25 @@
 import ast
-from typing import Dict
+from abc import ABC
 
-from boa3.internal.model import set_internal_call
-from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.event import Event
 from boa3.internal.model.variable import Variable
 
 
-class MemorySearchMethod(StdLibMethod):
-
-    def __init__(self):
+class IBuiltinEvent(IBuiltinCallable, Event, ABC):
+    def __init__(self,
+                 identifier: str,
+                 args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None,
+                 deprecated: bool = False
+                 ):
         from boa3.internal.model.type.type import Type
+        super().__init__(identifier, args, vararg, kwargs, defaults, Type.none, deprecated)
 
-        identifier = 'memory_search'
-        native_identifier = 'memorySearch'
-        byte_string_type = Type.union.build([Type.bytes, Type.str])
-
-        args: Dict[str, Variable] = {
-            'mem': Variable(byte_string_type),
-            'value': Variable(byte_string_type),
-            'start': Variable(Type.int),
-            'backward': Variable(Type.bool),
-        }
-
-        start_default = set_internal_call(ast.parse("{0}".format(Type.int.default_value)
-                                                    ).body[0].value)
-        backward_default = set_internal_call(ast.parse("{0}".format(Type.bool.default_value)
-                                                       ).body[0].value)
-
-        super().__init__(identifier, native_identifier, args,
-                         defaults=[start_default, backward_default],
-                         return_type=Type.int)
+        # constructor of IBuiltinCallable and Event classes are conflicting
+        self._identifier = identifier
+        self.name = identifier
+        self.args = args if args is not None else {}
+        self.defaults = defaults if defaults is not None else []
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,32 @@
 __all__ = ['FindOptionsType',
            'StorageContextType',
            'StorageDeleteMethod',
            'StorageFindMethod',
            'StorageGetContextMethod',
            'StorageGetReadOnlyContextMethod',
-           'StorageGetMethod',
+           'StorageGetBoolMethod',
+           'StorageGetBytesMethod',
+           'StorageGetECPointMethod',
+           'StorageGetIntMethod',
+           'StorageGetStrMethod',
+           'StorageGetUInt160Method',
+           'StorageGetUInt256Method',
            'StorageMapType',
-           'StoragePutMethod'
+           'StoragePutBoolMethod',
+           'StoragePutBytesMethod',
+           'StoragePutECPointMethod',
+           'StoragePutIntMethod',
+           'StoragePutStrMethod',
+           'StoragePutUInt160Method',
+           'StoragePutUInt256Method'
            ]
 
 from boa3.internal.model.builtin.interop.storage.findoptionstype import FindOptionsType
+from boa3.internal.model.builtin.interop.storage.get import *
+from boa3.internal.model.builtin.interop.storage.put import *
 from boa3.internal.model.builtin.interop.storage.storagecontext import StorageContextType
 from boa3.internal.model.builtin.interop.storage.storagedeletemethod import StorageDeleteMethod
 from boa3.internal.model.builtin.interop.storage.storagefindmethod import StorageFindMethod
 from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
-from boa3.internal.model.builtin.interop.storage.storagegetmethod import StorageGetMethod
 from boa3.internal.model.builtin.interop.storage.storagegetreadonlycontextmethod import StorageGetReadOnlyContextMethod
 from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import StorageMapType
-from boa3.internal.model.builtin.interop.storage.storageputmethod import StoragePutMethod
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/findoptionstype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/findoptionstype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class FindOptionsType(IntType):
@@ -27,15 +27,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.storage import FindOptions
         return isinstance(value, (FindOptions, FindOptionsType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.storage import FindOptions
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,13 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
 class StorageContextAsReadOnlyMethod(InteropMethod):
 
     def __init__(self):
         from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext
 
         identifier = 'as_read_only'
         syscall = 'System.Storage.AsReadOnly'
-        args: Dict[str, Variable] = {'self': Variable(_StorageContext)}
+        args: dict[str, Variable] = {'self': Variable(_StorageContext)}
         super().__init__(identifier, syscall, args, return_type=_StorageContext)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,32 +1,30 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class StorageContextCreateMapMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext
         from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
         from boa3.internal.model.type.type import Type
 
         identifier = 'create_map'
         byte_string_type = Type.bytes
 
-        args: Dict[str, Variable] = {'self': Variable(_StorageContext),
+        args: dict[str, Variable] = {'self': Variable(_StorageContext),
                                      'prefix': Variable(byte_string_type)}
 
         super().__init__(identifier, args, return_type=_StorageMap)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap as StorageMapType
         code_generator.convert_builtin_method_call(StorageMapType.constructor_method(), is_internal=True)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.interopinterfacetype import InteropInterfaceType
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.variable import Variable
 
 
@@ -12,58 +10,58 @@
     """
     A class used to represent Neo StorageContext class
     """
 
     def __init__(self):
         super().__init__('StorageContext')
 
-        self._variables: Dict[str, Variable] = {}
-        self._instance_methods: Dict[str, Method] = {}
+        self._variables: dict[str, Variable] = {}
+        self._instance_methods: dict[str, Method] = {}
         self._constructor: Method = None
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         # avoid recursive import
         if len(self._instance_methods) == 0:
             from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontextcreatemapmethod import \
                 StorageContextCreateMapMethod
             from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontextasreadonlymethod import \
                 StorageContextAsReadOnlyMethod
 
             self._instance_methods = {
                 'create_map': StorageContextCreateMapMethod(),
                 'as_read_only': StorageContextAsReadOnlyMethod()
             }
         return self._instance_methods
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> StorageContextType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _StorageContext
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, StorageContextType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagedeletemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagedeletemethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import ast
-from typing import Any, Dict, Iterable, List, Sized
+from collections.abc import Iterable, Sized
+from typing import Any
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
@@ -15,25 +16,25 @@
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
 
         identifier = 'delete'
         syscall = 'System.Storage.Delete'
         context_type = StorageContextType.build()
 
-        args: Dict[str, Variable] = {'key': Variable(Type.bytes),
+        args: dict[str, Variable] = {'key': Variable(Type.bytes),
                                      'context': Variable(context_type)}
 
         from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
         default_id = StorageGetContextMethod(context_type).identifier
         context_default = set_internal_call(ast.parse("{0}()".format(default_id)
                                                       ).body[0].value)
         super().__init__(identifier, syscall, args, defaults=[context_default], return_type=Type.none)
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         """
         Gets the indexes order that need to be used during code generation.
         If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
 
         :return: Index order for code generation
         """
         indexes = super().generation_order
@@ -47,15 +48,15 @@
         return indexes
 
     @property
     def key_arg(self) -> Variable:
         return self.args['key']
 
     def build(self, value: Any) -> IBuiltinMethod:
-        exp: List[IExpression] = []
+        exp: list[IExpression] = []
         if isinstance(value, Sized):
             if len(value) > 2 or not isinstance(value, Iterable):
                 return self
             exp = [exp if isinstance(exp, IExpression) else Variable(exp)
                    for exp in value if isinstance(exp, (IExpression, IType))]
 
         elif isinstance(exp, (IExpression, IType)):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagefindmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagefindmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import ast
-from typing import Any, Dict, Iterable, List, Sized
+from collections.abc import Iterable, Sized
+from typing import Any
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.storage import FindOptionsType
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
@@ -19,15 +20,15 @@
         identifier = 'find'
         syscall = 'System.Storage.Find'
         context_type = StorageContextType.build()
 
         if prefix_type is None:
             prefix_type = Type.bytes
 
-        args: Dict[str, Variable] = {'prefix': Variable(prefix_type),
+        args: dict[str, Variable] = {'prefix': Variable(prefix_type),
                                      'context': Variable(context_type),
                                      'options': Variable(find_options_type)}
 
         from boa3.internal.model.builtin.interop.iterator import IteratorType
         return_type = IteratorType.build(Type.dict.build([prefix_type,  # return an Iterator[prefix, bytes]
                                                           Type.bytes]))
 
@@ -47,24 +48,24 @@
     def identifier(self) -> str:
         return '-{0}_{1}'.format(self._identifier, self.prefix_arg.type.identifier)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if any(not isinstance(param, IExpression) for param in params):
             return False
 
-        args: List[IType] = [arg.type for arg in self.args.values()]
+        args: list[IType] = [arg.type for arg in self.args.values()]
         if len(params) > len(args):
             return False
         if len(params) < len(self.args_without_default):
             return False
 
         return self.prefix_arg.type.is_type_of(params[0].type)
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         """
         Gets the indexes order that need to be used during code generation.
         If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
 
         :return: Index order for code generation
         """
         indexes = super().generation_order
@@ -82,15 +83,15 @@
         return self.args['prefix']
 
     @property
     def options_arg(self) -> Variable:
         return self.args['options']
 
     def build(self, value: Any) -> IBuiltinMethod:
-        exp: List[IExpression] = []
+        exp: list[IExpression] = []
         if isinstance(value, Sized):
             if len(value) > 1 or not isinstance(value, Iterable):
                 return self
             exp = [exp if isinstance(exp, IExpression) else Variable(exp)
                    for exp in value if isinstance(exp, (IExpression, IType))]
 
         elif isinstance(exp, (IExpression, IType)):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
 from boa3.internal.model.variable import Variable
 
 
 class StorageGetContextMethod(InteropMethod):
 
     def __init__(self, storage_context_type: StorageContextType):
         identifier = 'get_context'
         native_identifier = 'System.Storage.GetContext'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, native_identifier, args, return_type=storage_context_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagegetmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/istorageputmethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,58 @@
+import abc
 import ast
-from typing import Any, Dict, Iterable, List, Sized
+from collections.abc import Iterable, Sized
+from typing import Any
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class StorageGetMethod(InteropMethod):
+class IStoragePutMethod(InteropMethod, abc.ABC):
 
-    def __init__(self):
+    def __init__(self, identifier: str, value_type: IType):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
 
-        identifier = 'get'
-        syscall = 'System.Storage.Get'
+        syscall = 'System.Storage.Put'
         context_type = StorageContextType.build()
 
-        args: Dict[str, Variable] = {'key': Variable(Type.bytes),
+        args: dict[str, Variable] = {'key': Variable(Type.bytes),
+                                     'value': Variable(value_type),
                                      'context': Variable(context_type)}
 
         from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
         default_id = StorageGetContextMethod(context_type).identifier
-        context_default = set_internal_call(ast.parse("{0}()".format(default_id)
+        context_default = set_internal_call(ast.parse(f"{default_id}()"
                                                       ).body[0].value)
-        super().__init__(identifier, syscall, args, defaults=[context_default], return_type=Type.bytes)
+        super().__init__(identifier, syscall, args, defaults=[context_default], return_type=Type.none)
+
+    @abc.abstractmethod
+    def generate_serialize_value_opcodes(self, code_generator):
+        pass
 
     def generate_internal_opcodes(self, code_generator):
+        start_address = code_generator.bytecode_size
+        code_generator.swap_reverse_stack_items(3)
+        self.generate_serialize_value_opcodes(code_generator)
+        end_address = code_generator.last_code_start_address
+
+        if end_address > start_address:
+            code_generator.swap_reverse_stack_items(3)
+        else:
+            code_generator._remove_inserted_opcodes_since(start_address)
+
         super().generate_internal_opcodes(code_generator)
-        # if result is None:
-        code_generator.duplicate_stack_top_item()
-        code_generator.insert_type_check(None)
-        if_is_null = code_generator.convert_begin_if()
-
-        #   result = b''
-        code_generator.remove_stack_top_item()
-        code_generator.convert_literal(b'')
-        code_generator.convert_end_if(if_is_null, is_internal=True)
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         """
         Gets the indexes order that need to be used during code generation.
         If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
 
         :return: Index order for code generation
         """
         indexes = super().generation_order
@@ -58,29 +65,32 @@
 
         return indexes
 
     @property
     def key_arg(self) -> Variable:
         return self.args['key']
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        exp: List[IExpression] = []
-        if isinstance(value, Sized):
-            if len(value) > 1 or not isinstance(value, Iterable):
-                return self
-            exp = [exp if isinstance(exp, IExpression) else Variable(exp)
-                   for exp in value if isinstance(exp, (IExpression, IType))]
+    @property
+    def value_arg(self) -> Variable:
+        return self.args['value']
 
-        elif isinstance(exp, (IExpression, IType)):
-            exp = [value if isinstance(value, IExpression) else Variable(value)]
-        else:
+    def build(self, value: Any) -> IBuiltinMethod:
+        if not isinstance(value, (Sized, Iterable)):
+            return self
+        num_args: int = len(self.args)
+        if len(value) != num_args or any(not isinstance(exp, (IExpression, IType)) for exp in value[:num_args]):
             return self
 
+        exp = [exp if isinstance(exp, IExpression) else Variable(exp) for exp in value]
         if not self.validate_parameters(*exp):
             return self
 
-        method = self
         key_type: IType = exp[0].type
-        if not method.key_arg.type.is_type_of(key_type):
-            method = StorageGetMethod()
-            method.args['key'] = Variable(key_type)
+        value_type: IType = exp[1].type
+        if self.key_arg.type.is_type_of(key_type) and self.value_arg.type.is_type_of(value_type):
+            return self
+
+        from boa3.internal.model.builtin.interop.storage.put.storageputintmethod import StoragePutBytesMethod
+        method: InteropMethod = StoragePutBytesMethod()
+        method.args['key'] = Variable(key_type)
+        method.args['value'] = Variable(value_type)
         return method
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
 from boa3.internal.model.variable import Variable
 
 
 class StorageGetReadOnlyContextMethod(InteropMethod):
 
     def __init__(self, storage_context_type: StorageContextType):
         identifier = 'get_read_only_context'
         native_identifier = 'System.Storage.GetContext'
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         super().__init__(identifier, native_identifier, args, return_type=storage_context_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class StorageMapDeleteMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
         from boa3.internal.model.type.type import Type
 
         identifier = 'delete'
-        args: Dict[str, Variable] = {'self': Variable(_StorageMap),
+        args: dict[str, Variable] = {'self': Variable(_StorageMap),
                                      'key': Variable(Type.bytes)}
 
         super().__init__(identifier, args, return_type=Type.none)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.interop import Interop
         from boa3.internal.model.operation.binaryop import BinaryOp
 
         # actual_key = self._prefix + key
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class StorageMapGetMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
         from boa3.internal.model.type.type import Type
 
         identifier = 'get'
-        args: Dict[str, Variable] = {'self': Variable(_StorageMap),
+        args: dict[str, Variable] = {'self': Variable(_StorageMap),
                                      'key': Variable(Type.bytes)}
 
         super().__init__(identifier, args, return_type=Type.bytes)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
@@ -24,15 +22,15 @@
     def self_type(self):
         """
         :rtype: boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype.StorageMapType
         """
         return self.args['self'].type
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.interop import Interop
         from boa3.internal.model.operation.binaryop import BinaryOp
 
         # actual_key = self._prefix + key
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemapputmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapputmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class StorageMapPutMethod(IBuiltinMethod):
 
     def __init__(self):
@@ -12,26 +10,26 @@
 
         identifier = 'put'
         storage_value_type = Type.union.build([Type.bytes,
                                                Type.int,
                                                Type.str,
                                                ])
 
-        args: Dict[str, Variable] = {'self': Variable(_StorageMap),
+        args: dict[str, Variable] = {'self': Variable(_StorageMap),
                                      'key': Variable(Type.bytes),
                                      'value': Variable(storage_value_type)}
 
         super().__init__(identifier, args, return_type=Type.none)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.interop import Interop
         from boa3.internal.model.operation.binaryop import BinaryOp
 
         # actual_key = self._prefix + key
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storagemap/storagemaptype.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemaptype.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.variable import Variable
@@ -14,75 +12,75 @@
     """
     A class used to represent Neo StorageMap class
     """
 
     def __init__(self):
         super().__init__('StorageMap')
 
-        self._variables: Dict[str, Variable] = {}
+        self._variables: dict[str, Variable] = {}
         self._constructor: Method = None
-        self._instance_methods: Dict[str, Method] = {}
+        self._instance_methods: dict[str, Method] = {}
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         return self._variables.copy()
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         return {}
 
     @property
-    def _all_variables(self) -> Dict[str, Variable]:
+    def _all_variables(self) -> dict[str, Variable]:
         from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import \
             _StorageContext as StorageContextType
         from boa3.internal.model.type.type import Type
 
         private_variables = {
             '_context': Variable(StorageContextType),
             '_prefix': Variable(Type.bytes)
         }
         variables = super()._all_variables
         variables.update(private_variables)
         return variables
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         return {}
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         return {}
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         # avoid recursive import
         if len(self._instance_methods) == 0:
             from boa3.internal.model.builtin.interop.storage.storagemap.storagemapdeletemethod import StorageMapDeleteMethod
             from boa3.internal.model.builtin.interop.storage.storagemap.storagemapgetmethod import StorageMapGetMethod
             from boa3.internal.model.builtin.interop.storage.storagemap.storagemapputmethod import StorageMapPutMethod
 
             self._instance_methods = {
                 'get': StorageMapGetMethod(),
                 'put': StorageMapPutMethod(),
                 'delete': StorageMapDeleteMethod()
             }
         return self._instance_methods
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         # was having a problem with recursive import
         if self._constructor is None:
             self._constructor: Method = StorageMapMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> StorageMapType:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _StorageMap
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, StorageMapType)
 
@@ -94,15 +92,15 @@
 
     def __init__(self, return_type: StorageMapType):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import \
             _StorageContext as StorageContextType
 
         identifier = '-StorageMap__init__'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'context': Variable(StorageContextType),
             'prefix': Variable(Type.bytes)
         }
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
@@ -111,9 +109,9 @@
         code_generator.convert_new_array(len(self.args), self.return_type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/interop/storage/storageputmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/listmethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,81 +1,87 @@
 import ast
-from typing import Any, Dict, Iterable, List, Sized
+from typing import Any
 
-from boa3.internal.model import set_internal_call
-from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.internal.model.expression import IExpression
-from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class StoragePutMethod(InteropMethod):
+class ListMethod(IBuiltinMethod):
 
-    def __init__(self):
-        from boa3.internal.model.type.type import Type
-        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
+    def __init__(self, args: dict[str, Variable] = None, return_type=None, defaults: list[ast.AST] = None):
+        identifier = 'list'
 
-        identifier = 'put'
-        syscall = 'System.Storage.Put'
-        context_type = StorageContextType.build()
-        storage_value_type = Type.union.build([Type.bytes,
-                                               Type.int,
-                                               Type.str,
-                                               ])
-
-        args: Dict[str, Variable] = {'key': Variable(Type.bytes),
-                                     'value': Variable(storage_value_type),
-                                     'context': Variable(context_type)}
-
-        from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
-        default_id = StorageGetContextMethod(context_type).identifier
-        context_default = set_internal_call(ast.parse("{0}()".format(default_id)
-                                                      ).body[0].value)
-        super().__init__(identifier, syscall, args, defaults=[context_default], return_type=Type.none)
+        super().__init__(identifier, args, defaults=defaults, return_type=return_type)
 
     @property
-    def generation_order(self) -> List[int]:
-        """
-        Gets the indexes order that need to be used during code generation.
-        If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
+    def _arg_value(self) -> Variable:
+        return self.args['value']
 
-        :return: Index order for code generation
-        """
-        indexes = super().generation_order
-        context_index = list(self.args).index('context')
+    @property
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
+
+        if self._arg_value.type is Type.str or self._arg_value.type is Type.bytes:
+            return '-{0}_{1}'.format(self._identifier, Type.str.identifier + Type.bytes.identifier)
+
+        if Type.sequence.is_type_of(self._arg_value.type):
+            return '-{0}_{1}'.format(self._identifier, Type.sequence.identifier)
 
-        if indexes[-1] != context_index:
-            # context must be the last generated argument
-            indexes.remove(context_index)
-            indexes.append(context_index)
+        if Type.mapping.is_type_of(self._arg_value.type):
+            return '-{0}_{1}'.format(self._identifier, Type.mapping.identifier)
 
-        return indexes
+        return self._identifier
+
+    def generate_internal_opcodes(self, code_generator):
+        self.generate_pack_opcodes(code_generator)
+        code_generator.insert_opcode(Opcode.PACK)
+
+    def generate_pack_opcodes(self, code_generator):
+        """
+        :type code_generator: boa3.internal.compiler.codegenerator.codegenerator.CodeGenerator
+        """
+        pass
 
     @property
-    def key_arg(self) -> Variable:
-        return self.args['key']
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
     @property
-    def value_arg(self) -> Variable:
-        return self.args['value']
+    def _body(self) -> str | None:
+        return None
 
     def build(self, value: Any) -> IBuiltinMethod:
-        if not isinstance(value, (Sized, Iterable)):
-            return self
-        num_args: int = len(self.args)
-        if len(value) != num_args or any(not isinstance(exp, (IExpression, IType)) for exp in value[:num_args]):
-            return self
-
-        exp = [exp if isinstance(exp, IExpression) else Variable(exp) for exp in value]
-        if not self.validate_parameters(*exp):
-            return self
-
-        key_type: IType = exp[0].type
-        value_type: IType = exp[1].type
-        if self.key_arg.type.is_type_of(key_type) and self.value_arg.type.is_type_of(value_type):
-            return self
-
-        method: InteropMethod = StoragePutMethod()
-        method.args['key'] = Variable(key_type)
-        method.args['value'] = Variable(value_type)
-        return method
+        if not isinstance(value, list):
+            value = [value]
+
+        from boa3.internal.model.type.type import Type
+
+        from boa3.internal.model.type.annotation.uniontype import UnionType
+        is_union = len(value) > 0 and isinstance(value[0], UnionType)
+        union_types = value[0].union_types if is_union else None
+
+        if len(value) > 0:
+            if Type.str.is_type_of(value[0]) or Type.bytes.is_type_of(value[0]) or \
+                    (is_union and all((union_type is Type.str or union_type is Type.bytes) for union_type in union_types)):
+                from boa3.internal.model.builtin.method import ListBytesStringMethod
+                return ListBytesStringMethod(value[0])
+
+            if Type.mapping.is_type_of(value[0]):
+                from boa3.internal.model.builtin.method import ListMappingMethod
+                return ListMappingMethod(value[0])
+
+            if is_union and \
+                    any((union_type is Type.str or
+                         union_type is Type.bytes or
+                         Type.sequence.is_type_of(union_type) or
+                         Type.mapping.is_type_of(union_type)) for union_type in union_types):
+                from boa3.internal.model.builtin.method import ListGenericMethod
+                return ListGenericMethod(value[0])
+
+            if value[0] is Type.any:
+                from boa3.internal.model.builtin.method import ListGenericMethod
+                return ListGenericMethod()
+
+            if Type.sequence.is_type_of(value[0]):
+                from boa3.internal.model.builtin.method import ListSequenceMethod
+                return ListSequenceMethod(value[0])
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/math/decimalceil.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/math/decimalceil.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class DecimalCeilingMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'ceil'
-        args: Dict[str, Variable] = {'x': Variable(Type.int),
+        args: dict[str, Variable] = {'x': Variable(Type.int),
                                      'decimals': Variable(Type.int)}
         super().__init__(identifier, args, return_type=Type.int)
 
     @property
     def exception_message(self) -> str:
         return "decimals cannot be negative"
 
@@ -62,9 +60,9 @@
         super().generate_opcodes(code_generator)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/math/decimalfloor.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/math/decimalfloor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class DecimalFloorMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'floor'
-        args: Dict[str, Variable] = {'x': Variable(Type.int),
+        args: dict[str, Variable] = {'x': Variable(Type.int),
                                      'decimals': Variable(Type.int)}
         super().__init__(identifier, args, return_type=Type.int)
 
     @property
     def exception_message(self) -> str:
         return "decimals cannot be negative"
 
@@ -60,9 +58,9 @@
         super().generate_opcodes(code_generator)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/math/powmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/contract_management/hasmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,36 +1,19 @@
-from typing import Dict, Optional
-
-from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.builtin.interop.nativecontract import ContractManagementMethod
 from boa3.internal.model.variable import Variable
-from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class PowMethod(IBuiltinMethod):
+class HasMethod(ContractManagementMethod):
 
     def __init__(self):
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.type import Type
-        identifier = 'pow'
-        args: Dict[str, Variable] = {
-            'base': Variable(Type.int),
-            'exponent': Variable(Type.int),
-        }
-        super().__init__(identifier, args, return_type=Type.int)
-
-    @property
-    def requires_reordering(self) -> bool:
-        return True
 
-    def reorder(self, arguments: list):
-        # swap base and exponent  positions
-        arguments[0], arguments[1] = arguments[1], arguments[0]
-
-    def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.POW)
-
-    @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+        identifier = 'has_method'
+        syscall = 'hasMethod'
+        args: dict[str, Variable] = {
+            'hash': Variable(UInt160Type.build()),
+            'method': Variable(Type.str),
+            'parameter_count': Variable(Type.int)
+        }
 
-    @property
-    def _body(self) -> Optional[str]:
-        return
+        super().__init__(identifier, syscall, args, return_type=Type.bool)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/math/sqrtmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/math/powmethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,34 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class SqrtMethod(IBuiltinMethod):
+class PowMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'sqrt'
-        args: Dict[str, Variable] = {'val': Variable(Type.int)}
+        identifier = 'pow'
+        args: dict[str, Variable] = {
+            'base': Variable(Type.int),
+            'exponent': Variable(Type.int),
+        }
         super().__init__(identifier, args, return_type=Type.int)
 
+    @property
+    def requires_reordering(self) -> bool:
+        return True
+
+    def reorder(self, arguments: list):
+        # swap base and exponent  positions
+        arguments[0], arguments[1] = arguments[1], arguments[0]
+
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.SQRT)
+        code_generator.insert_opcode(Opcode.POW)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/absmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/absmethod.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,25 +1,23 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class AbsMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'abs'
-        args: Dict[str, Variable] = {'val': Variable(Type.int)}
+        args: dict[str, Variable] = {'val': Variable(Type.int)}
         super().__init__(identifier, args, return_type=Type.int)
 
     def generate_internal_opcodes(self, code_generator):
         code_generator.insert_opcode(Opcode.ABS)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/boolmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/boolmethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class BoolMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'bool'
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(Type.any),
         }
         super().__init__(identifier, args, return_type=Type.bool)
 
     @property
     def _value(self) -> Variable:
         return self.args['value']
@@ -61,9 +59,9 @@
         code_generator.insert_opcode(Opcode.NZ)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/builtinevent.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/oracle/oraclerequestmethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,22 +1,26 @@
-import ast
-from abc import ABC
-from typing import Dict, List, Optional, Tuple
-
-from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
-from boa3.internal.model.event import Event
+from boa3.internal.model.builtin.interop.nativecontract import OracleMethod
 from boa3.internal.model.variable import Variable
 
 
-class IBuiltinEvent(IBuiltinCallable, Event, ABC):
-    def __init__(self, identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None):
+class OracleRequestMethod(OracleMethod):
+
+    def __init__(self):
         from boa3.internal.model.type.type import Type
-        super().__init__(identifier, args, vararg, kwargs, defaults, Type.none)
 
-        # constructor of IBuiltinCallable and Event classes are conflicting
-        self._identifier = identifier
-        self.name = identifier
-        self.args = args if args is not None else {}
-        self.defaults = defaults if defaults is not None else []
+        identifier = 'request'
+        syscall = 'request'
+        args: dict[str, Variable] = {'url': Variable(Type.str),
+                                     'request_filter': Variable(Type.str),
+                                     'callback': Variable(Type.str),
+                                     'user_data': Variable(Type.any),
+                                     'gas_for_response': Variable(Type.int)}
+
+        super().__init__(identifier, syscall, args, return_type=Type.none)
+
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
+
+    @property
+    def _body(self) -> str | None:
+        return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/builtinmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/builtinmethod.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,25 +1,28 @@
-from __future__ import annotations
-
 import ast
 from abc import ABC, abstractmethod
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, Self
 
 from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
 from boa3.internal.model.method import Method
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class IBuiltinMethod(IBuiltinCallable, Method, ABC):
-    def __init__(self, identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None):
-        super().__init__(identifier, args, vararg, kwargs, defaults, return_type)
+    def __init__(self,
+                 identifier: str,
+                 args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None,
+                 return_type: IType = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(identifier, args, vararg, kwargs, defaults, return_type, deprecated)
 
     @property
     def is_supported(self) -> bool:
         """
         Verifies if the builtin method is supported by the compiler
 
         :return: True if it is supported. False otherwise.
@@ -34,15 +37,15 @@
     def is_cast(self) -> bool:
         """
         Returns whether this method is for casting types
         """
         return False
 
     @property
-    def cast_types(self) -> Optional[Tuple[IType, IType]]:
+    def cast_types(self) -> tuple[IType, IType] | None:
         """
         If `is_cast` is True, must return the original type and the target type of the cast.
         Otherwise, must return None
         """
         return None
 
     @property
@@ -128,34 +131,34 @@
         If `requires_reordering` returns True, this method must be implemented
 
         :param arguments: list of arguments to be reordered
         """
         pass
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         """
         Gets the indexes order that need to be used during code generation.
         If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
 
         :return: Index order for code generation
         """
         indexes = list(reversed(range(0, len(self.args))))
         if self.push_self_first():
             indexes.remove(0)     # remove the first index from whatever position it is
             indexes.insert(0, 0)  # and move to the first position
 
         return indexes
 
-    def validate_negative_arguments(self) -> List[int]:
+    def validate_negative_arguments(self) -> list[int]:
         """
         Returns a list of the arguments that have to be positive values and need validation.
 
         :return: list with the arguments indexes that need to be fixed.
-        :rtype: List[int]
+        :rtype: list[int]
         """
         return []
 
     @property
     def pack_arguments(self) -> bool:
         """
         Return whether this method requires its parameters to be packed into an array
@@ -171,33 +174,33 @@
         :return: arguments to try to run the method
         :rtype: Any
         """
         from boa3.internal.analyser.model.optimizer import Undefined
         return Undefined
 
     @property
-    def body(self) -> Optional[str]:
+    def body(self) -> str | None:
         """
         Gets the body of the method.
 
         :return: Return the code of the method body if there is no opcode. None otherwise.
         """
         return self._body if len(self.opcode) <= 0 else None
 
     @property
     @abstractmethod
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         """
         Gets the body of the method.
 
         :return: Return the code of the method body.
         """
         return None
 
-    def build(self, value: Any) -> IBuiltinMethod:
+    def build(self, value: Any) -> Self:
         """
         Creates a method instance with the given value as self
 
         :param value: value to build the type
         :return: The built method if the value is valid. The current object otherwise
         :rtype: IBuiltinMethod
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/bytearraymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/bytearraymethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,33 +1,33 @@
 import ast
-from typing import Any, Dict, Optional, Union
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ByteArrayMethod(IBuiltinMethod):
 
-    def __init__(self, argument_type: Union[IType, Dict] = None):
+    def __init__(self, argument_type: IType | dict = None):
         identifier = 'bytearray'
         from boa3.internal.model.type.type import Type
 
-        if isinstance(argument_type, Dict):
+        if isinstance(argument_type, dict):
             args = argument_type
             defaults = []
         else:
             from boa3.internal.model.type.type import Type
             if argument_type is None or not self.validate_parameters(argument_type):
                 argument_type = Type.none
 
-            args: Dict[str, Variable] = {'object': Variable(argument_type)}
+            args: dict[str, Variable] = {'object': Variable(argument_type)}
             object_default = ast.parse(f"{Type.int.default_value}"
                                        ).body[0].value
             defaults = [object_default]
 
         super().__init__(identifier, args, defaults=defaults, return_type=Type.bytearray)
 
     @property
@@ -81,15 +81,15 @@
         return self._arg_object.type in (Type.bytes, Type.str, Type.int)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self._arg_object.type):
             return self
         if isinstance(value, list):
             if len(value) == 2:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/createeventmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/tostrmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,57 +1,73 @@
-from typing import Any, Optional
+from abc import ABC
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.model.variable import Variable
-from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class CreateEventMethod(IBuiltinMethod):
-    def __init__(self):
-        import ast
+class ToStrMethod(IBuiltinMethod, ABC):
+    def __init__(self, self_type: IType):
+        identifier = 'to_str'
+        if isinstance(self_type, IdentifiedSymbol):
+            identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
+
+        args: dict[str, Variable] = {'self': Variable(self_type)}
         from boa3.internal.model.type.type import Type
-        identifier = 'CreateNewEvent'
-        args = {
-            'arguments': Variable(Type.list.build(Type.tuple)),
-            'event_name': Variable(Type.str)
-        }
-        event_name_default = ast.parse("'{0}'".format(Type.str.default_value)
-                                       ).body[0].value
-        super().__init__(identifier, args, defaults=[event_name_default], return_type=EventType)
+        super().__init__(identifier, args, return_type=Type.str)
+
+    @property
+    def _arg_self(self) -> Variable:
+        return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
-        return len(params) == len(self.args)
+        if len(params) != 1:
+            return False
+        return isinstance(params[0], IExpression) and isinstance(params[0].type, BytesType)
+
+    def generate_internal_opcodes(self, code_generator):
+        from boa3.internal.model.type.type import Type
+        code_generator.convert_cast(Type.str, is_internal=True)
+
+    def push_self_first(self) -> bool:
+        return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
-        return 0
+        return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
-class __EventType(IType):
-    """
-    A class used to represent an Neo event
-    """
-
+class _ConvertToStrMethod(ToStrMethod):
     def __init__(self):
-        identifier = 'Event'
-        super().__init__(identifier)
-
-    @property
-    def abi_type(self) -> AbiType:
-        return AbiType.Void
-
-    @classmethod
-    def build(cls, value: Any) -> IType:
-        return EventType
-
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return value is EventType
-
+        super().__init__(None)
 
-EventType = __EventType()
+    def build(self, value: Any) -> IBuiltinMethod:
+        if isinstance(value, BytesType):
+            return BytesToStrMethod(value)
+        # if it is not a valid type, show mismatched type with bytes
+        return BytesToStrMethod()
+
+
+ToStr = _ConvertToStrMethod()
+
+
+class BytesToStrMethod(ToStrMethod):
+    def __init__(self, self_type: IType = None):
+        if not isinstance(self_type, BytesType):
+            from boa3.internal.model.type.type import Type
+            self_type = Type.bytes
+        super().__init__(self_type)
+
+    def build(self, value: Any) -> IBuiltinMethod:
+        if type(value) == type(self.args['self'].type):
+            return self
+        if isinstance(value, BytesType):
+            return BytesToStrMethod(value)
+        return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/ecpointmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/ecpointmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
@@ -12,15 +12,15 @@
 
     def __init__(self, return_type: ECPointType, argument_type: IType = None):
         from boa3.internal.model.type.type import Type
         if argument_type is None or not self.validate_parameters(argument_type):
             argument_type = Type.none
 
         identifier = 'ECPoint'
-        args: Dict[str, Variable] = {'arg': Variable(argument_type)}
+        args: dict[str, Variable] = {'arg': Variable(argument_type)}
 
         super().__init__(identifier, args, return_type=return_type)
 
     @property
     def _arg_arg(self) -> Variable:
         return self.args['arg']
 
@@ -71,15 +71,15 @@
         code_generator.convert_end_if(else_address, is_internal=True)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self._arg_arg.type):
             return self
         if isinstance(value, list):
             value = value[0] if len(value) > 0 else None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/ecpointtoscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/ecpointtoscripthashmethod.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/exceptionmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/exceptionmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 from boa3.internal.model.variable import Variable
 
@@ -12,15 +12,15 @@
 
     def __init__(self, argument_type: IType = None):
         from boa3.internal.model.type.type import Type
         if argument_type is None or not self.validate_parameters(argument_type):
             argument_type = Type.str
 
         identifier = '-Exception'
-        args: Dict[str, Variable] = {'message': Variable(argument_type)}
+        args: dict[str, Variable] = {'message': Variable(argument_type)}
         default_message = "'{0}'".format(self.default_message) if argument_type is Type.str else "{0}"
         default = ast.parse(default_message.format(argument_type.default_value)
                             ).body[0].value
         super().__init__(identifier, args, [default], return_type=Type.exception)
 
     @property
     def _arg_message(self) -> Variable:
@@ -51,15 +51,15 @@
         pass
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self._arg_message.type):
             return self
         if isinstance(value, list):
             value = value[0] if len(value) > 0 else None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/exitmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/math/sqrtmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,25 +1,23 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ExitMethod(IBuiltinMethod):
+class SqrtMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        identifier = 'exit'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=Type.none)
+        identifier = 'sqrt'
+        args: dict[str, Variable] = {'val': Variable(Type.int)}
+        super().__init__(identifier, args, return_type=Type.int)
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.ABORT)
+        code_generator.insert_opcode(Opcode.SQRT)
 
     @property
     def _args_on_stack(self) -> int:
-        return 0
+        return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
-        return None
+    def _body(self) -> str | None:
+        return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/intbytestringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/intbytestringmethod.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model.builtin.method.intmethod import IntMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IntByteStringMethod(IntMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(Type.union.build([
                 Type.bytes,
                 Type.str
             ])),
             'base': Variable(Type.int)
         }
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/intintmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetstrmethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-import ast
-from typing import Dict
+from boa3.internal.model.builtin.interop.storage.get.istoragegetmethod import IStorageGetMethod
 
-from boa3.internal.model.builtin.method.intmethod import IntMethod
-from boa3.internal.model.variable import Variable
 
+class StorageGetStrMethod(IStorageGetMethod):
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
 
-class IntIntMethod(IntMethod):
+        identifier = 'get_str'
+        value_type = Type.str
 
-    def __init__(self):
+        super().__init__(identifier, value_type=value_type)
+
+    def generate_default_value_opcodes(self, code_generator):
+        # default_value = ''
+        code_generator.convert_literal('')
+
+    def generate_deserialize_value_opcodes(self, code_generator):
+        from boa3.internal.model.builtin.method.tostrmethod import ToStr
         from boa3.internal.model.type.type import Type
-        args: Dict[str, Variable] = {
-            'value': Variable(Type.int),
-        }
-
-        value_default = ast.parse("{0}".format(Type.int.default_value)
-                                  ).body[0].value
-
-        super().__init__(args, [value_default])
-
-    def generate_internal_opcodes(self, code_generator):
-        # it is the identity function, so there is no need of including another opcode
-        super().generate_internal_opcodes(code_generator)
+
+        converter = ToStr.build(Type.bytes)
+        code_generator.convert_builtin_method_call(converter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/intmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/intmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import ast
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class IntMethod(IBuiltinMethod):
 
-    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+    def __init__(self, args: dict[str, Variable] = None, defaults: list[ast.AST] = None):
         from boa3.internal.model.type.type import Type
         identifier = 'int'
         super().__init__(identifier, args, defaults=defaults, return_type=Type.int)
 
     @property
     def _arg_value(self) -> Variable:
         return self.args['value']
@@ -29,15 +29,15 @@
         return self._identifier
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
         from boa3.internal.model.type.type import Type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/isinstancemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/isinstancemethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from typing import Any, Dict, List, Optional, Union
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IsInstanceMethod(IBuiltinMethod):
 
     def __init__(self, target_type: IType = None):
         from boa3.internal.model.type.type import Type
         identifier = 'isinstance'
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'x': Variable(Type.any),
             'A_tuple': None
         }
 
         super().__init__(identifier, args, return_type=Type.bool)
 
         from boa3.internal.model.type.collection.sequence.tupletype import TupleType
@@ -28,17 +28,17 @@
             instances = [Type.none]
         elif isinstance(target_type, TupleType) and isinstance(target_type.item_type, UnionType):
             instances = [typ.meta_type if isinstance(typ, MetaType) else typ
                          for typ in target_type.item_type.union_types]
         else:
             instances = [target_type.meta_type if isinstance(target_type, MetaType) else target_type]
 
-        self._instances_type: List[IType] = instances
+        self._instances_type: list[IType] = instances
 
-    def set_instance_type(self, value: List[IType]):
+    def set_instance_type(self, value: list[IType]):
         new_list = []
         for tpe in value:
             if isinstance(tpe, IType):
                 if not any(tpe.raw_identifier == other.raw_identifier for other in new_list):
                     new_list.append(tpe)
 
         self._instances_type = new_list
@@ -51,15 +51,15 @@
             ):
             return self._identifier
 
         types = list({tpe.raw_identifier for tpe in self._instances_type})
         types.sort()
         return '-{0}_of_{1}'.format(self._identifier, '_or_'.join(types))
 
-    def args_to_be_generated(self) -> List[int]:
+    def args_to_be_generated(self) -> list[int]:
         args = [name for name, symbol in self.args.items() if isinstance(symbol, Variable)]
         return [list(self.args).index(key) for key in args]
 
     @property
     def is_supported(self) -> bool:
         from boa3.internal.model.type.classes.classtype import ClassType
         return not any(isinstance(param, ClassType) and len(param.is_instance_opcodes()) == 0
@@ -71,15 +71,15 @@
 
         return '{0}({1}, {2})'.format(callable_id, self.arg_x, types)
 
     @property
     def arg_x(self) -> Variable:
         return self.args['x']
 
-    def validate_parameters(self, *params: Union[IExpression, IType]) -> bool:
+    def validate_parameters(self, *params: IExpression | IType) -> bool:
         if len(params) != 2:
             return False
 
         return not any(not isinstance(param, (IExpression, IType)) for param in params)
 
     def generate_internal_opcodes(self, code_generator):
         if len(self._instances_type) == 0:
@@ -111,25 +111,25 @@
             code_generator.convert_end_if(last_if, is_internal=True)
 
     @property
     def _args_on_stack(self) -> int:
         return 1
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         # type should not be converted
         indexes = super().generation_order
         typ_index = list(self.args).index('A_tuple')
 
         if typ_index in indexes:
             indexes.remove(typ_index)
 
         return indexes
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, list) and self.validate_parameters(*value):
             return IsInstanceMethod(value[-1])
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/lenmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/lenmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Any, Dict, Optional, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
@@ -13,15 +14,15 @@
 
     def __init__(self, collection_type: IType = None):
         from boa3.internal.model.type.type import Type
         if not isinstance(collection_type, ICollectionType):
             collection_type = Type.sequence
 
         identifier = 'len'
-        args: Dict[str, Variable] = {'__o': Variable(collection_type)}
+        args: dict[str, Variable] = {'__o': Variable(collection_type)}
         super().__init__(identifier, args, return_type=Type.int)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
         if not isinstance(params[0], IExpression):
             return False
@@ -31,15 +32,15 @@
         code_generator.insert_opcode(Opcode.SIZE)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['__o'].type):
             return self
 
         if isinstance(value, Sized) and len(value) == 1:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/listbytesstringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/listbytesstringmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.method.listmethod import ListMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ListBytesStringMethod(ListMethod):
 
     def __init__(self, value: IType = None):
         from boa3.internal.model.type.type import Type
 
         if value is None:
             value = Type.bytes
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(value),
         }
 
         return_type = Type.list.build_collection(value if value is Type.str else Type.int)
 
         super().__init__(args, return_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/listgenericmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/listgenericmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,23 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model.builtin.method.listmethod import ListMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class ListGenericMethod(ListMethod):
 
     def __init__(self, value: IType = None):
         from boa3.internal.model.type.type import Type
 
         if value is None:
             value = Type.any
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(value),
         }
 
         value_default = ast.parse("{0}".format(Type.sequence.default_value)
                                   ).body[0].value
 
         return_value = Type.any if value is Type.any else []
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/listmappingmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/listmappingmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,23 +1,21 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.method.listmethod import ListMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ListMappingMethod(ListMethod):
 
     def __init__(self, mapping_type: IType = None):
         from boa3.internal.model.type.type import Type
         if mapping_type is None:
             mapping_type = Type.mapping
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(mapping_type),
         }
 
         return_type = Type.list.build_collection(mapping_type.key_type)
 
         super().__init__(args, return_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/listmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/uint256type.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,87 +1,110 @@
-import ast
-from typing import Any, Dict, List, Optional
+from typing import Any
 
-from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.internal.model.variable import Variable
+from boa3.internal import constants
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.method import IBuiltinMethod
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.neo.vm.opcode import OpcodeHelper
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class ListMethod(IBuiltinMethod):
+class UInt256Type(BytesType, ClassType):
+    """
+    A class used to represent Neo's UInt256 type
+    """
+
+    def __init__(self):
+        super().__init__()
+        self._identifier = 'UInt256'
+        from boa3.internal.model.builtin.method.uint256method import UInt256Method
+        self._constructor = UInt256Method(self)
 
-    def __init__(self, args: Dict[str, Variable] = None, return_type=None, defaults: List[ast.AST] = None):
-        identifier = 'list'
-
-        super().__init__(identifier, args, defaults=defaults, return_type=return_type)
+    @property
+    def identifier(self) -> str:
+        return self._identifier
 
     @property
-    def _arg_value(self) -> Variable:
-        return self.args['value']
+    def abi_type(self) -> AbiType:
+        return AbiType.Hash256
+
+    def constructor_method(self) -> Method | None:
+        return self._constructor
 
     @property
-    def identifier(self) -> str:
-        from boa3.internal.model.type.type import Type
+    def default_value(self) -> Any:
+        return bytes(constants.SIZE_OF_INT256)
 
-        if self._arg_value.type is Type.str or self._arg_value.type is Type.bytes:
-            return '-{0}_{1}'.format(self._identifier, Type.str.identifier + Type.bytes.identifier)
+    @classmethod
+    def build(cls, value: Any = None) -> IType:
+        return _UInt256
 
-        if Type.sequence.is_type_of(self._arg_value.type):
-            return '-{0}_{1}'.format(self._identifier, Type.sequence.identifier)
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, UInt256Type)
 
-        if Type.mapping.is_type_of(self._arg_value.type):
-            return '-{0}_{1}'.format(self._identifier, Type.mapping.identifier)
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+        properties = [UInt256ZeroProperty()
+                      ]
 
-        return self._identifier
+        for prop in properties:
+            self._properties[prop.identifier] = prop
 
-    def generate_internal_opcodes(self, code_generator):
-        self.generate_pack_opcodes(code_generator)
-        code_generator.insert_opcode(Opcode.PACK)
+    def is_instance_opcodes(self) -> list[tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        return super(PythonClass, self).is_instance_opcodes()
+
+    def generate_is_instance_type_check(self, code_generator):
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        return super(PythonClass, self).generate_is_instance_type_check(code_generator)
+
+    def _generate_specific_class_type_check(self, code_generator) -> list[int]:
+        from boa3.internal.model.builtin.builtin import Builtin
+        from boa3.internal.model.operation.binaryop import BinaryOp
 
-    def generate_pack_opcodes(self, code_generator):
-        """
-        :type code_generator: boa3.internal.compiler.codegenerator.codegenerator.CodeGenerator
-        """
-        pass
+        code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
+        code_generator.convert_literal(constants.SIZE_OF_INT256)
+        code_generator.convert_operation(BinaryOp.NumEq, is_internal=True)
+        return []
+
+    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> list[tuple[Opcode, bytes]]:
+        push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_INT256)
+
+        return [
+            (Opcode.SIZE, b''),  # return len(value) == 32
+            (push_int_opcode, size_data),
+            (Opcode.NUMEQUAL, b'')
+        ]
+
+
+_UInt256 = UInt256Type()
+
+
+class GetUInt256ZeroMethod(IBuiltinMethod):
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        identifier = '-uint160_get_zero'
+        args = {}
+        super().__init__(identifier, args, return_type=Type.int)
+
+    def generate_internal_opcodes(self, code_generator):
+        code_generator.convert_literal(_UInt256.default_value)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
-        return None
+    def _body(self) -> str | None:
+        return
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if not isinstance(value, list):
-            value = [value]
-
-        from boa3.internal.model.type.type import Type
 
-        from boa3.internal.model.type.annotation.uniontype import UnionType
-        is_union = len(value) > 0 and isinstance(value[0], UnionType)
-        union_types = value[0].union_types if is_union else None
-
-        if len(value) > 0:
-            if Type.str.is_type_of(value[0]) or Type.bytes.is_type_of(value[0]) or \
-                    (is_union and all((union_type is Type.str or union_type is Type.bytes) for union_type in union_types)):
-                from boa3.internal.model.builtin.method import ListBytesStringMethod
-                return ListBytesStringMethod(value[0])
-
-            if Type.mapping.is_type_of(value[0]):
-                from boa3.internal.model.builtin.method import ListMappingMethod
-                return ListMappingMethod(value[0])
-
-            if is_union and \
-                    any((union_type is Type.str or
-                         union_type is Type.bytes or
-                         Type.sequence.is_type_of(union_type) or
-                         Type.mapping.is_type_of(union_type)) for union_type in union_types):
-                from boa3.internal.model.builtin.method import ListGenericMethod
-                return ListGenericMethod(value[0])
-
-            if value[0] is Type.any:
-                from boa3.internal.model.builtin.method import ListGenericMethod
-                return ListGenericMethod()
-
-            if Type.sequence.is_type_of(value[0]):
-                from boa3.internal.model.builtin.method import ListSequenceMethod
-                return ListSequenceMethod(value[0])
+class UInt256ZeroProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'zero'
+        getter = GetUInt256ZeroMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/listsequencemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/listsequencemethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,23 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model.builtin.method.listmethod import ListMethod
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ListSequenceMethod(ListMethod):
 
     def __init__(self, sequence_type: IType = None):
         from boa3.internal.model.type.type import Type
         if sequence_type is None:
             sequence_type = Type.sequence
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'value': Variable(sequence_type),
         }
 
         value_default = ast.parse("{0}".format(Type.sequence.default_value)
                                   ).body[0].value
 
         return_type = Type.list.build_collection(sequence_type.value_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/maxbytestringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/maxbytestringmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.method.maxmethod import MaxMethod
 from boa3.internal.model.type.itype import IType
 
 
 class MaxByteStringMethod(MaxMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         is_valid_type = Type.str.is_type_of(arg_value) or Type.bytes.is_type_of(arg_value)
         super().__init__(arg_value if is_valid_type else Type.str)
 
     def _compare_values(self, code_generator):
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/maxmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/maxmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.collection.sequence.tupletype import TupleType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class MaxMethod(IBuiltinMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         identifier = 'max'
 
         self._allowed_types = [Type.int, Type.str, Type.bytes]
         default_type = Type.int
         if not self._is_valid_type(arg_value):
             arg_value = default_type
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'args1': Variable(arg_value),
             'args2': Variable(arg_value)
         }
         vararg = ('values', Variable(arg_value))
         super().__init__(identifier, args, return_type=arg_value, vararg=vararg)
 
-    def _is_valid_type(self, arg_type: Optional[IType]) -> bool:
+    def _is_valid_type(self, arg_type: IType | None) -> bool:
         return (isinstance(arg_type, IType) and
                 any(allowed_type.is_type_of(arg_type) for allowed_type in self._allowed_types))
 
     @property
     def identifier(self) -> str:
         from boa3.internal.model.type.type import Type
         if self._arg_values.type is Type.int:
@@ -69,15 +69,15 @@
         else_stack_size_equals_3 = code_generator.convert_begin_else(if_stack_size_equals_2, is_internal=True)
         #   aux_list = [arg1, arg2, *values]
         code_generator.swap_reverse_stack_items(3)
         code_generator.insert_opcode(Opcode.UNPACK)
         code_generator.insert_opcode(Opcode.INC)
         code_generator.insert_opcode(Opcode.INC)
         code_generator.convert_end_if(else_stack_size_equals_3, is_internal=True)
-        code_generator.insert_opcode(Opcode.PACK)
+        code_generator.insert_opcode(Opcode.PACK, add_to_stack=[Type.list.build(self._arg_values.type)])
 
         # index = len(aux_list) - 1
         code_generator.duplicate_stack_top_item()
         code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
         code_generator.insert_opcode(Opcode.DEC)
         code_generator.duplicate_stack_item(2)
         code_generator.duplicate_stack_item(2)
@@ -116,15 +116,15 @@
         self.generate_internal_opcodes(code_generator)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, list) and len(value) > 0:
             value = value[0]
         if isinstance(value, TupleType):
             value = value.value_type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/minbytestringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/minbytestringmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Optional
-
 from boa3.internal.model.builtin.method.minmethod import MinMethod
 from boa3.internal.model.type.itype import IType
 
 
 class MinByteStringMethod(MinMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         is_valid_type = Type.str.is_type_of(arg_value) or Type.bytes.is_type_of(arg_value)
         super().__init__(arg_value if is_valid_type else Type.str)
 
     def _compare_values(self, code_generator):
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/minmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/minmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.collection.sequence.tupletype import TupleType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class MinMethod(IBuiltinMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         identifier = 'min'
 
         self._allowed_types = [Type.int, Type.str, Type.bytes]
         default_type = Type.int
         if not self._is_valid_type(arg_value):
             arg_value = default_type
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'args1': Variable(arg_value),
             'args2': Variable(arg_value)
         }
         vararg = ('values', Variable(arg_value))
         super().__init__(identifier, args, return_type=arg_value, vararg=vararg)
 
         self.internal_call_args = len(args)
 
-    def _is_valid_type(self, arg_type: Optional[IType]) -> bool:
+    def _is_valid_type(self, arg_type: IType | None) -> bool:
         return (isinstance(arg_type, IType) and
                 any(allowed_type.is_type_of(arg_type) for allowed_type in self._allowed_types))
 
     @property
     def identifier(self) -> str:
         from boa3.internal.model.type.type import Type
         if self._arg_values.type is Type.int:
@@ -69,15 +69,15 @@
         else_stack_size_equals_3 = code_generator.convert_begin_else(if_stack_size_equals_2, is_internal=True)
         #   aux_list = [arg1, arg2, *values]
         code_generator.swap_reverse_stack_items(3)
         code_generator.insert_opcode(Opcode.UNPACK)
         code_generator.insert_opcode(Opcode.INC)
         code_generator.insert_opcode(Opcode.INC)
         code_generator.convert_end_if(else_stack_size_equals_3, is_internal=True)
-        code_generator.insert_opcode(Opcode.PACK)
+        code_generator.insert_opcode(Opcode.PACK, add_to_stack=[Type.list.build(self._arg_values.type)])
 
         # index = len(aux_list) - 1
         code_generator.duplicate_stack_top_item()
         code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
         code_generator.insert_opcode(Opcode.DEC)
         code_generator.duplicate_stack_item(2)
         code_generator.duplicate_stack_item(2)
@@ -121,15 +121,15 @@
         code_generator.insert_opcode(Opcode.MIN, pop_from_stack=True, add_to_stack=[Type.int])
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, list) and len(value) > 0:
             value = value[0]
         if isinstance(value, TupleType):
             value = value.value_type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/printboolmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/printboolmethod.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/printbytestringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/printbytestringmethod.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/printclassmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/printclassmethod.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/printintmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/printintmethod.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/printmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/printmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.collection.sequence.tupletype import TupleType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class PrintMethod(IBuiltinMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
         identifier = 'print'
         if not isinstance(arg_value, IType):
             arg_value = Type.str
 
-        args: Dict[str, Variable] = {}
+        args: dict[str, Variable] = {}
         vararg = ('values', Variable(arg_value))
         super().__init__(identifier, args, return_type=Type.none, vararg=vararg)
 
     @property
     def _arg_values(self) -> Variable:
         return self._vararg[1]
 
@@ -88,15 +88,15 @@
         pass
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, list) and len(value) == 1:
             value = value[0]
         if isinstance(value, TupleType):
             value = value.value_type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/printsequencemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/printsequencemethod.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/rangemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/rangemethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 import ast
-from typing import Any, Dict, List, Optional, Union
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class RangeMethod(IBuiltinMethod):
 
-    def __init__(self, values_types: List[IType] = None):
+    def __init__(self, values_types: list[IType] = None):
         from boa3.internal.model.type.type import Type
         identifier = 'range'
         if not isinstance(values_types, list) or len(values_types) < 1:
             stop = Variable(Type.none)
             start = Variable(Type.none)
             step = Variable(Type.none)
         else:
             stop = Variable(Type.int)
             start = Variable(Type.int)
             step = Variable(Type.int)
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'stop': stop,
             'start': start,
             'step': step
         }
         start_default = ast.parse("{0}".format(Type.int.default_value)
                                   ).body[0].value
         step_default = ast.parse("1").body[0].value
@@ -48,22 +48,22 @@
         return True
 
     def reorder(self, arguments: list):
         if len(arguments) > 1:
             # swap start and stop default positions
             arguments[0], arguments[1] = arguments[1], arguments[0]
 
-    def validate_parameters(self, *params: Union[IExpression, IType]) -> bool:
+    def validate_parameters(self, *params: IExpression | IType) -> bool:
         if len(params) < 1 or len(params) > 3:
             return False
 
         if any(not isinstance(param, (IExpression, IType)) for param in params):
             return False
 
-        params_type: List[IType] = [param if isinstance(param, IType) else param.type for param in params]
+        params_type: list[IType] = [param if isinstance(param, IType) else param.type for param in params]
         from boa3.internal.model.type.type import Type
         return all(param is Type.int for param in params_type)
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
 
@@ -122,14 +122,14 @@
             code_generator.remove_stack_top_item()
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, list) and self.validate_parameters(*value):
             return RangeMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/reversedmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/reversedmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,24 @@
-from typing import Any, Dict, Iterable, Optional
+from collections.abc import Iterable
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ReversedMethod(IBuiltinMethod):
     def __init__(self, args_type: SequenceType = None):
         from boa3.internal.model.type.type import Type
         identifier = 'reversed'
         if not isinstance(args_type, SequenceType):
             args_type = Type.sequence
 
-        args: Dict[str, Variable] = {'sequence': Variable(args_type)}
+        args: dict[str, Variable] = {'sequence': Variable(args_type)}
 
         super().__init__(identifier, args, return_type=Type.reversed)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
@@ -37,15 +38,15 @@
 
         if type(value) == type(self.args['sequence'].type):
             return self
 
         return ReversedMethod(value)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
         from boa3.internal.model.type.type import Type
         from boa3.internal.neo.vm.type.StackItem import StackItemType
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strboolmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/put/storageputuint256method.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,28 +1,15 @@
-from typing import Dict
+from boa3.internal.model.builtin.interop.storage.put.istorageputmethod import IStoragePutMethod
 
-from boa3.internal.model.builtin.method.strmethod import StrMethod
-from boa3.internal.model.variable import Variable
-
-
-class StrBoolMethod(StrMethod):
 
+class StoragePutUInt256Method(IStoragePutMethod):
     def __init__(self):
-        from boa3.internal.model.type.type import Type
-        args: Dict[str, Variable] = {
-            'object': Variable(Type.bool),
-        }
-
-        super().__init__(args)
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 
-    def generate_internal_opcodes(self, code_generator):
-        # if object == True:
-        if_address = code_generator.convert_begin_if()
-        #   result = 'True'
-        code_generator.convert_literal(str(True))
+        identifier = 'put_uint256'
+        value_type = UInt256Type.build()
 
-        # else:
-        if_address = code_generator.convert_begin_else(if_address, is_internal=True)
-        #   result = 'False'
-        code_generator.convert_literal(str(False))
+        super().__init__(identifier, value_type=value_type)
 
-        code_generator.convert_end_if(if_address, is_internal=True)
+    def generate_serialize_value_opcodes(self, code_generator):
+        # it doesn't need to serialize UInt256 because it is also bytes value
+        return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strbytestringmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/strbytestringmethod.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 import ast
-from typing import Dict
 
 from boa3.internal.model.builtin.method.strmethod import StrMethod
 from boa3.internal.model.variable import Variable
 
 
 class StrBytesMethod(StrMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'object': Variable(Type.union.build([Type.bytes, Type.str])),
         }
         object_default = ast.parse("'{0}'".format(Type.str.default_value)).body[0].value
 
         super().__init__(args, [object_default])
 
     def generate_internal_opcodes(self, code_generator):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strclassmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/strclassmethod.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from typing import Dict, Any, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.model.builtin.method.strmethod import StrMethod
 from boa3.internal.model.type.classes.userclass import UserClass
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class StrClassMethod(StrMethod):
 
-    def __init__(self, arg_value: Optional[IType] = None):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.classes import userclass
 
         if arg_value is None:
             arg_value = userclass._EMPTY_CLASS
 
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'object': Variable(arg_value),
         }
 
         super().__init__(args)
 
     @property
     def arg_type(self) -> UserClass:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strintmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/strintmethod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.method.strmethod import StrMethod
 from boa3.internal.model.variable import Variable
 
 
 class StrIntMethod(StrMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'object': Variable(Type.int),
         }
 
         super().__init__(args)
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.interop.stdlib import ItoaMethod
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/strmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import ast
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class StrMethod(IBuiltinMethod):
 
-    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+    def __init__(self, args: dict[str, Variable] = None, defaults: list[ast.AST] = None):
         from boa3.internal.model.type.type import Type
         identifier = 'str'
         super().__init__(identifier, args, defaults=defaults, return_type=Type.str)
 
     @property
     def _arg_value(self) -> Variable:
         return self.args['object']
@@ -36,15 +36,15 @@
         return self._identifier
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
         from boa3.internal.model.type.type import Type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strsequencemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/unvote.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,34 +1,30 @@
-from typing import Dict, Any, Optional
-
-from boa3.internal.model.builtin.method import IBuiltinMethod
-from boa3.internal.model.builtin.method.strmethod import StrMethod
-from boa3.internal.model.type.itype import IType
-from boa3.internal.model.type.type import Type
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class StrSequenceMethod(StrMethod):
-
-    def __init__(self, arg_value: Optional[IType] = None):
-        if arg_value is None:
-            arg_value = Type.sequence
+class UnVoteMethod(NeoContractMethod):
 
-        args: Dict[str, Variable] = {
-            'object': Variable(arg_value),
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'un_vote'
+        native_identifier = 'vote'  # un_vote is not neo native
+        args: dict[str, Variable] = {
+            'account': Variable(UInt160Type.build()),
         }
 
-        super().__init__(args)
-
-    def build(self, value: Any) -> IBuiltinMethod:
-        if 'object' in self.args and self.args['object'].type is not Type.any:
-            return self
-
-        if Type.sequence.is_type_of(value):
-            return StrSequenceMethod(value)
+        neo_internal_args = {
+            'account': Variable(UInt160Type.build()),
+            'vote_to': Variable(ECPointType.build())
+        }
 
-        return super().build(value)
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool,
+                         internal_call_args=len(neo_internal_args))
 
     def generate_internal_opcodes(self, code_generator):
-        from boa3.internal.model.builtin.interop.interop import Interop
-
-        code_generator.convert_builtin_method_call(Interop.JsonSerialize, is_internal=True)
+        # unvote(account) = vote(account, None)
+        code_generator.convert_literal(None)
+        code_generator.swap_reverse_stack_items(2)
+        super().generate_internal_opcodes(code_generator)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/strsplitmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/strsplitmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 import ast
-from typing import Dict, List
 
 from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class StrSplitMethod(StdLibMethod):
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'split'
         syscall = 'stringSplit'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'self': Variable(Type.str),
             'sep': Variable(Type.str),
             'maxsplit': Variable(Type.int)
         }
         # whitespace is the default separator
         separator_default = ast.parse("' '").body[0].value
         # maxsplit the default value is -1
@@ -28,28 +27,29 @@
         }
 
         super().__init__(identifier, syscall, args, defaults=[separator_default, maxsplit_default],
                          return_type=Type.list.build_collection(Type.str),
                          internal_call_args=len(neo_internal_args))
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         # the original string must be the top value in the stack
         indexes = list(range(len(self.args)))
         str_index = list(self.args).index('self')
 
         if indexes[-1] != str_index:
             # context must be the last generated argument
             indexes.remove(str_index)
             indexes.append(str_index)
         return indexes
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
+        from boa3.internal.model.type.type import Type
 
         code_generator.duplicate_stack_item(3)
         code_generator.swap_reverse_stack_items(2)
         super().generate_internal_opcodes(code_generator)
 
         # if maxsplit > 0
         code_generator.duplicate_stack_item(2)
@@ -58,22 +58,25 @@
         code_generator.change_jump(is_valid_split_count, Opcode.JMPLT)
 
         #   while len(array) < maxsplit + 1:
         while_start = code_generator.convert_begin_while()
         code_generator.duplicate_stack_top_item()
 
         #       concat values
+        concat_operation = BinaryOp.Concat.build(Type.bytearray)  # to return buffer
+
         code_generator.duplicate_stack_item(4)
         code_generator.duplicate_stack_item(2)
         code_generator.insert_opcode(Opcode.POPITEM, pop_from_stack=True)
-        code_generator.convert_operation(BinaryOp.Concat, is_internal=True)
+        code_generator.convert_operation(concat_operation, is_internal=True)
         code_generator.duplicate_stack_item(2)
         code_generator.insert_opcode(Opcode.POPITEM, pop_from_stack=True)
         code_generator.swap_reverse_stack_items(2)
-        code_generator.convert_operation(BinaryOp.Concat, is_internal=True)
+        code_generator.convert_operation(concat_operation, is_internal=True)
+        code_generator.convert_cast(Type.str, is_internal=True)
         code_generator.convert_builtin_method_call(Builtin.SequenceAppend, is_internal=True)
 
         while_condition = code_generator.bytecode_size
         code_generator.duplicate_stack_top_item()
         code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
         code_generator.duplicate_stack_item(3)
         code_generator.insert_opcode(Opcode.INC)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/summethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/summethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 import ast
-from typing import Dict, Optional
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class SumMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'sum'
-        args: Dict[str, Variable] = {'__iterable': Variable(Type.sequence.build_collection(Type.int)),
+        args: dict[str, Variable] = {'__iterable': Variable(Type.sequence.build_collection(Type.int)),
                                      '__start': Variable(Type.int)}
 
         start_default = ast.parse("{0}".format(Type.int.default_value)
                                   ).body[0].value
         super().__init__(identifier, args, defaults=[start_default], return_type=Type.int)
 
     def generate_internal_opcodes(self, code_generator):
@@ -51,9 +50,9 @@
         code_generator.remove_stack_top_item()
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/supermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/supermethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Any, Optional, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.type.classes.classtype import ClassType
 from boa3.internal.model.type.itype import IType
 
 
 class SuperMethod(IBuiltinMethod):
@@ -30,15 +31,15 @@
         return self._super_type is not None
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, Sized) and len(value) > 0:
             value = value[0]
         if value == self._super_type:
             return self
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/toboolmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/toboolmethod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from abc import ABC
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.model.variable import Variable
@@ -11,15 +11,15 @@
 
 class ToBoolMethod(IBuiltinMethod, ABC):
     def __init__(self, self_type: IType):
         identifier = 'to_bool'
         if isinstance(self_type, IdentifiedSymbol):
             identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
 
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
         from boa3.internal.model.type.type import Type
         super().__init__(identifier, args, return_type=Type.bool)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -36,15 +36,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class _ConvertToBoolMethod(ToBoolMethod):
     def __init__(self):
         super().__init__(None)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/tobytesmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/tobytesmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 from abc import ABC
-from typing import Any, Dict, Optional, Sequence
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.model.type.primitive.inttype import IntType
@@ -11,15 +12,15 @@
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ToBytesMethod(IBuiltinMethod, ABC):
     def __init__(self, self_type: IType):
         identifier = 'to_bytes'
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
         from boa3.internal.model.type.type import Type
         super().__init__(identifier, args, return_type=Type.bytes)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -50,15 +51,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class _ConvertToBytesMethod(ToBytesMethod):
     def __init__(self):
         super().__init__(None)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/tohexstrmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/tohexstrmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import Dict, Optional
-
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.variable import Variable
 
 
 class ToHexStrMethod(IBuiltinMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         identifier = 'to_hex_str'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'data': Variable(Type.bytes)
         }
         super().__init__(identifier, args, return_type=Type.str)
 
     def generate_internal_opcodes(self, code_generator):
         from boa3.internal import constants
         from boa3.internal.model.builtin.builtin import Builtin
@@ -107,9 +105,9 @@
         code_generator.convert_end_if(is_empty)
 
     @property
     def _args_on_stack(self) -> int:
         return 0
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/tointmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/tointmethod.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from abc import ABC
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.model.variable import Variable
@@ -11,15 +11,15 @@
 
 class ToIntMethod(IBuiltinMethod, ABC):
     def __init__(self, self_type: IType):
         identifier = 'to_int'
         if isinstance(self_type, IdentifiedSymbol):
             identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
 
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        args: dict[str, Variable] = {'self': Variable(self_type)}
         from boa3.internal.model.type.type import Type
         super().__init__(identifier, args, return_type=Type.int)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
@@ -36,15 +36,15 @@
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
 
 class _ConvertToIntMethod(ToIntMethod):
     def __init__(self):
         super().__init__(None)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/toscripthashmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/toscripthashmethod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Any, Dict, Optional, Sized
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
@@ -13,15 +14,15 @@
     def __init__(self, data_type: IType = None):
         if (not Type.int.is_type_of(data_type)
                 and not Type.str.is_type_of(data_type)
                 and not Type.bytes.is_type_of(data_type)):
             data_type = Type.any
 
         identifier = 'to_script_hash'
-        args: Dict[str, Variable] = {'value': Variable(data_type)}
+        args: dict[str, Variable] = {'value': Variable(data_type)}
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         super().__init__(identifier, args, return_type=UInt160Type.build())
 
     @property
     def identifier(self) -> str:
         from boa3.internal.model.type.type import Type
         self_type = self.args['value'].type
@@ -93,15 +94,15 @@
         code_generator.convert_end_try(try_begin, try_end)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
         if 'value' in self.args and self.args['value'].type is not Type.any:
             return self
 
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/uint160method.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/uint160method.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
@@ -14,15 +14,15 @@
 
     def __init__(self, return_type: UInt160Type, argument_type: IType = None):
         from boa3.internal.model.type.type import Type
         if argument_type is None or not self.validate_parameters(argument_type):
             argument_type = Type.none
 
         identifier = 'UInt160'
-        args: Dict[str, Variable] = {'object': Variable(argument_type)}
+        args: dict[str, Variable] = {'object': Variable(argument_type)}
 
         args_default = ast.parse("{0}".format(Type.int.default_value)
                                  ).body[0].value
 
         super().__init__(identifier, args, [args_default], return_type=return_type)
 
     @property
@@ -122,15 +122,15 @@
         code_generator.convert_assert()
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self._arg_object.type):
             return self
         if isinstance(value, list):
             value = value[0] if len(value) > 0 else None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/method/uint256method.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/method/uint256method.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import ast
-from typing import Any, Dict, Optional
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
@@ -14,15 +14,15 @@
 
     def __init__(self, return_type: UInt256Type, argument_type: IType = None):
         from boa3.internal.model.type.type import Type
         if argument_type is None or not self.validate_parameters(argument_type):
             argument_type = Type.none
 
         identifier = 'UInt256'
-        args: Dict[str, Variable] = {'object': Variable(argument_type)}
+        args: dict[str, Variable] = {'object': Variable(argument_type)}
 
         args_default = ast.parse("{0}".format(Type.int.default_value)
                                  ).body[0].value
 
         super().__init__(identifier, args, [args_default], return_type=return_type)
 
     @property
@@ -122,15 +122,15 @@
         code_generator.convert_assert()
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self._arg_object.type):
             return self
         if isinstance(value, list):
             value = value[0] if len(value) > 0 else None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/contract_management/hasmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetransfermethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,25 @@
-from typing import Dict
+import ast
 
-from boa3.internal.model.builtin.interop.nativecontract import ContractManagementMethod
+from boa3.internal.model.builtin.contract.nep17_interface_methods.nep17interfacemethod import Nep17InterfaceMethod
+from boa3.internal.model.builtin.interop.contract import ContractType
 from boa3.internal.model.variable import Variable
 
 
-class HasMethod(ContractManagementMethod):
+class Nep17InterfaceTransferMethod(Nep17InterfaceMethod):
 
-    def __init__(self):
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+    def __init__(self, self_type: ContractType):
         from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
-        identifier = 'has_method'
-        syscall = 'hasMethod'
-        args: Dict[str, Variable] = {
-            'hash': Variable(UInt160Type.build()),
-            'method': Variable(Type.str),
-            'parameter_count': Variable(Type.int)
+        args: dict[str, Variable] = {
+            'self': Variable(self_type),
+            'from_address': Variable(UInt160Type.build()),
+            'to_address': Variable(UInt160Type.build()),
+            'amount': Variable(Type.int),
+            'data': Variable(Type.any),
         }
 
-        super().__init__(identifier, syscall, args, return_type=Type.bool)
+        data_default = ast.parse("{0}".format(Type.any.default_value)
+                                 ).body[0].value
+
+        super().__init__(args, 'transfer', return_type=Type.bool, defaults=[data_default])
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/contractmanagementclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/contractmanagementclass.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import ContractManagement
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class ContractManagementClass(INativeContractClass):
@@ -12,15 +10,15 @@
     A class used to represent ContractManagement native contract
     """
 
     def __init__(self):
         super().__init__('ContractManagement', ContractManagement)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.interop import Interop
 
         if len(self._class_methods) == 0:
             from boa3.internal.model.builtin.native.contract_management import HasMethod
 
             self._class_methods = {
@@ -30,15 +28,15 @@
                 'deploy': Interop.CreateContract,
                 'update': Interop.UpdateContract,
                 'destroy': Interop.DestroyContract
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> ContractManagementClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _ContractManagement
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, ContractManagementClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/cryptolibclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/cryptolibclass.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import CryptoLibContract
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class CryptoLibClass(INativeContractClass):
@@ -12,15 +10,15 @@
     A class used to represent CryptoLib native contract
     """
 
     def __init__(self):
         super().__init__('CryptoLib', CryptoLibContract)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.interop import Interop
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'murmur32': Interop.Murmur32,
                 'sha256': Interop.Sha256,
@@ -32,15 +30,15 @@
                 'bls12_381_mul': Interop.Bls12381Mul,
                 'bls12_381_pairing': Interop.Bls12381Pairing,
                 'bls12_381_serialize': Interop.Bls12381Serialize,
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> CryptoLibClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _CryptoLib
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, CryptoLibClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/gasclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/gasclass.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.constants import GAS_SCRIPT
 from boa3.internal.model.builtin.interop.contract import GasToken
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
@@ -13,15 +11,15 @@
     A class used to represent GAS native contract
     """
 
     def __init__(self):
         super().__init__('GAS', GasToken)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.native.nep17_methods import (BalanceOfMethod, DecimalsMethod, SymbolMethod,
                                                                       TotalSupplyMethod, TransferMethod)
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'balanceOf': BalanceOfMethod(GAS_SCRIPT),
@@ -29,15 +27,15 @@
                 'symbol': SymbolMethod(GAS_SCRIPT),
                 'totalSupply': TotalSupplyMethod(GAS_SCRIPT),
                 'transfer': TransferMethod(GAS_SCRIPT)
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> GasClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Gas
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, GasClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/inativecontractclass.py` & `neo3_boa-1.2.0/boa3/internal/model/property.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,47 +1,42 @@
-import abc
-from typing import Dict, Optional
+import ast
 
-from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
-from boa3.internal.model.property import Property
-from boa3.internal.model.type.classes.classarraytype import ClassArrayType
-from boa3.internal.model.variable import Variable
+from boa3.internal.model.type.itype import IType
 
 
-class INativeContractClass(ClassArrayType, abc.ABC):
-    def __init__(self, identifier: str, contract_hash_property: IBuiltinProperty):
-        super().__init__(identifier)
-
-        self._variables: Dict[str, Variable] = {}
-        self._class_methods: Dict[str, Method] = {}
-        self._constructor: Method = None
-        self._properties = {
-            'hash': contract_hash_property
-        }
+class Property(IExpression):
+    """
+    A class used to represent a variable
 
-    @property
-    def instance_variables(self) -> Dict[str, Variable]:
-        return self._variables.copy()
+    :ivar var_type: the type of the variable.
+    """
 
-    @property
-    def class_variables(self) -> Dict[str, Variable]:
-        return {}
+    def __init__(self,
+                 getter: Method,
+                 setter: Method = None,
+                 origin_node: ast.AST | None = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(origin_node, deprecated)
+        self._getter: Method = getter
+        self._setter: Method | None = setter
 
     @property
-    def properties(self) -> Dict[str, Property]:
-        return self._properties
+    def shadowing_name(self) -> str:
+        return 'property'
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
-        return {}
+    def type(self) -> IType:
+        return self._getter.type
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
-        return self._class_methods
+    def getter(self) -> Method:
+        return self._getter
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
+    def setter(self) -> Method | None:
+        return self._setter
 
-    def constructor_method(self) -> Optional[Method]:
-        return self._constructor
+    def __str__(self) -> str:
+        return str(self.type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/ledgerclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/ledgerclass.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import LedgerContract
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class LedgerClass(INativeContractClass):
@@ -12,15 +10,15 @@
     A class used to represent Ledger native contract
     """
 
     def __init__(self):
         super().__init__('Ledger', LedgerContract)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.interop import Interop
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'get_block': Interop.GetBlock,
                 'get_current_index': Interop.CurrentIndex.getter,
@@ -29,15 +27,15 @@
                 'get_transaction_height': Interop.GetTransactionHeight,
                 'get_transaction_signers': Interop.GetTransactionSigners,
                 'get_transaction_vm_state': Interop.GetTransactionVMState
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> LedgerClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Ledger
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, LedgerClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/nativecontract.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/nativecontract.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.builtin.interop.interop import Interop
 from boa3.internal.model.builtin.native import *
 from boa3.internal.model.builtin.native.oracleclass import OracleClass
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.imports.package import Package
 
 
@@ -57,15 +55,15 @@
 
     StdLibModule = Package(identifier=StdLib.identifier.lower(),
                            types=[StdLib]
                            )
 
     # endregion
 
-    package_symbols: List[IdentifiedSymbol] = [
+    package_symbols: list[IdentifiedSymbol] = [
         ContractManagementModule,
         CryptoLibModule,
         GasModule,
         LedgerModule,
         NeoModule,
         OracleModule,
         PolicyModule,
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getaccountstatemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getaccountstatemethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.contract import NeoAccountStateType
 from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
 class GetAccountStateMethod(NeoContractMethod):
 
     def __init__(self, neo_account_state: NeoAccountStateType):
         from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
         identifier = 'get_account_state'
         native_identifier = 'getAccountState'
-        args: Dict[str, Variable] = {
+        args: dict[str, Variable] = {
             'account': Variable(UInt160Type.build())
         }
         super().__init__(identifier, native_identifier, args, return_type=neo_account_state)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getallcandidatesmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/createmultisigaccountmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
-from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetAllCandidatesMethod(NeoContractMethod):
+class CreateMultisigAccountMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.type import Type
 
-        identifier = 'get_all_candidates'
-        native_identifier = 'getAllCandidates'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, native_identifier, args,
-                         return_type=IteratorType.build(Type.tuple.build_collection(
-                             [ECPointType.build(), Type.int]
-                         )))
+        identifier = 'create_multisig_account'
+        syscall = 'System.Contract.CreateMultisigAccount'
+        args: dict[str, Variable] = {
+            'm': Variable(Type.int),
+            'pub_keys': Variable(Type.list.build_collection([ECPointType.build()]))
+        }
+        super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatesmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getallcandidatesmethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict
-
+from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
 from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetCandidatesMethod(NeoContractMethod):
+class GetAllCandidatesMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        identifier = 'get_candidates'
-        native_identifier = 'getCandidates'
-        args: Dict[str, Variable] = {}
+        identifier = 'get_all_candidates'
+        native_identifier = 'getAllCandidates'
+        args: dict[str, Variable] = {}
         super().__init__(identifier, native_identifier, args,
-                         return_type=Type.list.build_collection([
-                             Type.tuple.build_collection([
-                                 ECPointType.build(),
-                                 Type.int])]))
+                         return_type=IteratorType.build(Type.tuple.build_collection(
+                             [ECPointType.build(), Type.int]
+                         )))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatevotemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neo_contract_methods/getcommitteemethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,19 +1,14 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetCandidateVoteMethod(NeoContractMethod):
+class GetCommitteeMethod(NeoContractMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
         from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        identifier = 'get_candidate_vote'
-        native_identifier = 'getCandidateVote'
-        args: Dict[str, Variable] = {
-            'pubkey': Variable(ECPointType.build())
-        }
-        super().__init__(identifier, native_identifier, args,
-                         return_type=Type.int)
+        identifier = 'get_committee'
+        native_identifier = 'getCommittee'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, native_identifier, args, return_type=Type.list.build([ECPointType.build()]))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getcommitteemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/contract/nep11transferevent.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,21 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
 from boa3.internal.model.variable import Variable
 
 
-class GetCommitteeMethod(NeoContractMethod):
+class Nep11TransferEvent(IBuiltinEvent):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'Nep11TransferEvent'
+        type_token_id = Type.union.build([Type.str, Type.bytes])
 
-        identifier = 'get_committee'
-        native_identifier = 'getCommittee'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, native_identifier, args, return_type=Type.list.build([ECPointType.build()]))
+        args: dict[str, Variable] = {
+            'from_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
+            'to_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
+            'amount': Variable(Type.int),
+            'tokenId': Variable(type_token_id),
+        }
+        super().__init__(identifier, args)
+        self.name = 'Transfer'
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/getnextblockvalidators.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/blockchain/gettransactionsignersmethod.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,15 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.builtin.interop.blockchain.signertype import SignerType
+from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
 from boa3.internal.model.variable import Variable
 
 
-class GetNextBlockValidatorsMethod(NeoContractMethod):
+class GetTransactionSignersMethod(LedgerMethod):
 
-    def __init__(self):
+    def __init__(self, signer_type: SignerType):
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
         from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        identifier = 'get_next_block_validators'
-        native_identifier = 'getNextBlockValidators'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, native_identifier, args, return_type=Type.list.build([ECPointType.build()]))
+        identifier = 'get_transaction_signers'
+        syscall = 'getTransactionSigners'
+        args: dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
+        super().__init__(identifier, syscall, args, return_type=Type.list.build([signer_type]))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/unclaimedgasmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/stdlib/atoimethod.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,19 +1,21 @@
-from typing import Dict
+import ast
 
-from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
 from boa3.internal.model.variable import Variable
 
 
-class UnclaimedGasMethod(NeoContractMethod):
+class AtoiMethod(StdLibMethod):
 
     def __init__(self):
         from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-
-        identifier = 'unclaimed_gas'
-        native_identifier = 'unclaimedGas'
-        args: Dict[str, Variable] = {
-            'account': Variable(UInt160Type.build()),
-            'end': Variable(Type.int)
+        identifier = 'atoi'
+        syscall = 'atoi'
+        args: dict[str, Variable] = {
+            'value': Variable(Type.str),
+            'base': Variable(Type.int)
         }
-        super().__init__(identifier, native_identifier, args, return_type=Type.int)
+
+        args_default = ast.parse("{0}".format(10)
+                                 ).body[0].value
+
+        super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.int)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/unvote.py` & `neo3_boa-1.2.0/boa3/internal/model/standards/standardmethod.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,32 +1,28 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.type import Type
 from boa3.internal.model.variable import Variable
 
 
-class UnVoteMethod(NeoContractMethod):
-
-    def __init__(self):
-        from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
-
-        identifier = 'un_vote'
-        native_identifier = 'vote'  # un_vote is not neo native
-        args: Dict[str, Variable] = {
-            'account': Variable(UInt160Type.build()),
-        }
-
-        neo_internal_args = {
-            'account': Variable(UInt160Type.build()),
-            'vote_to': Variable(ECPointType.build())
-        }
-
-        super().__init__(identifier, native_identifier, args, return_type=Type.bool,
-                         internal_call_args=len(neo_internal_args))
+class StandardMethod(Method):
+    def __init__(self,
+                 display_name: str,
+                 args: dict[str, IType] = None,
+                 return_type: IType = Type.none,
+                 safe: bool = False,
+                 literal_implementation: bool = True,
+                 deprecated: bool = False
+                 ):
+        if not isinstance(args, dict):
+            args = {}
+        method_args = {key: Variable(value) for key, value in args.items()}
+        super().__init__(
+            args=method_args,
+            return_type=return_type,
+            is_public=True,
+            external_name=display_name,
+            is_safe=safe,
+            deprecated=deprecated
+        )
 
-    def generate_internal_opcodes(self, code_generator):
-        # unvote(account) = vote(account, None)
-        code_generator.convert_literal(None)
-        code_generator.swap_reverse_stack_items(2)
-        super().generate_internal_opcodes(code_generator)
+        self.literal_implementation = literal_implementation
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neo_contract_methods/vote.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/classmethod/popsequencemethod.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,20 +1,28 @@
-from typing import Dict
+import ast
 
-from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.builtin.classmethod.popmethod import PopMethod
+from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
-class VoteMethod(NeoContractMethod):
+class PopSequenceMethod(PopMethod):
 
-    def __init__(self):
+    def __init__(self, arg_value: IType | None = None):
         from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
-        identifier = 'vote'
-        native_identifier = 'vote'
-        args: Dict[str, Variable] = {
-            'account': Variable(UInt160Type.build()),
-            'vote_to': Variable(ECPointType.build())
+        if not Type.mutableSequence.is_type_of(arg_value):
+            arg_value = Type.mutableSequence
+
+        args: dict[str, Variable] = {
+            'self': Variable(arg_value),
+            'index': Variable(arg_value.valid_key)
         }
-        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
+
+        index_default = ast.parse("-1").body[0].value.operand
+        index_default.n = -1
+
+        super().__init__(args, defaults=[index_default], return_type=arg_value.value_type)
+
+    def generate_opcodes(self, code_generator):
+        code_generator.fix_negative_index()
+        self.generate_internal_opcodes(code_generator)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/neoclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/neoclass.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.constants import NEO_SCRIPT
 from boa3.internal.model.builtin.interop.contract import NeoToken
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
@@ -13,15 +11,15 @@
     A class used to represent NEO native contract
     """
 
     def __init__(self):
         super().__init__('NEO', NeoToken)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.native.nep17_methods import (BalanceOfMethod, DecimalsMethod, SymbolMethod,
                                                                       TotalSupplyMethod, TransferMethod)
         from boa3.internal.model.builtin.native.neo_contract_methods import (GetAccountStateMethod, GetAllCandidatesMethod,
                                                                              GetCandidatesMethod, GetCandidateVoteMethod,
                                                                              GetCommitteeMethod, GetGasPerBlockMethod,
                                                                              GetNextBlockValidatorsMethod,
@@ -49,15 +47,15 @@
                 'unregister_candidate': UnregisterCandidateMethod(),
                 'un_vote': UnVoteMethod(),
                 'vote': VoteMethod(),
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> NeoClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Neo
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, NeoClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/nep17_methods/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/decimalsmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getplatformmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,15 +1,19 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
-class DecimalsMethod(Nep17Method):
-
-    def __init__(self, contract_script_hash: bytes):
+class GetPlatformMethod(InteropMethod):
+    def __init__(self):
         from boa3.internal.model.type.type import Type
+        identifier = '-get_platform'
+        syscall = 'System.Runtime.Platform'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, syscall, args, return_type=Type.str)
+
 
-        identifier = 'decimals'
-        native_identifier = 'decimals'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, native_identifier, args, return_type=Type.int, script_hash=contract_script_hash)
+class PlatformProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'platform'
+        getter = GetPlatformMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/symbolmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/runtime/getgasleftmethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,15 +1,19 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
-class SymbolMethod(Nep17Method):
-
-    def __init__(self, contract_script_hash: bytes):
+class GetGasLeftMethod(InteropMethod):
+    def __init__(self):
         from boa3.internal.model.type.type import Type
+        identifier = '-get_gas_left'
+        syscall = 'System.Runtime.GasLeft'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, syscall, args, return_type=Type.int)
+
 
-        identifier = 'symbol'
-        native_identifier = 'symbol'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, native_identifier, args, return_type=Type.str, script_hash=contract_script_hash)
+class GasLeftProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'gas_left'
+        getter = GetGasLeftMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/totalsupplymethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/contract/getcallflagsmethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,15 +1,12 @@
-from typing import Dict
-
-from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
+from boa3.internal.model.builtin.interop.contract.callflagstype import CallFlagsType
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
 from boa3.internal.model.variable import Variable
 
 
-class TotalSupplyMethod(Nep17Method):
-
-    def __init__(self, contract_script_hash: bytes):
-        from boa3.internal.model.type.type import Type
+class GetCallFlagsMethod(InteropMethod):
 
-        identifier = 'totalSupply'
-        native_identifier = 'totalSupply'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, native_identifier, args, return_type=Type.int, script_hash=contract_script_hash)
+    def __init__(self, call_flags_type: CallFlagsType):
+        identifier = 'get_call_flags'
+        syscall = 'System.Contract.GetCallFlags'
+        args: dict[str, Variable] = {}
+        super().__init__(identifier, syscall, args, return_type=call_flags_type)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/nep17_methods/transfermethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/interop/storage/get/storagegetuint160method.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,27 +1,20 @@
-import ast
-from typing import Dict
+from boa3.internal.model.builtin.interop.storage.get.istoragegetmethod import IStorageGetMethod
 
-from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
-from boa3.internal.model.variable import Variable
 
+class StorageGetUInt160Method(IStorageGetMethod):
+    def __init__(self):
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
-class TransferMethod(Nep17Method):
+        identifier = 'get_uint160'
+        value_type = UInt160Type.build()
 
-    def __init__(self, contract_script_hash: bytes):
-        from boa3.internal.model.type.type import Type
-        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        super().__init__(identifier, value_type=value_type)
 
-        identifier = 'transfer'
-        native_identifier = 'transfer'
-        args: Dict[str, Variable] = {
-            'from_address': Variable(UInt160Type.build()),
-            'to_address': Variable(UInt160Type.build()),
-            'amount': Variable(Type.int),
-            'data': Variable(Type.any),
-        }
+    def generate_default_value_opcodes(self, code_generator):
+        from boa3.internal.model.builtin.builtin import Builtin
 
-        data_default = ast.parse("{0}".format(Type.any.default_value)
-                                 ).body[0].value
+        code_generator.convert_literal(Builtin.UInt160.default_value)
 
-        super().__init__(identifier, native_identifier, args, defaults=[data_default],
-                         return_type=Type.bool, script_hash=contract_script_hash)
+    def generate_deserialize_value_opcodes(self, code_generator):
+        # it doesn't need to deserialize bytes values
+        return
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/oracleclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/oracleclass.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import OracleContract
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class OracleClass(INativeContractClass):
@@ -12,28 +10,28 @@
     A class used to represent Oracle class
     """
 
     def __init__(self):
         super().__init__('Oracle', OracleContract)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.oracle.oraclegetpricemethod import OracleGetPriceMethod
         from boa3.internal.model.builtin.interop.oracle.oraclerequestmethod import OracleRequestMethod
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'get_price': OracleGetPriceMethod(),
                 'request': OracleRequestMethod()
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> OracleClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Oracle
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, OracleClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/policyclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/policyclass.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import PolicyContract
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class PolicyClass(INativeContractClass):
@@ -12,29 +10,29 @@
     A class used to represent Policy native contract
     """
 
     def __init__(self):
         super().__init__('Policy', PolicyContract)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.interop import Interop
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'get_fee_per_byte': Interop.GetFeePerByte,
                 'get_exec_fee_factor': Interop.GetExecFeeFactor,
                 'get_storage_price': Interop.GetStoragePrice,
                 'is_blocked': Interop.IsBlocked
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> PolicyClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _Policy
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, PolicyClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/rolemanagementclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/rolemanagementclass.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import RoleManagement
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class RoleManagementClass(INativeContractClass):
@@ -12,26 +10,26 @@
     A class used to represent RoleManagement native contract
     """
 
     def __init__(self):
         super().__init__('RoleManagement', RoleManagement)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.interop import Interop
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'get_designated_by_role': Interop.GetDesignatedByRole
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> RoleManagementClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _RoleManagement
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, RoleManagementClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/builtin/native/stdlibclass.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/native/stdlibclass.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.builtin.interop.nativecontract import StdLibContract
 from boa3.internal.model.builtin.native.inativecontractclass import INativeContractClass
 from boa3.internal.model.method import Method
 
 
 class StdLibClass(INativeContractClass):
@@ -12,15 +10,15 @@
     A class used to represent StdLib native contract
     """
 
     def __init__(self):
         super().__init__('StdLib', StdLibContract)
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         # avoid recursive import
         from boa3.internal.model.builtin.interop.interop import Interop
 
         if len(self._class_methods) == 0:
             self._class_methods = {
                 'serialize': Interop.Serialize,
                 'deserialize': Interop.Deserialize,
@@ -36,15 +34,15 @@
                 'atoi': Interop.Atoi,
                 'memory_compare': Interop.MemoryCompare,
                 'memory_search': Interop.MemorySearch,
             }
         return super().class_methods
 
     @classmethod
-    def build(cls, value: Any = None) -> StdLibClass:
+    def build(cls, value: Any = None) -> Self:
         if value is None or cls._is_type_of(value):
             return _StdLib
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, StdLibClass)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/callable.py` & `neo3_boa-1.2.0/boa3/internal/model/callable.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,10 @@
-from __future__ import annotations
-
 import ast
 from abc import ABC
-from typing import Dict, List, Optional, Set, Tuple
+from typing import Self
 
 from boa3.internal.model import set_internal_call
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.model.variable import Variable
 from boa3.internal.neo.vm.VMCode import VMCode
 
@@ -16,33 +14,36 @@
     A class used to represent a function or a class method
 
     :ivar args: a dictionary that maps each arg with its name. Empty by default.
     :ivar is_public: a boolean value that specifies if the method is public. False by default.
     :ivar return_type: the return type of the method. None by default.
     """
 
-    def __init__(self, args: Dict[str, Variable] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None,
-                 defaults: List[ast.AST] = None,
+    def __init__(self,
+                 args: dict[str, Variable] = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None,
+                 defaults: list[ast.AST] = None,
                  return_type: IType = Type.none, is_public: bool = False,
-                 decorators: List[Callable] = None,
+                 decorators: list[Self] = None,
                  external_name: str = None,
                  is_safe: bool = False,
-                 origin_node: Optional[ast.AST] = None):
+                 origin_node: ast.AST | None = None,
+                 deprecated: bool = False
+                 ):
 
         if args is None:
             args = {}
-        self.args: Dict[str, Variable] = args.copy()
+        self.args: dict[str, Variable] = args.copy()
 
         if not isinstance(defaults, list):
             defaults = []
-        self.defaults: List[ast.AST] = defaults
+        self.defaults: list[ast.AST] = defaults
 
-        self._vararg: Optional[Tuple[str, Variable]] = None
+        self._vararg: tuple[str, Variable] | None = None
         if (isinstance(vararg, tuple) and len(vararg) == 2
                 and isinstance(vararg[0], str) and isinstance(vararg[1], Variable)):
 
             from boa3.internal.model.type.typeutils import TypeUtils
 
             vararg_id, vararg_var = vararg
             if vararg_var.type is not Type.any:
@@ -50,113 +51,113 @@
                                                       Type.tuple.build_collection(vararg_var.type),
                                                       Type.tuple.default_value)
             else:
                 default_code = "{0}".format(Type.tuple.default_value)
 
             default_value = set_internal_call(ast.parse(default_code).body[0].value)
 
-            self.args[vararg_id] = Variable(Type.tuple.build_collection([vararg_var.type]))
+            self.args[vararg_id] = Variable(Type.tuple.build_any_length(vararg_var.type))
             self.defaults.append(default_value)
             self._vararg = vararg
 
         if kwargs is None:
             kwargs = {}
-        self._kwargs: Dict[str, Variable] = kwargs.copy()
+        self._kwargs: dict[str, Variable] = kwargs.copy()
 
         self.return_type: IType = return_type
 
         if decorators is None:
             decorators = []
         from boa3.internal.model.decorator import IDecorator
-        self.decorators: List[IDecorator] = [decorator for decorator in decorators
+        self.decorators: list[IDecorator] = [decorator for decorator in decorators
                                              if isinstance(decorator, IDecorator)]
 
         from boa3.internal.model.builtin.decorator import PublicDecorator
         public_decorator = next((decorator for decorator in self.decorators
                                  if isinstance(decorator, PublicDecorator)),
                                 None)
 
         self.is_public: bool = is_public or public_decorator is not None
         if self.is_public:
             if isinstance(public_decorator, PublicDecorator):
                 external_name = public_decorator.name
             elif self.defined_by_entry:
                 external_name = None
 
-        self.external_name: Optional[str] = external_name
+        self.external_name: str | None = external_name
         self.is_safe: bool = is_safe or (isinstance(public_decorator, PublicDecorator) and public_decorator.safe)
 
-        self._self_calls: Set[ast.AST] = set()
+        self._self_calls: set[ast.AST] = set()
 
-        super().__init__(origin_node)
+        super().__init__(origin_node, deprecated)
 
-        self.init_address: Optional[int] = None
-        self.init_bytecode: Optional[VMCode] = None
-        self.init_defaults_bytecode: Optional[VMCode] = None
-        self.end_bytecode: Optional[VMCode] = None
+        self.init_address: int | None = None
+        self.init_bytecode: VMCode | None = None
+        self.init_defaults_bytecode: VMCode | None = None
+        self.end_bytecode: VMCode | None = None
 
     @property
     def type(self) -> IType:
         return self.return_type
 
     @property
-    def symbols(self) -> Dict[str, Variable]:
+    def symbols(self) -> dict[str, Variable]:
         """
         Gets all the symbols in the method
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         return self.args.copy()
 
     @property
-    def args_without_default(self) -> Dict[str, Variable]:
+    def args_without_default(self) -> dict[str, Variable]:
         num_defaults = len(self.defaults)
         if num_defaults > 0:
             return {key: self.args[key] for key in list(self.args.keys())[:-num_defaults]}
         return self.args
 
     @property
-    def positional_args(self) -> Dict[str, Variable]:
+    def positional_args(self) -> dict[str, Variable]:
         return {key: value for key, value in self.args.items() if key not in self._kwargs}
 
     @property
     def has_cls_or_self(self) -> bool:
         return any(decorator.has_cls_or_self for decorator in self.decorators)
 
     @property
-    def cls_or_self_type(self) -> Optional[IType]:
+    def cls_or_self_type(self) -> IType | None:
         if not self.has_cls_or_self or len(self.args) == 0:
             return None
 
         return list(self.args.values())[0].type
 
     @property
     def has_starred_argument(self) -> bool:
         return self._vararg is not None
 
     @property
-    def start_address(self) -> Optional[int]:
+    def start_address(self) -> int | None:
         """
         Gets the address where this method starts in the bytecode
 
         :return: the first address of the method
         """
         if self.init_bytecode is None and self.init_defaults_bytecode is None:
             return self.init_address
         else:
             from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
             return VMCodeMapping.instance().get_start_address(self.init_bytecode)
 
     @property
-    def start_bytecode(self) -> Optional[VMCode]:
+    def start_bytecode(self) -> VMCode | None:
         return (self.init_defaults_bytecode if len(self.defaults) > 0
                 else self.init_bytecode)
 
     @property
-    def end_address(self) -> Optional[int]:
+    def end_address(self) -> int | None:
         """
         Gets the address of this method's last operation in the bytecode
 
         :return: the last address of the method
         """
         if self.end_bytecode is None:
             return self.start_address
@@ -179,15 +180,15 @@
         try:
             self._self_calls.add(origin)
             return True
         except BaseException:
             return False
 
     def __str__(self) -> str:
-        args_types: List[str] = [str(arg.type) for arg in self.args.values()]
+        args_types: list[str] = [str(arg.type) for arg in self.args.values()]
         if self.return_type is not Type.none:
             signature = '({0}) -> {1}'.format(', '.join(args_types), self.return_type)
         else:
             signature = '({0})'.format(', '.join(args_types))
         public = 'public ' if self.is_public else ''
         return '{0}{1}'.format(public, signature)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/debuginstruction.py` & `neo3_boa-1.2.0/boa3/internal/model/debuginstruction.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,9 @@
-from __future__ import annotations
-
 import ast
+from typing import Self
 
 from boa3.internal.neo.vm.VMCode import VMCode
 
 
 class DebugInstruction:
     def __init__(self, code: VMCode, start_line: int, start_col: int, end_line: int = None, end_col: int = None):
         if end_line is None or end_line < start_line:
@@ -20,11 +19,11 @@
 
     def __str__(self) -> str:
         return '{0}:{1}-{2}:{3} {4}'.format(self.start_line, self.start_col,
                                             self.end_line, self.end_col,
                                             self.code)
 
     @classmethod
-    def build(cls, ast_node: ast.AST, bytecode: VMCode) -> DebugInstruction:
+    def build(cls, ast_node: ast.AST, bytecode: VMCode) -> Self:
         end_line: int = ast_node.end_lineno if hasattr(ast_node, 'end_lineno') else ast_node.lineno
         end_col: int = ast_node.end_col_offset + 1 if hasattr(ast_node, 'end_lineno') else ast_node.col_offset
         return cls(bytecode, ast_node.lineno, ast_node.col_offset, end_line, end_col)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/decorator.py` & `neo3_boa-1.2.0/boa3/internal/model/decorator.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,10 +1,9 @@
 import ast
 from abc import abstractmethod
-from typing import Optional
 
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.method import Method
 from boa3.internal.model.symbol import ISymbol
 
 
 class IDecorator(Method):
@@ -15,15 +14,15 @@
         Verifies if the given parameters are valid to the method
 
         :param params: arguments of the method
         :return: True if all arguments are valid. False otherwise.
         """
         pass
 
-    def update_args(self, args: ast.arguments, origin: Optional[ISymbol] = None):
+    def update_args(self, args: ast.arguments, origin: ISymbol | None = None):
         """
         Updates the given args object if this decorator has any specific cases.
         If this is not the case, DON'T overwrite this method
 
         :param args: arguments of the method
         :param origin: internal symbol that is
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/event.py` & `neo3_boa-1.2.0/boa3/internal/model/event.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,25 @@
 import ast
-from typing import Dict, List, Optional, Tuple
 
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.type.type import Type
 from boa3.internal.model.variable import Variable
 
 
 class Event(Callable, IdentifiedSymbol):
-    def __init__(self, event_id: str, args: Dict[str, Variable] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None,
-                 defaults: List[ast.AST] = None,
-                 origin_node: Optional[ast.AST] = None):
-        super().__init__(args, vararg, kwargs, defaults, Type.none, True, origin_node)
+    def __init__(self,
+                 event_id: str, args: dict[str, Variable] = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None,
+                 defaults: list[ast.AST] = None,
+                 origin_node: ast.AST | None = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(args, vararg, kwargs, defaults, Type.none, True, origin_node, deprecated=deprecated)
 
         self.name: str = event_id
         self._identifier: str = None
 
     @property
     def shadowing_name(self) -> str:
         return 'event'
@@ -26,13 +28,13 @@
     def identifier(self) -> str:
         if self._identifier is None:
             # internal identifier should not be the name to avoid nonexistent duplicated symbol ids
             self._identifier = f'-{self.name}-{hex(id(self))}'
         return self._identifier
 
     @property
-    def args_to_generate(self) -> Dict[str, Variable]:
+    def args_to_generate(self) -> dict[str, Variable]:
         return self.args.copy()
 
     @property
     def generate_name(self) -> bool:
         return True
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/imports/builtin.py` & `neo3_boa-1.2.0/boa3/internal/model/imports/compilerbuiltin.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,51 +1,53 @@
-from __future__ import annotations
+__all__ = [
+    'get_package',
+    'get_internal_symbol',
+    'CompilerBuiltin'
+]
 
-from typing import Dict, List, Optional, Tuple, Union
+from typing import Self
 
 from boa3.internal import constants
 from boa3.internal.model.builtin.builtin import Builtin, BoaPackage
 from boa3.internal.model.builtin.interop.interop import Interop
 from boa3.internal.model.builtin.native.nativecontract import NativeContract
 from boa3.internal.model.event import Event
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.imports.package import Package
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.math import Math
-from boa3.internal.model.type.typeutils import TypeUtils
+from boa3.internal.model.type.typeutils import TypeUtils, TypingPackage
 
-__all__ = ['get_package',
-           'get_internal_symbol',
-           'CompilerBuiltin'
-           ]
 
-
-def get_package(package_full_path: str) -> Optional[Package]:
+def get_package(package_full_path: str) -> Package | None:
     return CompilerBuiltin.instance().get_package(package_full_path)
 
 
-def get_internal_symbol(symbol_id: str) -> Optional[ISymbol]:
+def get_internal_symbol(symbol_id: str) -> ISymbol | None:
     return CompilerBuiltin.instance().get_internal_symbol(symbol_id)
 
 
 class CompilerBuiltin:
     _instance = None
 
     @classmethod
-    def instance(cls) -> CompilerBuiltin:
+    def instance(cls) -> Self:
         if cls._instance is None:
             cls._instance = cls()
         return cls._instance
 
     def __init__(self):
-        self.packages: List[Package] = []
-        self._events: List[Event] = []
+        self.packages: list[Package] = []
+        self._events: list[Event] = []
 
-        self._generate_builtin_package('typing', TypeUtils.get_types_from_typing_lib())
+        self._generate_builtin_package('typing', TypeUtils.package_symbols(TypingPackage.Typing))
+        self._generate_builtin_package('collections', TypeUtils.package_symbols(TypingPackage.Collections))
         self._generate_builtin_package('math', Math.get_methods_from_math_lib())
+
+        # TODO: deprecate boa3.builtin packages
         self._generate_builtin_package('boa3.builtin', Builtin.boa_builtins)
         self._set_events(Builtin.builtin_events())
         self._generate_builtin_package('boa3.builtin.contract', Builtin.package_symbols(BoaPackage.Contract))
         self._generate_builtin_package('boa3.builtin.compile_time', Builtin.package_symbols(BoaPackage.CompileTime))
         self._generate_builtin_package('boa3.builtin.interop', Interop.package_symbols)
         self._set_events(Interop.interop_events())
         self._generate_builtin_package('boa3.builtin.nativecontract', NativeContract.package_symbols)
@@ -60,23 +62,31 @@
 
     @classmethod
     def update_with_analyser(cls, analyser):
         for pkg in cls.instance().packages:
             if hasattr(pkg, 'update_with_analyser'):
                 pkg.update_with_analyser(analyser)
 
-    def _set_events(self, events: List[Event]):
+    def _set_events(self, events: list[Event]):
         self._events.extend(events)
 
-    def _generate_builtin_package(self, package_full_path: str,
-                                  symbols: Union[Dict[str, ISymbol], List[IdentifiedSymbol]] = None):
-        if isinstance(symbols, list):
-            symbols = {symbol.identifier: symbol for symbol in symbols}
-        if not isinstance(symbols, dict):
+    def _generate_builtin_package(self,
+                                  package_full_path: str,
+                                  symbols: dict[str | ISymbol] | list[IdentifiedSymbol] | Package = None,
+                                  deprecate: bool = False
+                                  ):
+        if isinstance(symbols, Package):
+            arg_pkg = symbols
             symbols = {}
+        else:
+            arg_pkg = None
+            if isinstance(symbols, list):
+                symbols = {symbol.identifier: symbol for symbol in symbols}
+            if not isinstance(symbols, dict):
+                symbols = {}
 
         package_ids = package_full_path.split(constants.ATTRIBUTE_NAME_SEPARATOR)
         cur_package: Package = None
 
         for package_id in package_ids:
             package = None
 
@@ -85,27 +95,31 @@
                     package = cur_package.inner_packages[package_id]
             else:
                 package = next((root_package for root_package in self.packages
                                 if root_package.identifier == package_id),
                                None)
 
             if not isinstance(package, Package):
-                package = Package(identifier=package_id)
+                need_new_pkg = package_id != package_ids[-1] or arg_pkg is None
+                package = Package(identifier=package_id) if need_new_pkg else arg_pkg
                 if isinstance(cur_package, Package):
                     cur_package.include_symbol(package_id, package)
                 else:
                     self.packages.append(package)
 
             cur_package = package
 
         if isinstance(cur_package, Package):
             for symbol_id, symbol in symbols.items():
                 cur_package.include_symbol(symbol_id, symbol)
 
-    def get_package(self, package_full_path: str) -> Optional[Package]:
+            if deprecate:
+                cur_package.deprecate()
+
+    def get_package(self, package_full_path: str) -> Package | None:
         package_ids = package_full_path.split(constants.ATTRIBUTE_NAME_SEPARATOR)
 
         cur_package: Package = next((root_package for root_package in self._instance.packages
                                      if root_package.identifier == package_ids[0]),
                                     None)
         if cur_package is None:
             return None
@@ -114,16 +128,16 @@
             if package_id not in cur_package.inner_packages:
                 return None
 
             cur_package = cur_package.inner_packages[package_id]
 
         return cur_package
 
-    def get_internal_symbol(self, symbol_id: str) -> Optional[ISymbol]:
-        packages_stack: List[Tuple[list, int]] = []
+    def get_internal_symbol(self, symbol_id: str) -> ISymbol | None:
+        packages_stack: list[tuple[list, int]] = []
         current_list = self._instance.packages
         current_index = 0
 
         while len(current_list) > current_index or len(packages_stack) > 0:
             if len(current_list) <= current_index:
                 # if didn't find in the current list, go back to the previous list search
                 # if the stack is empty, it doesn't continue the loop because the while condition
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/imports/importsymbol.py` & `neo3_boa-1.2.0/boa3/internal/model/imports/importsymbol.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Dict
 
 from boa3.internal.analyser.importanalyser import ImportAnalyser
 from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
 from boa3.internal.model.method import Method
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
@@ -14,16 +13,20 @@
     A class used to represent an imported package
 
     :ivar variables: a dictionary that maps each variable with its name. Empty by default.
     :ivar methods: a dictionary that maps each method with its name. Empty by default.
     :ivar types: a dictionary that maps each type with its name. Empty by default.
     """
 
-    def __init__(self, origin: str, syntax_tree: ast.AST, import_analyser: ImportAnalyser,
-                 imported_symbols: Dict[str, ISymbol] = None):
+    def __init__(self,
+                 origin: str,
+                 syntax_tree: ast.AST,
+                 import_analyser: ImportAnalyser,
+                 imported_symbols: dict[str, ISymbol] = None
+                 ):
         if imported_symbols is None:
             symbols = import_analyser.symbols
         else:
             symbols = import_analyser.export_symbols(list(imported_symbols.keys()))
 
         self.variables = {var_id: var for var_id, var in symbols.items() if isinstance(var, Variable)}
         self.methods = {fun_id: fun for fun_id, fun in symbols.items() if isinstance(fun, Method)}
@@ -45,28 +48,35 @@
         self.ast: ast.AST = syntax_tree
 
     @property
     def shadowing_name(self) -> str:
         return 'module'
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         symbol = {}
         symbol.update(self.variables)
         symbol.update(self.methods)
         symbol.update(self.types)
         symbol.update(self._other_symbols)
         symbol.update(self.imports)
         return symbol
 
     @property
-    def all_symbols(self) -> Dict[str, ISymbol]:
+    def all_symbols(self) -> dict[str, ISymbol]:
         symbol = self.symbols.copy()
         symbol.update(self._symbols_not_imported)
         return symbol
 
+    @property
+    def is_deprecated(self) -> bool:
+        return False
+
+    def deprecate(self, new_location: str = None):
+        return
+
 
 class BuiltinImport(Import):
     """
     A class used to differentiate built-in importings
     """
     pass
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/imports/package.py` & `neo3_boa-1.2.0/boa3/internal/model/module.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,131 +1,135 @@
-from __future__ import annotations
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.method import Method
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.variable import Variable
 
-from typing import Dict, List, Optional
 
-from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
-
-
-class Package(IdentifiedSymbol):
+class Module(ISymbol):
     """
-    A class used to represent a Python module.
+    A class used to represent a Python module
 
-    :ivar properties: a list that stores every property in the package. Empty by default.
-    :ivar methods: a list that stores every method in the package. Empty by default.
-    :ivar types: a list that stores every property in the package. Empty by default.
+    :ivar variables: a dictionary that maps each variable with its name. Empty by default.
+    :ivar methods: a dictionary that maps each method with its name. Empty by default.
+    :ivar callables: a dictionary that maps each callable object with its name. Empty by default.
+    :ivar classes: a dictionary that maps each class with its name. Empty by default.
+    :ivar imported_symbols: a dictionary that maps each imported symbol with its name. Empty by default.
     """
 
-    def __init__(self, identifier: str,
-                 properties: List[IdentifiedSymbol] = None,
-                 methods: List[IdentifiedSymbol] = None,
-                 types: List[IdentifiedSymbol] = None,
-                 packages: List[Package] = None,
-                 other_symbols: dict = None,
-                 import_origin=None
+    def __init__(self,
+                 variables: dict[str, Variable] = None,
+                 methods: dict[str, Method] = None,
+                 deprecated: bool = False
                  ):
-        """
-        :param packages: a list that stores the inner packages and modules of this package. Empty by default.
-        :param other_symbols: a dictionary with other symbols that are evaluated during the compilation. Empty by
-          default. Should be None for builtin packages.
-        :type other_symbols: dict or None
-        :param import_origin: the analyser that generated this package. Should be None for builtin packages.
-        :type import_origin: boa3.internal.model.imports.importsymbol.Import
-        """
-
-        from enum import Enum
-        if isinstance(identifier, Enum):
-            identifier = identifier.value
-
-        super().__init__(identifier)
-
-        self._all_symbols: List[IdentifiedSymbol] = []
+        if variables is None:
+            variables = {}
+        self.variables = variables
 
         if methods is None:
-            methods = []
-        self._all_symbols.extend(methods)
-
-        if properties is None:
-            properties = []
-        self._all_symbols.extend(properties)
-
-        if types is None:
-            types = []
-        self._all_symbols.extend(types)
-
-        if packages is None:
-            packages = []
-        self._packages = packages
-        for package in packages:
-            package._parent = self
-
-        # for packages that are not builtin
-        if isinstance(other_symbols, dict):
-            from boa3.internal.model.symbol import ISymbol
-            self._additional_symbols = {key: value
-                                        for key, value in other_symbols.items()
-                                        if (value not in self._all_symbols
-                                            and isinstance(key, str)
-                                            and isinstance(value, ISymbol))}
-            self.origin = import_origin
-        else:
-            self._additional_symbols = {}
-            self.origin = None
-
-        self._aliases: Dict[str, str] = {}
-        self._parent: Optional[Package] = None
+            methods = {}
+        self.methods = methods
+        self.callables: dict[str, Callable] = {}
+        self.classes: dict[str, ClassType] = {}
+
+        self.defined_by_entry = True
+        self._deprecated = deprecated
+        self.imported_symbols = {}
+        self.assigned_variables = []
 
     @property
     def shadowing_name(self) -> str:
-        return 'package'
+        return 'module'
 
     @property
-    def symbols(self) -> Dict[str, IdentifiedSymbol]:
+    def is_deprecated(self) -> bool:
+        return self._deprecated
+
+    def deprecate(self, new_location: str = None):
+        self._deprecated = True
+
+    def include_variable(self, var_id: str, var: Variable):
         """
-        Gets all the symbols in the package.
+        Includes a variable into the scope of the module
 
-        :return: a list that stores every symbol in the package
+        :param var_id: variable identifier
+        :param var: variable to be included
         """
-        symbol_map = {(self._aliases[symbol.raw_identifier]
-                       if symbol.raw_identifier in self._aliases
-                       else symbol.raw_identifier): symbol
-                      for symbol in self._all_symbols}
-        symbol_map.update(self._additional_symbols)
-        return symbol_map
+        if var_id not in self.symbols:
+            self.variables[var_id] = var
 
-    @property
-    def inner_packages(self) -> Dict[str, Package]:
-        return {symbol.raw_identifier: symbol for symbol in self._packages}
+    def is_variable_assigned(self, var_id: str) -> bool:
+        if var_id not in self.variables:
+            return False
 
-    @property
-    def parent(self) -> Optional[Package]:
+        if var_id in self.assigned_variables or var_id in self.imported_symbols:
+            return True
+
+        for imported in self.imported_symbols.values():
+            from boa3.internal.model.imports.importsymbol import Import
+            if isinstance(imported, Import) and self.variables[var_id] in imported.variables.values():
+                return True
+
+        return False
+
+    def assign_variable(self, var_id: str):
+        if var_id in self.variables:
+            self.assigned_variables.append(var_id)
+
+    def include_callable(self, method_id: str, method: Callable) -> bool:
+        """
+        Includes a method into the scope of the module
+
+        :param method_id: method identifier
+        :param method: method to be included
         """
-        Get the parent package of this one. None if it's the root package.
+        if method_id not in self.symbols:
+            if isinstance(method, Method):
+                self.methods[method_id] = method
+            else:
+                self.callables[method_id] = method
+
+            return True
+
+        return False
+
+    def include_class(self, class_id: str, class_obj: ClassType):
         """
-        return self._parent
+        Includes a class into the scope of the module
 
-    def include_symbol(self, symbol_id, symbol: IdentifiedSymbol):
-        identifier = symbol.raw_identifier if isinstance(symbol, IdentifiedSymbol) else symbol_id
-        check_list = self._packages if isinstance(symbol, Package) else self._all_symbols
+        :param class_id: class identifier
+        :param class_obj: class object to be included
+        """
+        if class_id not in self.symbols:
+            self.classes[class_id] = class_obj
 
-        if all(package_symbol.raw_identifier != identifier for package_symbol in check_list):
-            if isinstance(symbol, IdentifiedSymbol) and symbol.raw_identifier != symbol_id:
-                self._aliases[symbol.raw_identifier] = symbol_id
+    def include_symbol(self, symbol_id: str, symbol: ISymbol):
+        """
+        Includes a method into the scope of the module
 
-            if isinstance(symbol, Package):
-                self._packages.append(symbol)
-                if symbol._parent is not None:
-                    return
-                symbol._parent = self
+        :param symbol_id: method identifier
+        :param symbol: method to be included
+        """
+        if symbol_id not in self.symbols:
+            if isinstance(symbol, Variable):
+                self.include_variable(symbol_id, symbol)
+            elif isinstance(symbol, Callable):
+                self.include_callable(symbol_id, symbol)
+            elif isinstance(symbol, ClassType):
+                self.include_class(symbol_id, symbol)
             else:
-                self._all_symbols.append(symbol)
+                self.imported_symbols[symbol_id] = symbol
 
-    def update_with_analyser(self, analyser):
-        from boa3.internal.analyser.analyser import Analyser
-        if isinstance(analyser, Analyser):
-            for symbol in self._all_symbols:
-                if hasattr(symbol, 'update_with_analyser'):
-                    symbol.update_with_analyser(analyser)
-            for pkg in self._packages:
-                pkg.update_with_analyser(analyser)
+    @property
+    def symbols(self) -> dict[str, ISymbol]:
+        """
+        Gets all the symbols in the module
 
-    def __repr__(self) -> str:
-        return self.identifier
+        :return: a dictionary that maps each symbol in the module with its name
+        """
+        symbols = {}
+        symbols.update(self.imported_symbols)
+        symbols.update(self.variables)
+        symbols.update(self.methods)
+        symbols.update(self.callables)
+        symbols.update(self.classes)
+        return symbols
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/method.py` & `neo3_boa-1.2.0/boa3/internal/model/method.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import ast
-from typing import Dict, List, Optional, Tuple
 
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.debuginstruction import DebugInstruction
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.classes.classtype import ClassType
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.model.variable import Variable
@@ -16,38 +15,53 @@
     :ivar args: a dictionary that maps each arg with its name. Empty by default.
     :ivar locals: a dictionary that maps each local variable with its name. Empty by default.
     :ivar imported_symbols: a dictionary that maps each imported symbol with its name. Empty by default.
     :ivar is_public: a boolean value that specifies if the method is public. False by default.
     :ivar return_type: the return type of the method. None by default.
     """
 
-    def __init__(self, args: Dict[str, Variable] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None,
-                 kwargs: Optional[Dict[str, Variable]] = None,
-                 defaults: List[ast.AST] = None,
+    def __init__(self,
+                 args: dict[str, Variable] = None,
+                 vararg: tuple[str, Variable] | None = None,
+                 kwargs: dict[str, Variable] | None = None,
+                 defaults: list[ast.AST] = None,
                  return_type: IType = Type.none, is_public: bool = False,
-                 decorators: List[Callable] = None,
+                 decorators: list[Callable] = None,
                  is_init: bool = False,
                  external_name: str = None,
                  is_safe: bool = False,
-                 origin_node: Optional[ast.AST] = None):
-        super().__init__(args, vararg, kwargs, defaults, return_type, is_public, decorators, external_name, is_safe, origin_node)
+                 origin_node: ast.AST | None = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(
+            args=args,
+            vararg=vararg,
+            kwargs=kwargs,
+            defaults=defaults,
+            return_type=return_type,
+            is_public=is_public,
+            decorators=decorators,
+            external_name=external_name,
+            is_safe=is_safe,
+            origin_node=origin_node,
+            deprecated=deprecated
+        )
 
         self.imported_symbols = {}
         self._symbols = {}
         self.defined_by_entry = True
         self.is_init = is_init
-        self.locals: Dict[str, Variable] = {}
+        self.locals: dict[str, Variable] = {}
 
         if is_init and self.has_cls_or_self:
             self.return_type = list(self.args.values())[0].type
 
-        self._debug_map: List[DebugInstruction] = []
-        self.origin_class: Optional[ClassType] = None
-        self.file_origin: Optional[str] = None
+        self._debug_map: list[DebugInstruction] = []
+        self.origin_class: ClassType | None = None
+        self.file_origin: str | None = None
 
     @property
     def shadowing_name(self) -> str:
         return 'method'
 
     def include_variable(self, var_id: str, var: Variable, is_global: bool = False):
         """
@@ -60,15 +74,15 @@
         if var_id not in self.symbols:
             if is_global:
                 self._symbols[var_id] = var
             else:
                 self.locals[var_id] = var
 
     @property
-    def symbols(self) -> Dict[str, Variable]:
+    def symbols(self) -> dict[str, Variable]:
         """
         Gets all the symbols in the method
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         symbols = self._symbols.copy()
         symbols.update(self.imported_symbols)
@@ -95,30 +109,30 @@
         """
         Returns the method origin ast node.
 
         :return: the ast node that describes this method. None if it is not from a ast.
         """
         return self._origin_node
 
-    def debug_map(self) -> List[DebugInstruction]:
+    def debug_map(self) -> list[DebugInstruction]:
         """
         Returns a list with the debug information of each mapped Python instruction inside this method
         """
         from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
         return sorted(self._debug_map, key=lambda instr: VMCodeMapping.instance().get_start_address(instr.code))
 
     def include_instruction(self, instr_info: DebugInstruction):
         """
         Includes a new instruction in the debug info
 
         :param instr_info: debug information from the new instruction
         """
         if not any((info.start_line == instr_info.start_line and info.start_col == instr_info.start_col
                     for info in self._debug_map)):
-            existing_instr_info: Optional[DebugInstruction] = \
+            existing_instr_info: DebugInstruction | None = \
                 next((info for info in self._debug_map if info.code == instr_info.code), None)
             if existing_instr_info is not None:
                 self._debug_map.remove(existing_instr_info)
             self._debug_map.append(instr_info)
 
     def remove_instruction(self, start_line: int, start_col: int):
         """
@@ -129,15 +143,15 @@
         """
         instruction = next((info for info in self._debug_map
                             if info.start_line == start_line and info.start_col == start_col),
                            None)
         if instruction is not None:
             self._debug_map.remove(instruction)
 
-    def args_to_be_generated(self) -> List[int]:
+    def args_to_be_generated(self) -> list[int]:
         """
         Gets the indexes of the arguments that must be generated.
         If method has `self` arg, it must be in this list.
 
         By default, all the arguments are generated.
 
         :return: A list with the indexes of the arguments that must be generated
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/additional/membership.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/additional/membership.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List, Optional, Tuple
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
 from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
@@ -14,15 +12,15 @@
     A class used to represent a collection membership operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.collection]
+    _valid_types: list[IType] = [Type.collection]
 
     def __init__(self, left: IType = Type.any, right: IType = None):
         self.operator: Operator = Operator.In
 
         if not isinstance(right, ICollectionType):
             right = Type.collection
 
@@ -54,15 +52,15 @@
 
         return reference_type.is_type_of(left)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         return Type.bool
 
     def get_valid_operand_for_validation(self, left_operand: IType,
-                                         right_operand: IType = None) -> Tuple[Optional[IType], Optional[IType]]:
+                                         right_operand: IType = None) -> tuple[IType | None, IType | None]:
         if isinstance(right_operand, ICollectionType):
             left = right_operand.item_type if not isinstance(right_operand, MappingType) else right_operand.key_type
             return left, right_operand
 
         return left_operand, self.right_type
 
     def generate_internal_opcodes(self, code_generator):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/additional/notmembership.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/additional/notmembership.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List, Optional, Tuple
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
 from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 from boa3.internal.model.type.type import IType, Type
 
@@ -13,15 +11,15 @@
     A class used to represent a collection not membership operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.collection]
+    _valid_types: list[IType] = [Type.collection]
 
     def __init__(self, left: IType = Type.any, right: IType = None):
         self.operator: Operator = Operator.NotIn
 
         if not isinstance(right, ICollectionType):
             right = Type.collection
 
@@ -49,15 +47,15 @@
 
         return reference_type.is_type_of(left)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         return Type.bool
 
     def get_valid_operand_for_validation(self, left_operand: IType,
-                                         right_operand: IType = None) -> Tuple[Optional[IType], Optional[IType]]:
+                                         right_operand: IType = None) -> tuple[IType | None, IType | None]:
         if isinstance(right_operand, ICollectionType):
             left = right_operand.item_type if not isinstance(right_operand, MappingType) else right_operand.key_type
             return left, right_operand
 
         return left_operand, self.right_type
 
     def generate_internal_opcodes(self, code_generator):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/addition.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/lessthanorequal.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,43 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Addition(BinaryOperation):
+class LessThanOrEqual(BinaryOperation):
     """
-    A class used to represent a numeric addition operation
+    A class used to represent a numeric less than or equal comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Plus
+        self.operator: Operator = Operator.LtE
         super().__init__(left, right)
 
-    @property
-    def is_symmetric(self) -> bool:
-        return True
-
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
         return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.ADD)
+        code_generator.insert_opcode(Opcode.LE)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/concat.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/concat.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List, Optional
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class Concat(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a string concatenation operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.str, Type.bytes]
+    _valid_types: list[IType] = [Type.str, Type.bytes]
 
     def __init__(self, left: IType = Type.str, right: IType = None):
         self.operator: Operator = Operator.Plus
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
@@ -44,15 +42,15 @@
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
-    def _get_valid_type(self, operator_type: IType) -> Optional[IType]:
+    def _get_valid_type(self, operator_type: IType) -> IType | None:
         return next((valid_type for valid_type in self._valid_types
                      if valid_type.is_type_of(operator_type)), None)
 
     def generate_opcodes(self, code_generator):
         from boa3.internal.neo.vm.type.StackItem import StackItemType
 
         super().generate_opcodes(code_generator)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/division.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/division.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 
 
 class Division(BinaryOperation):
     """
     A class used to represent a floating-point division operation. Floating division is not supported on Neo.
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
         self.operator: Operator = Operator.Div
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/floordivision.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/floordivision.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class FloorDivision(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent an integer division operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
         self.operator: Operator = Operator.IntDiv
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/listaddition.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/listaddition.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ListAddition(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a list addition operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.list]
+    _valid_types: list[IType] = [Type.list]
 
     def __init__(self, left: IType = Type.list, right: IType = None):
         self.operator: Operator = Operator.Plus
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/modulo.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/modulo.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class Modulo(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a numeric modulo operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
         self.operator: Operator = Operator.Mod
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/multiplication.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/addition.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Multiplication(BinaryOperation):
+class Addition(BinaryOperation):
     """
-    A class used to represent a numeric multiplication operation
+    A class used to represent a numeric addition operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Mult
+        self.operator: Operator = Operator.Plus
         super().__init__(left, right)
 
     @property
     def is_symmetric(self) -> bool:
         return True
 
     def validate_type(self, *types: IType) -> bool:
@@ -36,8 +34,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.MUL)
+        code_generator.insert_opcode(Opcode.ADD)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/power.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/greaterthan.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Power(BinaryOperation):
+class GreaterThan(BinaryOperation):
     """
-    A class used to represent a numeric power operation
+    A class used to represent a numeric greater than comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Pow
+        self.operator: Operator = Operator.Gt
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
         return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.POW)
+        code_generator.insert_opcode(Opcode.GT)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/strbytesmultiplication.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/strbytesmultiplication.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class StrBytesMultiplication(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a string or bytes concatenation operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.str, Type.bytes]
+    _valid_types: list[IType] = [Type.str, Type.bytes]
 
     def __init__(self, left: IType = Type.str, right: IType = Type.int):
         self.operator: Operator = Operator.Mult
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
@@ -62,9 +60,8 @@
         code_generator.convert_operation(BinaryOp.Gt, is_internal=True)
         code_generator.convert_end_while(concat_start, condition_start, is_internal=True)
 
         # clear stack
         code_generator.remove_stack_top_item()
         code_generator.remove_stack_top_item()
 
-        if Type.str.is_type_of(self.left_type):
-            code_generator.convert_cast(self.left_type, is_internal=True)
+        code_generator.convert_cast(self.left_type, is_internal=True)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/arithmetic/subtraction.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/multiplication.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,30 +1,32 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Subtraction(BinaryOperation):
+class Multiplication(BinaryOperation):
     """
-    A class used to represent a numeric subtraction operation
+    A class used to represent a numeric multiplication operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Minus
+        self.operator: Operator = Operator.Mult
         super().__init__(left, right)
 
+    @property
+    def is_symmetric(self) -> bool:
+        return True
+
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
         return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
@@ -32,8 +34,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.SUB)
+        code_generator.insert_opcode(Opcode.MUL)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/binaryoperation.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/binaryoperation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,24 @@
-from __future__ import annotations
-
 from abc import ABC, abstractmethod
-from typing import List, Optional, Tuple
+from typing import Self
 
 from boa3.internal.model.operation.operation import IOperation
 from boa3.internal.model.type.itype import IType
 
 
 class BinaryOperation(IOperation, ABC):
     """
     An interface used to represent binary operations
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = []
+    _valid_types: list[IType] = []
 
     def __init__(self, left: IType, right: IType = None):
         if right is None:
             right = left
 
         self.left_type: IType = left
         self.right_type: IType = right
@@ -43,48 +41,48 @@
         :param left: left operand type
         :param right: right operand type
         :return: the result type of the operation. Type.none if the operands are not valid.
         """
         pass
 
     @classmethod
-    def build(cls, *operands: IType) -> Optional[BinaryOperation]:
+    def build(cls, *operands: IType) -> Self | None:
         if len(operands) == 1:
             return cls._build_with_left_arg(operands[0])
         if len(operands) == 2:
             return cls._build_with_two_args(operands[0], operands[1])
 
     @classmethod
-    def _build_with_left_arg(cls, left: IType) -> Optional[BinaryOperation]:
+    def _build_with_left_arg(cls, left: IType) -> Self | None:
         """
         Creates a binary operation with the given operands types
 
         :param left: left operand type
         :return: The built operation if the operands is valid. None otherwise
         :rtype: BinaryOperation or None
         """
         return cls(left)
 
     @classmethod
-    def _build_with_two_args(cls, left: IType, right: IType) -> Optional[BinaryOperation]:
+    def _build_with_two_args(cls, left: IType, right: IType) -> Self | None:
         """
         Creates a binary operation with the given operands types
 
         :param left: left operand type
         :param right: right operand type
         :return: The built operation if the operands are valid. None otherwise
         :rtype: BinaryOperation or None
         """
         operation = cls(left, right)
         if operation.validate_type(left, right):
             return operation
         return cls(left, left)
 
     def get_valid_operand_for_validation(self, left_operand: IType,
-                                         right_operand: IType = None) -> Tuple[Optional[IType], Optional[IType]]:
+                                         right_operand: IType = None) -> tuple[IType | None, IType | None]:
         """
         Returns a valid operand type for the given types.
 
         :param left_operand: reference type
         :param right_operand: reference type
         """
         return next((valid_type for valid_type in self._valid_types if valid_type.is_type_of(left_operand)),
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/booleanand.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/booleanand.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class BooleanAnd(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent the boolean or operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.bool]
+    _valid_types: list[IType] = [Type.bool]
 
     def __init__(self, left: IType = Type.bool, right: IType = None):
         self.operator: Operator = Operator.And
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/booleanor.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/identity.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,33 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class BooleanOr(BinaryOperation):
+class Identity(BinaryOperation):
     """
-    A class used to represent the boolean or operation
+    A class used to represent an is comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.bool]
 
-    def __init__(self, left: IType = Type.bool, right: IType = None):
-        self.operator: Operator = Operator.Or
+    def __init__(self, left: IType = Type.int, right: IType = None):
+        self.operator: Operator = Operator.Is
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        left: IType = types[0]
-        right: IType = types[1]
-
-        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
+        return True
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.BOOLOR)
+        code_generator.insert_opcode(Opcode.EQUAL)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/elvisoperatoror.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/elvisoperatoror.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 
 
 class ElvisOperatorOr(BinaryOperation):
     """
     A class used to represent the boolean or operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.bool]
+    _valid_types: list[IType] = [Type.bool]
 
     def __init__(self, left: IType = Type.bool, right: IType = None):
         self.operator: Operator = Operator.Or
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/leftshift.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/leftshift.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class LeftShift(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent the bit left shift [ << ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = Type.int):
         self.operator: Operator = Operator.LeftShift
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/logicand.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/logicor.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LogicAnd(BinaryOperation):
+class LogicOr(BinaryOperation):
     """
-    A class used to represent the bit and [ & ] operation
+    A class used to represent the bit or [ | ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.BitAnd
+        self.operator: Operator = Operator.BitOr
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
@@ -32,8 +30,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.AND)
+        code_generator.insert_opcode(Opcode.OR)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/logicor.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/logicand.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LogicOr(BinaryOperation):
+class LogicAnd(BinaryOperation):
     """
-    A class used to represent the bit or [ | ] operation
+    A class used to represent the bit and [ & ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.BitOr
+        self.operator: Operator = Operator.BitAnd
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
@@ -32,8 +30,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.OR)
+        code_generator.insert_opcode(Opcode.AND)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/logicxor.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/rightshift.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LogicXor(BinaryOperation):
+class RightShift(BinaryOperation):
     """
-    A class used to represent the bit xor [ ^ ] operation
+    A class used to represent the bit right shift [ >> ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.BitXor
+    def __init__(self, left: IType = Type.int, right: IType = Type.int):
+        self.operator: Operator = Operator.RightShift
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
+        return any(_type.is_type_of(left) for _type in self._valid_types) and Type.int.is_type_of(right)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.XOR)
+        code_generator.insert_opcode(Opcode.SHR)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/logical/rightshift.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/logicxor.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class RightShift(BinaryOperation):
+class LogicXor(BinaryOperation):
     """
-    A class used to represent the bit right shift [ >> ] operation
+    A class used to represent the bit xor [ ^ ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = Type.int):
-        self.operator: Operator = Operator.RightShift
+    def __init__(self, left: IType = Type.int, right: IType = None):
+        self.operator: Operator = Operator.BitXor
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return any(_type.is_type_of(left) for _type in self._valid_types) and Type.int.is_type_of(right)
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.SHR)
+        code_generator.insert_opcode(Opcode.XOR)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,20 +3,28 @@
            'GreaterThan',
            'GreaterThanOrEqual',
            'Identity',
            'NotIdentity',
            'NumericEquality',
            'NumericInequality',
            'ObjectEquality',
-           'ObjectInequality'
+           'ObjectInequality',
+           'StrBytesGreaterThan',
+           'StrBytesGreaterThanOrEqual',
+           'StrBytesLessThan',
+           'StrBytesLessThanOrEqual',
            ]
 
 from boa3.internal.model.operation.binary.relational.greaterthan import GreaterThan
 from boa3.internal.model.operation.binary.relational.greaterthanorequal import GreaterThanOrEqual
 from boa3.internal.model.operation.binary.relational.identity import Identity
 from boa3.internal.model.operation.binary.relational.lessthan import LessThan
 from boa3.internal.model.operation.binary.relational.lessthanorequal import LessThanOrEqual
 from boa3.internal.model.operation.binary.relational.notidentity import NotIdentity
 from boa3.internal.model.operation.binary.relational.numericequality import NumericEquality
 from boa3.internal.model.operation.binary.relational.numericinequality import NumericInequality
 from boa3.internal.model.operation.binary.relational.objectequality import ObjectEquality
 from boa3.internal.model.operation.binary.relational.objectinequality import ObjectInequality
+from boa3.internal.model.operation.binary.relational.strbytesgreaterthan import StrBytesGreaterThan
+from boa3.internal.model.operation.binary.relational.strbytesgreaterthanorequal import StrBytesGreaterThanOrEqual
+from boa3.internal.model.operation.binary.relational.strbyteslessthan import StrBytesLessThan
+from boa3.internal.model.operation.binary.relational.strbyteslessthanorequal import StrBytesLessThanOrEqual
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/greaterthan.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/greaterthanorequal.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class GreaterThan(BinaryOperation):
+class GreaterThanOrEqual(BinaryOperation):
     """
-    A class used to represent a numeric greater than comparison
+    A class used to represent a numeric greater than or equal comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Gt
+        self.operator: Operator = Operator.GtE
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
@@ -32,8 +30,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.GT)
+        code_generator.insert_opcode(Opcode.GE)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/greaterthanorequal.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/logical/booleanor.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class GreaterThanOrEqual(BinaryOperation):
+class BooleanOr(BinaryOperation):
     """
-    A class used to represent a numeric greater than or equal comparison
+    A class used to represent the boolean or operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: list[IType] = [Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.GtE
+    def __init__(self, left: IType = Type.bool, right: IType = None):
+        self.operator: Operator = Operator.Or
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
@@ -32,8 +30,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.GE)
+        code_generator.insert_opcode(Opcode.BOOLOR)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/identity.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/notidentity.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Identity(BinaryOperation):
+class NotIdentity(BinaryOperation):
     """
-    A class used to represent an is comparison
+    A class used to represent an is not comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Is
+        self.operator: Operator = Operator.IsNot
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         return True
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.EQUAL)
+        code_generator.insert_opcode(Opcode.NOTEQUAL)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/lessthan.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/lessthan.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class LessThan(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a numeric less than comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
         self.operator: Operator = Operator.Lt
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/lessthanorequal.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/numericequality.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LessThanOrEqual(BinaryOperation):
+class NumericEquality(BinaryOperation):
     """
-    A class used to represent a numeric less than or equal comparison
+    A class used to represent a numeric equality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.LtE
+        self.operator: Operator = Operator.Eq
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
@@ -32,8 +30,8 @@
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.LE)
+        code_generator.insert_opcode(Opcode.NUMEQUAL)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/notidentity.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/numericinequality.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,36 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NotIdentity(BinaryOperation):
+class NumericInequality(BinaryOperation):
     """
-    A class used to represent an is not comparison
+    A class used to represent a numeric inequality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.IsNot
+        self.operator: Operator = Operator.NotEq
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        return True
+        left: IType = types[0]
+        right: IType = types[1]
+
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.NOTEQUAL)
+        code_generator.insert_opcode(Opcode.NUMNOTEQUAL)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/numericequality.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/power.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NumericEquality(BinaryOperation):
+class Power(BinaryOperation):
     """
-    A class used to represent a numeric equality comparison
+    A class used to represent a numeric power operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Eq
+        self.operator: Operator = Operator.Pow
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
         return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return Type.bool
+            return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.NUMEQUAL)
+        code_generator.insert_opcode(Opcode.POW)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/numericinequality.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/arithmetic/subtraction.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NumericInequality(BinaryOperation):
+class Subtraction(BinaryOperation):
     """
-    A class used to represent a numeric inequality comparison
+    A class used to represent a numeric subtraction operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.NotEq
+        self.operator: Operator = Operator.Minus
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
         return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return Type.bool
+            return left
         else:
             return Type.none
 
     def generate_internal_opcodes(self, code_generator):
-        code_generator.insert_opcode(Opcode.NUMNOTEQUAL)
+        code_generator.insert_opcode(Opcode.SUB)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/objectequality.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/objectequality.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ObjectEquality(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a equality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.str, Type.bytes, Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.str, Type.bytes, Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.str, right: IType = None):
         self.operator: Operator = Operator.Eq
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binary/relational/objectinequality.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binary/relational/objectinequality.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ObjectInequality(BinaryOperation):
@@ -11,15 +9,15 @@
     A class used to represent a inequality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.any]
+    _valid_types: list[IType] = [Type.any]
 
     def __init__(self, left: IType = Type.str, right: IType = None):
         self.operator: Operator = Operator.NotEq
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/binaryop.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/binaryop.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List, Optional
-
 from boa3.internal.model.operation.binary.additional import *
 from boa3.internal.model.operation.binary.arithmetic import *
 from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
 from boa3.internal.model.operation.binary.logical import *
 from boa3.internal.model.operation.binary.relational import *
 from boa3.internal.model.operation.operation import IOperation
 from boa3.internal.model.operation.operator import Operator
@@ -34,14 +32,18 @@
     GtE = GreaterThanOrEqual()
     IsNone = NoneIdentity()
     IsNotNone = NoneNotIdentity()
     Is = Identity()
     IsNot = NotIdentity()
     Eq = ObjectEquality()
     NotEq = ObjectInequality()
+    StrBytesGt = StrBytesGreaterThan()
+    StrBytesGtE = StrBytesGreaterThanOrEqual()
+    StrBytesLt = StrBytesLessThan()
+    StrBytesLtE = StrBytesLessThanOrEqual()
 
     # Logical operations
     And = BooleanAnd()
     Or = BooleanOr()
     ElvisOperatorOr = ElvisOperatorOr()
     BitAnd = LogicAnd()
     BitOr = LogicOr()
@@ -50,15 +52,15 @@
     RShift = RightShift()
 
     # Other operations
     In = CollectionMembership()
     NotIn = CollectionNotMembership()
 
     @classmethod
-    def validate_type(cls, operator: Operator, left: IType, right: IType) -> Optional[BinaryOperation]:
+    def validate_type(cls, operator: Operator, left: IType, right: IType) -> BinaryOperation | None:
         """
         Gets a binary operation given the operator and the operands types.
 
         :param operator: binary operator
         :param left: type of the left operand
         :param right: type of the right operand
         :return: The operation if exists. None otherwise;
@@ -71,38 +73,38 @@
                 else:
                     from boa3.internal.model.type.type import Type
                     operand = right if left is Type.none else left
                     return op.build(operand)
 
     @classmethod
     def get_operation_by_operator(cls, operator: Operator, left_operand: IType,
-                                  right_operand: Optional[IType] = None) -> Optional[BinaryOperation]:
+                                  right_operand: IType | None = None) -> BinaryOperation | None:
         """
         Gets a binary operation given the operator.
 
         :param operator: binary operator
         :param left_operand: left operand of the operator
         :param right_operand: right operand of the operator
         :return: The operation if exists. If exists more than one operation with the same operator, returns the one with
         the same left operand. If none has the same left operand, returns the first found. None otherwise;
         :rtype: BinaryOperation or None
         """
-        valid_operations: List[BinaryOperation] = []
+        valid_operations: list[BinaryOperation] = []
         for id, op in vars(cls).items():
             if isinstance(op, BinaryOperation) and op.operator is operator:
                 left, right = op.get_valid_operand_for_validation(left_operand, right_operand)
                 if left is not None:
                     return op.build(left_operand if right_operand is None else left, right)
                 else:
                     valid_operations.append(op)
 
         return valid_operations[0] if len(valid_operations) > 0 else None
 
     @classmethod
-    def get_operation(cls, operation: BinaryOperation) -> Optional[BinaryOperation]:
+    def get_operation(cls, operation: BinaryOperation) -> BinaryOperation | None:
         """
         Gets a binary operation given another operation.
 
         :param operation: binary operation
         :return: The operation if exists. None otherwise;
         :rtype: BinaryOperation or None
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/operation.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/operation.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,28 +1,27 @@
-from __future__ import annotations
-
 from abc import ABC, abstractmethod
-from typing import Optional
+from typing import Self
 
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 
 
 class IOperation(ISymbol, ABC):
     """
     An interface used to represent operations
 
     :ivar operator: the operator of the operation
     :ivar result: the result type of the operation
     """
 
-    def __init__(self, operator: Operator, result_type: IType):
+    def __init__(self, operator: Operator, result_type: IType, deprecated: bool = False):
         self.operator: Operator = operator
         self.result: IType = result_type
+        self._deprecated: bool = deprecated
 
     def generate_opcodes(self, code_generator):
         """
         Generate the Neo VM opcodes for the method.
 
         :type code_generator: boa3.internal.compiler.codegenerator.codegenerator.CodeGenerator
         """
@@ -42,14 +41,21 @@
         Gets the type of the evaluated expression
 
         :return: the resulting type when the expression is evaluated
         """
         return self.operator.value
 
     @property
+    def is_deprecated(self) -> bool:
+        return self._deprecated
+
+    def deprecate(self, new_location: str = None):
+        self._deprecated = True
+
+    @property
     @abstractmethod
     def number_of_operands(self) -> int:
         """
         Gets the number of operands required for this operations
 
         :return: Number of operands
         """
@@ -94,15 +100,15 @@
 
         :return: True if it is supported. False otherwise.
         """
         return True
 
     @classmethod
     @abstractmethod
-    def build(cls, *operands: IType) -> Optional[IOperation]:
+    def build(cls, *operands: IType) -> Self | None:
         """
         Creates an operation with the given operands types
 
         :param operands: operands types
         :return: The built operation if the operands are valid. None otherwise
         :rtype: IOperation or None
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/operator.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/operator.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,10 @@
-from __future__ import annotations
-
 import ast
 from enum import Enum
-from typing import Dict, Optional, Type
+from typing import Self
 
 
 class Operator(str, Enum):
     # Arithmetic operators
     Plus = '+'
     Minus = '-'
     Mult = '*'
@@ -38,16 +36,16 @@
 
     # Other operators
     Subscript = '[]'
     In = 'in'
     NotIn = 'not in'
 
     @classmethod
-    def get_operation(cls, node: ast.operator) -> Optional[Operator]:
-        operators: Dict[Type[ast.operator], Operator] = {
+    def get_operation(cls, node: ast.operator) -> Self | None:
+        operators: dict[type[ast.operator], Operator] = {
             ast.Add: Operator.Plus,
             ast.Sub: Operator.Minus,
             ast.Mult: Operator.Mult,
             ast.Div: Operator.Div,
             ast.FloorDiv: Operator.IntDiv,
             ast.Mod: Operator.Mod,
             ast.Pow: Operator.Pow,
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/booleannot.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/booleannot.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import List
-
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class BooleanNot(UnaryOperation):
     """
     A class used to represent the boolean not operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.bool]
+    _valid_types: list[IType] = [Type.bool]
 
     def __init__(self, operand: IType = Type.bool):
         self.operator: Operator = Operator.Not
         super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/logicnot.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/logicnot.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import List
-
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class LogicNot(UnaryOperation):
     """
     A class used to represent the bit not [ ~ ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: list[IType] = [Type.int, Type.bool]
 
     def __init__(self, operand: IType = Type.int):
         self.operator: Operator = Operator.BitNot
         super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/negative.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/negative.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from typing import List
-
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
 from boa3.internal.model.type.type import IType, Type
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class Negative(UnaryOperation):
     """
     A class used to represent a numeric negative operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, operand: IType = Type.int):
         self.operator: Operator = Operator.Minus
         super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/noneidentity.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/noneidentity.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/nonenotidentity.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/nonenotidentity.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/positive.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/positive.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,21 @@
-from typing import List
-
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
 from boa3.internal.model.type.type import IType, Type
 
 
 class Positive(UnaryOperation):
     """
     A class used to represent a numeric positive operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: list[IType] = [Type.int]
 
     def __init__(self, operand: IType = Type.int):
         self.operator: Operator = Operator.Plus
         super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unary/unaryoperation.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unary/unaryoperation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,23 @@
-from __future__ import annotations
-
 from abc import ABC, abstractmethod
-from typing import List, Optional
+from typing import Self
 
 from boa3.internal.model.operation.operation import IOperation
 from boa3.internal.model.type.itype import IType
 
 
 class UnaryOperation(IOperation, ABC):
     """
     An interface used to represent binary operations
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar operand: the operand type.
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = []
+    _valid_types: list[IType] = []
 
     def __init__(self, operand: IType):
         self.operand_type: IType = operand
         result = self._get_result(operand)
         super().__init__(self.operator, result)
 
     @property
@@ -33,15 +31,15 @@
 
         :param operand:  operand type
         :return: the result type of the operation. Type.none if the operand is not valid.
         """
         pass
 
     @classmethod
-    def build(cls, operand: IType) -> Optional[UnaryOperation]:
+    def build(cls, operand: IType) -> Self | None:
         """
         Creates a unary operation with the given operand type
 
         :param operand: operand type
         :return: The built operation if the operands are valid. None otherwise
         :rtype: UnaryOperation or None
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/operation/unaryop.py` & `neo3_boa-1.2.0/boa3/internal/model/operation/unaryop.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Optional
-
 from boa3.internal.model.operation.operator import Operator
 from boa3.internal.model.operation.unary import *
 from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
 from boa3.internal.model.type.itype import IType
 
 
 class UnaryOp:
@@ -12,43 +10,43 @@
     Negative = Negative()
 
     # Logical operations
     Not = BooleanNot()
     BitNot = LogicNot()
 
     @classmethod
-    def validate_type(cls, operator: Operator, operand: IType) -> Optional[UnaryOperation]:
+    def validate_type(cls, operator: Operator, operand: IType) -> UnaryOperation | None:
         """
         Gets a unary operation given the operator and the operand type.
 
         :param operator: unary operator
         :param operand: type of the operand
         :return: The operation if exists. None otherwise;
         :rtype: UnaryOperation or None
         """
         for id, op in vars(cls).items():
             if isinstance(op, UnaryOperation) and op.is_valid(operator, operand):
                 return op.build(operand)
 
     @classmethod
-    def get_operation_by_operator(cls, operator: Operator) -> Optional[UnaryOperation]:
+    def get_operation_by_operator(cls, operator: Operator) -> UnaryOperation | None:
         """
         Gets a unary operation given the operator.
 
         :param operator: unary operator
         :return: The operation if exists. If exists more than one operation with the same operator, returns the first
         found. None otherwise.
         :rtype: UnaryOperation or None
         """
         for id, op in vars(cls).items():
             if isinstance(op, UnaryOperation) and op.operator is operator:
                 return op
 
     @classmethod
-    def get_operation(cls, operation: UnaryOperation) -> Optional[UnaryOperation]:
+    def get_operation(cls, operation: UnaryOperation) -> UnaryOperation | None:
         """
         Gets an unary operation given another operation.
 
         :param operation: unary operation
         :return: The operation if exists. None otherwise;
         :rtype: UnaryOperation or None
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/standards/neostandard.py` & `neo3_boa-1.2.0/boa3/internal/model/standards/neostandard.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,33 +1,32 @@
 import abc
-from typing import List, Optional, Union
 
 from boa3.internal.model.event import Event
 from boa3.internal.model.method import Method
 
 
 class INeoStandard(abc.ABC):
-    def __init__(self, methods: List[Method], events: List[Event], optionals: Optional[List[Method]] = None):
+    def __init__(self, methods: list[Method], events: list[Event], optionals: list[Method] | None = None):
         if optionals is None:
             optionals = []
-        self.methods: List[Method] = methods.copy()
-        self.events: List[Event] = events.copy()
-        self.optionals: List[Method] = optionals.copy()
+        self.methods: list[Method] = methods.copy()
+        self.events: list[Event] = events.copy()
+        self.optionals: list[Method] = optionals.copy()
 
-    def match_definition(self, standard: Union[Method, Event], symbol: Union[Method, Event]) -> bool:
+    def match_definition(self, standard: Method | Event, symbol: Method | Event) -> bool:
         if not isinstance(standard, (Method, Event)) or not isinstance(symbol, (Method, Event)):
             return False
 
         standard_symbols = self.methods + self.optionals if isinstance(symbol, Method) else self.events
         if standard not in standard_symbols:
             return False
 
         return self._have_same_signature(standard, symbol)
 
-    def _have_same_signature(self, symbol: Union[Method, Event], other: Union[Method, Event]) -> bool:
+    def _have_same_signature(self, symbol: Method | Event, other: Method | Event) -> bool:
         if (isinstance(symbol, Method) and not isinstance(other, Method)
                 or isinstance(symbol, Event) and not isinstance(other, Event)):
             return False
 
         if symbol.return_type != other.return_type and not (
                 # verifies if both return types are equal if they are a neo3-boa type
                 symbol.return_type.is_type_of(other.return_type) and other.return_type.is_type_of(symbol.return_type)):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/standards/nep11divisiblestandard.py` & `neo3_boa-1.2.0/boa3/internal/model/standards/nep11divisiblestandard.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/standards/nep11nondivisiblestandard.py` & `neo3_boa-1.2.0/boa3/internal/model/standards/nep11nondivisiblestandard.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/standards/nep17standard.py` & `neo3_boa-1.2.0/boa3/internal/model/standards/nep17standard.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/standards/standardmethod.py` & `neo3_boa-1.2.0/boa3/internal/model/builtin/decorator/builtindecorator.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,21 +1,31 @@
-from typing import Dict
+import ast
+from abc import ABC
+from typing import Any
 
-from boa3.internal.model.method import Method
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.decorator import IDecorator
+from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
-from boa3.internal.model.type.type import Type
 from boa3.internal.model.variable import Variable
 
 
-class StandardMethod(Method):
-    def __init__(self, display_name: str,
-                 args: Dict[str, IType] = None,
-                 return_type: IType = Type.none,
-                 safe: bool = False,
-                 literal_implementation: bool = True):
-        if not isinstance(args, dict):
-            args = {}
-        method_args = {key: Variable(value) for key, value in args.items()}
-        super().__init__(args=method_args, return_type=return_type, is_public=True,
-                         external_name=display_name, is_safe=safe)
+class IBuiltinDecorator(IBuiltinCallable, IDecorator, ABC):
+    def __init__(self,
+                 identifier: str, args: dict[str, Variable] = None,
+                 defaults: list[ast.AST] = None,
+                 return_type: IType = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(
+            identifier,
+            args,
+            defaults,
+            return_type,
+            deprecated=deprecated
+        )
 
-        self.literal_implementation = literal_implementation
+    def validate_parameters(self, *params: IExpression) -> bool:
+        return len(params) == len(self.args)
+
+    def validate_values(self, *params: Any) -> list[Any]:
+        return []
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/annotation/metatype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/genericcollectiontype.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,57 +1,48 @@
-from typing import Any, Optional
+from typing import Any
 
+from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.itype import IType
-from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class MetaType(IType):
+class GenericCollectionType(ICollectionType):
     """
-    A class used to represent internal Boa and Python types
+    An class used to represent a generic Python collection type
     """
 
-    def __init__(self, type_of: IType = None):
-        identifier = 'type'
-        super().__init__(identifier)
-        self._internal_type: Optional[IType] = type_of
+    def __init__(self, keys_type: set[IType] = None, values_type: set[IType] = None):
+        identifier: str = 'collection'
+        keys_type = self.filter_types(keys_type)
+        values_type = self.filter_types(values_type)
+        super().__init__(identifier, keys_type, values_type)
 
-    @property
-    def abi_type(self) -> AbiType:
-        return AbiType.Any
-
-    @classmethod
-    def build(cls, value: Any = None) -> IType:
-        if isinstance(value, MetaType):
-            return value
-        if isinstance(value, IType):
-            return cls(value)
-        else:
-            return metaType
-
-    @classmethod
-    def _is_type_of(cls, value: Any) -> bool:
-        return isinstance(value, MetaType)
-
-    def is_type_of(self, value: Any) -> bool:
-        return isinstance(value, MetaType) and self._internal_type.is_type_of(value._internal_type)
+    def is_valid_key(self, key_type: IType) -> bool:
+        return key_type == self.valid_key
 
     @property
-    def meta_identifier(self) -> str:
-        if self.has_meta_type:
-            return f'{self._identifier}[{self._internal_type}]'
-        else:
-            return self._identifier
+    def valid_key(self) -> IType:
+        return self.key_type
 
     @property
-    def has_meta_type(self) -> bool:
-        return self._internal_type is not None
+    def is_generic(self) -> bool:
+        return True
 
-    @property
-    def meta_type(self) -> Optional[IType]:
-        return self._internal_type
-
-    @property
-    def meta_id(self) -> Optional[None]:
-        return self._internal_type.identifier if self._internal_type is not None else None
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, ICollectionType)
 
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            if isinstance(value, dict):
+                keys = list(value.keys())
+                values = list(value.values())
+            else:
+                keys = value.key_type
+                values = value.value_type
+
+            keys_types: set[IType] = cls.get_types(keys)
+            values_types: set[IType] = cls.get_types(values)
+            return cls(keys_types, values_types)
 
-metaType: IType = MetaType()
+    def __hash__(self):
+        return hash(self.identifier)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/annotation/optionaltype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/annotation/optionaltype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-from typing import Any, Iterable, List, Set
+from collections.abc import Iterable
+from typing import Any
 
 from boa3.internal.model.type.annotation.uniontype import UnionType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.nonetype import noneType
 
 
 class OptionalType(UnionType):
     """
     An class used to represent Python Optional annotation type
     """
 
-    def __init__(self, optional_types: Set[IType] = None):
+    def __init__(self, optional_types: set[IType] = None):
         if optional_types is None:
             union_types = None
         else:
             union_types = optional_types.copy()
             if noneType in optional_types:
                 optional_types.remove(noneType)
             else:
@@ -26,15 +27,15 @@
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}]'.format(self._identifier,
                                  ', '.join([t.identifier for t in self._optional_type]))
 
     @property
-    def optional_types(self) -> List[IType]:
+    def optional_types(self) -> list[IType]:
         return list(self._optional_type)
 
     def _is_type_of(self, value: Any) -> bool:
         if not isinstance(self._optional_type, Iterable) or len(self._optional_type) == 0:
             return False
         if isinstance(value, UnionType):
             return all(self._is_type_of(x) for x in value._union_types)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/annotation/uniontype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/annotation/uniontype.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,35 +1,36 @@
-from typing import Any, Iterable, List, Set
+from collections.abc import Iterable
+from typing import Any
 
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class UnionType(IType):
     """
     An class used to represent Python Union annotation type
     """
 
-    def __init__(self, union_types: Set[IType] = None):
+    def __init__(self, union_types: set[IType] = None):
         identifier: str = 'Union'
         super().__init__(identifier)
-        self._union_types: Set[IType] = union_types if union_types is not None else set()
+        self._union_types: set[IType] = union_types if union_types is not None else set()
 
         # variables to not reevaluate everytime we need to access
         self._abi_type: AbiType = None
         self._stack_item: StackItemType = None
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}]'.format(self._identifier,
                                  ', '.join([t.identifier for t in self._union_types]))
 
     @property
-    def union_types(self) -> List[IType]:
+    def union_types(self) -> list[IType]:
         return list(self._union_types)
 
     @property
     def abi_type(self) -> AbiType:
         if self._abi_type is None:
             self._abi_type = AbiType.union([union.abi_type for union in self._union_types])
         return self._abi_type
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/anytype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/anytype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/baseexceptiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/baseexceptiontype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/classarraytype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/classarraytype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/classinitmethoddefault.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/classinitmethoddefault.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,33 +1,31 @@
-from typing import Optional
-
 from boa3.internal import constants
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.method import Method
 from boa3.internal.model.type.classes.userclass import UserClass
 from boa3.internal.model.variable import Variable
 
 
 class ClassInitMethod(IdentifiedSymbol, Method):
-    def __init__(self, user_class: UserClass):
+    def __init__(self, user_class: UserClass, deprecated: bool = False):
         self_var = Variable(user_class)
         args = {
             'self': self_var
         }
         base_init = None
         if len(user_class.bases) == 1:
             # TODO: change when class inheritance with multiple bases is implemented #2kq1gmc
             # use update to keep the original order
             base_init = user_class.bases[0].constructor_method()
             args.update(base_init.args)
             # but change the self type
             args['self'] = self_var
 
-        Method.__init__(self, args=args, return_type=user_class)
-        IdentifiedSymbol.__init__(self, identifier=constants.INIT_METHOD_ID)
+        Method.__init__(self, args=args, return_type=user_class, deprecated=deprecated)
+        IdentifiedSymbol.__init__(self, identifier=constants.INIT_METHOD_ID, deprecated=deprecated)
 
         self.defined_by_entry = False
         self.is_init = True
         self.origin_class = user_class
         # __init__ method behave like class methods
         from boa3.internal.model.builtin.builtin import Builtin
         self.decorators.append(Builtin.ClassMethodDecorator)
@@ -37,9 +35,9 @@
             base_init.add_call_origin(origin)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/classstructtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/classstructtype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/classtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/classtype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,8 @@
-from __future__ import annotations
-
 from abc import ABC, abstractmethod
-from typing import Dict, List, Tuple
 
 from boa3.internal.compiler.codegenerator import get_bytes_count
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.opcode import OpcodeHelper
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.type.AbiType import AbiType
@@ -15,117 +12,117 @@
 
 class ClassType(IType, ABC):
     """
     An abstract class used to represent Python class
     """
 
     def __init__(self, identifier: str, decorators: list = None,
-                 bases: List[ClassType] = None):
+                 bases: list["ClassType"] = None):
         super().__init__(identifier)
 
         if decorators is None:
             decorators = []
         else:
             # avoid circular import
             from boa3.internal.model.decorator import IDecorator
             decorators = [decorator for decorator in decorators
                           if isinstance(decorator, IDecorator)]
 
         self.decorators = decorators
 
         if not isinstance(bases, list):
             bases = []
-        self.bases: List[ClassType] = bases
+        self.bases: list[ClassType] = bases
 
     @property
     @abstractmethod
     def class_variables(self):
         """
-        :rtype: Dict[str, boa3.internal.model.variable.Variable]
+        :rtype: dict[str, boa3.internal.model.variable.Variable]
         """
         class_vars = {}
         for base in self.bases:
             class_vars.update(base.class_variables)
         return class_vars
 
     @property
     @abstractmethod
     def instance_variables(self):
         """
-        :rtype: Dict[str, boa3.internal.model.variable.Variable]
+        :rtype: dict[str, boa3.internal.model.variable.Variable]
         """
         instance_vars = {}
         for base in self.bases:
             instance_vars.update(base.instance_variables)
         return instance_vars
 
     @property
     def variables(self):
         """
-        :rtype: Dict[str, boa3.internal.model.variable.Variable]
+        :rtype: dict[str, boa3.internal.model.variable.Variable]
         """
         variables = self.class_variables.copy()
         variables.update(self.instance_variables)
         return variables
 
     @property
     def _all_variables(self):
         """
-        :rtype: Dict[str, boa3.internal.model.variable.Variable]
+        :rtype: dict[str, boa3.internal.model.variable.Variable]
         """
         return self.variables
 
     @property
     @abstractmethod
     def properties(self):
         """
-        :rtype: Dict[str, boa3.internal.model.property.Property]
+        :rtype: dict[str, boa3.internal.model.property.Property]
         """
         props = {}
         for base in self.bases:
             props.update(base.properties)
         return props
 
     @property
     @abstractmethod
     def static_methods(self):
         """
-        :rtype: Dict[str, boa3.internal.model.method.Method]
+        :rtype: dict[str, boa3.internal.model.method.Method]
         """
         static_funcs = {}
         for base in self.bases:
             static_funcs.update(base.static_methods)
         return static_funcs
 
     @property
     @abstractmethod
     def class_methods(self):
         """
-        :rtype: Dict[str, boa3.internal.model.method.Method]
+        :rtype: dict[str, boa3.internal.model.method.Method]
         """
         class_funcs = {}
         for base in self.bases:
             class_funcs.update(base.class_methods)
         return class_funcs
 
     @property
     @abstractmethod
     def instance_methods(self):
         """
-        :rtype: Dict[str, boa3.internal.model.method.Method]
+        :rtype: dict[str, boa3.internal.model.method.Method]
         """
         instance_funcs = {}
         for base in self.bases:
             instance_funcs.update(base.instance_methods)
         return instance_funcs
 
     @property
     def methods(self):
         """
-        :rtype: Dict[str, boa3.internal.model.method.Method]
+        :rtype: dict[str, boa3.internal.model.method.Method]
         """
         methods = self.static_methods.copy()
         methods.update(self.class_methods)
         methods.update(self.instance_methods)
         return methods
 
     @abstractmethod
@@ -134,32 +131,32 @@
         If the class constructor is None, it mustn't allow instantiation of this class
 
         :rtype: boa3.internal.model.method.Method or None
         """
         pass
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         s = {}
         s.update(self.methods)
         s.update(self.variables)
         s.update(self.properties)
         return s
 
     @property
-    def class_symbols(self) -> Dict[str, ISymbol]:
-        s: Dict[str, ISymbol] = {}
+    def class_symbols(self) -> dict[str, ISymbol]:
+        s: dict[str, ISymbol] = {}
         s.update(self.class_methods)  # class methods and variables can be accessed both
         s.update(self.class_variables)  # from class name or instance object
         s.update(self.static_methods)
         return s
 
     @property
-    def instance_symbols(self) -> Dict[str, ISymbol]:
-        s: Dict[str, ISymbol] = {}
+    def instance_symbols(self) -> dict[str, ISymbol]:
+        s: dict[str, ISymbol] = {}
         s.update(self.class_methods)  # class methods and variables can be accessed both
         s.update(self.class_variables)  # from class name or instance object
         s.update(self.instance_methods)
         s.update(self.instance_variables)
         s.update(self.properties)
         return s
 
@@ -209,15 +206,15 @@
             code_generator.convert_end_if(validation, is_internal=True)
 
         #   result = False
         code_generator.remove_stack_top_item()
         code_generator.convert_literal(False)
         code_generator.convert_end_if(begin_else, is_internal=True)
 
-    def _generate_specific_class_type_check(self, code_generator) -> List[int]:
+    def _generate_specific_class_type_check(self, code_generator) -> list[int]:
         """
         :type code_generator: boa3.internal.compiler.codegenerator.codegenerator.CodeGenerator
 
         :return: list of inner jumps addresses for failed checks
         :rtype: list[int]
         """
         from boa3.internal.model.builtin.builtin import Builtin
@@ -252,15 +249,15 @@
                         inner_validations.append(code_generator.convert_begin_if())
 
             code_generator.remove_stack_item(2)
 
         inner_validations.insert(0, begin_if)
         return inner_validations
 
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+    def is_instance_opcodes(self) -> list[tuple[Opcode, bytes]]:
         is_type_opcodes = [
             (Opcode.DUP, b''),  # if is the same internal type
             (Opcode.ISTYPE, self.stack_item)
         ]
 
         return_false = [
             (Opcode.DROP, b''),
@@ -283,15 +280,15 @@
                                   return_false)
         else:
             is_type_opcodes.remove((Opcode.DUP, b''))
             final_instructions = is_type_opcodes
 
         return final_instructions
 
-    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
+    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> list[tuple[Opcode, bytes]]:
         if self.stack_item not in (StackItemType.Array, StackItemType.Struct, StackItemType.Map):
             return []
 
         variables_count_is_equal = [
             (Opcode.DUP, b''),
             (Opcode.SIZE, b''),
             OpcodeHelper.get_push_and_data(len(self._all_variables)),
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/contractinterfaceclass.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/contractinterfaceclass.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-from typing import List
-
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.type.classes.classtype import ClassType
 from boa3.internal.model.type.classes.contractinterfacehash import ContractHashProperty
 from boa3.internal.model.type.classes.userclass import UserClass
 from boa3.internal.neo3.core.types import UInt160
 
 
 class ContractInterfaceClass(UserClass):
-    def __init__(self, identifier: str, contract_hash: UInt160, decorators: List[Callable] = None,
-                 bases: List[ClassType] = None):
+    def __init__(self, identifier: str, contract_hash: UInt160, decorators: list[Callable] = None,
+                 bases: list[ClassType] = None):
         from boa3.internal.model.builtin.builtin import Builtin, ContractDecorator
 
         if not isinstance(decorators, list):
             decorators = [Builtin.ContractInterface]
         elif not any(isinstance(decorator, ContractDecorator) for decorator in decorators):
             decorators.append(Builtin.ContractInterface)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/pythonclass.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/pythonclass.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import abc
-from typing import List, Tuple
 
 from boa3.internal import constants
 from boa3.internal.model.type.classes import classtype
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
@@ -108,12 +107,12 @@
         """
         Get the Neo VM stack item type representation for this type
 
         :return: the stack item type of this type. Any by default.
         """
         return super().stack_item
 
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+    def is_instance_opcodes(self) -> list[tuple[Opcode, bytes]]:
         return [(Opcode.ISTYPE, self.stack_item)]
 
     def generate_is_instance_type_check(self, code_generator):
         code_generator.insert_type_check(self.stack_item)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/classes/userclass.py` & `neo3_boa-1.2.0/boa3/internal/model/type/classes/userclass.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-from typing import Any, Dict, List, Optional
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.method import Method
 from boa3.internal.model.property import Property
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.classes.classarraytype import ClassArrayType
 from boa3.internal.model.type.classes.classscope import ClassScope
 from boa3.internal.model.type.classes.classtype import ClassType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.variable import Variable
 
 
 class UserClass(ClassArrayType):
-    def __init__(self, identifier: str, decorators: List[Callable] = None,
-                 bases: List[ClassType] = None):
+    def __init__(self, identifier: str, decorators: list[Callable] = None,
+                 bases: list[ClassType] = None):
         super(ClassArrayType, self).__init__(identifier, decorators, bases)
 
-        self._static_methods: Dict[str, Method] = {}
+        self._static_methods: dict[str, Method] = {}
 
-        self._class_variables: Dict[str, Variable] = {}
-        self._class_methods: Dict[str, Method] = {}
+        self._class_variables: dict[str, Variable] = {}
+        self._class_methods: dict[str, Method] = {}
 
-        self._instance_variables: Dict[str, Variable] = {}
-        self._instance_methods: Dict[str, Method] = {}
-        self._properties: Dict[str, Property] = {}
+        self._instance_variables: dict[str, Variable] = {}
+        self._instance_methods: dict[str, Method] = {}
+        self._properties: dict[str, Property] = {}
 
         self.imported_symbols = {}
 
     @property
     def shadowing_name(self) -> str:
         return 'class'
 
     @property
-    def class_variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> dict[str, Variable]:
         class_vars = super().class_variables
         class_vars.update(self._class_variables)
         return class_vars
 
     @property
-    def instance_variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> dict[str, Variable]:
         instance_vars = super().instance_variables
         instance_vars.update(self._instance_variables)
         return instance_vars
 
     @property
-    def properties(self) -> Dict[str, Property]:
+    def properties(self) -> dict[str, Property]:
         props = super().properties
         props.update(self._properties)
         return props
 
     @property
-    def static_methods(self) -> Dict[str, Method]:
+    def static_methods(self) -> dict[str, Method]:
         static_funcs = super().static_methods
         static_funcs.update(self._static_methods)
         return static_funcs
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
+    def class_methods(self) -> dict[str, Method]:
         class_funcs = super().class_methods
         class_funcs.update(self._class_methods)
         return class_funcs
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
+    def instance_methods(self) -> dict[str, Method]:
         instance_funcs = super().instance_methods
         instance_funcs.update(self._instance_methods)
         return instance_funcs
 
     def include_variable(self, var_id: str, var: Variable, is_instance: bool):
         """
         Includes a variable into the list of class variables
@@ -127,15 +127,15 @@
             elif isinstance(symbol, Property):
                 self.include_property(symbol_id, symbol)
             elif isinstance(symbol, Callable):
                 self.include_callable(symbol_id, symbol, scope)
             else:
                 self.imported_symbols[symbol_id] = symbol
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         if constants.INIT_METHOD_ID not in self._class_methods:
             from boa3.internal.model.type.classes.classinitmethoddefault import ClassInitMethod
             self._class_methods[constants.INIT_METHOD_ID] = ClassInitMethod(self)
 
         return self._class_methods[constants.INIT_METHOD_ID]
 
     def is_type_of(self, value: Any) -> bool:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/genericcollectiontype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/genericsequencetype.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,48 +1,40 @@
-from typing import Any, Set
+from typing import Any
 
-from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 
 
-class GenericCollectionType(ICollectionType):
+class GenericSequenceType(SequenceType):
     """
-    An class used to represent a generic Python collection type
+    An class used to represent a generic Python sequence type
     """
 
-    def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
-        identifier: str = 'collection'
-        keys_type = self.filter_types(keys_type)
+    def __init__(self, values_type: set[IType] = None):
+        identifier: str = 'sequence'
         values_type = self.filter_types(values_type)
-        super().__init__(identifier, keys_type, values_type)
+        super().__init__(identifier, values_type)
 
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
-        return self.key_type
+        from boa3.internal.model.type.type import Type
+        return Type.int
 
     @property
     def is_generic(self) -> bool:
         return True
 
     @classmethod
-    def _is_type_of(cls, value: Any):
-        return isinstance(value, ICollectionType)
-
-    @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            if isinstance(value, dict):
-                keys = list(value.keys())
-                values = list(value.values())
-            else:
-                keys = value.key_type
-                values = value.value_type
-
-            keys_types: Set[IType] = cls.get_types(keys)
-            values_types: Set[IType] = cls.get_types(values)
-            return cls(keys_types, values_types)
+            values_types: set[IType] = cls.get_types(value)
+            return cls(values_types)
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, SequenceType)
 
     def __hash__(self):
         return hash(self.identifier)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/icollection.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/icollection.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,23 @@
-from __future__ import annotations
-
 from abc import ABC, abstractmethod
-from typing import Any, Iterable, Set, Union
+from collections.abc import Iterable
+from typing import Any, Self
 
 from boa3.internal.model.type.annotation.uniontype import UnionType
 from boa3.internal.model.type.classes.pythonclass import PythonClass
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 
 
 class ICollectionType(PythonClass, ABC):
     """
     An interface used to represent Python mapping type
     """
 
-    def __init__(self, identifier: str, keys_type: Set[IType] = None, values_type: Set[IType] = None):
+    def __init__(self, identifier: str, keys_type: set[IType] = None, values_type: set[IType] = None):
         if keys_type is None:
             keys_type = set()
         self.key_type: IType = self._get_collection_type(keys_type)
 
         if values_type is None:
             values_type = set()
         self.item_type: IType = self._get_collection_type(values_type)
@@ -50,52 +49,60 @@
         return False
 
     @property
     @abstractmethod
     def valid_key(self) -> IType:
         pass
 
-    def _get_collection_type(self, values_type: Set[IType]):
+    def _get_collection_type(self, values_type: set[IType]):
         if len(values_type) == 0:
             from boa3.internal.model.type.anytype import anyType
             val_type: IType = anyType
         elif len(values_type) == 1:
             val_type: IType = list(values_type)[0]
         else:
             val_type: IType = UnionType.build(values_type)
 
         return val_type
 
     @classmethod
-    def get_types(cls, value: Any) -> Set[IType]:
+    def get_types(cls, value: Any) -> set[IType]:
         from boa3.internal.model.type.type import Type
         if isinstance(value, IType):
             return {value}
 
         if not isinstance(value, Iterable):
             value = {value}
 
-        types: Set[IType] = {val if isinstance(val, IType) else Type.get_type(val) for val in value}
+        types: set[IType] = {val if isinstance(val, IType) else Type.get_type(val) for val in value}
         return cls.filter_types(types)
 
+    def get_item_type(self, index: tuple):
+        return self.item_type
+
     @classmethod
-    def filter_types(cls, values_type) -> Set[IType]:
+    def filter_types(cls, values_type) -> set[IType]:
         if values_type is None:
             values_type = set()
         elif not isinstance(values_type, set):
             if isinstance(values_type, Iterable):
                 values_type = set(values_type)
             else:
                 values_type = {values_type}
 
         if len(values_type) > 1:
             from boa3.internal.model.type.type import Type
             if any(t is Type.any or t is Type.none for t in values_type):
                 return {Type.any}
 
+            if Type.ellipsis in values_type:
+                values_type.remove(Type.ellipsis)
+                if len(values_type) == 1:
+                    return values_type
+
             actual_types = list(values_type)[:1]
             for value in list(values_type)[1:]:
                 other = next((x for x in actual_types
                               if x.is_type_of(value) or value.is_type_of(x)), None)
 
                 if other is not None and value.is_type_of(other):
                     actual_types.remove(other)
@@ -122,24 +129,24 @@
                 types = set(value.item_type for value in values_type)
                 values_type = {collection_type.build(types)}
             else:
                 generic_type: IType = Type.get_generic_type(*values_type)
                 if (isinstance(generic_type, ICollectionType)
                         and all(isinstance(x.item_type, value_type) for x in values_type)):
                     # the collections doesn't have the same type but the value type is the same
-                    # for example: Tuple[int] and List[int]
+                    # for example: tuple[int] and list[int]
                     values_type = {generic_type.build_collection(first_item.item_type)}
                 else:
                     # otherwise, built a generic sequence with any as parameters
                     values_type = {generic_type}
 
         return values_type
 
     @classmethod
-    def build_collection(cls, *value_type: Union[IType, Iterable]) -> ICollectionType:
+    def build_collection(cls, *value_type: IType | Iterable) -> Self:
         """
         Creates a collection type instance with the given value
 
         :param value_type: value to build the type
         :type value_type: IType or Iterable
         :return: The built collection type.
         :rtype: IType or None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/genericmappingtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/genericmappingtype.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
 from boa3.internal.model.type.itype import IType
 
 
 class GenericMappingType(MappingType):
     """
     An class used to represent a generic Python sequence type
     """
 
-    def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
+    def __init__(self, keys_type: set[IType] = None, values_type: set[IType] = None):
         identifier: str = 'mapping'
         keys_type = self.filter_types(keys_type)
         values_type = self.filter_types(values_type)
         super().__init__(identifier, keys_type, values_type)
 
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mappingtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mappingtype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 from abc import ABC
-from typing import Any, Iterable, Set, Sized
+from collections.abc import Iterable, Sized
+from typing import Any
 
 from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class MappingType(ICollectionType, ABC):
     """
     An interface used to represent Python mapping type
     """
 
-    def __init__(self, identifier: str, keys_type: Set[IType], values_type: Set[IType]):
+    def __init__(self, identifier: str, keys_type: set[IType], values_type: set[IType]):
         super().__init__(identifier, keys_type=keys_type, values_type=values_type)
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}, {2}]'.format(self._identifier, self.key_type.identifier, self.value_type.identifier)
 
     @property
@@ -47,15 +48,15 @@
         return self.valid_key.is_type_of(key_type)
 
     @property
     def valid_key(self) -> IType:
         return self.key_type
 
     @classmethod
-    def filter_types(cls, values_type) -> Set[IType]:
+    def filter_types(cls, values_type) -> set[IType]:
         if values_type is None:
             values_type = set()
         elif not isinstance(values_type, set):
             if isinstance(values_type, Iterable):
                 values_type = set(values_type)
             else:
                 values_type = {values_type}
@@ -87,16 +88,16 @@
             if isinstance(value, dict):
                 keys = list(value.keys())
                 values = list(value.values())
             else:
                 keys = value.key_type
                 values = value.value_type
 
-            keys_types: Set[IType] = cls.get_types(keys)
-            values_types: Set[IType] = cls.get_types(values)
+            keys_types: set[IType] = cls.get_types(keys)
+            values_types: set[IType] = cls.get_types(values)
             return cls(keys_types, values_types)
 
         elif isinstance(value, Sized) and len(value) == 2:
             # value is a tuple with two lists of types for contructing the map
             keys_type, values_type = value
 
             if not isinstance(keys_type, Iterable):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mutable/dicttype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mutable/dicttype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.mapping.mutable.mutablemappingtype import MutableMappingType
 from boa3.internal.model.type.itype import IType
 
 
 class DictType(MutableMappingType):
     """
     A class used to represent Python dict type
     """
 
-    def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
+    def __init__(self, keys_type: set[IType] = None, values_type: set[IType] = None):
         identifier = 'dict'
         keys_type = self.filter_types(keys_type)
         values_type = self.filter_types(values_type)
         super().__init__(identifier, keys_type, values_type)
 
     @property
     def default_value(self) -> Any:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/mapping/mutable/mutablemappingtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/mapping/mutable/mutablemappingtype.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from abc import ABC
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
 from boa3.internal.model.type.itype import IType
 
 
 class MutableMappingType(MappingType, ABC):
     """
     An interface used to represent Python mutable mapping type
     """
 
-    def __init__(self, identifier: str, keys_type: Set[IType], values_type: Set[IType]):
+    def __init__(self, identifier: str, keys_type: set[IType], values_type: set[IType]):
         super().__init__(identifier, keys_type, values_type)
 
     def is_type_of(self, value: Any) -> bool:
         if self._is_type_of(value):
             if isinstance(value, MutableMappingType):
                 return self.value_type.is_type_of(value.value_type)
             return True
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/buffertype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/buffertype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/ecpointtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/ecpointtype.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,12 @@
-from typing import Any, List, Optional, Tuple
+from typing import Any
 
 from boa3.internal import constants
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.model.method import Method
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.neo.vm.opcode import OpcodeHelper
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.type.AbiType import AbiType
 
@@ -24,15 +26,15 @@
     def identifier(self) -> str:
         return self._identifier
 
     @property
     def abi_type(self) -> AbiType:
         return AbiType.PublicKey
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @property
     def default_value(self) -> Any:
         return bytes(constants.SIZE_OF_ECPOINT)
 
     @classmethod
@@ -44,42 +46,73 @@
         return isinstance(value, ECPointType)
 
     def _init_class_symbols(self):
         super()._init_class_symbols()
 
         from boa3.internal.model.builtin.builtin import Builtin
 
+        properties = [ECPointZeroProperty()
+                      ]
         instance_methods = [Builtin.ScriptHashMethod_,
                             ]
 
         for instance_method in instance_methods:
             self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
 
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+        for prop in properties:
+            self._properties[prop.identifier] = prop
+
+    def is_instance_opcodes(self) -> list[tuple[Opcode, bytes]]:
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         return super(PythonClass, self).is_instance_opcodes()
 
     def generate_is_instance_type_check(self, code_generator):
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         return super(PythonClass, self).generate_is_instance_type_check(code_generator)
 
-    def _generate_specific_class_type_check(self, code_generator) -> List[int]:
+    def _generate_specific_class_type_check(self, code_generator) -> list[int]:
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
 
         code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
         code_generator.convert_literal(constants.SIZE_OF_ECPOINT)
         code_generator.convert_operation(BinaryOp.NumEq, is_internal=True)
         return []
 
-    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
+    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> list[tuple[Opcode, bytes]]:
         from boa3.internal import constants
         push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_ECPOINT)
 
         return [
             (Opcode.SIZE, b''),  # return len(value) == 33
             (push_int_opcode, size_data),
             (Opcode.NUMEQUAL, b'')
         ]
 
 
 _ECPoint = ECPointType()
+
+
+class GetECPointZeroMethod(IBuiltinMethod):
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        identifier = '-ecpoint_get_zero'
+        args = {}
+        super().__init__(identifier, args, return_type=Type.int)
+
+    def generate_internal_opcodes(self, code_generator):
+        code_generator.convert_literal(_ECPoint.default_value)
+
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
+
+    @property
+    def _body(self) -> str | None:
+        return
+
+
+class ECPointZeroProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'zero'
+        getter = GetECPointZeroMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/genericsequencetype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/rangetype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,40 +1,53 @@
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 
 
-class GenericSequenceType(SequenceType):
+class RangeType(SequenceType):
     """
-    An class used to represent a generic Python sequence type
+    A class used to represent Python range type
     """
 
-    def __init__(self, values_type: Set[IType] = None):
-        identifier: str = 'sequence'
+    def __init__(self, values_type: IType):
+        identifier = 'range'
         values_type = self.filter_types(values_type)
         super().__init__(identifier, values_type)
 
+    @property
+    def default_value(self) -> Any:
+        return range(0)
+
+    @property
+    def identifier(self) -> str:
+        return self._identifier
+
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
         from boa3.internal.model.type.type import Type
         return Type.int
 
-    @property
-    def is_generic(self) -> bool:
-        return True
-
     @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            values_types: Set[IType] = cls.get_types(value)
-            return cls(values_types)
+            from boa3.internal.model.type.type import Type
+            return cls(Type.int)
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, SequenceType)
+        return type(value) is range or isinstance(value, RangeType)
+
+    @property
+    def can_reassign_values(self) -> bool:
+        return False
+
+    def __eq__(self, other) -> bool:
+        if type(self) != type(other):
+            return False
+        return self.value_type == other.value_type
 
     def __hash__(self):
         return hash(self.identifier)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/genericmutablesequencetype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/genericmutablesequencetype.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.type.itype import IType
 
 
 class GenericMutableSequenceType(MutableSequenceType):
     """
     An class used to represent a generic Python mutable sequence type
     """
 
-    def __init__(self, values_type: Set[IType] = None):
+    def __init__(self, values_type: set[IType] = None):
         identifier: str = 'MutableSequence'
         values_type = self.filter_types(values_type)
         super().__init__(identifier, values_type)
 
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
@@ -25,15 +25,15 @@
     @property
     def is_generic(self) -> bool:
         return True
 
     @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            values_types: Set[IType] = cls.get_types(value)
+            values_types: set[IType] = cls.get_types(value)
             return cls(values_types)
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, MutableSequenceType)
 
     def __hash__(self):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/listtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/listtype.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
 from boa3.internal.model.type.itype import IType
 
 
 class ListType(MutableSequenceType):
     """
     A class used to represent Python list type
     """
 
-    def __init__(self, values_type: Set[IType] = None):
+    def __init__(self, values_type: set[IType] = None):
         identifier = 'list'
         values_type = self.filter_types(values_type)
         super().__init__(identifier, values_type)
 
     @property
     def default_value(self) -> Any:
         return list()
@@ -39,15 +39,15 @@
     @property
     def valid_key(self) -> IType:
         from boa3.internal.model.type.type import Type
         return Type.int
 
     @classmethod
     def build(cls, value: Any) -> IType:
-        values_types: Set[IType] = cls.get_types(value)
+        values_types: set[IType] = cls.get_types(value)
         return cls(values_types)
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return type(value) in [list, ListType]
 
     def __eq__(self, other) -> bool:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/mutable/mutablesequencetype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/mutable/mutablesequencetype.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from abc import ABC
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 
 
 class MutableSequenceType(SequenceType, ABC):
     """
     An interface used to represent Python mutable sequence type
     """
 
-    def __init__(self, identifier: str, values_type: Set[IType]):
+    def __init__(self, identifier: str, values_type: set[IType]):
         super().__init__(identifier, values_type)
 
     def _init_class_symbols(self):
         super()._init_class_symbols()
 
         from boa3.internal.model.builtin.builtin import Builtin
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/rangetype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/reversedtype.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 from typing import Any
 
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
 
 
-class RangeType(SequenceType):
+class ReversedType(SequenceType):
     """
-    A class used to represent Python range type
+    A class used to represent Python reversed type. It's represented as a Sequence instead of a Iterable.
     """
 
-    def __init__(self, values_type: IType):
-        identifier = 'range'
+    def __init__(self, values_type: IType = None):
+        identifier = 'reversed'
         values_type = self.filter_types(values_type)
         super().__init__(identifier, values_type)
 
     @property
     def default_value(self) -> Any:
-        return range(0)
+        return reversed([])
 
     @property
     def identifier(self) -> str:
         return self._identifier
 
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return cls(Type.reversed)
+
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
         from boa3.internal.model.type.type import Type
         return Type.int
 
     @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            from boa3.internal.model.type.type import Type
-            return cls(Type.int)
-
-    @classmethod
     def _is_type_of(cls, value: Any):
-        return type(value) is range or isinstance(value, RangeType)
+        return type(value) is reversed or isinstance(value, ReversedType)
 
     @property
     def can_reassign_values(self) -> bool:
         return False
 
     def __eq__(self, other) -> bool:
         if type(self) != type(other):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/reversedtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/annotation/metatype.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,53 +1,57 @@
 from typing import Any
 
-from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class ReversedType(SequenceType):
+class MetaType(IType):
     """
-    A class used to represent Python reversed type. It's represented as a Sequence instead of a Iterable.
+    A class used to represent internal Boa and Python types
     """
 
-    def __init__(self, values_type: IType = None):
-        identifier = 'reversed'
-        values_type = self.filter_types(values_type)
-        super().__init__(identifier, values_type)
+    def __init__(self, type_of: IType = None):
+        identifier = 'type'
+        super().__init__(identifier)
+        self._internal_type: IType | None = type_of
 
     @property
-    def default_value(self) -> Any:
-        return reversed([])
+    def abi_type(self) -> AbiType:
+        return AbiType.Any
 
-    @property
-    def identifier(self) -> str:
-        return self._identifier
+    @classmethod
+    def build(cls, value: Any = None) -> IType:
+        if isinstance(value, MetaType):
+            return value
+        if isinstance(value, IType):
+            return cls(value)
+        else:
+            return metaType
 
     @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            from boa3.internal.model.type.type import Type
-            return cls(Type.reversed)
+    def _is_type_of(cls, value: Any) -> bool:
+        return isinstance(value, MetaType)
 
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
+    def is_type_of(self, value: Any) -> bool:
+        return isinstance(value, MetaType) and self._internal_type.is_type_of(value._internal_type)
 
     @property
-    def valid_key(self) -> IType:
-        from boa3.internal.model.type.type import Type
-        return Type.int
+    def meta_identifier(self) -> str:
+        if self.has_meta_type:
+            return f'{self._identifier}[{self._internal_type}]'
+        else:
+            return self._identifier
 
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return type(value) is reversed or isinstance(value, ReversedType)
+    @property
+    def has_meta_type(self) -> bool:
+        return self._internal_type is not None
+
+    @property
+    def meta_type(self) -> IType | None:
+        return self._internal_type
 
     @property
-    def can_reassign_values(self) -> bool:
-        return False
+    def meta_id(self) -> str | None:
+        return self._internal_type.identifier if self._internal_type is not None else None
 
-    def __eq__(self, other) -> bool:
-        if type(self) != type(other):
-            return False
-        return self.value_type == other.value_type
 
-    def __hash__(self):
-        return hash(self.identifier)
+metaType: IType = MetaType()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/sequencetype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/sequencetype.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 from abc import ABC
-from typing import Any, Set
+from typing import Any
 
 from boa3.internal.model.type.collection.icollection import ICollectionType
 from boa3.internal.model.type.itype import IType
 from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class SequenceType(ICollectionType, ABC):
     """
     An interface used to represent Python sequence type
     """
 
-    def __init__(self, identifier: str, values_type: Set[IType]):
+    def __init__(self, identifier: str, values_type: set[IType]):
         super().__init__(identifier, values_type=values_type)
         self.value_type: IType = self.item_type
 
     @property
     def default_value(self) -> Any:
         return []
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/tupletype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/bytestype.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,49 +1,38 @@
-from typing import Any, Set
+from typing import Any
 
-from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class TupleType(SequenceType):
+class BytesType(IByteStringType):
     """
-    A class used to represent Python tuple type
+    A class used to represent Python bytes type
     """
 
-    def __init__(self, values_type: Set[IType] = None):
-        identifier = 'tuple'
-        values_type = self.filter_types(values_type)
+    def __init__(self):
+        identifier = 'bytes'
+        from boa3.internal.model.type.primitive.inttype import IntType
+        values_type = [IntType()]
         super().__init__(identifier, values_type)
 
     @property
-    def default_value(self) -> Any:
-        return tuple()
-
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
+    def abi_type(self) -> AbiType:
+        return AbiType.ByteArray
 
     @property
-    def valid_key(self) -> IType:
-        from boa3.internal.model.type.type import Type
-        return Type.int
+    def default_value(self) -> Any:
+        return bytes()
 
     @classmethod
     def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            values_types: Set[IType] = cls.get_types(value)
-            return cls(values_types)
+        from boa3.internal.model.type.type import Type
+        return Type.bytes
 
     @classmethod
-    def _is_type_of(cls, value: Any):
-        return type(value) is tuple or isinstance(value, TupleType)
+    def build_collection(cls, *value_type: IType):
+        return cls.build(value_type)
 
-    @property
-    def can_reassign_values(self) -> bool:
-        return False
-
-    def __eq__(self, other) -> bool:
-        if type(self) != type(other):
-            return False
-        return self.value_type == other.value_type
-
-    def __hash__(self):
-        return hash(self.identifier)
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return type(value) is bytes or isinstance(value, BytesType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/uint160type.py` & `neo3_boa-1.2.0/boa3/internal/model/type/collection/sequence/uint160type.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,12 @@
-from typing import Any, List, Optional, Tuple
+from typing import Any
 
 from boa3.internal import constants
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.method import IBuiltinMethod
 from boa3.internal.model.method import Method
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.bytestype import BytesType
 from boa3.internal.neo.vm.opcode import OpcodeHelper
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.type.AbiType import AbiType
 
@@ -24,50 +26,84 @@
     def identifier(self) -> str:
         return self._identifier
 
     @property
     def abi_type(self) -> AbiType:
         return AbiType.Hash160
 
-    def constructor_method(self) -> Optional[Method]:
+    def constructor_method(self) -> Method | None:
         return self._constructor
 
     @property
     def default_value(self) -> Any:
         return bytes(constants.SIZE_OF_INT160)
 
     @classmethod
     def build(cls, value: Any = None) -> IType:
         return _UInt160
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, UInt160Type)
 
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+        properties = [UInt160ZeroProperty()
+                      ]
+
+        for prop in properties:
+            self._properties[prop.identifier] = prop
+
+    def is_instance_opcodes(self) -> list[tuple[Opcode, bytes]]:
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         return super(PythonClass, self).is_instance_opcodes()
 
     def generate_is_instance_type_check(self, code_generator):
         from boa3.internal.model.type.classes.pythonclass import PythonClass
         return super(PythonClass, self).generate_is_instance_type_check(code_generator)
 
-    def _generate_specific_class_type_check(self, code_generator) -> List[int]:
+    def _generate_specific_class_type_check(self, code_generator) -> list[int]:
         from boa3.internal.model.builtin.builtin import Builtin
         from boa3.internal.model.operation.binaryop import BinaryOp
 
         code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
         code_generator.convert_literal(constants.SIZE_OF_INT160)
         code_generator.convert_operation(BinaryOp.NumEq, is_internal=True)
         return []
 
-    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
+    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> list[tuple[Opcode, bytes]]:
         push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_INT160)
 
         return [
             (Opcode.SIZE, b''),  # return len(value) == 20
             (push_int_opcode, size_data),
             (Opcode.NUMEQUAL, b'')
         ]
 
 
 _UInt160 = UInt160Type()
+
+
+class GetUInt160ZeroMethod(IBuiltinMethod):
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        identifier = '-uint160_get_zero'
+        args = {}
+        super().__init__(identifier, args, return_type=Type.int)
+
+    def generate_internal_opcodes(self, code_generator):
+        code_generator.convert_literal(_UInt160.default_value)
+
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
+
+    @property
+    def _body(self) -> str | None:
+        return
+
+
+class UInt160ZeroProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'zero'
+        getter = GetUInt160ZeroMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/collection/sequence/uint256type.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/ibytestringtype.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,74 +1,61 @@
-from typing import Any, List, Optional, Tuple
+import abc
+from typing import Any
 
-from boa3.internal import constants
-from boa3.internal.model.method import Method
-from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
-from boa3.internal.model.type.primitive.bytestype import BytesType
-from boa3.internal.neo.vm.opcode import OpcodeHelper
-from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
-class UInt256Type(BytesType, ClassType):
+class IByteStringType(SequenceType, PrimitiveType, abc.ABC):
     """
-    A class used to represent Neo's UInt256 type
+    A class used to represent Neo ByteString type
     """
 
-    def __init__(self):
-        super().__init__()
-        self._identifier = 'UInt256'
-        from boa3.internal.model.builtin.method.uint256method import UInt256Method
-        self._constructor = UInt256Method(self)
+    def __init__(self, identifier: str, values_type: list[IType]):
+        super().__init__(identifier, values_type)
 
     @property
     def identifier(self) -> str:
         return self._identifier
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.Hash256
-
-    def constructor_method(self) -> Optional[Method]:
-        return self._constructor
+        return AbiType.ByteArray
 
     @property
-    def default_value(self) -> Any:
-        return bytes(constants.SIZE_OF_INT256)
+    def stack_item(self) -> StackItemType:
+        return StackItemType.ByteString
+
+    def is_type_of(self, value: Any) -> bool:
+        return self._is_type_of(value)
 
-    @classmethod
-    def build(cls, value: Any = None) -> IType:
-        return _UInt256
-
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return isinstance(value, UInt256Type)
-
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.internal.model.type.classes.pythonclass import PythonClass
-        return super(PythonClass, self).is_instance_opcodes()
-
-    def generate_is_instance_type_check(self, code_generator):
-        from boa3.internal.model.type.classes.pythonclass import PythonClass
-        return super(PythonClass, self).generate_is_instance_type_check(code_generator)
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
 
-    def _generate_specific_class_type_check(self, code_generator) -> List[int]:
         from boa3.internal.model.builtin.builtin import Builtin
-        from boa3.internal.model.operation.binaryop import BinaryOp
 
-        code_generator.convert_builtin_method_call(Builtin.Len, is_internal=True)
-        code_generator.convert_literal(constants.SIZE_OF_INT256)
-        code_generator.convert_operation(BinaryOp.NumEq, is_internal=True)
-        return []
+        instance_methods = [Builtin.BytesStringIsDigit,
+                            Builtin.BytesStringJoin,
+                            Builtin.BytesStringLower,
+                            Builtin.BytesStringUpper,
+                            Builtin.BytesStringStartswith,
+                            Builtin.BytesStringStrip,
+                            Builtin.BytesStringReplace,
+                            ]
 
-    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
-        push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_INT256)
+        for instance_method in instance_methods:
+            self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
 
-        return [
-            (Opcode.SIZE, b''),  # return len(value) == 32
-            (push_int_opcode, size_data),
-            (Opcode.NUMEQUAL, b'')
-        ]
+    def is_valid_key(self, key_type: IType) -> bool:
+        return key_type == self.valid_key
 
+    @property
+    def valid_key(self) -> IType:
+        from boa3.internal.model.type.type import Type
+        return Type.int
 
-_UInt256 = UInt256Type()
+    @property
+    def can_reassign_values(self) -> bool:
+        return False
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/itype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/itype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,25 @@
-from __future__ import annotations
-
 from abc import abstractmethod
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class IType(IdentifiedSymbol):
     """
     An interface used to represent types
 
     :ivar identifier: the name identifier of the type
     """
 
-    def __init__(self, identifier: str):
-        super().__init__(identifier)
+    def __init__(self, identifier: str, deprecated: bool = False):
+        super().__init__(identifier, deprecated)
 
     @property
     def shadowing_name(self) -> str:
         return 'type'
 
     def __repr__(self) -> str:
         return self.__str__()
@@ -81,15 +79,15 @@
         :return: a boolean value that represents if this is the type of the value.
         :rtype: bool
         """
         return self._is_type_of(value)
 
     @classmethod
     @abstractmethod
-    def build(cls, value: Any) -> IType:
+    def build(cls, value: Any) -> Self:
         """
         Creates a type instance with the given value
 
         :param value: value to build the type
         :return: The built type if the value is valid. None otherwise
         :rtype: IType or None
         """
@@ -100,47 +98,47 @@
         Generates the opcodes to check if a value is of this type
 
         :type code_generator: boa3.internal.compiler.codegenerator.codegenerator.CodeGenerator
         """
         code_generator.insert_type_check(self.stack_item)
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the class type with its name
         """
         return {}
 
-    def union_type(self, other_type: IType) -> IType:
+    def union_type(self, other_type: "IType") -> "IType":
         """
         Gets a type that is an union of `self` and `other_type`
 
         :param other_type: type that'll be united with `self`
         :type other_type: IType
         :return: an union of this type and other_type
         :rtype: IType
         """
         from boa3.internal.model.type.annotation.uniontype import UnionType
         return UnionType.build((self, other_type))
 
-    def except_type(self, other_type: IType) -> IType:
+    def except_type(self, other_type: "IType") -> "IType":
         """
         Gets a type that is type of `self` but is not type of `other_type`.
         If `other_type` is an implementation of `self`, returns `self`
 
         :param other_type: type that won't be allowed in the resulting type
         :type other_type: IType
         :return: an union of this type and the exclusion of other_type
         :rtype: IType
         """
         return self
 
-    def intersect_type(self, other_type: IType) -> IType:
+    def intersect_type(self, other_type: "IType") -> "IType":
         """
         Gets a type that is the intersection of `self` but is not type of `other_type`.
         If `other_type` is an implementation of `self`, returns `other_type`
         If `other_type` and `self` has no values in common, returns None
 
         :param other_type: type that'll be intersected with self
         :type other_type: IType
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/math.py` & `neo3_boa-1.2.0/boa3/internal/model/type/math.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,37 +1,35 @@
-from typing import Dict
-
 from boa3.internal.model.builtin.math import *
 from boa3.internal.model.callable import Callable
 from boa3.internal.model.symbol import ISymbol
 
 
 class Math:
 
     # python math methods
     Pow = PowMethod()
     Sqrt = SqrtMethod()
 
     @classmethod
-    def all_functions(cls) -> Dict[str, Callable]:
+    def all_functions(cls) -> dict[str, Callable]:
         from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
 
         functions = [
             cls.Pow,
             cls.Sqrt,
         ]
 
         return {method._identifier: method for method in functions if isinstance(method, IBuiltinCallable)}
 
     @classmethod
-    def get_methods_from_math_lib(cls) -> Dict[str, ISymbol]:
+    def get_methods_from_math_lib(cls) -> dict[str, ISymbol]:
         import math
         from inspect import getmembers, isbuiltin
 
-        method_symbols: Dict[str, ISymbol] = {}
+        method_symbols: dict[str, ISymbol] = {}
         all_functions = getmembers(math, isbuiltin)
 
         for m_id, method in all_functions:
             method_id: str = m_id if m_id in cls.all_functions() else m_id.lower()
             if method_id in cls.all_functions():
                 method_symbols[m_id] = cls.all_functions()[method_id]
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/__init__.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/blockhashtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/blockhashtype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/opcodetype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/opcodetype.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Dict
+from typing import Any
 
 from boa3.internal.model.symbol import ISymbol
 from boa3.internal.model.type.itype import IType
 from boa3.internal.model.type.primitive.bytestype import BytesType
 
 
 class OpcodeType(BytesType):
@@ -26,15 +26,15 @@
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.internal.neo.vm.opcode.Opcode import Opcode
         return isinstance(value, (Opcode, OpcodeType))
 
     @property
-    def symbols(self) -> Dict[str, ISymbol]:
+    def symbols(self) -> dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.internal.neo.vm.opcode.Opcode import Opcode
         from boa3.internal.model.variable import Variable
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/publickeytype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/publickeytype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/scripthashlittleendiantype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/scripthashlittleendiantype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/scripthashtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/scripthashtype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/neo/transactionidtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/neo/transactionidtype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/primitive/booltype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/booltype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/primitive/bytearraytype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/inttype.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,37 +1,46 @@
 from typing import Any
 
-from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal import constants
 from boa3.internal.model.type.itype import IType
-from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
-class ByteArrayType(BytesType, MutableSequenceType):
+class IntType(PrimitiveType):
     """
-    A class used to represent Python list type
+    A class used to represent Python int type
     """
 
     def __init__(self):
-        super().__init__()
-        self._identifier = 'bytearray'
+        identifier = 'int'
+        super().__init__(identifier)
 
     @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.Buffer
+    def default_value(self) -> Any:
+        return int()
 
     @property
-    def default_value(self) -> Any:
-        return bytearray()
+    def abi_type(self) -> AbiType:
+        return AbiType.Integer
+
+    @property
+    def stack_item(self) -> StackItemType:
+        return StackItemType.Integer
+
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+
+        from boa3.internal.model.builtin.builtin import Builtin
+
+        self._instance_methods[constants.INIT_METHOD_ID] = Builtin.IntInt
 
     @classmethod
     def build(cls, value: Any) -> IType:
-        from boa3.internal.model.type.type import Type
-        return Type.bytearray
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return Type.int
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return type(value) in [bytearray, ByteArrayType]
-
-    @property
-    def can_reassign_values(self) -> bool:
-        return True
+        return type(value) is int or isinstance(value, IntType)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/primitive/bytestringtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/bytestringtype.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/primitive/bytestype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/nonetype.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,38 +1,36 @@
 from typing import Any
 
+from boa3.internal.model.type.classes.pythonclass import PythonClass
 from boa3.internal.model.type.itype import IType
-from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class BytesType(IByteStringType):
+class NoneType(PythonClass):
     """
-    A class used to represent Python bytes type
+    A class used to represent Python None value
     """
 
     def __init__(self):
-        identifier = 'bytes'
-        from boa3.internal.model.type.primitive.inttype import IntType
-        values_type = [IntType()]
-        super().__init__(identifier, values_type)
+        identifier = 'none'
+        super().__init__(identifier)
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.ByteArray
-
-    @property
-    def default_value(self) -> Any:
-        return bytes()
+        return AbiType.Void
 
     @classmethod
     def build(cls, value: Any) -> IType:
-        from boa3.internal.model.type.type import Type
-        return Type.bytes
-
-    @classmethod
-    def build_collection(cls, *value_type: IType):
-        return cls.build(value_type)
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return Type.none
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return type(value) is bytes or isinstance(value, BytesType)
+        from boa3.internal.model.type.type import Type
+        return value is None or value is Type.none
+
+    def generate_is_instance_type_check(self, code_generator):
+        code_generator.insert_type_check(None)
+
+
+noneType: IType = NoneType()
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/primitive/ibytestringtype.py` & `neo3_boa-1.2.0/boa3/internal/model/type/primitive/strtype.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,61 +1,57 @@
-import abc
-from typing import Any, List
+from typing import Any
 
-from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal import constants
 from boa3.internal.model.type.itype import IType
-from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 from boa3.internal.neo.vm.type.AbiType import AbiType
-from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
-class IByteStringType(SequenceType, PrimitiveType, abc.ABC):
+class StrType(IByteStringType):
     """
-    A class used to represent Neo ByteString type
+    A class used to represent Python str type
     """
 
-    def __init__(self, identifier: str, values_type: List[IType]):
-        super().__init__(identifier, values_type)
+    def __init__(self):
+        identifier = 'str'
+        super().__init__(identifier, [self])
 
     @property
-    def identifier(self) -> str:
-        return self._identifier
+    def default_value(self) -> Any:
+        return str()
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.ByteArray
-
-    @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.ByteString
-
-    def is_type_of(self, value: Any) -> bool:
-        return self._is_type_of(value)
+        return AbiType.String
 
     def _init_class_symbols(self):
         super()._init_class_symbols()
 
         from boa3.internal.model.builtin.builtin import Builtin
 
-        instance_methods = [Builtin.BytesStringIsDigit,
-                            Builtin.BytesStringJoin,
-                            Builtin.BytesStringLower,
-                            Builtin.BytesStringUpper,
-                            Builtin.BytesStringStartswith,
-                            Builtin.BytesStringStrip,
-                            Builtin.BytesStringReplace,
+        instance_methods = [Builtin.StrSplit,
+                            Builtin.BytesStringIndex,
                             ]
 
         for instance_method in instance_methods:
             self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
 
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
+        self._instance_methods[constants.INIT_METHOD_ID] = Builtin.StrBytes
 
-    @property
-    def valid_key(self) -> IType:
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return Type.str
+
+    @classmethod
+    def build_collection(cls, value_type: IType):
         from boa3.internal.model.type.type import Type
-        return Type.int
+        return Type.str
 
-    @property
-    def can_reassign_values(self) -> bool:
-        return False
+    @classmethod
+    def _is_type_of(cls, value: Any) -> bool:
+        from boa3.internal.model.type.collection.sequence.buffertype import BufferType
+        return isinstance(value, (str, StrType)) and not isinstance(value, BufferType)
+
+    def is_type_of(self, value: Any) -> bool:
+        return self._is_type_of(value)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/type.py` & `neo3_boa-1.2.0/boa3/internal/model/type/type.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,10 @@
-from typing import Any, Dict
+from typing import Any
 
+from boa3.internal.model.type.annotation.ellipsistype import ellipsisType
 from boa3.internal.model.type.annotation.optionaltype import OptionalType
 from boa3.internal.model.type.annotation.uniontype import UnionType
 from boa3.internal.model.type.anytype import anyType
 from boa3.internal.model.type.baseexceptiontype import BaseExceptionType
 from boa3.internal.model.type.collection.genericcollectiontype import GenericCollectionType
 from boa3.internal.model.type.collection.mapping.genericmappingtype import GenericMappingType
 from boa3.internal.model.type.collection.mapping.mutable.dicttype import DictType
@@ -20,15 +21,15 @@
 from boa3.internal.model.type.primitive.inttype import IntType
 from boa3.internal.model.type.primitive.nonetype import noneType
 from boa3.internal.model.type.primitive.strtype import StrType
 
 
 class Type:
     @classmethod
-    def builtin_types(cls) -> Dict[str, IType]:
+    def builtin_types(cls) -> dict[str, IType]:
         """
         Gets a dictionary that maps each type with its name
 
         :return: A dictionary that maps each Python builtin type representation with its name
         """
         builtin_types = [
             Type.int,
@@ -42,15 +43,15 @@
             Type.bytes,
             Type.bytearray,
             Type.none
         ]
         return {tpe._identifier: tpe for tpe in builtin_types if isinstance(tpe, IType)}
 
     @classmethod
-    def all_types(cls) -> Dict[str, IType]:
+    def all_types(cls) -> dict[str, IType]:
         return {tpe._identifier: tpe for tpe in vars(cls).values() if isinstance(tpe, IType)}
 
     @classmethod
     def get_type(cls, value: Any) -> IType:
         """
         Returns the type of the given value.
 
@@ -118,8 +119,9 @@
     mapping = GenericMappingType()
     collection = GenericCollectionType()
     exception = BaseExceptionType()
 
     # Annotation types
     union = UnionType()
     optional = OptionalType()
+    ellipsis = ellipsisType
     any = anyType
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/type/typingmethod/casttypemethod.py` & `neo3_boa-1.2.0/boa3/internal/model/type/typingmethod/casttypemethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Any, Dict, List, Optional, Sized, Tuple
+from collections.abc import Sized
+from typing import Any
 
 from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.annotation.metatype import MetaType, metaType
 from boa3.internal.model.type.anytype import anyType
 from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
 from boa3.internal.model.type.itype import IType
@@ -22,15 +23,15 @@
 
         if origin_type is None:
             origin_type = anyType
         elif isinstance(origin_type, MetaType):
             origin_type = origin_type.meta_type if origin_type.has_meta_type else anyType
 
         identifier = 'cast'
-        args: Dict[str, Variable] = {'typ': Variable(type_value),
+        args: dict[str, Variable] = {'typ': Variable(type_value),
                                      'val': Variable(anyType)}
         super().__init__(identifier, args,
                          return_type=cast_to_type.meta_type if isinstance(cast_to_type, MetaType) else anyType)
         self._origin_type: IType = origin_type
 
     @property
     def identifier(self) -> str:
@@ -61,15 +62,15 @@
                                            for arg in self.args.values()]))
 
     @property
     def is_cast(self) -> bool:
         return True
 
     @property
-    def cast_types(self) -> Optional[Tuple[IType, IType]]:
+    def cast_types(self) -> tuple[IType, IType] | None:
         origin_type = self._origin_type
         target_type = (self.typ_arg.type.meta_type
                        if hasattr(self.typ_arg.type, 'meta_type')
                        else self.typ_arg.type)
         return origin_type, target_type
 
     def generate_internal_opcodes(self, code_generator):
@@ -80,26 +81,26 @@
         return 1  # the implementation is the same as x = arg
 
     @property
     def args_on_stack(self) -> int:
         return 1  # the implementation is the same as x = arg
 
     @property
-    def generation_order(self) -> List[int]:
+    def generation_order(self) -> list[int]:
         # type should not be converted
         indexes = super().generation_order
         typ_index = list(self.args).index('typ')
 
         if typ_index in indexes:
             indexes.remove(typ_index)
 
         return indexes
 
     @property
-    def _body(self) -> Optional[str]:
+    def _body(self) -> str | None:
         return None
 
     @property
     def typ_arg(self) -> Variable:
         return self.args['typ'] if isinstance(self.args['typ'], Variable) else Variable(anyType)
 
     @property
```

### Comparing `neo3-boa-1.1.1/boa3/internal/model/variable.py` & `neo3_boa-1.2.0/boa3/internal/model/variable.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,38 +1,40 @@
-from __future__ import annotations
-
 import ast
-from typing import Any, Optional, Union
+from typing import Any, Self
 
 from boa3.internal.model.expression import IExpression
 from boa3.internal.model.type.itype import IType
 
 
 class Variable(IExpression):
     """
     A class used to represent a variable
 
     :ivar var_type: the type of the variable.
     """
 
-    def __init__(self, var_type: Optional[IType], origin_node: Optional[ast.AST] = None):
-        super().__init__(origin_node)
+    def __init__(self,
+                 var_type: IType | None,
+                 origin_node: ast.AST | None = None,
+                 deprecated: bool = False
+                 ):
+        super().__init__(origin_node, deprecated)
         self.defined_by_entry = True
 
         from boa3.internal.analyser.model.optimizer import Undefined, UndefinedType
         if var_type is None:
             var_type = Undefined
 
-        self._var_type: Union[IType, UndefinedType] = var_type
+        self._var_type: IType | UndefinedType = var_type
 
         self.is_reassigned = False
-        self._origin_variable: Optional[Variable] = None
+        self._origin_variable: Variable | None = None
         self._first_assign_value: Any = Undefined
 
-    def copy(self) -> Variable:
+    def copy(self) -> Self:
         var = Variable(self._var_type, self._origin_node)
         var.is_reassigned = self.is_reassigned
         var._first_assign_value = self._first_assign_value
         var._origin_variable = self._origin_variable if self._origin_variable is not None else self
         return var
 
     @property
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/__init__.py` & `neo3_boa-1.2.0/boa3/internal/neo/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-from typing import Union
-
-
 def to_script_hash(data_bytes: bytes) -> bytes:
     """
     Converts a data to a script hash.
 
     :param data_bytes: data to hash.
     :type data_bytes: bytearray or bytes
 
@@ -20,15 +17,15 @@
         if len(base58_decoded) < SIZE_OF_INT160:
             raise ValueError
         return bytes(base58_decoded[:SIZE_OF_INT160])
     except BaseException:
         return cryptography.hash160(data_bytes)
 
 
-def public_key_to_script_hash(public_key: Union[str, bytes]) -> bytes:
+def public_key_to_script_hash(public_key: str | bytes) -> bytes:
     """
     Converts a public key bytes sequence to a script hash.
 
     :return: the script hash of the data
     :rtype: bytes
     """
     if isinstance(public_key, str):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/contracts/neffile.py` & `neo3_boa-1.2.0/boa3/internal/neo/contracts/neffile.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import List
+from typing import Self
 
 from boa3.internal import constants
 from boa3.internal.neo.contracts import NEF
 from boa3.internal.neo.core import BinaryReader, BinaryWriter
 from boa3.internal.neo3.contracts.nef import MethodToken
 
 
@@ -12,15 +10,15 @@
     """
     The object encapsulates the information of the NEO Executable Format (NEF)
 
     :ivar _nef: nef serializable object
     """
 
     def __init__(self, script_bytes: bytes,
-                 method_tokens: List[MethodToken] = None,
+                 method_tokens: list[MethodToken] = None,
                  source: str = None):
         """
         :param script_bytes: the script of the smart contract
         """
         compiler: str = f"neo3-boa by COZ-{constants.COMPILER_VERSION}"
         self._nef = NEF(compiler_name=compiler,
                         script=script_bytes,
@@ -52,15 +50,15 @@
         """
         with BinaryWriter() as writer:
             self._nef.serialize(writer)
             result = writer.to_array()
         return result
 
     @classmethod
-    def deserialize(cls, bts: bytes) -> NefFile:
+    def deserialize(cls, bts: bytes) -> Self:
         """
         Deserialize the NefFile object
 
         :param bts: stream data
         :return: the deserialized object.
         :rtype: NefFile
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/cryptography/__init__.py` & `neo3_boa-1.2.0/boa3/internal/neo/cryptography/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/smart_contract/notification.py` & `neo3_boa-1.2.0/boa3/internal/neo/smart_contract/notification.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Tuple
+from typing import Any, Self
 
 from boa3.internal.neo import to_hex_str
 from boa3.internal.neo.utils import stack_item_from_json
 
 
 class Notification:
     _event_name_key = 'eventname'
     _script_hash_key = 'scripthash'
     _value_key = 'value'
 
     def __init__(self, event_name: str, script_hash: bytes, *value: Any):
         self._event_name: str = event_name
         self._script_hash: bytes = script_hash
-        self._value: Tuple[Any] = value
+        self._value: tuple = value
 
     @property
     def name(self) -> str:
         return self._event_name
 
     @property
     def origin(self) -> bytes:
         return self._script_hash
 
     @property
     def arguments(self) -> tuple:
         return self._value
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], *args, **kwargs) -> Notification:
+    def from_json(cls, json: dict[str, Any], *args, **kwargs) -> Self:
         """
         Creates a Notification object from a json.
 
         :param json: json that contains the notification data
         :return: a Notification object
         :rtype: Notification
         """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/utils/__init__.py` & `neo3_boa-1.2.0/boa3/internal/neo/utils/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,18 @@
-from typing import Any, Dict, Optional, Sequence
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal.neo.core.types.InteropInterface import InteropInterface
 from boa3.internal.neo.vm.type.AbiType import AbiType
 from boa3.internal.neo.vm.type.Integer import Integer
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 from boa3.internal.neo.vm.type.String import String
 
 
-def stack_item_from_json(item: Dict[str, Any]) -> Any:
+def stack_item_from_json(item: dict[str, Any]) -> Any:
     if 'type' not in item:
         return None
 
     item_type: StackItemType = StackItemType.get_stack_item_type(item['type'])
     if item_type is StackItemType.InteropInterface:
         if 'value' in item:
             interop_interface = item['value']
@@ -69,26 +70,26 @@
             if 'key' not in x or 'value' not in x:
                 raise ValueError
             value[stack_item_from_json(x['key'])] = stack_item_from_json(x['value'])
 
     return value
 
 
-def bytes_from_json(item: Dict[str, Any]) -> Optional[bytes]:
+def bytes_from_json(item: dict[str, Any]) -> bytes | None:
     value = stack_item_from_json(item)
 
     if isinstance(value, str):
         value = String(value).to_bytes()
     elif isinstance(value, int):
         value = Integer(value).to_byte_array()
 
     return value if isinstance(value, bytes) else None
 
 
-def contract_parameter_to_json(value: Any) -> Dict[str, Any]:
+def contract_parameter_to_json(value: Any) -> dict[str, Any]:
     if value is None:
         return {'type': AbiType.Any}
 
     stack_type: AbiType = AbiType.Any
     parameter_value: Any = None
 
     if isinstance(value, bool):
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/CallCode.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/CallCode.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/TryCode.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/TryCode.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from typing import Optional
-
 from boa3.internal.neo.vm.VMCode import VMCode
 from boa3.internal.neo.vm.type.Integer import Integer
 
 
 class TryCode(VMCode):
     """
     Represents a Neo VM function try code
 
     :ivar info: the opcode information of the code
     :ivar data: the data in bytes of the code. Empty byte array by default.
     """
 
-    def __init__(self, except_start_code: Optional[VMCode] = None, finally_start_code: Optional[VMCode] = None):
+    def __init__(self, except_start_code: VMCode | None = None, finally_start_code: VMCode | None = None):
         """
         :param except_start_code: the first code of the except body
         :type except_start_code: VMCode or None
         """
-        self._except_start_code: Optional[VMCode] = except_start_code
-        self._finally_start_code: Optional[VMCode] = finally_start_code
+        self._except_start_code: VMCode | None = except_start_code
+        self._finally_start_code: VMCode | None = finally_start_code
         from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo
         super().__init__(OpcodeInfo.TRY)
 
     @property
     def target(self) -> VMCode:
         return self._except_start_code if self._finally_start_code is None else self._finally_start_code
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/VMCode.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/VMCode.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Optional
+from typing import Self
 
 from boa3.internal.neo.vm.opcode import OpcodeHelper
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.opcode.OpcodeInformation import OpcodeInformation
 from boa3.internal.neo.vm.type.Integer import Integer
 
 
@@ -20,15 +18,15 @@
         """
         :param op_info: information of the opcode of the code
         :param data: the data in bytes of the code. Empty byte array by default.
         """
         if data is None:
             data = bytes(op_info.data_len)
         self._info: OpcodeInformation = op_info
-        self._target: Optional[VMCode] = None
+        self._target: VMCode | None = None
         self._data: bytes = data
 
     @property
     def info(self) -> OpcodeInformation:
         """
         Gets the Neo VM opcode information
 
@@ -83,15 +81,15 @@
         Gets the Neo VM opcode of the code
 
         :return: the opcode of the code
         """
         return self.info.opcode
 
     @property
-    def target(self) -> VMCode:
+    def target(self) -> Self:
         """
         Gets the target code of this code
 
         :return: the target code if this is a control code. None otherwise
         :rtype: VMCode
         """
         return self._target if OpcodeHelper.has_target(self.opcode) else None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/Opcode.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/Opcode.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from __future__ import annotations
-
 from enum import Enum
 
 
 class Opcode(bytes, Enum):
     """
     Opcodes are similar to instructions in assembly language.
     """
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/OpcodeHelper.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/OpcodeHelper.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,20 @@
-from __future__ import annotations
-
-from typing import Dict, Optional, Tuple, Union
-
 from boa3.internal.constants import FOUR_BYTES_MAX_VALUE
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.type.Integer import Integer
 from boa3.internal.neo.vm.type.String import String
 
 
-def get_pushdata_and_data(bytestring: Union[str, bytes]) -> Tuple[Opcode, bytes]:
+def get_pushdata_and_data(bytestring: str | bytes) -> tuple[Opcode, bytes]:
     """
     Gets the push opcode and data to the respective str ot bytes value
 
     :param bytestring: value that will be pushed
     :return: the respective opcode and its required data
-    :rtype: Tuple[Opcode, bytes]
+    :rtype: tuple[Opcode, bytes]
     """
     if isinstance(bytestring, str):
         bytestring = String(bytestring).to_bytes()
 
     bytes_size = Integer(len(bytestring)).to_byte_array(min_length=1)
     if len(bytes_size) == 1:
         opcode = Opcode.PUSHDATA1
@@ -30,49 +26,49 @@
         bytes_size = Integer(len(bytestring)).to_byte_array(min_length=4)
         opcode = Opcode.PUSHDATA4
 
     data = bytes_size + bytestring
     return opcode, data
 
 
-def get_pushdata_and_data_from_size(data_size: int) -> Tuple[Opcode, bytes]:
+def get_pushdata_and_data_from_size(data_size: int) -> tuple[Opcode, bytes]:
     bytes_size = Integer(data_size).to_byte_array(min_length=1)
     if len(bytes_size) == 1:
         opcode = Opcode.PUSHDATA1
     elif len(bytes_size) == 2:
         opcode = Opcode.PUSHDATA2
     else:
         bytes_size = FOUR_BYTES_MAX_VALUE
         opcode = Opcode.PUSHDATA4
 
     return opcode, bytes_size
 
 
-def get_literal_push(integer: int) -> Optional[Opcode]:
+def get_literal_push(integer: int) -> Opcode | None:
     """
     Gets the push opcode to the respective integer
 
     :param integer: value that will be pushed
     :return: the respective opcode
     :rtype: Opcode or None
     """
     if -1 <= integer <= 16:
         opcode_value: int = Integer.from_bytes(Opcode.PUSH0) + integer
         return Opcode(Integer(opcode_value).to_byte_array())
     else:
         return None
 
 
-def get_push_and_data(integer: int) -> Tuple[Opcode, bytes]:
+def get_push_and_data(integer: int) -> tuple[Opcode, bytes]:
     """
     Gets the push opcode and data to the respective integer
 
     :param integer: value that will be pushed
     :return: the respective opcode and its required data
-    :rtype: Tuple[Opcode, bytes]
+    :rtype: tuple[Opcode, bytes]
     """
     opcode = get_literal_push(integer)
     if isinstance(opcode, Opcode):
         return opcode, b''
     else:
         data = Integer(integer).to_byte_array(signed=True, min_length=1)
         if len(data) == 1:
@@ -110,15 +106,15 @@
         return _larger_opcode[opcode]
     elif opcode in _larger_opcode.values():
         return opcode
     else:
         return None
 
 
-_larger_opcode: Dict[Opcode, Opcode] = {
+_larger_opcode: dict[Opcode, Opcode] = {
     Opcode.JMP: Opcode.JMP_L,
     Opcode.JMPIF: Opcode.JMPIF_L,
     Opcode.JMPIFNOT: Opcode.JMPIFNOT_L,
     Opcode.JMPEQ: Opcode.JMPEQ_L,
     Opcode.JMPNE: Opcode.JMPNE_L,
     Opcode.JMPGT: Opcode.JMPGT_L,
     Opcode.JMPGE: Opcode.JMPGE_L,
@@ -130,15 +126,15 @@
 }
 
 
 def is_jump(opcode: Opcode) -> bool:
     return Opcode.JMP <= opcode <= Opcode.JMPLE_L
 
 
-def get_try_and_data(except_target: int, finally_target: int = 0, jump_through: bool = False) -> Tuple[Opcode, bytes]:
+def get_try_and_data(except_target: int, finally_target: int = 0, jump_through: bool = False) -> tuple[Opcode, bytes]:
     """
     Gets the try opcode and data to the respective targets
     """
     jmp_placeholder = Opcode.JMP
     jmp_to_except_placeholder = get_jump_and_data(jmp_placeholder, except_target + jump_through, jump_through)
     jmp_to_finally_placeholder = get_jump_and_data(jmp_placeholder, finally_target, jump_through and finally_target > 0)
 
@@ -152,23 +148,23 @@
     each_arg_len = opcode_info.data_len // 2
 
     return (opcode,
             jmp_to_except_placeholder[1].rjust(each_arg_len, b'\x00')
             + jmp_to_finally_placeholder[1].rjust(each_arg_len, b'\x00'))
 
 
-def get_jump_and_data(opcode: Opcode, integer: int, jump_through: bool = False) -> Tuple[Opcode, bytes]:
+def get_jump_and_data(opcode: Opcode, integer: int, jump_through: bool = False) -> tuple[Opcode, bytes]:
     """
     Gets the jump opcode and data to the respective integer
 
     :param opcode: which jump will be used
     :param integer: number of bytes that'll be jumped
     :param jump_through: whether it should go over the instructions or not
     :return: the respective opcode and its required data
-    :rtype: Tuple[Opcode, bytes]
+    :rtype: tuple[Opcode, bytes]
     """
     if not has_target(opcode):
         opcode = Opcode.JMP
 
     from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo
     opcode_info = OpcodeInfo.get_info(opcode)
     arg_size = opcode_info.data_len
@@ -190,15 +186,15 @@
     return jmp_opcode, jmp_arg
 
 
 def has_target(opcode: Opcode) -> bool:
     return Opcode.JMP <= opcode <= Opcode.CALL_L or Opcode.TRY <= opcode < Opcode.ENDFINALLY
 
 
-def get_drop(position: int) -> Optional[Opcode]:
+def get_drop(position: int) -> Opcode | None:
     """
     Gets the opcode to remove the item n back in the stack
 
     :param position: index of the variable
     :return: the respective opcode
     :rtype: Opcode
     """
@@ -210,15 +206,15 @@
     if position > 0:
         if position in duplicate_item:
             return duplicate_item[position]
         else:
             return Opcode.XDROP
 
 
-def get_dup(position: int) -> Optional[Opcode]:
+def get_dup(position: int) -> Opcode | None:
     """
     Gets the opcode to duplicate the item n back in the stack
 
     :param position: index of the variable
     :return: the respective opcode
     :rtype: Opcode
     """
@@ -230,15 +226,15 @@
     if position >= 0:
         if position in duplicate_item:
             return duplicate_item[position]
         else:
             return Opcode.PICK
 
 
-def get_reverse(no_stack_items: int, rotate: bool = False) -> Optional[Opcode]:
+def get_reverse(no_stack_items: int, rotate: bool = False) -> Opcode | None:
     """
     Gets the opcode to reverse n items on the stack
 
     :param no_stack_items: index of the variable
     :param rotate: whether the stack should be reversed or rotated
     :return: the respective opcode
     :rtype: Opcode
@@ -321,15 +317,15 @@
 
 def is_load_slot(opcode: Opcode) -> bool:
     return (Opcode.LDSFLD0 <= opcode <= Opcode.LDSFLD
             or Opcode.LDLOC0 <= opcode <= Opcode.LDLOC
             or Opcode.LDARG0 <= opcode <= Opcode.LDARG)
 
 
-def get_store_from_load(load_opcode) -> Optional[Opcode]:
+def get_store_from_load(load_opcode) -> Opcode | None:
     """
     Gets the store slot opcode equivalent to the given load slot opcode.
 
     :param load_opcode: load opcode
     :type load_opcode: Opcode
     :return: equivalent store opcode if the given opcode is a load slot. Otherwise, returns None
     :rtype: Opcode or None
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/OpcodeInfo.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/OpcodeInfo.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,15 @@
-from typing import Optional
-
 from boa3.internal import constants
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 from boa3.internal.neo.vm.opcode.OpcodeInformation import OpcodeInformation
 
 
 class OpcodeInfo:
     @classmethod
-    def get_info(cls, opcode: Opcode) -> Optional[OpcodeInformation]:
+    def get_info(cls, opcode: Opcode) -> OpcodeInformation | None:
         """
         Gets a binary operation given the operator.
 
         :param opcode: Neo VM opcode
         :return: The opcode info if it exists. None otherwise
         :rtype: OpcodeInformation or None
         """
@@ -203,15 +201,15 @@
     # The item at the top of the stack is copied and inserted before the second-to-top item.
     TUCK = OpcodeInformation(Opcode.TUCK)
     # The top two items on the stack are swapped.
     SWAP = OpcodeInformation(Opcode.SWAP)
     # The top three items on the stack are rotated to the left.
     ROT = OpcodeInformation(Opcode.ROT)
     # The item n back in the stack is moved to the top.
-    ROLL = OpcodeInformation(Opcode.ROLL)
+    ROLL = OpcodeInformation(Opcode.ROLL, stack_items=1)
     # Reverse the order of the top 3 items on the stack.
     REVERSE3 = OpcodeInformation(Opcode.REVERSE3)
     # Reverse the order of the top 4 items on the stack.
     REVERSE4 = OpcodeInformation(Opcode.REVERSE4)
     # Pop the number N on the stack, and reverse the order of the top N items on the stack.
     REVERSEN = OpcodeInformation(Opcode.REVERSEN, stack_items=1)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/opcode/OpcodeInformation.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/opcode/OpcodeInformation.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Optional
+from typing import Self
 
 from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class OpcodeInformation:
     """
     Stores the information about a specific :class:`Opcode`
@@ -25,14 +23,14 @@
             extra_data_max_len = 0
         self.max_data_len: int = min_data_len + extra_data_max_len
 
         if stack_items < 0:
             stack_items = 0
         self.stack_items: int = stack_items
 
-    def get_large(self) -> Optional[OpcodeInformation]:
+    def get_large(self) -> Self | None:
         large_op = self.opcode.get_large
         if large_op is None:
             return None
 
         from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo
         return OpcodeInfo.get_info(large_op)
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/type/AbiType.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/type/AbiType.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-from __future__ import annotations
-
 from enum import Enum
-from typing import List
+from typing import Self
 
 
 class AbiType(str, Enum):
     Signature = 'Signature'
     Boolean = 'Boolean'
     Integer = 'Integer'
     Hash160 = 'Hash160'
@@ -15,16 +13,16 @@
     String = 'String'
     Array = 'Array'
     Map = 'Map'
     InteropInterface = 'InteropInterface'
     Any = 'Any'
     Void = 'Void'
 
-    @staticmethod
-    def union(abi_types: List[AbiType]) -> AbiType:
+    @classmethod
+    def union(cls, abi_types: list[Self]) -> Self:
         if len(abi_types) == 0:
             return AbiType.Any
 
         if len(abi_types) == 1:
             return abi_types[0]
 
         if AbiType.Void in abi_types:
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/type/ContractParameterType.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/type/ContractParameterType.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo/vm/type/Integer.py` & `neo3_boa-1.2.0/boa3/internal/neo/vm/type/Integer.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/contracts/contracttypes.py` & `neo3_boa-1.2.0/boa3/internal/neo3/contracts/contracttypes.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/contracts/findoptions.py` & `neo3_boa-1.2.0/boa3/internal/neo3/contracts/findoptions.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/contracts/native/nativetypes.py` & `neo3_boa-1.2.0/boa3/internal/neo3/contracts/native/nativetypes.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/contracts/nef.py` & `neo3_boa-1.2.0/boa3/internal/neo3/contracts/nef.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-from __future__ import annotations
-
 import hashlib
-from typing import List, Tuple
+from typing import Self
 
 from boa3.internal.neo3 import contracts
 from boa3.internal.neo3.core import Size as s, serialization, types, utils
 
 
 class Version(serialization.ISerializable):
     """
@@ -67,27 +65,27 @@
         major, minor, build, revision = version_split
         self.major = int(major)
         self.minor = int(minor)
         self.build = int(build)
         self.revision = int(revision)
 
     @classmethod
-    def _parse_component(self, c: str) -> Tuple[bool, int]:
+    def _parse_component(self, c: str) -> tuple[bool, int]:
         try:
             r = int(c)
         except ValueError:
             return False, -1
         if r < 0:
             return False, -1
         if r > 255:
             return False, -1
         return True, r
 
     @classmethod
-    def from_string(cls, input: str) -> Version:
+    def from_string(cls, input: str) -> Self:
         """
         Parse an instance out of a string.
 
         Args:
             input: string representing a version number following the format `Major.Minor[.build[.revision]]`.
             Each version part must fit in the range >= 0 <= 255.
 
@@ -117,19 +115,54 @@
             if not success:
                 raise ValueError(f"Cannot parse revision field from: {parts[3]}")
         else:
             revision = 0
         return cls(major, minor, build, revision)
 
 
+class MethodToken(serialization.ISerializable):
+    def __init__(self,
+                 hash: types.UInt160,
+                 method: str,
+                 parameters_count: int,
+                 has_return_value: bool,
+                 call_flags: contracts.CallFlags):
+        self.hash = hash
+        self.method = method
+        self.parameters_count = parameters_count
+        self.has_return_value = has_return_value
+        self.call_flags = call_flags
+
+    def __len__(self):
+        return s.uint160 + utils.get_var_size(self.method) + s.uint16 + s.uint8 + s.uint8
+
+    def serialize(self, writer: serialization.BinaryWriter):
+        writer.write_serializable(self.hash)
+        writer.write_var_string(self.method)
+        writer.write_uint16(self.parameters_count)
+        writer.write_uint8(self.has_return_value)
+        writer.write_uint8(self.call_flags.value)
+
+    def deserialize(self, reader: serialization.BinaryReader):
+        self.hash = reader.read_serializable(types.UInt160)
+        self.method = reader.read_var_string(32)
+        self.parameters_count = reader.read_uint16()
+        self.has_return_value = bool(reader.read_uint8())
+        self.call_flags = contracts.CallFlags(reader.read_uint8())
+
+    @classmethod
+    def _serializable_init(cls):
+        return cls(types.UInt160.zero(), "", 0, False, contracts.CallFlags.NONE)
+
+
 class NEF(serialization.ISerializable):
     def __init__(self,
                  compiler_name: str = None,
                  script: bytes = None,
-                 tokens: List[MethodToken] = None,
+                 tokens: list[MethodToken] = None,
                  source: str = None,
                  _magic: int = 0x3346454E):
         self.magic = _magic
         if compiler_name is None:
             self.compiler = 'unknown'
         else:
             self.compiler = compiler_name[:64]
@@ -206,43 +239,8 @@
             'little'
         )
 
     @classmethod
     def _serializable_init(cls):
         c = cls()
         c._checksum = 0
-        return c
-
-
-class MethodToken(serialization.ISerializable):
-    def __init__(self,
-                 hash: types.UInt160,
-                 method: str,
-                 parameters_count: int,
-                 has_return_value: bool,
-                 call_flags: contracts.CallFlags):
-        self.hash = hash
-        self.method = method
-        self.parameters_count = parameters_count
-        self.has_return_value = has_return_value
-        self.call_flags = call_flags
-
-    def __len__(self):
-        return s.uint160 + utils.get_var_size(self.method) + s.uint16 + s.uint8 + s.uint8
-
-    def serialize(self, writer: serialization.BinaryWriter):
-        writer.write_serializable(self.hash)
-        writer.write_var_string(self.method)
-        writer.write_uint16(self.parameters_count)
-        writer.write_uint8(self.has_return_value)
-        writer.write_uint8(self.call_flags.value)
-
-    def deserialize(self, reader: serialization.BinaryReader):
-        self.hash = reader.read_serializable(types.UInt160)
-        self.method = reader.read_var_string(32)
-        self.parameters_count = reader.read_uint16()
-        self.has_return_value = bool(reader.read_uint8())
-        self.call_flags = contracts.CallFlags(reader.read_uint8())
-
-    @classmethod
-    def _serializable_init(cls):
-        return cls(types.UInt160.zero(), "", 0, False, contracts.CallFlags.NONE)
+        return c
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/core/serialization.py` & `neo3_boa-1.2.0/boa3/internal/neo3/core/serialization.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,84 +1,32 @@
-from __future__ import annotations
-
 import abc
 import struct
 import sys
 from io import BytesIO, SEEK_END
-from typing import Any, List, Type, TypeVar, Union
+from typing import Any, TypeVar
 
 ISerializable_T = TypeVar('ISerializable_T', bound='ISerializable')
 
 __all__ = ['ISerializable', 'BinaryReader', 'BinaryWriter']
 
 
-class ISerializable(abc.ABC):
-    """
-    An interface like class supporting NEO's network serialization protocol.
-    """
-
-    @abc.abstractmethod
-    def serialize(self, writer: BinaryWriter) -> None:
-        """
-        Serialize the object into a binary stream.
-
-        Args:
-            writer: instance.
-        """
-
-    @abc.abstractmethod
-    def deserialize(self, reader: BinaryReader) -> None:
-        """
-        Deserialize the object from a binary stream.
-
-        Args:
-            reader: instance.
-        """
-
-    @classmethod
-    def deserialize_from_bytes(cls: Type[ISerializable_T], data: Union[bytes, bytearray]) -> ISerializable_T:
-        """
-        Parse data into an object instance.
-
-        Args:
-            data: hex escaped bytes.
-
-        Returns:
-            a deserialized instance of the class.
-        """
-        with BinaryReader(data) as br:
-            payload = cls()
-            payload.deserialize(br)
-            return payload
-
-    def to_array(self) -> bytes:
-        """ Serialize the object into a bytearray."""
-        with BinaryWriter() as bw:
-            self.serialize(bw)
-            return bw._stream.getvalue()
-
-    @abc.abstractmethod
-    def __len__(self):
-        """ Return the length of the object in number of bytes."""
-
-
 class BinaryReader(object):
     """
         A convenience class for reading data from byte streams.
 
         Context manager support is available to ensure proper cleanup of resources.
 
         Example:
         ::
 
             with BinaryReader(b'\\x01\\x02') as br:
                 my_value = br.read_uint16()
     """
 
-    def __init__(self, stream: Union[bytes, bytearray]) -> None:
+    def __init__(self, stream: bytes | bytearray) -> None:
         """
         Create an instance.
 
         Args:
             stream: a stream to operate on.
         """
         super(BinaryReader, self).__init__()
@@ -340,26 +288,26 @@
         length = self.read_var_int(max)
         try:
             data = self._unpack(str(length) + 's', length)
             return data.decode('utf-8')
         except Exception as e:
             raise ValueError(str(e))
 
-    def read_serializable(self, obj_type: Type[ISerializable_T]) -> ISerializable_T:
+    def read_serializable(self, obj_type: type[ISerializable_T]) -> ISerializable_T:
         """
         Read and deserialize an object of `obj_type` from the stream.
 
         Args:
             obj_type: the object class to deserialize into.
         """
         obj = obj_type._serializable_init()
         obj.deserialize(self)
         return obj
 
-    def read_serializable_list(self, obj_type: Type[ISerializable_T], max: int = None) -> list[ISerializable_T]:
+    def read_serializable_list(self, obj_type: type[ISerializable_T], max: int = None) -> list[ISerializable_T]:
         """
         Read and deserialize a list of objects of `obj_type` from the stream.
 
         Expects to start with a `varint` list length indicator.
 
         Args:
             obj_type: the object class to deserialize into.
@@ -403,15 +351,15 @@
     ::
 
         with serialization.BinaryWriter() as bw:
             bw.write_uint8(5)
             self.assertEqual(b'\\x05', bw._stream.getvalue())
     """
 
-    def __init__(self, stream: Union[bytearray, bytes] = None) -> None:
+    def __init__(self, stream: bytearray | bytes = None) -> None:
         """
         Create an instance.
 
         Args:
             stream: a stream to operate on.
         """
         super(BinaryWriter, self).__init__()
@@ -697,15 +645,15 @@
         Serialize an object instance and write it to the stream.
 
         Args:
             obj_instance: the instance to serialize.
         """
         obj_instance.serialize(self)
 
-    def write_serializable_list(self, objects: List[ISerializable_T]) -> None:
+    def write_serializable_list(self, objects: list[ISerializable_T]) -> None:
         """
         Serialize a list of objects and write them to the stream.
 
         Args:
             objects: a list of objects.
         """
         self.write_var_int(len(objects))
@@ -723,7 +671,57 @@
             self._stream.close()
 
     def to_array(self) -> bytes:
         """
         Get the raw bytes from the underlying stream.
         """
         return self._stream.getvalue()
+
+
+class ISerializable(abc.ABC):
+    """
+    An interface like class supporting NEO's network serialization protocol.
+    """
+
+    @abc.abstractmethod
+    def serialize(self, writer: BinaryWriter) -> None:
+        """
+        Serialize the object into a binary stream.
+
+        Args:
+            writer: instance.
+        """
+
+    @abc.abstractmethod
+    def deserialize(self, reader: BinaryReader) -> None:
+        """
+        Deserialize the object from a binary stream.
+
+        Args:
+            reader: instance.
+        """
+
+    @classmethod
+    def deserialize_from_bytes(cls: type[ISerializable_T], data: bytes | bytearray) -> ISerializable_T:
+        """
+        Parse data into an object instance.
+
+        Args:
+            data: hex escaped bytes.
+
+        Returns:
+            a deserialized instance of the class.
+        """
+        with BinaryReader(data) as br:
+            payload = cls()
+            payload.deserialize(br)
+            return payload
+
+    def to_array(self) -> bytes:
+        """ Serialize the object into a bytearray."""
+        with BinaryWriter() as bw:
+            self.serialize(bw)
+            return bw._stream.getvalue()
+
+    @abc.abstractmethod
+    def __len__(self):
+        """ Return the length of the object in number of bytes."""
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/core/types/biginteger.py` & `neo3_boa-1.2.0/boa3/internal/neo3/core/types/biginteger.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,36 +1,34 @@
-from __future__ import annotations
-
 from decimal import Decimal, localcontext
-from typing import Type
+from typing import Self
 
 
 class BigInteger(int):
     """
     An implementation to match the C# BigInteger class as used by the NEO reference project.
     """
 
     @classmethod
-    def ZERO(cls: Type[BigInteger]) -> BigInteger:
+    def ZERO(cls: type[Self]) -> Self:
         """
         Returns:
             An instance initialized to zero.
         """
         return cls(0)
 
     @classmethod
-    def ONE(cls: Type[BigInteger]) -> BigInteger:
+    def ONE(cls: type[Self]) -> Self:
         """
         Returns:
             An instance initialized to one.
         """
         return cls(1)
 
     @classmethod
-    def frombytes(cls: Type[BigInteger], bytes: bytes) -> BigInteger:
+    def frombytes(cls: type[Self], bytes: bytes) -> Self:
         """
         Return the BigInteger represented by the given array of bytes.
 
         The underlying value is always signed and in little endian format.
 
         Args:
             bytes: Holds the array of bytes to convert. The argument must either support the buffer protocol or
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/core/types/uint.py` & `neo3_boa-1.2.0/boa3/internal/neo3/core/types/uint.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from __future__ import annotations
-
 import binascii
-from typing import Type, Union
+from typing import Self
 
 from boa3.internal.neo import to_hex_str
 from boa3.internal.neo3.core import serialization
 
 __all__ = ['UInt160', 'UInt256']
 
 
 class _UIntBase(serialization.ISerializable):
-    def __init__(self, num_bytes: int, data: Union[bytes, bytearray] = None) -> None:
+    def __init__(self, num_bytes: int, data: bytes | bytearray = None) -> None:
         """
 
         Args:
             num_bytes:
             data:
         """
         super(_UIntBase, self).__init__()
@@ -131,30 +129,30 @@
 
         Args:
             data: hex escaped bytearray.
         """
         super(UInt160, self).__init__(num_bytes=self._BYTE_LEN, data=data)
 
     @classmethod
-    def deserialize_from_bytes(cls: Type[UInt160], data: bytes) -> UInt160:
+    def deserialize_from_bytes(cls: type[Self], data: bytes) -> Self:
         """
         Parse data into an object instance.
 
         Args:
             data: hex escaped bytes.
 
         Raises:
             ValueError: if the length of the supplied bytearray is insufficient for the type.
         """
         if len(data) < cls._BYTE_LEN:
             raise ValueError(f"Insufficient data {len(data)} bytes is less than the required {cls._BYTE_LEN}")
         return cls(data[:cls._BYTE_LEN])
 
     @classmethod
-    def from_string(cls: Type[UInt160], value: str) -> UInt160:
+    def from_string(cls: type[Self], value: str) -> Self:
         """
         Try to parse a string into an instance.
 
         Note:
             NEO's string representation is in reverse byte order from the internal bytearray.
 
 
@@ -169,15 +167,15 @@
         if len(value) != cls._BYTE_LEN * 2:
             raise ValueError(f"Invalid {cls.__name__} Format: {len(value)} chars != {cls._BYTE_LEN * 2} chars")
         reversed_data = bytearray.fromhex(value)
         reversed_data.reverse()
         return cls(data=reversed_data)
 
     @classmethod
-    def zero(cls: Type[UInt160]) -> UInt160:
+    def zero(cls: type[Self]) -> Self:
         """
         Returns:
             An instance initialized to zero.
         """
         return cls(data=bytearray(20))
 
     def serialize(self, writer: serialization.BinaryWriter) -> None:
@@ -208,30 +206,30 @@
 
         Args:
             data: hex escaped bytearray.
         """
         super(UInt256, self).__init__(num_bytes=self._BYTE_LEN, data=data)
 
     @classmethod
-    def deserialize_from_bytes(cls: Type[UInt256], data: bytes) -> UInt256:
+    def deserialize_from_bytes(cls: type[Self], data: bytes) -> Self:
         """
         Parse data into an object instance.
 
         Args:
             data: hex escaped bytes.
 
         Raises:
             ValueError: if the length of the supplied bytearray is insufficient for the type.
         """
         if len(data) < cls._BYTE_LEN:
             raise ValueError(f"Insufficient data {len(data)} bytes is less than the required {cls._BYTE_LEN}")
         return cls(data[:cls._BYTE_LEN])
 
     @classmethod
-    def from_string(cls: Type[UInt256], value: str) -> UInt256:
+    def from_string(cls: type[Self], value: str) -> Self:
         """
         Try to parse a string into an instance.
 
         Note:
             NEO's string representation is in reverse byte order from the internal bytearray.
 
 
@@ -246,15 +244,15 @@
         if len(value) != cls._BYTE_LEN * 2:
             raise ValueError(f"Invalid {cls.__name__} Format: {len(value)} chars != {cls._BYTE_LEN * 2} chars")
         reversed_data = bytearray.fromhex(value)
         reversed_data.reverse()
         return cls(data=reversed_data)
 
     @classmethod
-    def zero(cls: Type[UInt256]) -> UInt256:
+    def zero(cls: type[Self]) -> Self:
         """
         Returns:
             An instance initialized to zero.
         """
 
         return cls(data=bytearray(cls._BYTE_LEN))
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/core/utils.py` & `neo3_boa-1.2.0/boa3/internal/neo3/core/utils.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 # type: ignore
 
 from enum import Enum
-from typing import Iterable
+from collections.abc import Iterable
 
 from boa3.internal.neo3.core import Size, serialization
 
 
 def get_var_size(value: object) -> int:
     """
     Determine the variable size of an object.
```

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/network/payloads/oracleresponsecode.py` & `neo3_boa-1.2.0/boa3/internal/neo3/network/payloads/oracleresponsecode.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/network/payloads/verification.py` & `neo3_boa-1.2.0/boa3/internal/neo3/network/payloads/verification.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3/internal/neo3/vm/vmstate.py` & `neo3_boa-1.2.0/boa3/internal/neo3/vm/vmstate.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from __future__ import annotations
-
 from enum import IntEnum
 
 
 class VMState(IntEnum):
     """
     Represents the VM execution state.
     """
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/interface/itransactionobject.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/interface/itransactionobject.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neobatchinvoke.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neobatchinvoke.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-from typing import Type, Iterable
+from collections.abc import Iterable
 
 from boa3_test.test_drive.model.interface.itransactionobject import ITransactionObject
 from boa3_test.test_drive.model.invoker import invokeresult
 from boa3_test.test_drive.model.invoker.neoinvoke import NeoInvoke
 
 
 class NeoBatchInvoke(ITransactionObject):
-    def __init__(self, invoke: NeoInvoke, tx_pos: int, expected_result_type: Type = None):
+    def __init__(self, invoke: NeoInvoke, tx_pos: int, expected_result_type: type = None):
         super().__init__()
         self._invoke: NeoInvoke = invoke
         self._tx_pos: int = tx_pos
         self._result = invokeresult.NOT_EXECUTED
 
         if not isinstance(expected_result_type, type):
             expected_result_type = None
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neoinvoke.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neoinvoke.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-from typing import Any, Dict, Tuple, Union
+from typing import Any
 
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.testrunner import utils
 
 
 class NeoInvoke:
-    def __init__(self, contract_id: Union[str, UInt160], operation: str, *args: Any, invoker: Account = None):
+    def __init__(self, contract_id: str | UInt160, operation: str, *args: Any, invoker: Account = None):
         self._contract_id = str(contract_id)
         self._contract: TestContract = None  # set if available
         self._operation = operation
         self._args = tuple(utils.value_to_parameter(x) for x in args)
         self._invoker: Account = invoker
 
     @property
@@ -23,30 +23,30 @@
         return self._contract_id
 
     @property
     def operation(self) -> str:
         return self._operation
 
     @property
-    def args(self) -> Tuple[str]:
+    def args(self) -> tuple[str, ...]:
         import json
         return tuple((json.dumps(arg, separators=(',', ':')) for arg in self._args))
 
     @property
-    def cli_args(self) -> Tuple[str]:
+    def cli_args(self) -> tuple[str, ...]:
         import json
         return tuple((str(arg) if (isinstance(arg, str) and len(arg.split(' ')) == 1)
                       else json.dumps(arg, separators=(',', ':'))
                       for arg in self._args))
 
     @property
     def invoker(self) -> Account:
         return self._invoker
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         return {
             'contract': self._contract_id,
             'operation': self._operation,
             'args': list(self._args)
         }
 
     def __repr__(self):
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neoinvokecollection.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neoinvokecollection.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-from typing import Any, List, Optional, Type
+from typing import Any
 
 from boa3.internal.neo3.vm import VMState
 from boa3_test.test_drive.model.invoker.neoinvoke import NeoInvoke
 from boa3_test.test_drive.model.invoker.neoinvokeresult import NeoInvokeResult
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 from boa3_test.test_drive.model.wallet.account import Account
 
 __all__ = ['NeoInvokeCollection']
 
 
 class NeoInvokeCollection:
     def __init__(self):
-        self._internal_list: List[NeoInvoke] = []
-        self._invoke_results: List[NeoInvokeResult] = []
-        self._pending_results: List[NeoInvokeResult] = []
+        self._internal_list: list[NeoInvoke] = []
+        self._invoke_results: list[NeoInvokeResult] = []
+        self._pending_results: list[NeoInvokeResult] = []
 
     def create_contract_invoke(self, contract: TestContract, operation: str, *args: Any) -> NeoInvoke:
         invoker = NeoInvoke(contract.name, operation, *args)
         invoker._contract = contract
         return invoker
 
     def append_contract_invoke(self, contract: TestContract, operation: str, *args: Any,
-                               expected_result_type: Type = None) -> NeoInvokeResult:
+                               expected_result_type: type = None) -> NeoInvokeResult:
         invoker = NeoInvoke(contract.name, operation, *args)
         invoker._contract = contract
         invoke_result = NeoInvokeResult(invoker, expected_result_type=expected_result_type)
         self._internal_list.append(invoker)
         self._invoke_results.append(invoke_result)
         self._pending_results.append(invoke_result)
         return invoke_result
@@ -42,15 +42,15 @@
 
     def to_json(self):
         if len(self._internal_list) > 0:
             return [invoke.to_json() for invoke in self._internal_list]
 
         return [{}]
 
-    def set_results(self, new_result_stack: List[Any], calling_account: Optional[Account] = None) -> List[NeoInvokeResult]:
+    def set_results(self, new_result_stack: list[Any], calling_account: Account | None = None) -> list[NeoInvokeResult]:
         no_iterations = min(len(new_result_stack), len(self._pending_results)) + 1
         pending_results = self._pending_results.copy()
 
         for index in range(1, no_iterations):
             invoke_result = self._pending_results.pop(0)
             invoke_result.invoke._invoker = calling_account
             invoke_result._result = new_result_stack[-index]
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/invoker/neoinvokeresult.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/invoker/neoinvokeresult.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-from typing import Type, Iterable
+from collections.abc import Iterable
 
 from boa3_test.test_drive.model.invoker import invokeresult
 from boa3_test.test_drive.model.invoker.neoinvoke import NeoInvoke
 
 
 class NeoInvokeResult:
-    def __init__(self, invoke: NeoInvoke, expected_result_type: Type = None):
+    def __init__(self, invoke: NeoInvoke, expected_result_type: type = None):
         self._invoke: NeoInvoke = invoke
         self._result = invokeresult.NOT_EXECUTED
 
         if not isinstance(expected_result_type, type):
             expected_result_type = None
         self._expected_result_type = expected_result_type
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/oracleresponse.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/oracleresponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-from __future__ import annotations
-
-from typing import Dict, Any
+from typing import Any, Self
 
 from boa3_test.test_drive.model.network.payloads.transactionattribute import TransactionAttribute, \
     TransactionAttributeType
 
 
 class OracleResponse(TransactionAttribute):
     def __init__(self, id_: int, code: str, result: str):
         super().__init__(TransactionAttributeType.ORACLE_RESPONSE)
         self._id = id_
         self._code = code
         self._result = result
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         import base64
         import json
         json_response = super().to_json()
 
         json_response['id'] = self._id
         json_response['code'] = self._code
         json_response['result'] = json.loads(base64.b64decode(self._result))
 
         return json_response
 
-    @staticmethod
-    def from_json(json: Dict[str, Any]) -> OracleResponse:
+    @classmethod
+    def from_json(cls, json: dict[str, Any]) -> Self:
         oracle_response: OracleResponse = OracleResponse(json['id'], json['code'], json['result'])
 
         return oracle_response
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/signer.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/signer.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,44 +1,42 @@
-from __future__ import annotations
-
-from typing import Any, Dict, List
+from typing import Any, Self
 
 from boa3.internal.neo import from_hex_str, to_hex_str
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
 
 
 class Signer:
     def __init__(self, account: UInt160, scopes: WitnessScope = WitnessScope.CalledByEntry):
         if scopes == WitnessScope.WitnessRules:
             raise NotImplementedError
         self._account: UInt160 = account
         self._scopes: WitnessScope = scopes
-        self._allowed_contracts: List[UInt160] = []
-        self._allowed_groups: List[bytes] = []
+        self._allowed_contracts: list[UInt160] = []
+        self._allowed_groups: list[bytes] = []
 
     @property
     def account(self) -> UInt160:
         return self._account
 
     @property
     def scopes(self) -> WitnessScope:
         return self._scopes
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         return {
             'account': str(self._account),
             'scopes': self._scopes.neo_name(),
             'allowedcontracts': [str(contract_hash) for contract_hash in self._allowed_contracts],
             'allowedgroups': [to_hex_str(group_pubkey) for group_pubkey in self._allowed_groups],
             'rules': []
         }
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> Signer:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         account_hex = json['account']
         account = UInt160(from_hex_str(account_hex))
         scopes = WitnessScope.get_from_neo_name(json['scopes']) if 'scopes' in json else WitnessScope.CalledByEntry
 
         signer = cls(account, scopes)
         signer._allowed_contracts = ([UInt160(from_hex_str(contract_hex)) for contract_hex in json['allowedcontracts']]
                                      if 'allowedcontracts' in json else [])
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/testblock.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/testblock.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,45 +1,43 @@
-from __future__ import annotations
-
-from typing import Optional, List, Dict, Any
+from typing import Any, Self
 
 from boa3.internal.neo import from_hex_str
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.model.network.payloads.testtransaction import TestTransaction
 
 
 class TestBlock:
     def __init__(self):
         self._index: int = 0
         self._timestamp: int = 0
-        self._hash: Optional[UInt256] = None
-        self._transactions: List[TestTransaction] = []
+        self._hash: UInt256 | None = None
+        self._transactions: list[TestTransaction] = []
 
     @property
     def index(self) -> int:
         return self._index
 
     @property
     def timestamp(self) -> int:
         return self._timestamp
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         json_block = {
             'index': self._index,
             'timestamp': self._timestamp,
             'transactions': [tx.to_json() for tx in self._transactions]
         }
 
         if self._hash is not None:
             json_block['hash'] = str(self._hash)
 
         return json_block
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], *args, **kwargs) -> TestBlock:
+    def from_json(cls, json: dict[str, Any], *args, **kwargs) -> Self:
         block = object.__new__(cls)
 
         if 'index' in json:
             block._index = int(json['index'])
         else:
             block._index = 0
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/testtransaction.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/testtransaction.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,54 +1,52 @@
-from __future__ import annotations
-
-from typing import List, Dict, Any, Union, Optional
+from typing import Any, Self
 
 from boa3.internal.neo import from_hex_str, utils
 from boa3.internal.neo3.core.types import UInt256
 from boa3.internal.neo3.vm import VMState
 from boa3_test.test_drive.model.network.payloads.signer import Signer
 from boa3_test.test_drive.model.network.payloads.transactionattribute import TransactionAttribute
 from boa3_test.test_drive.model.network.payloads.witness import Witness
 from boa3_test.test_drive.model.smart_contract.contractcollection import ContractCollection
 from boa3_test.test_drive.model.smart_contract.triggertype import TriggerType
 from boa3_test.test_drive.testrunner.blockchain.notification import TestRunnerNotification as Notification
 
 
 class TestTransaction:
-    def __init__(self, tx_hash: Union[UInt256, bytes], script: bytes, signers: List[Signer] = None, witnesses: List[Witness] = None):
+    def __init__(self, tx_hash: UInt256 | bytes, script: bytes, signers: list[Signer] = None, witnesses: list[Witness] = None):
         if isinstance(tx_hash, bytes):
             tx_hash = UInt256(tx_hash)
 
         self._hash: UInt256 = tx_hash
         self._script: bytes = script
 
-        self._signers: List[Signer] = signers if signers is not None else []
-        self._witnesses: List[Witness] = witnesses if witnesses is not None else []
-        self._attributes: List[TransactionAttribute] = []
+        self._signers: list[Signer] = signers if signers is not None else []
+        self._witnesses: list[Witness] = witnesses if witnesses is not None else []
+        self._attributes: list[TransactionAttribute] = []
 
     def __new__(cls, *args, **kwargs):
         return super().__new__(cls)
 
     @property
     def hash(self) -> UInt256:
         return self._hash
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         import base64
         from boa3.internal.neo.vm.type.String import String
         return {
             'hash': str(self._hash),
             'signers': [signer.to_json() for signer in self._signers],
             'witnesses': [witness.to_json() for witness in self._witnesses],
             'attributes': [attr.to_json() for attr in self._attributes if hasattr(attr, 'to_json')],
             'script': String.from_bytes(base64.b64encode(self._script))
         }
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], *args, **kwargs) -> TestTransaction:
+    def from_json(cls, json: dict[str, Any], *args, **kwargs) -> Self:
         import base64
 
         if 'hash' in json and isinstance(json['hash'], str):
             tx_hash = UInt256(from_hex_str(json['hash']))
         else:
             tx_hash = UInt256.zero()
 
@@ -89,42 +87,42 @@
     def __init__(self):
         super().__init__()
         self._trigger = TriggerType.All
         self._vm_state = VMState.NONE
         self._gas_consumed: int = 0
         self._exception: str = None
         self._stack = []
-        self._notifications: List[Notification] = []
+        self._notifications: list[Notification] = []
 
     @property
     def trigger(self) -> TriggerType:
         return self._trigger
 
     @property
     def vm_state(self) -> VMState:
         return self._vm_state
 
     @property
-    def exception(self) -> Optional[str]:
+    def exception(self) -> str | None:
         return self._exception
 
     @property
     def gas_consumed(self) -> int:
         return self._gas_consumed
 
     @property
     def result_stack(self) -> list:
         return self._stack.copy()
 
     @property
-    def notifications(self) -> List[Notification]:
+    def notifications(self) -> list[Notification]:
         return self._notifications.copy()
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], contract_collection: ContractCollection = None) -> TransactionExecution:
+    def from_json(cls, json: dict[str, Any], contract_collection: ContractCollection = None) -> Self:
         tx_exec = cls()
 
         tx_exec._trigger = TriggerType[json['trigger']]
         tx_exec._vm_state = VMState[json['vmstate']]
         tx_exec._gas_consumed = int(json['gasconsumed'])
         tx_exec._exception = str(json['exception']) if json['exception'] is not None else None
         tx_exec._stack = [utils.stack_item_from_json(value) for value in json['stack']]
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/transactionattribute.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/transactionattribute.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,30 +1,28 @@
-from __future__ import annotations
-
-from typing import Dict, Any
+from typing import Any, Self
 
 
 class TransactionAttributeType:
 
     ORACLE_RESPONSE = 'OracleResponse'
     NOT_VALID_BEFORE = 'NotValidBefore'
     HIGH_PRIORITY_ATTRIBUTE = 'HighPriorityAttribute'
 
 
 class TransactionAttribute:
     def __init__(self, type_: str):
         self._type = type_
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         return {
             'type': self._type,
         }
 
-    @staticmethod
-    def from_json(json: Dict[str, Any]) -> TransactionAttribute:
+    @classmethod
+    def from_json(cls, json: dict[str, Any]) -> Self:
         if json['type'] == TransactionAttributeType.ORACLE_RESPONSE:
             from boa3_test.test_drive.model.network.payloads.oracleresponse import OracleResponse
             tx_attr = OracleResponse.from_json(json)
         else:
             tx_attr = TransactionAttribute(json['type'])
 
         return tx_attr
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/witness.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/witness.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-from __future__ import annotations
-
 import base64
-from typing import Any, Dict
+from typing import Any, Self
 
 
 class Witness:
     def __init__(self, invocation_script: bytes, verification_script: bytes):
         self._invocation_script = invocation_script
         self._verification_script = verification_script
 
@@ -13,19 +11,19 @@
     def invocation_script(self) -> bytes:
         return self._invocation_script
 
     @property
     def verification_script(self) -> bytes:
         return self._verification_script
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         import base64
         return {
             'invocation': base64.b64encode(self._invocation_script).decode(),
             'verification': base64.b64encode(self._verification_script).decode()
         }
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> Witness:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         invocation = base64.b64decode(json['invocation'])
         verification = base64.b64decode(json['verification'])
         return cls(invocation, verification)
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/network/payloads/witnessscope.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/network/payloads/witnessscope.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,10 +1,9 @@
-from __future__ import annotations
-
 import enum
+from typing import Self
 
 
 class WitnessScope(enum.IntEnum):
     # Indicates that no contract was witnessed. Only sign the transaction.
     _None = 0
 
     # Indicates that the calling contract must be the entry contract. The witness/permission/signature
@@ -27,13 +26,13 @@
 
     def neo_name(self) -> str:
         if self is WitnessScope._None:
             return 'None'
         else:
             return self.name
 
-    @staticmethod
-    def get_from_neo_name(neo_name: str) -> WitnessScope:
+    @classmethod
+    def get_from_neo_name(cls, neo_name: str) -> Self:
         if neo_name == 'None':
             return WitnessScope._None
         elif neo_name != WitnessScope._None.name:
             return WitnessScope[neo_name]
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/contractcollection.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/contractcollection.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import List
-
 from boa3.internal import constants
 from boa3.internal.neo import to_hex_str
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 from boa3_test.test_drive.testrunner.blockchain.contract import TestRunnerContract
 
 
 class ContractCollection:
@@ -19,18 +17,18 @@
         TestRunnerContract('StdLib', to_hex_str(constants.STD_LIB_SCRIPT)),
         TestRunnerContract('ContractManagement', to_hex_str(constants.MANAGEMENT_SCRIPT)),
     ]
 
     def __init__(self):
         natives = self._native_contracts.copy()
 
-        self._contract_names: List[str] = [native.name for native in natives]
-        self._contract_paths: List[str] = [native.path for native in natives]
-        self._internal_list: List[TestContract] = natives
-        self._waiting_deploy: List[TestContract] = []
+        self._contract_names: list[str] = [native.name for native in natives]
+        self._contract_paths: list[str] = [native.path for native in natives]
+        self._internal_list: list[TestContract] = natives
+        self._waiting_deploy: list[TestContract] = []
 
     def append(self, new_contract: TestContract):
         if not isinstance(new_contract, TestContract):
             return
         if new_contract.name not in self._contract_names:
             self._contract_names.append(new_contract.name)
             self._contract_paths.append(new_contract.path)
@@ -95,15 +93,15 @@
 
     def __str__(self):
         return str(self._internal_list)
 
     def __repr__(self):
         return self._internal_list.__repr__()
 
-    def replace(self, deployed_contracts: List[TestContract]):
+    def replace(self, deployed_contracts: list[TestContract]):
         already_existing_contracts = self._contract_names.copy()
         contract_indexes = list(range(len(already_existing_contracts)))
 
         for contract in deployed_contracts:
             try:
                 contract_index = self._contract_names.index(contract.name)
                 existing_contract = self._internal_list[contract_index]
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/testcontract.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/testcontract.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,36 +1,34 @@
-from typing import Optional
-
 from boa3.internal import constants
 from boa3.internal.neo import to_hex_str
 from boa3_test.test_drive.model.interface.itransactionobject import ITransactionObject
 
 
 class TestContract(ITransactionObject):
     contract_hash_group = 'scripthash'
 
     def __init__(self, file_path: str, manifest_path: str):
         super().__init__()
         self._nef_path: str = file_path
         self._manifest_path: str = manifest_path
         self._manifest: dict = self._read_manifest()
-        self._script_hash: Optional[bytes] = None
+        self._script_hash: bytes | None = None
 
     @property
     def path(self) -> str:
         return self._nef_path
 
     @property
-    def script_hash(self) -> Optional[bytes]:
+    def script_hash(self) -> bytes | None:
         if not isinstance(self._script_hash, bytes) and len(self._log) > 0 and not self._log.isspace():
             self._handle_log()
         return self._script_hash
 
     @script_hash.setter
-    def script_hash(self, new_value: Optional[bytes]):
+    def script_hash(self, new_value: bytes | None):
         if self._script_hash is None and isinstance(new_value, bytes) and len(new_value) == constants.SIZE_OF_INT160:
             self._script_hash = new_value
 
     @property
     def name(self) -> str:
         return self._manifest['name'] if 'name' in self._manifest else None
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/smart_contract/triggertype.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/smart_contract/triggertype.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,9 @@
-from __future__ import annotations
-
 import enum
+from typing import Self
 
 
 class TriggerType(enum.IntEnum):
     # Indicate that the contract is triggered by the system to execute the OnPersist method of the native contracts.
     OnPersist = 0x01
 
     # Indicate that the contract is triggered by the system to execute the PostPersist method of the native contracts.
@@ -21,10 +20,10 @@
 
     # The combination of all triggers.
     All = OnPersist | PostPersist | Verification | Application
 
     def neo_name(self) -> str:
         return self.name
 
-    @staticmethod
-    def get_from_neo_name(neo_name: str) -> TriggerType:
+    @classmethod
+    def get_from_neo_name(cls, neo_name: str) -> Self:
         return TriggerType[neo_name]
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/wallet/account.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/wallet/account.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-from __future__ import annotations
-
 import abc
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.wallet import utils
 
 
 class Account(abc.ABC):
     def __init__(self, script_hash: UInt160,
@@ -19,39 +17,39 @@
             elif not isinstance(script_hash, UInt160):
                 raise TypeError(f"Invalid data type {type(script_hash)}. Expecting UInt160 or bytes")
         self._script_hash: UInt160 = script_hash
         self._version: int = account_version
 
         if name is not None and not isinstance(name, str):
             raise TypeError(f"Invalid data type {type(name)}. Expecting str or None")
-        self._name: Optional[str] = name
+        self._name: str | None = name
 
         if label is not None and not isinstance(label, str):
             raise TypeError(f"Invalid data type {type(label)}. Expecting str or None")
-        self._label: Optional[str] = label
+        self._label: str | None = label
 
     @property
     def script_hash(self) -> UInt160:
         return self._script_hash
 
     @property
-    def address(self) -> Optional[str]:
+    def address(self) -> str | None:
         return utils.address_from_script_hash(self._script_hash.to_array(), self._version)
 
     @property
-    def name(self) -> Optional[str]:
+    def name(self) -> str | None:
         return self._name
 
     @property
-    def label(self) -> Optional[str]:
+    def label(self) -> str | None:
         return self._label
 
     @classmethod
     @abc.abstractmethod
-    def from_json(cls, json: Dict[str, Any]) -> Account:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         pass
 
     def get_identifier(self) -> str:
         if isinstance(self._name, str):
             return self._name
         return self.address
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/model/wallet/utils.py` & `neo3_boa-1.2.0/boa3_test/test_drive/model/wallet/utils.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/batch.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/batch.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import threading
-from typing import List, Union, Any, Type
+from typing import Any
 
 from boa3.internal.neo.vm.type.String import String
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.interface.itransactionobject import ITransactionObject
 from boa3_test.test_drive.model.invoker.neobatchinvoke import NeoBatchInvoke
 from boa3_test.test_drive.model.invoker.neoinvoke import NeoInvoke
 from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
@@ -14,20 +14,20 @@
 from boa3_test.test_drive.neoxp.command.neoexpresscommand import NeoExpressCommand
 
 _NEOXP_BATCH_LOCK = threading.Lock()
 
 
 class NeoExpressBatch:
     def __init__(self, neoxp_config):
-        self._instructions: List[NeoExpressCommand] = []
-        self._transaction_submissions: List[int] = []
-        self._transaction_logs: List[str] = []
+        self._instructions: list[NeoExpressCommand] = []
+        self._transaction_submissions: list[int] = []
+        self._transaction_logs: list[str] = []
 
-        self._tx_invokes: List[ITransactionObject] = []
-        self._tx_invokes_pos: List[int] = []
+        self._tx_invokes: list[ITransactionObject] = []
+        self._tx_invokes_pos: list[int] = []
         self._neoxp_config = neoxp_config
 
     def is_empty(self) -> bool:
         return len(self._instructions) == 0
 
     def cur_size(self) -> int:
         return len(self._instructions)
@@ -49,15 +49,15 @@
 
         self._tx_invokes.append(deployed_contract)
         self._tx_invokes_pos.append(tx_pos)
 
         return deployed_contract
 
     def run_contract(self, invoke: NeoInvoke, witness_scope: WitnessScope = None,
-                     expected_result_type: Type = None) -> NeoBatchInvoke:
+                     expected_result_type: type = None) -> NeoBatchInvoke:
         if hasattr(invoke.invoker, 'name') and isinstance(invoke.invoker.name, str):
             invoker_id = invoke.invoker
         else:
             invoker_id = utils.get_default_account(self._neoxp_config)  # neo express default account
 
         tx_pos = len(self._instructions)
         batch_invoke = NeoBatchInvoke(invoke, tx_pos, expected_result_type=expected_result_type)
@@ -79,16 +79,16 @@
 
         if witness_scope != WitnessScope.CalledByEntry:
             # only CalledByEntry and Global are accepted as WitnessScopes in neo express
             witness_scope = WitnessScope.Global
 
         self._instructions.append(neoxp.contract.invoke(invoke_file, invoker_id, witness_scope))
 
-    def transfer_assets(self, sender: Account, receiver: Account, asset: Union[str, UInt160],
-                        quantity: Union[int, float], decimals: int = 0, data: Any = None):
+    def transfer_assets(self, sender: Account, receiver: Account, asset: str | UInt160,
+                        quantity: int | float, decimals: int = 0, data: Any = None):
         if isinstance(asset, UInt160):
             asset = asset.__str__()
 
         self._instructions.append(neoxp.transfer(sender, receiver, asset,
                                                  quantity, decimals=decimals,
                                                  data=data)
                                   )
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-from typing import Dict, Optional
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.neoexpresscommand import NeoExpressCommand
 
 __all__ = ['BatchCommand']
 
 
 class BatchCommand(NeoExpressCommand):
     def __init__(self, file_name: str,
                  reset: bool = False,
-                 check_point_file: Optional[str] = None,
+                 check_point_file: str | None = None,
                  trace: bool = False,
                  neo_express_data_file: str = None):
 
         self.file_name = file_name
         self.reset = reset
         self.check_point_file = check_point_file
         self.trace = trace
         self.input = neo_express_data_file
 
         command_id = 'batch'
         super().__init__(command_id, [file_name])
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.reset or isinstance(self.check_point_file, str):
             flag = '--reset'
             if isinstance(self.check_point_file, str):
                 flag = f'{flag}:{self.check_point_file}'
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/create.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/create.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,25 @@
-from typing import Dict, Optional
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.checkpoint.icheckpointcommand import ICheckpointCommand
 
 
 class CheckpointCreateCommand(ICheckpointCommand):
-    def __init__(self, file_name: Optional[str] = None,
+    def __init__(self, file_name: str | None = None,
                  force: bool = False,
                  neo_express_data_file: str = None):
 
         self.file_name = file_name
         self.force = force
         self.input = neo_express_data_file
 
         args = []
         if isinstance(file_name, str):
             args.append(file_name)
 
         super().__init__('create', args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.force:
             options['--force'] = ''
 
         return options
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/restore.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/restore.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,25 @@
-from typing import Dict, Optional
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.checkpoint.icheckpointcommand import ICheckpointCommand
 
 
 class CheckpointRestoreCommand(ICheckpointCommand):
-    def __init__(self, file_name: Optional[str] = None,
+    def __init__(self, file_name: str | None = None,
                  force: bool = False,
                  neo_express_data_file: str = None):
 
         self.file_name = file_name
         self.force = force
         self.input = neo_express_data_file
 
         args = []
         if isinstance(file_name, str):
             args.append(file_name)
 
         super().__init__('restore', args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.force:
             options['--force'] = ''
 
         return options
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/deploy.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/deploy.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import json
-from typing import Any, Dict
+from typing import Any
 
 from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.contract.icontractcommand import IContractCommand
 
 
 class ContractDeployCommand(IContractCommand):
@@ -26,15 +26,15 @@
         self.input = neo_express_data_file
         self.trace = trace
         self.force = force
         self.json_output = json_output
 
         super().__init__('deploy', [contract_nef, account.get_identifier()])
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if isinstance(self.witness_scope, WitnessScope):
             options['--witness-scope'] = self.witness_scope.name
         if self.data is not None:
             options['--data'] = json.dumps(self.data)
         if isinstance(self.password, str):
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/invoke.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/invoke.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Dict
-
 from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command import utils
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.contract.icontractcommand import IContractCommand
 
 
 class ContractInvokeCommand(IContractCommand):
@@ -26,15 +24,15 @@
         self.additional_gas = additional_gas if additional_gas > 0 else 0
         self.input = neo_express_data_file
         self.trace = trace
         self.json_output = json_output
 
         super().__init__('invoke', [invoke_file, account.get_identifier()])
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if isinstance(self.witness_scope, WitnessScope):
             options['--witness-scope'] = self.witness_scope.name
         if self.results:
             options['--results'] = ''
         if self.additional_gas > 0:
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/list.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/list.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from typing import Dict
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.contract.icontractcommand import IContractCommand
 
 
 class ContractListCommand(IContractCommand):
     def __init__(self, json_output: bool = False,
                  neo_express_data_file: str = None):
 
         self.input = neo_express_data_file
         self.json_output = json_output
 
         super().__init__('list')
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.json_output:
             options['--json'] = ''
 
         return options
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/run.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/run.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-from typing import Any, Dict, Union
+from typing import Any
 
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command import utils
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.contract.icontractcommand import IContractCommand
 
 
 class ContractRunCommand(IContractCommand):
-    def __init__(self, contract: Union[str, UInt160], method: str, *args: Any,
+    def __init__(self, contract: str | UInt160, method: str, *args: Any,
                  account: Account = None,
                  witness_scope: WitnessScope = WitnessScope.CalledByEntry,
                  results_only: bool = False,
                  additional_gas: int = 0,
                  wallet_password: str = None,
                  trace: bool = False,
                  json_output: bool = False,
@@ -33,15 +33,15 @@
         self.json_output = json_output
 
         arguments = [str(contract), method]
         arguments.extend(args)
 
         super().__init__('run', arguments)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if isinstance(self.account, Account):
             options['--account'] = self.account.get_identifier()
         if isinstance(self.witness_scope, WitnessScope):
             options['--witness-scope'] = self.witness_scope.name
         if self.results:
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Dict, Optional
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.neoexpresscommand import NeoExpressCommand
 
 __all__ = ['CreateCommand']
 
 
 class CreateCommand(NeoExpressCommand):
-    def __init__(self, config_output: Optional[str] = None,
+    def __init__(self, config_output: str | None = None,
                  node_count: int = None,
                  address_version: int = None,
                  force: bool = False):
 
         if node_count not in [1, 4, 7]:  # allowed values for node count
             node_count = None
 
@@ -22,15 +20,15 @@
         command_id = 'create'
         args = []
         if isinstance(config_output, str):
             args.append(config_output)
 
         super().__init__(command_id, args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if isinstance(self.address_version, int):
             options['--count'] = str(self.address_version)
         if isinstance(self.address_version, int):
             options['--address-version'] = str(self.address_version)
         if self.force:
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Dict
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.neoexpresscommand import NeoExpressCommand
 
 __all__ = ['FastForwardCommand']
 
 
 class FastForwardCommand(NeoExpressCommand):
     def __init__(self, block_count: int = 0,
@@ -17,14 +15,14 @@
         command_id = 'fastfwd'
         args = []
         if isinstance(block_count, int):
             args.append(str(block_count))
 
         super().__init__(command_id, args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.timestamp_delta > 0:
             options['--timestamp-delta'] = str(self.timestamp_delta)
 
         return options
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/neoexpresscommand.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/neoexpresscommand.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 import abc
-from typing import Dict, List
 
 
 class NeoExpressCommand:
-    def __init__(self, command_id: str, args: List[str] = None, options: Dict[str, str] = None):
+    def __init__(self, command_id: str, args: list[str] = None, options: dict[str, str] = None):
         if not isinstance(args, list):
             args = []
 
         if not isinstance(options, dict):
             options = self._get_options()
 
         self._command_id = command_id
         self._args = args
         self._options = options
 
     @abc.abstractmethod
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         import os.path
         options = {}
 
         if hasattr(self, 'input') and isinstance(self.input, str) and os.path.isfile(self.input):
             options['--input'] = self.input
 
         return options
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/enable.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/enable.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Dict
-
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.oracle.ioraclecommand import IOracleCommand
 
 
 class OracleEnableCommand(IOracleCommand):
     def __init__(self, account: Account,
                  trace: bool = False,
@@ -15,14 +13,14 @@
         command_id = 'enable'
         args = [
             account.get_identifier(),
         ]
 
         super().__init__(command_id, args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.trace:
             options['--trace'] = ''
 
         return options
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/response.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/oracle/response.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,13 @@
-from typing import Dict, Optional
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.oracle.ioraclecommand import IOracleCommand
 
 
 class OracleResponseCommand(IOracleCommand):
     def __init__(self, url: str, response_path: str,
-                 request_id: Optional[int] = None,
+                 request_id: int | None = None,
                  trace: bool = False,
                  neo_express_data_file: str = None):
 
         self.request_id = request_id
         self.trace = trace
         self.input = neo_express_data_file
 
@@ -17,15 +15,15 @@
         args = [
             url,
             response_path,
         ]
 
         super().__init__(command_id, args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.request_id:
             options[f'--request_id:{self.request_id}'] = ''
 
         if self.trace:
             options['--trace'] = ''
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import Dict, Optional
-
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.neoexpresscommand import NeoExpressCommand
 
 __all__ = ['ResetCommand']
 
 
 class ResetCommand(NeoExpressCommand):
-    def __init__(self, node_index: Optional[int] = None,
+    def __init__(self, node_index: int | None = None,
                  force: bool = False,
                  reset_all: bool = False,
                  neo_express_data_file: str = None):
 
         self.node_index = node_index
         self.force = force
         self.reset_all = reset_all
@@ -19,15 +17,15 @@
         command_id = 'reset'
         args = []
         if isinstance(node_index, int):
             args.append(str(node_index))
 
         super().__init__(command_id, args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.force:
             options['--force'] = ''
         if self.reset_all:
             options['--all'] = ''
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/block.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/block.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,13 @@
-from typing import Dict, Union
-
 from boa3_test.test_drive.neoxp.command import utils
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.show.ishowcommand import IShowCommand
 
 
 class ShowBlockCommand(IShowCommand):
-    def __init__(self, block_hash_or_index: Union[bytes, str, int] = None,
+    def __init__(self, block_hash_or_index: bytes | str | int = None,
                  neo_express_data_file: str = None):
 
         if isinstance(block_hash_or_index, int) and block_hash_or_index < 0:
             block_hash_or_index = 0
 
         if isinstance(block_hash_or_index, bytes):
             block_hash_or_index = utils.to_hex_str(block_hash_or_index)
@@ -22,9 +20,9 @@
             hash_or_index = None
 
         self.block_hash_or_index = hash_or_index
         self.input = neo_express_data_file
 
         super().__init__('block', arguments)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         return super()._get_options()
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/transaction.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/transaction.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from typing import Dict, Union
-
 from boa3_test.test_drive.neoxp.command import utils
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.show.ishowcommand import IShowCommand
 
 
 class ShowTransactionCommand(IShowCommand):
-    def __init__(self, transaction_hash: Union[bytes, str],
+    def __init__(self, transaction_hash: bytes | str,
                  neo_express_data_file: str = None):
 
         if isinstance(transaction_hash, bytes):
             transaction_hash = utils.to_hex_str(transaction_hash)
 
         self.transaction_hash = transaction_hash
         self.input = neo_express_data_file
 
         super().__init__('transaction', [transaction_hash])
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         return super()._get_options()
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import json
-from typing import Dict, Any
+from typing import Any
 
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command import utils
 from boa3_test.test_drive.neoxp.command.neoexpresscommand.neoexpresscommand import NeoExpressCommand
 
 __all__ = ['TransferAssetCommand']
 
@@ -33,15 +33,15 @@
             token_symbol,
             sender.get_identifier(),
             receiver.get_identifier(),
         ]
 
         super().__init__(command_id, args)
 
-    def _get_options(self) -> Dict[str, str]:
+    def _get_options(self) -> dict[str, str]:
         options = super()._get_options()
 
         if self.data is not None:
             options['--data'] = json.dumps(self.data)
         if self.trace:
             options['--trace'] = ''
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoxp.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoxp.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Any, Union
+from typing import Any
 
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command import neoexpresscommand as neoxp
 from boa3_test.test_drive.neoxp.command import neoxp_contract as contract
 from boa3_test.test_drive.neoxp.command import neoxp_oracle as oracle
 from boa3_test.test_drive.neoxp.command.neoexpresscommand import NeoExpressCommand
 
@@ -19,13 +19,13 @@
     if not isinstance(block_count, int) or block_count < 1:
         block_count = 1
 
     return neoxp.fastforward.FastForwardCommand(block_count, time_interval_in_secs)
 
 
 def transfer(sender: Account, receiver: Account, asset: str,
-             quantity: Union[int, float], decimals: int = 0,
+             quantity: int | float, decimals: int = 0,
              data: Any = None) -> NeoExpressCommand:
 
     return neoxp.transfer.TransferAssetCommand(asset, sender, receiver, quantity,
                                                decimals=decimals,
                                                data=data)
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoxp_contract.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoxp_contract.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/neoxp_oracle.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/neoxp_oracle.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/command/utils/__init__.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/command/utils/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from typing import Union
-
 from boa3.internal import constants as __boa_constants
 from boa3.internal.neo import to_hex_str
 
 GAS_DECIMALS = __boa_constants.GAS_DECIMALS
 NEO_DECIMALS = __boa_constants.NEO_DECIMALS
 DEFAULT_ACCOUNT_VERSION = 53
 
 
-def stringify_asset_quantity(quantity: Union[int, float], decimals: int) -> str:
+def stringify_asset_quantity(quantity: int | float, decimals: int) -> str:
     if decimals < 0:
         decimals = 0
 
     quantity_format = f'.{decimals}f'
     formatted_quantity = f'{quantity:{quantity_format}}'  # format to fix decimals
     if decimals > 0:
         formatted_quantity = (
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/executor.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/executor.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,30 +3,29 @@
     '_NEOXP_CONFIG_LOCK'
 ]
 
 import os.path
 import re
 import subprocess
 import threading
-from typing import Tuple, List, Union
 
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.neoxp.command import neoexpresscommand as neoxp
 from boa3_test.test_drive.neoxp.model.neoxpconfig import NeoExpressConfig
 from boa3_test.test_drive.testrunner.blockchain.block import TestRunnerBlock as Block
 from boa3_test.test_drive.testrunner.blockchain.contract import TestRunnerContract as Contract
 from boa3_test.test_drive.testrunner.blockchain.transaction import TestRunnerTransaction as Transaction
 from boa3_test.test_drive.testrunner.blockchain.transactionlog import TestRunnerTransactionLog as TransactionLog
 
 _NEOXP_CONFIG_LOCK = threading.Lock()
 
 
 class NeoExpressWrapper:
     @classmethod
-    def run_neo_express_cli(cls, command: neoxp.NeoExpressCommand) -> Tuple[str, str]:
+    def run_neo_express_cli(cls, command: neoxp.NeoExpressCommand) -> tuple[str, str]:
         neoxp_args = ['neoxp']
         neoxp_args.extend(command.cli_command().split())
 
         cli_result = cls._run_cli(*neoxp_args)
         return cli_result
 
     @classmethod
@@ -60,15 +59,15 @@
         else:
             command = neoxp.reset.ResetCommand(neo_express_data_file=neoxp_path,
                                                force=True)
         stdout, stderr = cls.run_neo_express_cli(command)
         return stdout
 
     @classmethod
-    def get_deployed_contracts(cls, neoxp_path: str, check_point_file: str = None) -> List[Contract]:
+    def get_deployed_contracts(cls, neoxp_path: str, check_point_file: str = None) -> list[Contract]:
         command = neoxp.contract.ContractListCommand(neo_express_data_file=neoxp_path)
         with _NEOXP_CONFIG_LOCK:
             cls.reset_neo_express_instance(neoxp_path, check_point_file)
             stdout, stderr = cls.run_neo_express_cli(command)
 
         contracts = []
         for line in stdout.splitlines():
@@ -123,15 +122,15 @@
         return tx_log
 
     @classmethod
     def get_latest_block(cls, neoxp_path: str, check_point_file: str = None) -> Block:
         return cls.get_block(neoxp_path, check_point_file=check_point_file)
 
     @classmethod
-    def get_block(cls, neoxp_path: str, block_hash_or_index: Union[UInt256, int] = None,
+    def get_block(cls, neoxp_path: str, block_hash_or_index: UInt256 | int = None,
                   check_point_file: str = None) -> Block:
         if isinstance(block_hash_or_index, (UInt256, int)):
             if isinstance(block_hash_or_index, int):
                 if block_hash_or_index < 0:
                     block_hash_or_index = 0
             else:
                 block_hash_or_index = block_hash_or_index.to_array()
@@ -167,15 +166,15 @@
         with _NEOXP_CONFIG_LOCK:
             stdout, stderr = cls.run_neo_express_cli(command)
 
         return stdout
 
     @classmethod
     def oracle_response(cls, neoxp_path: str, url: str, response_path: str, request_id: int = None,
-                        check_point_file: str = None) -> List[UInt256]:
+                        check_point_file: str = None) -> list[UInt256]:
         command = neoxp.oracle.OracleResponseCommand(url, response_path, request_id, neo_express_data_file=neoxp_path)
 
         with _NEOXP_CONFIG_LOCK:
             if isinstance(check_point_file, str):
                 cls.reset_neo_express_instance(neoxp_path, check_point_file)
             stdout, stderr = cls.run_neo_express_cli(command)
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/model/neoxpaccount.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/model/neoxpaccount.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Dict, Any, Optional
+from typing import Any, Self
 
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.wallet import utils
 from boa3_test.test_drive.model.wallet.account import Account
 
 
 class NeoExpressAccount(Account):
@@ -10,17 +10,19 @@
                  account_version: int = 53,  # default Neo account version
                  name: str = None,
                  label: str = None):
 
         super().__init__(script_hash, account_version, name=name, label=label)
 
     @property
-    def address(self) -> Optional[str]:
+    def address(self) -> str | None:
         return utils.address_from_script_hash(self._script_hash.to_array(), self._version)
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> Account:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         address = json['script-hash']
         label = json['label']
-        account = NeoExpressAccount(script_hash=UInt160(utils.address_to_script_hash(address)),
-                                    label=label)
+        account = NeoExpressAccount(
+            script_hash=UInt160(utils.address_to_script_hash(address)),
+            label=label
+        )
         return account
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/model/neoxpconfig.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/model/neoxpconfig.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,9 @@
 import json
 import os.path
-from typing import List
 
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.command import utils
 from boa3_test.test_drive.neoxp.model.neoxpaccount import NeoExpressAccount
 
 _VERSION = utils.DEFAULT_ACCOUNT_VERSION  # default Neo account version
 
@@ -70,15 +69,15 @@
         return self._genesis_block
 
     @property
     def config_path(self):
         return self._neo_express_config_path
 
 
-def _wallet_accounts_from_json(wallet_json: dict) -> List[Account]:
+def _wallet_accounts_from_json(wallet_json: dict) -> list[Account]:
     wallet_accounts = []
     name = wallet_json['name']
     default_was_set = False
 
     for json_account in wallet_json['accounts']:
         account = NeoExpressAccount.from_json(json_account)
         if not isinstance(account, Account):
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/neoxp/utils.py` & `neo3_boa-1.2.0/boa3_test/test_drive/neoxp/utils.py`

 * *Files 9% similar despite different names*

```diff
@@ -19,16 +19,14 @@
     'Block',
     'Contract',
     'NeoExpressConfig',
     'Transaction',
     'TransactionLog'
 ]
 
-from typing import List, Union
-
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.model.wallet import utils as wallet_utils
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp.executor import NeoExpressWrapper
 from boa3_test.test_drive.neoxp.model.neoxpconfig import NeoExpressConfig
 from boa3_test.test_drive.testrunner.blockchain.block import TestRunnerBlock as Block
 from boa3_test.test_drive.testrunner.blockchain.contract import TestRunnerContract as Contract
@@ -60,15 +58,15 @@
     return neoxp_config.default_account
 
 
 def get_genesis_block(neoxp_config: NeoExpressConfig) -> Block:
     return neoxp_config.genesis_block
 
 
-def get_account_from_script_hash_or_id(neoxp_config: NeoExpressConfig, script_hash_or_address: Union[bytes, str]) -> Account:
+def get_account_from_script_hash_or_id(neoxp_config: NeoExpressConfig, script_hash_or_address: bytes | str) -> Account:
     if isinstance(script_hash_or_address, bytes):
         script_hash = script_hash_or_address
         address = wallet_utils.address_from_script_hash(script_hash, neoxp_config.version)
         account = get_account_by_address(neoxp_config, address)
     elif isinstance(script_hash_or_address, str):
         account = get_account_by_identifier(neoxp_config, script_hash_or_address)
         script_hash = wallet_utils.address_to_script_hash(script_hash_or_address, neoxp_config.version)
@@ -87,15 +85,15 @@
     return NeoExpressWrapper.create_neo_express_instance(neoxp_path)
 
 
 def reset_neo_express_instance(neoxp_path: str, check_point_file: str = None) -> str:
     return NeoExpressWrapper.reset_neo_express_instance(neoxp_path, check_point_file)
 
 
-def get_deployed_contracts(neoxp_path: str, check_point_file: str = None) -> List[Contract]:
+def get_deployed_contracts(neoxp_path: str, check_point_file: str = None) -> list[Contract]:
     return NeoExpressWrapper.get_deployed_contracts(neoxp_path, check_point_file)
 
 
 def get_transaction(neoxp_path: str, tx_hash: UInt256, check_point_file: str = None) -> Transaction:
     return NeoExpressWrapper.get_transaction(neoxp_path, tx_hash, check_point_file)
 
 
@@ -103,19 +101,19 @@
     return NeoExpressWrapper.get_transaction_log(neoxp_path, tx_hash, check_point_file, contract_collection)
 
 
 def get_latest_block(neoxp_path: str, check_point_file: str = None) -> Block:
     return NeoExpressWrapper.get_latest_block(neoxp_path, check_point_file)
 
 
-def get_block(neoxp_path: str, block_hash_or_index: Union[UInt256, int] = None,
+def get_block(neoxp_path: str, block_hash_or_index: UInt256 | int = None,
               check_point_file: str = None) -> Block:
     return NeoExpressWrapper.get_block(neoxp_path, block_hash_or_index, check_point_file)
 
 
 def run_batch(neoxp_path: str, batch_path: str, reset: bool = False, check_point_file: str = None) -> str:
     return NeoExpressWrapper.run_batch(neoxp_path, batch_path, reset, check_point_file)
 
 
 def oracle_response(neoxp_path: str, url: str, response_path: str, request_id: int = None,
-                    check_point_file: str = None) -> List[UInt256]:
+                    check_point_file: str = None) -> list[UInt256]:
     return NeoExpressWrapper.oracle_response(neoxp_path, url, response_path, request_id, check_point_file)
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/block.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/block.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,32 +1,30 @@
-from __future__ import annotations
-
-from typing import List, Dict, Any
+from typing import Any, Self
 
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.model.network.payloads.testblock import TestBlock
 from boa3_test.test_drive.model.network.payloads.witness import Witness
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp import utils
 from boa3_test.test_drive.testrunner.blockchain.transaction import TestRunnerTransaction
 
 
 class TestRunnerBlock(TestBlock):
     def __init__(self):
-        self._transactions: List[TestRunnerTransaction] = []
+        self._transactions: list[TestRunnerTransaction] = []
         super().__init__()
         self._hash: UInt256 = UInt256.zero()
         self._size = 0
         self._version = 0
         self._previous_block_hash = UInt256.zero()
         self._merkle_root = UInt256.zero()
         self._nonce = 0
         self._primary_index = 0
         self._next_consensus: Account = None
-        self._witnesses: List[Witness] = []
+        self._witnesses: list[Witness] = []
 
     @property
     def hash(self) -> UInt256:
         return self._hash
 
     @property
     def size(self) -> int:
@@ -53,35 +51,35 @@
         return self._primary_index
 
     @property
     def next_consensus(self) -> Account:
         return self._next_consensus
 
     @property
-    def witnesses(self) -> List[Witness]:
+    def witnesses(self) -> list[Witness]:
         return self._witnesses.copy()
 
     @property
-    def transactions(self) -> List[TestRunnerTransaction]:
+    def transactions(self) -> list[TestRunnerTransaction]:
         return self._transactions.copy()
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         json_block = super().to_json()
 
         # timestamp in this implementation is exported as time
         time = json_block.pop('timestamp')
         json_block['time'] = time
 
         return json_block
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], *args, **kwargs) -> TestRunnerBlock:
+    def from_json(cls, json: dict[str, Any], *args, **kwargs) -> Self:
         from boa3.internal.neo import from_hex_str
 
-        block: TestRunnerBlock = super().from_json(json)
+        block: Self = super().from_json(json)
 
         if 'neoxp_config' in kwargs:
             neoxp_config = kwargs['neoxp_config']
         elif len(args) > 0:
             neoxp_config = args[0]
         else:
             neoxp_config = None
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/contract.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/contract.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from typing import Optional
-
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 
 
 class TestRunnerContract(TestContract):
     def __init__(self, contract_name: str, contract_hex_hash: str):
         self._name: str = contract_name
@@ -20,15 +18,15 @@
     def path(self) -> str:
         return super().path
 
     @path.setter
     def path(self, value: str):
         self._nef_path = value
 
-    def _get_script_hash(self) -> Optional[bytes]:
+    def _get_script_hash(self) -> bytes | None:
         try:
             return UInt160.from_string(self._contract_hash[2:]
                                        if self._contract_hash.startswith('0x')
                                        else self._contract_hash
                                        ).to_array()
         except BaseException:
             return None
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/log.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/log.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.neo import to_hex_str
 from boa3.internal.neo3.core.types import UInt160
 
 
 class TestRunnerLog:
     _contract_key = 'contract'
@@ -19,15 +17,15 @@
         return self._script_hash
 
     @property
     def message(self) -> str:
         return self._message
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> TestRunnerLog:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         """
         Creates a Log object from a json.
 
         :param json: json that contains the log data
         :return: a Log object
         :rtype: TestRunnerLog
         """
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/notification.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/notification.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Dict, Any
+from typing import Any, Self
 
 from boa3.internal.neo.smart_contract.notification import Notification
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.smart_contract.contractcollection import ContractCollection
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 
 
@@ -15,16 +15,21 @@
         self._contract = None
 
     @property
     def contract(self) -> TestContract:
         return self._contract
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], contract_collection: ContractCollection = None,
-                  *args, **kwargs) -> Notification:
+    def from_json(
+            cls,
+            json: dict[str, Any],
+            contract_collection: ContractCollection = None,
+            *args,
+            **kwargs
+    ) -> Self:
 
         result = super().from_json(json)
         if result is None:
             return result
 
         if isinstance(contract_collection, ContractCollection) and result.origin in contract_collection:
             result._contract = contract_collection[result.origin]
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/storage.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/storage.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,88 +1,22 @@
-from __future__ import annotations
-
 import base64
-from typing import Any, Dict, Optional
+from typing import Any, Self
 
 from boa3.internal.neo.vm.type.Integer import Integer
 from boa3.internal.neo.vm.type.String import String
 from boa3_test.test_drive.model.smart_contract.contractcollection import ContractCollection
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 
 
-class TestRunnerStorage:
-    _storage_contract_name_key = 'name'
-    _storage_contract_hash_key = 'hash'
-    _storage_contract_values_key = 'values'
-    _storage_key_key = 'key'
-    _storage_item_key = 'value'
-
-    def __init__(self, contract: TestContract, values: Dict[StorageKey, StorageItem]):
-        self._contract: TestContract = contract
-        self._values: Dict[StorageKey, StorageItem] = values
-
-    @property
-    def contract(self) -> Optional[TestContract]:
-        if isinstance(self._contract, TestContract):
-            return self._contract
-        return None
-
-    @property
-    def values(self) -> Dict[StorageKey, StorageItem]:
-        return self._values
-
-    @classmethod
-    def from_json(cls, json: Dict[str, Any], contracts: ContractCollection = None) -> TestRunnerStorage:
-        keys = set(json.keys())
-        if not keys.issubset([cls._storage_contract_name_key,
-                              cls._storage_contract_hash_key,
-                              cls._storage_contract_values_key]):
-            return None
-
-        contract_name = json[cls._storage_contract_name_key]
-        contract_hash = json[cls._storage_contract_hash_key]
-        if contract_name in contracts:
-            contract = contracts[contract_name]
-        elif contract_hash in contracts:
-            contract = contracts[contract_hash]
-        else:
-            contract = None
-
-        storage = {}
-        storage_required_fields = [cls._storage_key_key, cls._storage_item_key]
-        for item_json in json[cls._storage_contract_values_key]:
-            if not set(item_json.keys()).issubset(storage_required_fields):
-                continue
-
-            key = StorageKey.from_json(item_json[cls._storage_key_key])
-            item = StorageItem.from_json(item_json[cls._storage_item_key])
-
-            storage[key] = item
-
-        return cls(contract, storage)
-
-    def is_valid_identifier(self, item: str) -> bool:
-        if isinstance(self._contract, TestContract):
-            return self._contract.is_valid_identifier(item)
-
-        return False
-
-    def __str__(self) -> str:
-        return str(self._values)
-
-    def __repr__(self) -> str:
-        return self._values.__repr__()
-
-
 class StorageKey:
     def __init__(self, key: bytes):
         self._key: bytes = key
 
     @classmethod
-    def from_json(cls, json: str) -> StorageKey:
+    def from_json(cls, json: str) -> Self:
         decoded: bytes = base64.b64decode(json)
         return cls(decoded)
 
     def as_str(self) -> str:
         return String.from_bytes(self._key)
 
     def as_bytes(self) -> bytes:
@@ -104,15 +38,15 @@
 
 
 class StorageItem:
     def __init__(self, value: bytes):
         self._value: bytes = value
 
     @classmethod
-    def from_json(cls, json: str) -> StorageItem:
+    def from_json(cls, json: str) -> Self:
         decoded: bytes = base64.b64decode(json)
         return cls(decoded)
 
     def as_bytes(self) -> bytes:
         return self._value
 
     def as_str(self) -> str:
@@ -131,7 +65,71 @@
         return self._value.__hash__()
 
     def __eq__(self, other) -> bool:
         return (other == self.as_bytes()
                 or other == self.as_int()
                 or other == self.as_str()
                 or (isinstance(other, StorageItem) and self._value == other._value))
+
+
+class TestRunnerStorage:
+    _storage_contract_name_key = 'name'
+    _storage_contract_hash_key = 'hash'
+    _storage_contract_values_key = 'values'
+    _storage_key_key = 'key'
+    _storage_item_key = 'value'
+
+    def __init__(self, contract: TestContract, values: dict[StorageKey, StorageItem]):
+        self._contract: TestContract = contract
+        self._values: dict[StorageKey, StorageItem] = values
+
+    @property
+    def contract(self) -> TestContract | None:
+        if isinstance(self._contract, TestContract):
+            return self._contract
+        return None
+
+    @property
+    def values(self) -> dict[StorageKey, StorageItem]:
+        return self._values
+
+    @classmethod
+    def from_json(cls, json: dict[str, Any], contracts: ContractCollection = None) -> Self:
+        keys = set(json.keys())
+        if not keys.issubset([cls._storage_contract_name_key,
+                              cls._storage_contract_hash_key,
+                              cls._storage_contract_values_key]):
+            return None
+
+        contract_name = json[cls._storage_contract_name_key]
+        contract_hash = json[cls._storage_contract_hash_key]
+        if contract_name in contracts:
+            contract = contracts[contract_name]
+        elif contract_hash in contracts:
+            contract = contracts[contract_hash]
+        else:
+            contract = None
+
+        storage = {}
+        storage_required_fields = [cls._storage_key_key, cls._storage_item_key]
+        for item_json in json[cls._storage_contract_values_key]:
+            if not set(item_json.keys()).issubset(storage_required_fields):
+                continue
+
+            key = StorageKey.from_json(item_json[cls._storage_key_key])
+            item = StorageItem.from_json(item_json[cls._storage_item_key])
+
+            storage[key] = item
+
+        return cls(contract, storage)
+
+    def is_valid_identifier(self, item: str) -> bool:
+        if isinstance(self._contract, TestContract):
+            return self._contract.is_valid_identifier(item)
+
+        return False
+
+    def __str__(self) -> str:
+        return str(self._values)
+
+    def __repr__(self) -> str:
+        return self._values.__repr__()
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/storagecollection.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/storagecollection.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-from typing import List, Union
-
 from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
 from boa3_test.test_drive.testrunner.blockchain.storage import TestRunnerStorage, StorageKey
 
 
 class StorageCollection:
     def __init__(self):
-        self._internal_list: List[TestRunnerStorage] = []
-        self._storage_contracts: List[TestContract] = []
+        self._internal_list: list[TestRunnerStorage] = []
+        self._storage_contracts: list[TestContract] = []
 
     def append(self, new_storage: TestRunnerStorage):
         self._storage_contracts.append(new_storage.contract)
         return self._internal_list.append(new_storage)
 
     def remove(self, storage: TestRunnerStorage):
         try:
             index = self._internal_list.index(storage)
             self._storage_contracts.pop(index)
             self._internal_list.pop(index)
         except BaseException as e:
             raise e  # try except just to ensure that the value will be removed from both lists
 
-    def get(self, storage_contract: TestContract, key: Union[bytes, str]):
+    def get(self, storage_contract: TestContract, key: bytes | str):
         if isinstance(key, str):
             try:
                 key = bytes(key)
             except TypeError:
                 from boa3.internal import constants
                 key = key.encode(encoding=constants.ENCODING)
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/transaction.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/transaction.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from __future__ import annotations
-
-from typing import List, Dict, Any, Union
+from typing import Any, Self
 
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.model.network.payloads.signer import Signer
 from boa3_test.test_drive.model.network.payloads.testtransaction import TestTransaction
 from boa3_test.test_drive.model.network.payloads.witness import Witness
 from boa3_test.test_drive.model.wallet.account import Account
 from boa3_test.test_drive.neoxp import utils
 
 
 class TestRunnerTransaction(TestTransaction):
-    def __init__(self, tx_hash: Union[UInt256, bytes], script: bytes, sender: Account):
+    def __init__(self, tx_hash: UInt256 | bytes, script: bytes, sender: Account):
         super().__init__(tx_hash, script)
         self._size = 0
         self._version = 0
         self._nonce = 0
         self._sender = sender
         self._system_fee = 0
         self._network_fee = 0
@@ -50,28 +48,28 @@
         return self._network_fee
 
     @property
     def valid_until_block(self) -> int:
         return self._valid_until_block
 
     @property
-    def signers(self) -> List[Signer]:
+    def signers(self) -> list[Signer]:
         return self._signers.copy()
 
     @property
     def attributes(self) -> list:
         return self._attributes.copy()
 
     @property
-    def witnesses(self) -> List[Witness]:
+    def witnesses(self) -> list[Witness]:
         return self._witnesses.copy()
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], *args, **kwargs) -> TestRunnerTransaction:
-        tx: TestRunnerTransaction = super().from_json(json)
+    def from_json(cls, json: dict[str, Any], *args, **kwargs) -> Self:
+        tx: Self = super().from_json(json)
 
         if 'neoxp_config' in kwargs:
             neoxp_config = kwargs['neoxp_config']
         elif len(args) > 0:
             neoxp_config = args[0]
         else:
             neoxp_config = None
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/blockchain/transactionlog.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/blockchain/transactionlog.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,25 +1,23 @@
-from __future__ import annotations
-
-from typing import List, Dict, Any
+from typing import Any, Self
 
 from boa3_test.test_drive.model.interface.itransactionobject import ITransactionObject
 from boa3_test.test_drive.model.network.payloads.testtransaction import TransactionExecution
 from boa3_test.test_drive.model.smart_contract.contractcollection import ContractCollection
 
 
 class TestRunnerTransactionLog(ITransactionObject):
     def __init__(self):
         super().__init__()
-        self._executions: List[TransactionExecution] = []
+        self._executions: list[TransactionExecution] = []
 
     @property
-    def executions(self) -> List[TransactionExecution]:
+    def executions(self) -> list[TransactionExecution]:
         return self._executions.copy()
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any], contract_collection: ContractCollection = None) -> TestRunnerTransactionLog:
+    def from_json(cls, json: dict[str, Any], contract_collection: ContractCollection = None) -> Self:
         tx_log = cls()
 
         tx_log._executions = [TransactionExecution.from_json(execution, contract_collection) for execution in json['executions']]
 
         return tx_log
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/neo_test_runner.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/neo_test_runner.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 __all__ = [
     'NeoTestRunner'
 ]
 
 import json
 import os.path
 import subprocess
-from typing import Any, Callable, List, Dict, Optional, Sequence, Tuple, Type, Union
+from collections.abc import Callable, Sequence
+from typing import Any
 
 from boa3.internal import constants
 from boa3.internal.neo import utils as neo_utils
 from boa3.internal.neo.vm.type.String import String
 from boa3.internal.neo3.core.types import UInt256
 from boa3.internal.neo3.vm import vmstate, VMState
 from boa3_test.test_drive.model.invoker.neobatchinvoke import NeoBatchInvoke
@@ -40,22 +41,22 @@
     _CHECKPOINT_FILE = f'{_FOLDER_NAME}.neoxp-checkpoint'
 
     _DEFAULT_ACCOUNT = None
 
     def __init__(self, neoxp_path: str, runner_id: str = None):
         self._vm_state: VMState = VMState.NONE
         self._gas_consumed: int = 0
-        self._result_stack: List[Any] = []
-        self._error_message: Optional[str] = None
-        self._last_cli_log: Optional[str] = None
+        self._result_stack: list[Any] = []
+        self._error_message: str | None = None
+        self._last_cli_log: str | None = None
         self._cli_log: str = ''
 
-        self._calling_account: Optional[Account] = None
-        self._notifications: List[Notification] = []
-        self._logs: List[Log] = []
+        self._calling_account: Account | None = None
+        self._notifications: list[Notification] = []
+        self._logs: list[Log] = []
         self._storages: StorageCollection = StorageCollection()
 
         self._neoxp_abs_path = os.path.abspath(neoxp_path)
         self._neoxp_config = self._set_up_neoxp_config()
 
         if isinstance(runner_id, str):
             self._file_name: str = None  # defined in the following line
@@ -65,15 +66,15 @@
 
         self._first_execution = True
 
         self._batch = NeoExpressBatch(self._neoxp_config)
         self._contracts = ContractCollection()
         self._invokes = NeoInvokeCollection()
         self._invokes_to_batch = 0
-        self._last_execution_results: List[NeoInvokeResult] = []
+        self._last_execution_results: list[NeoInvokeResult] = []
 
     @property
     def file_name(self) -> str:
         return self._file_name
 
     @file_name.setter
     def file_name(self, value: str):
@@ -96,33 +97,33 @@
         return self._vm_state
 
     @property
     def gas_consumed(self) -> int:
         return self._gas_consumed
 
     @property
-    def result_stack(self) -> List[Any]:
+    def result_stack(self) -> list[Any]:
         return self._result_stack.copy()
 
     @property
-    def error(self) -> Optional[str]:
+    def error(self) -> str | None:
         return self._error_message
 
     @property
     def cli_log(self) -> str:
         return self._cli_log
 
     @property
-    def notifications(self) -> List[Notification]:
+    def notifications(self) -> list[Notification]:
         return self._notifications.copy()
 
-    def get_events(self, event_name: str = None, origin: TestContract = None) -> List[Notification]:
+    def get_events(self, event_name: str = None, origin: TestContract = None) -> list[Notification]:
         return self._filter_events(self._notifications, event_name, origin)
 
-    def get_logs(self, origin: TestContract = None) -> List[Log]:
+    def get_logs(self, origin: TestContract = None) -> list[Log]:
         return self._filter_events(self._logs, origin=origin)
 
     def _filter_events(self, events: list, event_name: str = None, origin: TestContract = None) -> list:
         if origin is None and event_name is None:
             return events.copy()
         elif origin is None:
             return [n for n in events if n.name == event_name]
@@ -137,15 +138,15 @@
             if event_name is None:
                 return [n for n in events if n.origin == origin_bytes]
             else:
                 return [n for n in events if (n.name == event_name
                                               and n.origin == origin_bytes)]
 
     @property
-    def logs(self) -> List[Log]:
+    def logs(self) -> list[Log]:
         return self._logs.copy()
 
     @property
     def contracts(self) -> ContractCollection:
         return self._contracts
 
     @property
@@ -173,49 +174,49 @@
 
     def get_genesis_block(self) -> Block:
         return self.get_block(0)
 
     def get_latest_block(self) -> Block:
         return self.get_block(None)
 
-    def get_block(self, block_hash_or_index: Union[UInt256, bytes, int]) -> Optional[Block]:
+    def get_block(self, block_hash_or_index: UInt256 | bytes | int) -> Block | None:
         genesis = self._get_genesis_block()
         if isinstance(genesis, Block) and block_hash_or_index in (genesis.hash, genesis.index):
             # genesis block doesn't change between neo express resets
             return genesis
 
         block = self._get_block(block_hash_or_index)
         if not isinstance(genesis, Block) and isinstance(block, Block) and block.index == 0:
             self._set_genesis_block(block)  # optimization for consecutive executions
         return block
 
-    def _get_genesis_block(self) -> Optional[Block]:
+    def _get_genesis_block(self) -> Block | None:
         return neoxp_utils.get_genesis_block(self._neoxp_config)
 
-    def _get_block(self, block_hash_or_index) -> Optional[Block]:
+    def _get_block(self, block_hash_or_index) -> Block | None:
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return neoxp_utils.get_block(self._neoxp_abs_path, block_hash_or_index,
                                      check_point_file=check_point_path)
 
     def _set_genesis_block(self, genesis):
         if isinstance(genesis, Block):
             self._neoxp_config._genesis_block = genesis
 
-    def get_transaction(self, tx_hash: Union[UInt256, bytes]) -> Optional[Transaction]:
+    def get_transaction(self, tx_hash: UInt256 | bytes) -> Transaction | None:
         if isinstance(tx_hash, bytes):
             tx_hash = UInt256(tx_hash)
 
         return self._get_tx(tx_hash)
 
     def _get_tx(self, tx_hash: UInt256):
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return neoxp_utils.get_transaction(self._neoxp_abs_path, tx_hash,
                                            check_point_file=check_point_path)
 
-    def get_transaction_result(self, tx_hash: Union[UInt256, bytes]) -> Optional[TransactionLog]:
+    def get_transaction_result(self, tx_hash: UInt256 | bytes) -> TransactionLog | None:
         if isinstance(tx_hash, bytes):
             tx_hash = UInt256(tx_hash)
 
         return self._get_tx_log(tx_hash, contract_collection=self._contracts)
 
     def _get_tx_log(self, tx_hash: UInt256, contract_collection: ContractCollection):
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
@@ -235,26 +236,26 @@
                 raise ValueError('Contract with duplicated name')
             self._contracts.append(contract)
         else:
             contract = self._contracts[nef_path]
         return contract
 
     def call_contract(self, nef_path: str, method: str, *arguments: Any,
-                      expected_result_type: Type = None) -> NeoInvokeResult:
+                      expected_result_type: type = None) -> NeoInvokeResult:
         if nef_path not in self._contracts:
             contract = self.deploy_contract(nef_path)
         else:
             contract = self._contracts[nef_path]
 
         return self._invokes.append_contract_invoke(contract, method, *arguments,
                                                     expected_result_type=expected_result_type)
 
     def run_contract(self, nef_path: str, method: str, *arguments: Any,
                      account: Account = None, witness_scope: WitnessScope = WitnessScope.CalledByEntry,
-                     expected_result_type: Type = None) -> NeoBatchInvoke:
+                     expected_result_type: type = None) -> NeoBatchInvoke:
         if nef_path not in self._contracts:
             contract = self.deploy_contract(nef_path)
         else:
             contract = self._contracts[nef_path]
 
         if witness_scope != WitnessScope.CalledByEntry:
             # neo express only supports CalledByEntry and Global as witness scopes
@@ -263,15 +264,15 @@
         invoke = self._invokes.create_contract_invoke(contract, method, *arguments)
         if isinstance(account, Account):
             invoke._invoker = account
         return self._batch.run_contract(invoke,
                                         witness_scope=witness_scope,
                                         expected_result_type=expected_result_type)
 
-    def get_contract(self, contract_id: Union[str, bytes]) -> TestContract:
+    def get_contract(self, contract_id: str | bytes) -> TestContract:
         return self._contracts[contract_id]
 
     def update_contracts(self, export_checkpoint: bool = False):
         self._generate_root_folder()
         if export_checkpoint:
             self._create_checkpoint_from_batch()
         else:
@@ -291,15 +292,15 @@
                                   reset=True
                                   )
         self._update_cli_log(log)
 
         if batch_has_deploys:
             self._contracts.update_after_deploy()
 
-    def execute(self, account: Account = None, get_storage_from: Union[str, TestContract] = None,
+    def execute(self, account: Account = None, get_storage_from: str | TestContract = None,
                 clear_invokes: bool = True, add_invokes_to_batch: bool = False):
         self._generate_files()
         invoke_file_path = self.get_full_path(self._INVOKE_FILE)
         cli_args = ['neo-test-runner', invoke_file_path
                     ]
 
         checkpoint_file = self.get_full_path(self._CHECKPOINT_FILE)
@@ -361,15 +362,15 @@
         self._first_execution = True
 
         self._batch.clear()
         self._contracts.clear()
         self._invokes.clear()
         self._invokes_to_batch = 0
 
-    def _update_runner(self, result: Dict[str, Any]):
+    def _update_runner(self, result: dict[str, Any]):
         self.reset_state()
         self._error_message = result['exception'] if 'exception' in result else None
 
         self._last_cli_log = self._cli_log
         if 'state' in result:
             self._vm_state = vmstate.get_vm_state(result['state'])
 
@@ -431,15 +432,15 @@
         methods_to_call = [
             (self._create_checkpoint_from_batch, ()),
             (self._generate_invoke_file, ()),
         ]
 
         self._internal_generate_files(methods_to_call)
 
-    def _internal_generate_files(self, methods_to_call: List[Tuple[Callable, Sequence]]):
+    def _internal_generate_files(self, methods_to_call: list[tuple[Callable, Sequence]]):
         for method, args in methods_to_call:
             method(*args)
 
     def _create_checkpoint_from_batch(self):
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
 
         if not os.path.exists(check_point_path) or self._batch.cur_size() > 0:
@@ -453,29 +454,29 @@
         param_json = json.dumps(invoke_file_content, separators=(',', ':'))
         with open(self.get_full_path(self._INVOKE_FILE), 'wb+') as json_file:
             json_file.write(String(param_json).to_bytes())
 
     def get_full_path(self, file_name: str):
         return self._root + os.path.sep + file_name
 
-    def _run_command_line(self, args: List[str]) -> Tuple[str, str]:
+    def _run_command_line(self, args: list[str]) -> tuple[str, str]:
         process = subprocess.Popen(args,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT,
                                    text=True)
         return process.communicate()
 
     def increase_block(self, block_to_mint: int = None, time_interval_in_secs: int = 0):
         self._batch.mint_block(block_to_mint, time_interval_in_secs)
 
     def oracle_enable(self, account: Account):
         self._batch.oracle_enable(account)
 
-    def oracle_response(self, url: str, response_path: str, request_id: int = None) -> List[UInt256]:
+    def oracle_response(self, url: str, response_path: str, request_id: int = None) -> list[UInt256]:
         # add to command to batch file and get the tx id
         self._batch.oracle_response(url, response_path, request_id=request_id)
         return self._get_oracle_resp(url, response_path, request_id)
 
-    def _get_oracle_resp(self, url: str, response_path: str, request_id: int = None) -> List[UInt256]:
+    def _get_oracle_resp(self, url: str, response_path: str, request_id: int = None) -> list[UInt256]:
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return neoxp_utils.oracle_response(self._neoxp_abs_path, url, response_path, request_id,
                                            check_point_file=check_point_path)
```

### Comparing `neo3-boa-1.1.1/boa3_test/test_drive/testrunner/utils.py` & `neo3_boa-1.2.0/boa3_test/test_drive/testrunner/utils.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from typing import Any, Sequence
+from collections.abc import Sequence
+from typing import Any
 
 from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
 def value_to_parameter(value: Any) -> Any:
     if isinstance(value, (int, str)):
         return value
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/run_unit_tests.py` & `neo3_boa-1.2.0/boa3_test/tests/run_unit_tests.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 
     # The unit test should not be included in the neo3-boa package, so to not have an import problem, we are directly
     # adding the project root to the sys path, because the boa3_test unit test files are not in the package.
     project_root = os.path.abspath(f'{os.path.dirname(__file__)}/../..')
     sys.path.append(project_root)
 
     from boa3.internal import env
-    from boa3_test.tests import boa_test
+    from boa3_test.tests import boatestcase
     from boa3_test.tests.test_suite import *
     from boa3_test.test_drive import utils
 
     neo_express_dir = env.NEO_EXPRESS_INSTANCE_DIRECTORY
     env_test_runner_dir = env.TEST_RUNNER_DIRECTORY
 
     # avoids to have multiple applications accessing the same config file
@@ -27,36 +27,41 @@
         if not os.path.exists(neo_express_exec_dir):
             os.mkdir(neo_express_exec_dir)
 
         neo_express_exec_file = f'{neo_express_exec_dir}/default.neo-express'
         shutil.copy(f'{neo_express_dir}/default.neo-express', neo_express_exec_file)
         env.NEO_EXPRESS_INSTANCE_DIRECTORY = neo_express_exec_dir
         env.TEST_RUNNER_DIRECTORY = test_runner_dir
-        boa_test.USE_UNIQUE_NAME = True
+        boatestcase.USE_UNIQUE_NAME = True
 
         suite = AsyncTestSuite()
+        default_suite = unittest.TestSuite()
         discover_path = f'{env.PROJECT_ROOT_DIRECTORY}/boa3_test/'
         test_discover = unittest.loader.defaultTestLoader.discover(discover_path,
                                                                    top_level_dir=env.PROJECT_ROOT_DIRECTORY,
                                                                    )
 
         for test in list_of_tests_gen(test_discover):
-            suite.addTest(test)
+            if isinstance(test, boatestcase.SmartContractTestCase):
+                default_suite.addTest(test)
+            else:
+                suite.addTest(test)
 
-        print(f'Found {suite.countTestCases()} tests\n')
+        default_suite.addTest(suite)
+        print(f'Found {default_suite.countTestCases()} tests\n')
 
         test_result = unittest.TextTestRunner(verbosity=2,
                                               resultclass=CustomTestResult,
-                                              ).run(suite)
+                                              ).run(default_suite)
 
         sys.exit(not test_result.wasSuccessful())
     finally:
         # set environment variables back to their starting state
         env.NEO_EXPRESS_INSTANCE_DIRECTORY = neo_express_dir
         env.TEST_RUNNER_DIRECTORY = env_test_runner_dir
-        boa_test.USE_UNIQUE_NAME = False
+        boatestcase.USE_UNIQUE_NAME = False
         # clear test directories
         shutil.rmtree(neo_express_exec_dir)
         if len(os.listdir(test_runner_dir)) == 0:
             os.rmdir(test_runner_dir)
 
     sys.exit(0)
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/binaryserializer/__init__.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/binaryserializer/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/block.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/block.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,55 +1,53 @@
-from __future__ import annotations
-
-from typing import Any, Dict, List, Optional
+from typing import Any, Self
 
 from boa3_test.test_drive.model.network.payloads.testblock import TestBlock
 from boa3_test.tests.test_classes.transaction import Transaction
 
 
 class Block(TestBlock):
     def __init__(self, index: int):
-        self._transactions: List[Transaction] = []
+        self._transactions: list[Transaction] = []
         super().__init__()
 
         import time
         # time() returns timestamp in nanoseconds and Neo uses timestamp in milliseconds
         self._timestamp: int = int(time.time_ns() / 1_000_000)
         self._index: int = index
 
-    def get_transactions(self) -> List[Transaction]:
+    def get_transactions(self) -> list[Transaction]:
         """
         Gets a list of the block transactions. Changes in those transactions don't affect the ones inside the block.
 
         :return: the block transactions
-        :rtype: List[Transaction]
+        :rtype: list[Transaction]
         """
         return [tx.copy() for tx in self._transactions]
 
     def add_transaction(self, tx: Transaction):
         if all(block_tx != tx for block_tx in self._transactions):
             self._transactions.append(tx)
 
     @property
-    def hash(self) -> Optional[bytes]:
+    def hash(self) -> bytes | None:
         if self._hash is None:
             return None
         else:
             return self._hash.to_array()
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         json_block = super().to_json()
 
         if self._hash is not None:
             json_block['hash'] = str(self._hash)
 
         return json_block
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> Block:
-        block: Block = super().from_json(json)
+    def from_json(cls, json: dict[str, Any]) -> Self:
+        block: Self = super().from_json(json)
 
         # 'index' and 'timestamp' fields are required
         block._index = int(json['index'])
         block._timestamp = int(json['timestamp'])
 
         return block
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neoabistruct.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neomanifeststruct.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,33 +1,42 @@
-from __future__ import annotations
+from typing import Any, Self
 
-from typing import Any, Dict, List
-
-from boa3_test.tests.test_classes.contract.neoeventstruct import NeoEventStruct
-from boa3_test.tests.test_classes.contract.neomethodstruct import NeoMethodStruct
+from boa3_test.tests.test_classes.contract.neoabistruct import NeoAbiStruct
+from boa3_test.tests.test_classes.contract.neopermissionsstruct import NeoPermissionsStruct
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
-class NeoAbiStruct(NeoStruct):
-    _methods_field = 'methods'
-    _events_field = 'events'
+class NeoManifestStruct(NeoStruct):
+    _name_field = 'name'
+    _groups_field = 'groups'
+    _supported_standards_field = 'supportedstandards'
+    _abi_field = 'abi'
+    _permissions_field = 'permissions'
+    _trusts_field = 'trusts'
+    _features_field = 'features'
+    _extra_field = 'extra'
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> NeoAbiStruct:
-        required_fields = [cls._methods_field,
-                           cls._events_field
+    def from_json(cls, json: dict[str, Any]) -> Self:
+        required_fields = [cls._name_field,
+                           cls._groups_field,
+                           cls._supported_standards_field,
+                           cls._abi_field,
+                           cls._permissions_field,
+                           cls._trusts_field,
+                           cls._features_field,
+                           cls._extra_field
                            ]
         cls._validate_json(json, required_fields)
 
         struct = cls()
-        struct.append(cls._get_methods(json[cls._methods_field]))
-        struct.append(cls._get_events(json[cls._events_field]))
+        struct.append(json[cls._name_field])
+        struct.append(json[cls._groups_field])
+        struct.append({})  # features were not implemented on Neo yet
+        struct.append(json[cls._supported_standards_field])
+        struct.append(NeoAbiStruct.from_json(json[cls._abi_field]))
+        struct.append([NeoPermissionsStruct.from_json(permission) for permission in json[cls._permissions_field]])
+        struct.append(json[cls._trusts_field])
+        extras = json[cls._extra_field]
+        struct.append(extras if extras is not None else "null")
 
         return struct
-
-    @classmethod
-    def _get_methods(cls, json_list: List[Dict[str, Any]]) -> List[NeoMethodStruct]:
-        return [NeoMethodStruct.from_json(method_json) for method_json in json_list]
-
-    @classmethod
-    def _get_events(cls, json_list: List[Dict[str, Any]]) -> List[NeoEventStruct]:
-        return [NeoEventStruct.from_json(method_json) for method_json in json_list]
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neoeventstruct.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neoeventstruct.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
 class NeoEventStruct(NeoStruct):
     _name_field = 'name'
     _parameters_field = 'parameters'
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> NeoEventStruct:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         required_fields = [cls._name_field,
                            cls._parameters_field
                            ]
         cls._validate_json(json, required_fields)
 
         struct = cls()
         struct.append(json[cls._name_field])
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neomethodstruct.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neomethodstruct.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-from __future__ import annotations
-
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
 class NeoMethodStruct(NeoStruct):
     _name_field = 'name'
     _parameters_field = 'parameters'
     _return_type_field = 'returntype'
     _offset_field = 'offset'
     _is_safe_field = 'safe'
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> NeoMethodStruct:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         required_fields = [cls._name_field,
                            cls._parameters_field,
                            cls._return_type_field,
                            cls._offset_field,
                            cls._is_safe_field
                            ]
         cls._validate_json(json, required_fields)
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neopermissionsstruct.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neopermissionsstruct.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-from __future__ import annotations
-
-from typing import Any, Dict, Optional, Union
+from typing import Any, Self
 
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
 class NeoPermissionsStruct(NeoStruct):
     _contract_fields = 'contract'
     _methods_fields = 'methods'
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> NeoPermissionsStruct:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         required_fields = [cls._contract_fields,
                            cls._methods_fields
                            ]
         cls._validate_json(json, required_fields)
 
         struct = cls()
         struct.append(cls.get_contract(json[cls._contract_fields]))
@@ -25,22 +23,22 @@
     @classmethod
     def _is_wildcard(cls, value: Any) -> bool:
         if value is None:
             return True
         return value == '*'
 
     @classmethod
-    def get_contract(cls, value: Any) -> Optional[Union[UInt160, bytes]]:
+    def get_contract(cls, value: Any) -> UInt160 | bytes | None:
         if cls._is_wildcard(value):
             return None
 
         if isinstance(value, str):
             if len(value) == 40 or len(value) == 42:
                 return UInt160.from_string(value)
             return bytes.fromhex(value)
 
     @classmethod
-    def get_methods(cls, value: Any) -> Optional[list]:
+    def get_methods(cls, value: Any) -> list | None:
         if cls._is_wildcard(value):
             return None
         else:
             return [method for method in value]
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/contract/neostruct.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/contract/neostruct.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,28 +1,26 @@
-from __future__ import annotations
-
 from abc import ABC, abstractmethod
-from typing import Any, Dict, List
+from typing import Any, Self
 
 
 class NeoStruct(list, ABC):
 
     @classmethod
     @abstractmethod
-    def from_json(cls, json: Dict[str, Any]) -> NeoStruct:
+    def from_json(cls, json: dict[str, Any]) -> Self:
         pass
 
     @classmethod
-    def _validate_json(cls, json: Dict[str, Any], required_fields: List[str]):
+    def _validate_json(cls, json: dict[str, Any], required_fields: list[str]):
         required = set(required_fields)
         if not required.issubset(json.keys()):
             raise ValueError
 
     @classmethod
-    def _get_param_info(cls, json: Dict[str, Any]) -> list:
+    def _get_param_info(cls, json: dict[str, Any]) -> list:
         _name = 'name'
         _type = 'type'
 
         required_fields = [_name, _type]
         cls._validate_json(json, required_fields)
 
         name = json[_name]
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/contractcollection.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/contractcollection.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-from typing import List
-
 from boa3.internal import constants
 from boa3_test.tests.test_classes.testcontract import TestContract
 
 
 class ContractCollection:
     def __init__(self):
-        self._internal_list: List[TestContract] = []
+        self._internal_list: list[TestContract] = []
 
     def append(self, new_contract: TestContract):
         return self._internal_list.append(new_contract)
 
     def remove(self, contract: TestContract):
         return self._internal_list.remove(contract)
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/nativeaccountstate.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/nativeaccountstate.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/nativecontractprefix.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/nativecontractprefix.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 from enum import IntEnum
-from typing import Optional, Tuple
 
 from boa3.internal import constants
 from boa3.internal.neo.vm.type.Integer import Integer
 
 
-def get_native_contract_data(token_script: bytes) -> Tuple[Optional[bytes], Optional[int]]:
-    prefix: Optional[NativeContractPrefix] = None
+def get_native_contract_data(token_script: bytes) -> tuple[bytes | None, int | None]:
+    prefix: NativeContractPrefix | None = None
     contract_id: NativeContractId = NativeContractId.NONE
 
     if token_script is constants.NEO_SCRIPT:
         prefix = NativeContractPrefix.NEO
         contract_id = NativeContractId.NEO
     elif token_script is constants.GAS_SCRIPT:
         prefix = NativeContractPrefix.GAS
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/signer.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/signer.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,7 @@
-from __future__ import annotations
-
-from typing import List
-
 from boa3.internal import constants
 from boa3.internal.neo import from_hex_str
 from boa3.internal.neo3.core.types import UInt160
 from boa3_test.test_drive.model.network.payloads.signer import Signer as TestSigner
 from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
 
 
@@ -29,15 +25,15 @@
                 script_hash = contract_hash
 
             if not isinstance(script_hash, UInt160):
                 raise ValueError(f"Incorrect data type for allowed contract: {type(script_hash).__name__}")
             if script_hash not in self._allowed_contracts:
                 self._allowed_contracts.append(script_hash)
 
-    def add_permitted_groups(self, groups_pubkeys: List[bytes]):
+    def add_permitted_groups(self, groups_pubkeys: list[bytes]):
         for group_pubkey in groups_pubkeys:
             if isinstance(group_pubkey, str):
                 group = from_hex_str(group_pubkey)
             else:
                 group = group_pubkey
 
             if not isinstance(group, bytes):
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/storage.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/storage.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,79 @@
-from __future__ import annotations
-
-from typing import Any, Dict, List, Union
+from typing import Any, Self
 
 from boa3.internal import constants
 from boa3.internal.neo.utils import contract_parameter_to_json, stack_item_from_json
 from boa3.internal.neo.vm.type.Integer import Integer
 from boa3.internal.neo.vm.type.String import String
 from boa3.internal.neo3.core.serialization import BinaryReader
 from boa3_test.tests.test_classes.nativecontractprefix import get_native_contract_data
 
 
+class StorageKey:
+    def __init__(self, key: bytes, _id: int = 0):
+        self._ID: int = _id
+        self._key: bytes = key
+
+    def to_json(self) -> dict[str, Any]:
+        return {'id': self._ID,
+                'key': contract_parameter_to_json(self._key)
+                }
+
+    @classmethod
+    def from_json(cls, json: dict[str, Any]) -> Self:
+        k = stack_item_from_json(json['key'])
+        if isinstance(k, str):
+            from boa3.internal.neo.vm.type.String import String
+            k = String(k).to_bytes()
+
+        key = StorageKey(k)
+        key._ID = json['id']
+        return key
+
+    def __eq__(self, other) -> bool:
+        return isinstance(other, StorageKey) and self._key == other._key and self._ID == other._ID
+
+    def __str__(self) -> str:
+        return '({0}, {1})'.format(self._key, self._ID)
+
+    def __hash__(self) -> int:
+        return self._key.__hash__()
+
+
+class StorageItem:
+    def __init__(self, value: bytes, is_constant: bool = False):
+        self._is_constant: bool = is_constant
+        self._value: bytes = value
+
+    @property
+    def value(self) -> bytes:
+        return self._value
+
+    def to_json(self) -> dict[str, Any]:
+        return {'isconstant': self._is_constant,
+                'value': contract_parameter_to_json(self._value)
+                }
+
+    @classmethod
+    def from_json(cls, json: dict[str, Any]) -> Self:
+        value = stack_item_from_json(json['value'])
+        if isinstance(value, str):
+            from boa3.internal.neo.vm.type.String import String
+            value = String(value).to_bytes()
+
+        item = StorageItem(value, json['isconstant'])
+        return item
+
+    def __str__(self) -> str:
+        return self._value.__str__()
+
+
 class Storage:
     def __init__(self):
-        self._dict: Dict[StorageKey, StorageItem] = {}
+        self._dict: dict[StorageKey, StorageItem] = {}
 
     def pop(self, key: bytes) -> StorageItem:
         storage_key = StorageKey(key)
         return self._dict.pop(storage_key)
 
     def clear(self, delete_deploy_data: bool = True):
         prefix, native_id = get_native_contract_data(constants.MANAGEMENT_SCRIPT)
@@ -27,27 +84,27 @@
                                  and key._key.startswith(prefix)  # it's a deployed contract register
                                  )
                              )
             if should_delete:
                 # keep native contracts storage
                 self._dict.pop(key)
 
-    def copy(self) -> Storage:
+    def copy(self) -> Self:
         storage = Storage()
         storage._dict = self._dict.copy()
         return storage
 
-    def to_json(self) -> List[Dict[str, Any]]:
+    def to_json(self) -> list[dict[str, Any]]:
         return [{'key': key.to_json(),
                  'value': item.to_json()
                  } for key, item in self._dict.items()
                 ]
 
     @classmethod
-    def from_json(cls, json: Union[Dict[str, Any], List[Dict[str, Any]]]) -> Storage:
+    def from_json(cls, json: dict[str, Any | list[dict[str, Any]]]) -> Self:
         if not isinstance(json, list):
             json = [json]
 
         new_storage = {}
         for storage_value in json:
             key = StorageKey.from_json(storage_value['key'])
             value = StorageItem.from_json(storage_value['value'])
@@ -119,66 +176,7 @@
         else:
             storage_value = StackItem.serialize(value)
         self._dict[key] = StorageItem(storage_value)
 
     @staticmethod
     def build_key(key: bytes, index: int) -> StorageKey:
         return StorageKey(key, index)
-
-
-class StorageKey:
-    def __init__(self, key: bytes, _id: int = 0):
-        self._ID: int = _id
-        self._key: bytes = key
-
-    def to_json(self) -> Dict[str, Any]:
-        return {'id': self._ID,
-                'key': contract_parameter_to_json(self._key)
-                }
-
-    @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> StorageKey:
-        k = stack_item_from_json(json['key'])
-        if isinstance(k, str):
-            from boa3.internal.neo.vm.type.String import String
-            k = String(k).to_bytes()
-
-        key = StorageKey(k)
-        key._ID = json['id']
-        return key
-
-    def __eq__(self, other) -> bool:
-        return isinstance(other, StorageKey) and self._key == other._key and self._ID == other._ID
-
-    def __str__(self) -> str:
-        return '({0}, {1})'.format(self._key, self._ID)
-
-    def __hash__(self) -> int:
-        return self._key.__hash__()
-
-
-class StorageItem:
-    def __init__(self, value: bytes, is_constant: bool = False):
-        self._is_constant: bool = is_constant
-        self._value: bytes = value
-
-    @property
-    def value(self) -> bytes:
-        return self._value
-
-    def to_json(self) -> Dict[str, Any]:
-        return {'isconstant': self._is_constant,
-                'value': contract_parameter_to_json(self._value)
-                }
-
-    @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> StorageItem:
-        value = stack_item_from_json(json['value'])
-        if isinstance(value, str):
-            from boa3.internal.neo.vm.type.String import String
-            value = String(value).to_bytes()
-
-        item = StorageItem(value, json['isconstant'])
-        return item
-
-    def __str__(self) -> str:
-        return self._value.__str__()
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/testcontract.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/testcontract.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 import os
-from typing import Optional
 
 from boa3.internal.neo import to_hex_str
 from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class TestContract:
     def __init__(self, file_path: str, manifest_path: str):
         self._nef_path: str = file_path
         self._manifest_path: str = manifest_path
         self._manifest: dict = self._read_manifest()
-        self._script_hash: Optional[bytes] = self._get_script_hash()
+        self._script_hash: bytes | None = self._get_script_hash()
 
     def _get_script_hash(self) -> bytes:
         file_path = self._nef_path
         if file_path.endswith('.nef') and os.path.isfile(file_path):
             with open(file_path, mode='rb') as nef:
                 file = nef.read()
 
@@ -47,15 +46,15 @@
         return manifest
 
     @property
     def path(self) -> str:
         return self._nef_path
 
     @property
-    def script_hash(self) -> Optional[bytes]:
+    def script_hash(self) -> bytes | None:
         return self._script_hash
 
     def __str__(self) -> str:
         return f'[{to_hex_str(self._script_hash)}] {self._nef_path}'
 
     def __repr__(self) -> str:
         return str(self)
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/transaction.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/transaction.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,50 +1,48 @@
-from __future__ import annotations
-
-from typing import Any, Dict, List, Optional
+from typing import Any, Self
 
 from boa3.internal.neo3.vm import VMState, vmstate
 from boa3_test.test_drive.model.network.payloads.testtransaction import TestTransaction
 from boa3_test.tests.test_classes import transactionattribute as tx_attribute
 from boa3_test.tests.test_classes.signer import Signer
 from boa3_test.tests.test_classes.witness import Witness
 
 
 class Transaction(TestTransaction):
-    def __init__(self, script: bytes, signers: List[Signer] = None, witnesses: List[Witness] = None):
+    def __init__(self, script: bytes, signers: list[Signer] = None, witnesses: list[Witness] = None):
         super().__init__(None, script, signers, witnesses)
-        self._attributes: List[tx_attribute.TransactionAttribute] = []
+        self._attributes: list[tx_attribute.TransactionAttribute] = []
         self._state: VMState = VMState.NONE
 
     def add_attribute(self, tx_attr: tx_attribute.TransactionAttribute):
         if tx_attr not in self._attributes:
             self._attributes.append(tx_attr)
 
     @property
-    def hash(self) -> Optional[bytes]:
+    def hash(self) -> bytes | None:
         if self._hash is None:
             return None
 
         return super().hash.to_array()
 
     @property
     def state(self) -> VMState:
         return self._state
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         json = super().to_json()
 
         json.pop('hash')  # don't include hash in this json
         json['state'] = self._state.name
 
         return json
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> Transaction:
-        tx: Transaction = super().from_json(json)
+    def from_json(cls, json: dict[str, Any]) -> Self:
+        tx: Self = super().from_json(json)
 
         if 'attributes' in json:
             attributes_json = json['attributes']
             if not isinstance(attributes_json, list):
                 attributes_json = [attributes_json]
             tx._attributes = [tx_attribute.TransactionAttribute.from_json(js) for js in attributes_json]
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,46 +1,15 @@
-from __future__ import annotations
-
 import base64
 import enum
-from typing import Any, Dict
+from typing import Any, Self
 
 from boa3.internal.neo.vm.type.String import String
 from boa3_test.tests.test_classes.transactionattribute import TransactionAttribute, TransactionAttributeType
 
 
-class OracleResponse(TransactionAttribute):
-    def __init__(self, request_id: int, code: OracleResponseCode, result: bytes):
-        super().__init__(TransactionAttributeType.OracleResponse)
-        self._id: int = request_id
-        self._response_code: OracleResponseCode = code
-        self._result: bytes = result
-
-    def to_json(self) -> Dict[str, Any]:
-        json = super().to_json()
-        json.update({
-            'id': self._id,
-            'code': self._response_code.value,
-            'result': String.from_bytes(base64.b64encode(self._result))
-        })
-        return json
-
-    @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> OracleResponse:
-        return cls(request_id=json['id'],
-                   code=json['code'],
-                   result=base64.b64decode(json['result']))
-
-    def __eq__(self, other) -> bool:
-        return (isinstance(other, OracleResponse)
-                and self._id == other._id
-                and self._response_code == other._response_code
-                and self._result == other._result)
-
-
 class OracleResponseCode(enum.IntEnum):
     # Indicates that the request has been successfully completed.
     Success = 0x00
 
     # Indicates that the protocol of the request is not supported.
     ProtocolNotSupported = 0x10
 
@@ -60,7 +29,36 @@
     ResponseTooLarge = 0x1a
 
     # Indicates that the request failed due to insufficient balance.
     InsufficientFunds = 0x1c
 
     # Indicates that the request failed due to other errors.
     Error = 0xff
+
+
+class OracleResponse(TransactionAttribute):
+    def __init__(self, request_id: int, code: OracleResponseCode, result: bytes):
+        super().__init__(TransactionAttributeType.OracleResponse)
+        self._id: int = request_id
+        self._response_code: OracleResponseCode = code
+        self._result: bytes = result
+
+    def to_json(self) -> dict[str, Any]:
+        json = super().to_json()
+        json.update({
+            'id': self._id,
+            'code': self._response_code.value,
+            'result': String.from_bytes(base64.b64encode(self._result))
+        })
+        return json
+
+    @classmethod
+    def from_json(cls, json: dict[str, Any]) -> Self:
+        return cls(request_id=json['id'],
+                   code=json['code'],
+                   result=base64.b64decode(json['result']))
+
+    def __eq__(self, other) -> bool:
+        return (isinstance(other, OracleResponse)
+                and self._id == other._id
+                and self._response_code == other._response_code
+                and self._result == other._result)
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py` & `neo3_boa-1.2.0/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,25 +1,24 @@
-from __future__ import annotations
-
 import abc
-from typing import Any, Dict
+from typing import Any, Self
 
-from boa3_test.tests.test_classes import transactionattribute
+from boa3_test.tests.test_classes.transactionattribute import transactionattributetype
 
 
 class TransactionAttribute(abc.ABC):
 
-    def __init__(self, _type: transactionattribute.TransactionAttributeType):
-        self._type: transactionattribute.TransactionAttributeType = _type
+    def __init__(self, _type: transactionattributetype.TransactionAttributeType):
+        self._type: transactionattributetype.TransactionAttributeType = _type
 
-    def to_json(self) -> Dict[str, Any]:
+    def to_json(self) -> dict[str, Any]:
         return {
             'type': self._type.name
         }
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> TransactionAttribute:
+    @abc.abstractmethod
+    def from_json(cls, json: dict[str, Any]) -> Self:
         tx_type = json['type']
         pass
 
     def __eq__(self, other) -> bool:
         return isinstance(other, type(self)) and self._type == other._type
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_drive/neoxp/utils.py` & `neo3_boa-1.2.0/boa3_test/tests/test_drive/neoxp/utils.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
     'get_block',
     'run_batch',
     'oracle_response'
 ]
 
 
 import logging
-from typing import List, Union
 
 from filelock import FileLock
 
 from boa3.internal import env
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.neoxp import utils as neoxp_utils
 from boa3_test.test_drive.neoxp.executor import NeoExpressWrapper
@@ -46,15 +45,15 @@
     return neoxp_utils.get_account_by_address(_NEOXP_CONFIG, account_address)
 
 
 def get_account_by_identifier(account_identifier: str) -> Account:
     return neoxp_utils.get_account_by_identifier(_NEOXP_CONFIG, account_identifier)
 
 
-def get_account_from_script_hash_or_id(script_hash_or_address: Union[bytes, str]) -> Account:
+def get_account_from_script_hash_or_id(script_hash_or_address: bytes | str) -> Account:
     return neoxp_utils.get_account_from_script_hash_or_id(_NEOXP_CONFIG, script_hash_or_address)
 
 
 def get_default_account() -> Account:
     return _NEOXP_CONFIG.default_account
 
 
@@ -78,15 +77,15 @@
         return cli_result
 
 
 def reset_neo_express_instance(neoxp_path: str, check_point_file: str = None) -> str:
     return _BoaNeoExpressWrapper.reset_neo_express_instance(neoxp_path, check_point_file)
 
 
-def get_deployed_contracts(neoxp_path: str, check_point_file: str = None) -> List[Contract]:
+def get_deployed_contracts(neoxp_path: str, check_point_file: str = None) -> list[Contract]:
     return _BoaNeoExpressWrapper.get_deployed_contracts(neoxp_path, check_point_file)
 
 
 def get_transaction(neoxp_path: str, tx_hash: UInt256, check_point_file: str = None) -> Transaction:
     return _BoaNeoExpressWrapper.get_transaction(neoxp_path, tx_hash, check_point_file)
 
 
@@ -94,19 +93,19 @@
     return _BoaNeoExpressWrapper.get_transaction_log(neoxp_path, tx_hash, check_point_file, contract_collection)
 
 
 def get_latest_block(neoxp_path: str, check_point_file: str = None) -> Block:
     return _BoaNeoExpressWrapper.get_latest_block(neoxp_path, check_point_file)
 
 
-def get_block(neoxp_path: str, block_hash_or_index: Union[UInt256, int] = None,
+def get_block(neoxp_path: str, block_hash_or_index: UInt256 | int = None,
               check_point_file: str = None) -> Block:
     return _BoaNeoExpressWrapper.get_block(neoxp_path, block_hash_or_index, check_point_file)
 
 
 def run_batch(neoxp_path: str, batch_path: str, reset: bool = False, check_point_file: str = None) -> str:
     return _BoaNeoExpressWrapper.run_batch(neoxp_path, batch_path, reset, check_point_file)
 
 
 def oracle_response(neoxp_path: str, url: str, response_path: str, request_id: int = None,
-                    check_point_file: str = None) -> List[UInt256]:
+                    check_point_file: str = None) -> list[UInt256]:
     return _BoaNeoExpressWrapper.oracle_response(neoxp_path, url, response_path, request_id, check_point_file)
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_drive/testrunner/boa_test_runner.py` & `neo3_boa-1.2.0/boa3_test/tests/test_drive/testrunner/boa_test_runner.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 __all__ = [
     'BoaTestRunner'
 ]
 
 import os.path
 import threading
-from typing import Callable, List, Sequence, Optional, Tuple, Union
+from collections.abc import Callable, Sequence
 
 from boa3.internal import env
 from boa3.internal.neo3.core.types import UInt256
 from boa3_test.test_drive.model.smart_contract.contractcollection import ContractCollection
 from boa3_test.test_drive.neoxp.model.neoxpconfig import NeoExpressConfig
 from boa3_test.test_drive.testrunner.blockchain.block import TestRunnerBlock as Block
 from boa3_test.test_drive.testrunner.neo_test_runner import NeoTestRunner
@@ -35,28 +35,28 @@
         return super()._set_up_neoxp_config()
 
     def _set_up_generate_file_names(self, file_name: str):
         from boa3_test.test_drive import utils
         runner_specific_id = utils.create_custom_id(file_name)
         super()._set_up_generate_file_names(runner_specific_id)
 
-    def add_neo(self, script_hash_or_address: Union[bytes, str], amount: int):
+    def add_neo(self, script_hash_or_address: bytes | str, amount: int):
         address = boa_neoxp_utils.get_account_from_script_hash_or_id(script_hash_or_address)
         self._batch.transfer_assets(sender=self._DEFAULT_ACCOUNT, receiver=address,
                                     quantity=amount,
                                     asset='NEO')
 
-    def add_gas(self, script_hash_or_address: Union[bytes, str], amount: int):
+    def add_gas(self, script_hash_or_address: bytes | str, amount: int):
         address = boa_neoxp_utils.get_account_from_script_hash_or_id(script_hash_or_address)
         gas_decimals = 8
         self._batch.transfer_assets(sender=self._DEFAULT_ACCOUNT, receiver=address,
                                     asset='GAS', decimals=gas_decimals,
                                     quantity=(amount / (10 ** gas_decimals)))
 
-    def _internal_generate_files(self, methods_to_call: List[Tuple[Callable, Sequence]]):
+    def _internal_generate_files(self, methods_to_call: list[tuple[Callable, Sequence]]):
         worker_threads = []
 
         if len(methods_to_call) > 0:
             last_method, last_method_args = methods_to_call[-1]
 
             for method, args in methods_to_call[:-1]:
                 work_thread = threading.Thread(target=method, args=args)
@@ -66,18 +66,18 @@
                 work_thread.start()
 
             last_method(*last_method_args)
 
         for worker in worker_threads:
             worker.join()
 
-    def _get_genesis_block(self) -> Optional[Block]:
+    def _get_genesis_block(self) -> Block | None:
         return boa_neoxp_utils.get_genesis_block()
 
-    def _get_block(self, block_hash_or_index) -> Optional[Block]:
+    def _get_block(self, block_hash_or_index) -> Block | None:
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return boa_neoxp_utils.get_block(self._neoxp_abs_path, block_hash_or_index,
                                          check_point_file=check_point_path)
 
     def _get_tx(self, tx_hash: UInt256):
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return boa_neoxp_utils.get_transaction(self._neoxp_abs_path, tx_hash,
@@ -85,15 +85,15 @@
 
     def _get_tx_log(self, tx_hash: UInt256, contract_collection: ContractCollection):
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return boa_neoxp_utils.get_transaction_log(self._neoxp_abs_path, tx_hash,
                                                    check_point_file=check_point_path,
                                                    contract_collection=contract_collection)
 
-    def _get_oracle_resp(self, url: str, response_path: str, request_id: int = None) -> List[UInt256]:
+    def _get_oracle_resp(self, url: str, response_path: str, request_id: int = None) -> list[UInt256]:
         check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
         return boa_neoxp_utils.oracle_response(self._neoxp_abs_path, url, response_path, request_id,
                                                check_point_file=check_point_path)
 
     def __del__(self):
         self.reset()
         if self._clear_files_when_destroyed:
```

### Comparing `neo3-boa-1.1.1/boa3_test/tests/test_suite.py` & `neo3_boa-1.2.0/boa3_test/tests/test_suite.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-1.1.1/neo3_boa.egg-info/PKG-INFO` & `neo3_boa-1.2.0/neo3_boa.egg-info/PKG-INFO`

 * *Files identical despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: neo3-boa
-Version: 1.1.1
+Version: 1.2.0
 Summary: A Python compiler for the Neo3 Virtual Machine
 License:                                  Apache License
                                    Version 2.0, January 2004
                                 http://www.apache.org/licenses/
         
            TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
         
@@ -208,30 +208,31 @@
 Project-URL: documentation, https://dojo.coz.io/neo3/boa/index.html
 Project-URL: changelog, https://github.com/CityOfZion/neo3-boa/blob/master/CHANGELOG.md
 Keywords: compiler,NEO,.nef,blockchain,smartcontract,development,dApp
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Topic :: Software Development :: Build Tools
 Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
-Requires-Python: <=3.12,>=3.10.0
+Classifier: Programming Language :: Python :: 3.12
+Requires-Python: <=3.12,>=3.11
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: base58>=1.0.3
 Requires-Dist: wheel>=0.30.0
 Requires-Dist: requests==2.31.0
 Provides-Extra: dev
 Requires-Dist: autopep8>=1.4.4; extra == "dev"
 Requires-Dist: bump-my-version==0.10.0; extra == "dev"
+Requires-Dist: coverage>=6.0.1; extra == "dev"
+Requires-Dist: filelock>=3.10.7; extra == "dev"
 Requires-Dist: pycodestyle>=2.11.1; extra == "dev"
 Requires-Dist: twine>=1.10.0; extra == "dev"
 Provides-Extra: test
-Requires-Dist: filelock>=3.10.7; extra == "test"
-Requires-Dist: coverage>=6.0.1; extra == "test"
+Requires-Dist: boa-test-constructor==0.3.0; extra == "test"
 Provides-Extra: docs
 Requires-Dist: myst-parser==1.0.0; extra == "docs"
 Requires-Dist: Sphinx==5.0.0; extra == "docs"
 Requires-Dist: sphinx-rtd-theme==1.2.1; extra == "docs"
 
 <p align="center">
   <img
```

### Comparing `neo3-boa-1.1.1/neo3_boa.egg-info/SOURCES.txt` & `neo3_boa-1.2.0/neo3_boa.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -173,15 +173,14 @@
 boa3/internal/model/builtin/contract/nep17_interface_methods/nep17interfacetransfermethod.py
 boa3/internal/model/builtin/decorator/__init__.py
 boa3/internal/model/builtin/decorator/builtindecorator.py
 boa3/internal/model/builtin/decorator/classmethoddecorator.py
 boa3/internal/model/builtin/decorator/contractdecorator.py
 boa3/internal/model/builtin/decorator/displaynamedecorator.py
 boa3/internal/model/builtin/decorator/instancemethoddecorator.py
-boa3/internal/model/builtin/decorator/metadatadecorator.py
 boa3/internal/model/builtin/decorator/propertydecorator.py
 boa3/internal/model/builtin/decorator/publicdecorator.py
 boa3/internal/model/builtin/decorator/staticmethoddecorator.py
 boa3/internal/model/builtin/internal/__init__.py
 boa3/internal/model/builtin/internal/getenvmethod.py
 boa3/internal/model/builtin/internal/innerdeploymethod.py
 boa3/internal/model/builtin/internal/internalmethod.py
@@ -334,17 +333,33 @@
 boa3/internal/model/builtin/interop/stdlib/memorysearchmethod.py
 boa3/internal/model/builtin/interop/stdlib/serializemethod.py
 boa3/internal/model/builtin/interop/storage/__init__.py
 boa3/internal/model/builtin/interop/storage/findoptionstype.py
 boa3/internal/model/builtin/interop/storage/storagedeletemethod.py
 boa3/internal/model/builtin/interop/storage/storagefindmethod.py
 boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py
-boa3/internal/model/builtin/interop/storage/storagegetmethod.py
 boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py
-boa3/internal/model/builtin/interop/storage/storageputmethod.py
+boa3/internal/model/builtin/interop/storage/get/__init__.py
+boa3/internal/model/builtin/interop/storage/get/istoragegetmethod.py
+boa3/internal/model/builtin/interop/storage/get/storagegetboolmethod.py
+boa3/internal/model/builtin/interop/storage/get/storagegetbytesmethod.py
+boa3/internal/model/builtin/interop/storage/get/storagegetecpointmethod.py
+boa3/internal/model/builtin/interop/storage/get/storagegetintmethod.py
+boa3/internal/model/builtin/interop/storage/get/storagegetstrmethod.py
+boa3/internal/model/builtin/interop/storage/get/storagegetuint160method.py
+boa3/internal/model/builtin/interop/storage/get/storagegetuint256method.py
+boa3/internal/model/builtin/interop/storage/put/__init__.py
+boa3/internal/model/builtin/interop/storage/put/istorageputmethod.py
+boa3/internal/model/builtin/interop/storage/put/storageputboolmethod.py
+boa3/internal/model/builtin/interop/storage/put/storageputbytesmethod.py
+boa3/internal/model/builtin/interop/storage/put/storageputecpointmethod.py
+boa3/internal/model/builtin/interop/storage/put/storageputintmethod.py
+boa3/internal/model/builtin/interop/storage/put/storageputstrmethod.py
+boa3/internal/model/builtin/interop/storage/put/storageputuint160method.py
+boa3/internal/model/builtin/interop/storage/put/storageputuint256method.py
 boa3/internal/model/builtin/interop/storage/storagecontext/__init__.py
 boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py
 boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py
 boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py
 boa3/internal/model/builtin/interop/storage/storagemap/__init__.py
 boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py
 boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py
@@ -438,15 +453,15 @@
 boa3/internal/model/builtin/native/nep17_methods/__init__.py
 boa3/internal/model/builtin/native/nep17_methods/balanceofmethod.py
 boa3/internal/model/builtin/native/nep17_methods/decimalsmethod.py
 boa3/internal/model/builtin/native/nep17_methods/symbolmethod.py
 boa3/internal/model/builtin/native/nep17_methods/totalsupplymethod.py
 boa3/internal/model/builtin/native/nep17_methods/transfermethod.py
 boa3/internal/model/imports/__init__.py
-boa3/internal/model/imports/builtin.py
+boa3/internal/model/imports/compilerbuiltin.py
 boa3/internal/model/imports/importsymbol.py
 boa3/internal/model/imports/package.py
 boa3/internal/model/operation/__init__.py
 boa3/internal/model/operation/binaryop.py
 boa3/internal/model/operation/operation.py
 boa3/internal/model/operation/operator.py
 boa3/internal/model/operation/unaryop.py
@@ -482,14 +497,18 @@
 boa3/internal/model/operation/binary/relational/lessthan.py
 boa3/internal/model/operation/binary/relational/lessthanorequal.py
 boa3/internal/model/operation/binary/relational/notidentity.py
 boa3/internal/model/operation/binary/relational/numericequality.py
 boa3/internal/model/operation/binary/relational/numericinequality.py
 boa3/internal/model/operation/binary/relational/objectequality.py
 boa3/internal/model/operation/binary/relational/objectinequality.py
+boa3/internal/model/operation/binary/relational/strbytesgreaterthan.py
+boa3/internal/model/operation/binary/relational/strbytesgreaterthanorequal.py
+boa3/internal/model/operation/binary/relational/strbyteslessthan.py
+boa3/internal/model/operation/binary/relational/strbyteslessthanorequal.py
 boa3/internal/model/operation/unary/__init__.py
 boa3/internal/model/operation/unary/booleannot.py
 boa3/internal/model/operation/unary/logicnot.py
 boa3/internal/model/operation/unary/negative.py
 boa3/internal/model/operation/unary/noneidentity.py
 boa3/internal/model/operation/unary/nonenotidentity.py
 boa3/internal/model/operation/unary/positive.py
@@ -504,14 +523,15 @@
 boa3/internal/model/type/anytype.py
 boa3/internal/model/type/baseexceptiontype.py
 boa3/internal/model/type/itype.py
 boa3/internal/model/type/math.py
 boa3/internal/model/type/type.py
 boa3/internal/model/type/typeutils.py
 boa3/internal/model/type/annotation/__init__.py
+boa3/internal/model/type/annotation/ellipsistype.py
 boa3/internal/model/type/annotation/metatype.py
 boa3/internal/model/type/annotation/optionaltype.py
 boa3/internal/model/type/annotation/uniontype.py
 boa3/internal/model/type/classes/__init__.py
 boa3/internal/model/type/classes/classarraytype.py
 boa3/internal/model/type/classes/classinitmethoddefault.py
 boa3/internal/model/type/classes/classscope.py
@@ -686,16 +706,19 @@
 boa3_test/test_drive/testrunner/blockchain/log.py
 boa3_test/test_drive/testrunner/blockchain/notification.py
 boa3_test/test_drive/testrunner/blockchain/storage.py
 boa3_test/test_drive/testrunner/blockchain/storagecollection.py
 boa3_test/test_drive/testrunner/blockchain/transaction.py
 boa3_test/test_drive/testrunner/blockchain/transactionlog.py
 boa3_test/tests/__init__.py
-boa3_test/tests/boa_test.py
+boa3_test/tests/annotation.py
+boa3_test/tests/boatestcase.py
+boa3_test/tests/event.py
 boa3_test/tests/run_unit_tests.py
+boa3_test/tests/stackitem.py
 boa3_test/tests/test_suite.py
 boa3_test/tests/test_classes/TestExecutionException.py
 boa3_test/tests/test_classes/__init__.py
 boa3_test/tests/test_classes/block.py
 boa3_test/tests/test_classes/contractcollection.py
 boa3_test/tests/test_classes/nativeaccountstate.py
 boa3_test/tests/test_classes/nativecontractprefix.py
```

### Comparing `neo3-boa-1.1.1/pyproject.toml` & `neo3_boa-1.2.0/pyproject.toml`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 [project]
 name = 'neo3-boa'
 description = 'A Python compiler for the Neo3 Virtual Machine'
 readme = 'README.md'
-requires-python = '>= 3.10.0,<= 3.12'
+requires-python = '>= 3.11,<= 3.12'
 license = {file = 'LICENSE' }
 keywords = ['compiler', 'NEO', '.nef', 'blockchain', 'smartcontract', 'development', 'dApp']
 classifiers = [
     'Development Status :: 5 - Production/Stable',
     'Intended Audience :: Developers',
     'Topic :: Software Development :: Build Tools',
     'License :: OSI Approved :: Apache Software License',
-    'Programming Language :: Python :: 3.10',
     'Programming Language :: Python :: 3.11',
+    'Programming Language :: Python :: 3.12',
 ]
 dynamic = ['version']
 dependencies = [
     'base58>=1.0.3',
     'wheel>=0.30.0',
     'requests==2.31.0',
 ]
 
 [project.optional-dependencies]
 dev = [
     'autopep8>=1.4.4',
     'bump-my-version==0.10.0',
+    'coverage>=6.0.1',
+    'filelock>=3.10.7',
     'pycodestyle>=2.11.1',
     'twine>=1.10.0',
 ]
 test = [
-    'filelock>=3.10.7',
-    'coverage>=6.0.1',
+    'boa-test-constructor==0.3.0',
 ]
 docs = [
     'myst-parser==1.0.0',
     'Sphinx==5.0.0',
     'sphinx-rtd-theme==1.2.1',
 ]
 
@@ -60,15 +61,15 @@
 boa3 = ['py.typed']
 
 [tool.setuptools.dynamic]
 version = { attr = 'boa3.__version__' }
 
 
 [tool.bumpversion]
-current_version = '1.1.1'
+current_version = '1.2.0'
 commit = true
 tag = true
 
 [[tool.bumpversion.files]]
 filename = './pyproject.toml'
 search = "current_version = '{current_version}'"
 replace = "current_version = '{new_version}'"
```

